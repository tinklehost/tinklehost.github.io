/*! For license information please see main.0404d3d4.chunk.js.LICENSE.txt */
(this.webpackJsonpclient = this.webpackJsonpclient || []).push([
    [0], {
        106: function(t, e, n) {},
        162: function(t, e, n) {
            "use strict";
            n.r(e), e.default = n.p + "static/media/rooms.c5432161.png"
        },
        163: function(t, e, n) {},
        188: function(t, e, n) {},
        189: function(t, e, n) {},
        200: function(t, e, n) {},
        338: function(t, e, n) {},
        352: function(t, e, n) {},
        353: function(t, e, n) {},
        356: function(t, e, n) {},
        364: function(t, e, n) {},
        365: function(t, e, n) {
            "use strict";
            n.r(e), e.default = n.p + "static/media/dj3d_logo.39f69e26.png"
        },
        366: function(t, e, n) {
            "use strict";
            n.r(e), e.default = n.p + "static/media/mangobox.8ad80e90.png"
        },
        367: function(t, e, n) {},
        368: function(t, e, n) {},
        370: function(t, e, n) {},
        371: function(t, e, n) {},
        376: function(t, e, n) {},
        388: function(t, e, n) {},
        389: function(t, e, n) {},
        390: function(t, e, n) {},
        392: function(t, e, n) {
            "use strict";
            n.r(e), e.default = n.p + "static/media/chat.7bf6e7d0.png"
        },
        393: function(t, e, n) {
            "use strict";
            n.r(e), e.default = n.p + "static/media/controls.f70a2dc2.png"
        },
        394: function(t, e, n) {
            "use strict";
            n.r(e), e.default = n.p + "static/media/video_chat.c7a5722e.png"
        },
        395: function(t, e, n) {
            "use strict";
            n.r(e), e.default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAAEH5aXCAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAZKADAAQAAAABAAAAZAAAAAAMc/x7AAAFH0lEQVR4Ae2dT6hPQRTH/U2USImytbBRUkokUjaUjSwsWLyit/BnIXtlo5TEgsjCwsqelFJKSkkpGyRF+RNREvn/PT93fubOm7nvzP3d37vn/t53arr3njkzc87nzJ2Z37z3e2/GjKlKM11Hf5Dcfew6EykmH66s36VN8/rOi3mRtFsUCvlap9z3yQliV6nk5IJ+lnvQXLNihY5WahptWadHzaeSsifL+VQjKnnXTBIyjqCjNOlgdBUKIp8mJSMVivRqUmVREGWVYqtKJVBNmOwi4HuV9Zb7Fc3dE1f9kBRvj/bSW2Skt6LCm1TPc4KCw8Fz1ePDoHCZ/wrEhnKgn/dY4fpqaSn0JK/1iHbjHkT6oGhwAqMzrYzOVD94VK20wNFlJRKjaEft0eUvTsWyOwuy6Ka5yWnlt7/G+xEJl9+cjYTfTv++6OgSvDrghCVcTph7TXmAduags19N4ppgm3QgwhDXBMU6AjReItS0JyfDDuoYGa1TEZOoPoUkQAIBgdK775dZebu000fT85bPYkrvR8aRKaXGzhQEql72Q4r6Q1fBy35O00mVI9HtrKbRJnWm3azVJDy2RQIaArJFGVLqn4X7dhR99U6Ofbn23trK/siDp5p2naPWHHF2yfWg59R73Fu29b/dntGa2/X/a/67Sy6IoeKwn8X6Gn28xYK5XOp1I1xlD0/Lal+knhPl4pafJhlPq1o2T9994MgLfU1jmnDkuDGTaA4JkAAJkMA0IhDdNMoqa4GB7Ke0dnRx0xj1jY5EsbQoZERahM+uSYAEpjOB6BYAO5RO/bRKAphyhHuttoY3V/a2yKf6HZmIpByknARIgAQ6RECOg4aVYhjQ127kO7EyrczSOrKpgLdPa7yvZ8kRZ9cVOPQTebETaK4WHRG7ZyN/hDP3NE6IjlVHnP3ri+G23wlS19R3CQb+Ckaqw5ryi3DoAuouw3Hw+5ptDL8ajJRZS5sexCyyPrRiNq8tPD7oF3bREWf/OTi01z2k3hFXbvV6B+/KZt+4rjnyE8YvgROffSfkvktDaw8cmBtzQhzpQkRuwfhtYmxVsuzIdxguw+hLlQOuzOrQ2gUH5mmdEGesReQ6jN/hKOdcrTjyFUbPhxPfcoynLgmQAAmQAAmQAAmQAAmQAAm0SyD6Wygpk+RsL1U2HeX4CJjFT8PI6qmDxvaR1GFAjIWVAWFAjBEwZk7uOel2Y/bTHBIgARIgARIgARKwSSDroz+PTspB5NFJmcdIPvGTurGwMiAMiDECxszJPTp5Zsx+mkMCJEACJEACJEACNgnkHp08telGpVWHccRxo1KjKMTR0BbcroD+VY1+6zpyltXBFP0L7jGY8M3/7qZ8t/kM8qKY7rBk/KSeJivf0T6C/KkYhHdxXZNWb6aEAdFz3ADVh0Vw3uE6hpw15Wu6YkA0lCbqLIXoMrL8D8ZfyOeRl0xUy5cwIPnMwhrCcBz5A4Ii6T7yulCJzzUIAKS/qAvcQZMEaRxZPfDVijX8YxV8tRsQziPLtCbT22Vkme6SiQFJomm8QDYAY8iyIZAkG4SNYS8MSEhk+M/yn4TPIm/BB9C7YXe5Pw8J6/NZR+A11I5pTgAYEB3QOlq3UekQgvA4pzKnrBxa1bo/UHwKeSGCIGkrclYwpHm+IUKhfnqJqkcB/lr9Jso1GZAyD83TTSjJCfITjTJ1BiCAbWjsg+E3yE8gLxigaVatQ8ALyHPc76zTBuuQAAmQAAmQAAmQQI/AX6EvXeFvmD8uAAAAAElFTkSuQmCC"
        },
        396: function(t, e, n) {
            "use strict";
            n.r(e), e.default = n.p + "static/media/parkour.6dcc653f.png"
        },
        397: function(t, e, n) {
            "use strict";
            n.r(e), e.default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAAEH5aXCAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAZKADAAQAAAABAAAAZAAAAAAMc/x7AAAQW0lEQVR4Ae1de4wV1R0+d1/sLiCsAouyu7CCFrrgA62NCFIEnxULKqxiSvAPjUktUatNrFKVtGlj/4CYqJhgFG2jxdgUFNQIBaVWiVh8rIIigSKCvFyQx7oge/p9d3bmnjN3ztyZuXPvXpZ7kt+d8/o9zzlz3nOFiMtJIaQC57rpJtQIZlTDqh8ZnbyOxw/BRrYRS+yI5HPBAl0wVUhksAknOdmBpCYaFSWQsIQiN52Tkkcw0yOPqDG6n5ySIBX32mtKAN7OPA6mnDr13DQkHUVDsgQFOpEcKgYP9WGSo5MdYcjP6B/sNIeTHeHFMQBBGz2XT4j2a4rXCR1uXpouXnrYCLY+DoJfZhUpaWInsy2I+zlwoI1jFYyG4CS5PKx3w4c/m4wlgqyrS1WQ8eMtHqkYh6dT6mLnTp0ks3i4pNJBRaKlbA6zk8Qopwk6uSU50O9w6UxwP0iKcTYHhhjR5M7IsJ3ZK+0EiIMt1tEeAeFXJpWSBnMnZjK0O7877LatUyDMCOL/zZZBJx1qP8LNXMhx4+4kAwfUah7Gr9BIZ6IkyspKb7JsZ/X13ml2rEoHfjLSzOVwPvVUx5vm+eorqxUdP56WlDFClpf/4JiK0kR1qiYNDb8lY612kYkjTZ8+Quzf7wQDefieUJy7ljlJmjaqVOH8ax2Cfp6IzN71o5kxDUyf9WCctHlG5JMnA0xUDtjmYSq+HVYHsYRe5xQMEGBDDdzijNUVRDxbPBgsDcOAsnVqehH9GR0yf96JkHpZhmsjl/kyAfHmLBkkBXMz0cqEDNwZoobVMnLKBNQ/1AhGMZZCAPR+pAQtL7VwoKUl2jv4rLNSNNKsIiXbQipDNBZSLl2aoqEwSZpLNjf71whbb77K9+yxQ+nPc85Jj0OMVSabN9/jmeoVOWCA1TN6pbEP8nAWk46Ogx5p5qhLLvFO60ibVyTzlSV/Bwx4CM8bvDGVWJrLQCiZq7VVyez2SpmIpeCfftqz4B12GpNFi6LVr969U0wSlNvlEDNXY7RlSzhG8+alGFjNodRmkd/XSifXcpt7Nk/1vUU6VhXupIhEzs9ndAYjPdwMjERQNg1a+aivHB+/kaBfAhh9F5DZS350AqWB0XhAq4thC8KnByJQzBTCAlpbDIHnmxVF1U/U148WNTVXiPLykchcDdgp2treF7t2LRP79m0B4+99ieQzkQID1gPcb60o4YfyKTtHZbGM/jIovxvpzis8VgVBONvxcZRSIs70WBQBoVcAUYWIE6/OTyFjY4fw7MoCz7H8mMSY9h8I7Dnc81QESvQDc/Not6ZGiGnThJgwATMDTA04Zu3RQ4iKCsxfMT4oRfUuw4DRXie1NWH5cFT4A7p3wrFjQhw9KsRBjFy5IvTxx5hBYgq5cqWN4fU8CKFP8UrQ4uTtt+vTB7VajRsXbgyWTe7jx83VMpH4QBPaKyB79TKtB2QjVjTc++83KzNx4jgv+ZNxKA32C2bkMOKMHSvlq6+GwUjP++mnZlnKy7XZiTY2FZs332/Ush+bTQjHdnLttal2Qn9Y17+/GePYsb5qoq7IgQPmRZdqjjKycMuWpZS6++5ghPgCCeh0RYYP56qTt/vuO+/4ILG1tRhp7UxV2nnzgmAJceRIsHzuXDukrI6tjTz/fHqdDxuzdq25jQwc+Ilbfi0sq6reNipz9GhYUbLL39xsVmTVqtRupaaBEmC35amMaR8lO3G9sdesMSshxB8UcZNez56dKVTEnTktzJ68vl6IQYOEYDs47TQhevUSomdPC5jOHp5vMPbi7M2/xzTk0CEhDh/GLBftbu9eIb7+Wojt24XYvTuNhUfEyxD6Ro94cxQ0+dazZFLN1s9quUhrNkubIQWK/LQAlMnilelSEMpM6gKF4lPApU8yCIX+nWOlbvbim9M4KNQE+CBLxf6YUyGLxIsWKFqg+1jAOESJqiLeXhXilFMaRF3d1aKycowoKTkDtL7HEGUjhiQrxJYta8E00FgkqgyR8SD8MMAywFFA0KHJDuT9HaAqMuO4ECEEjyfqZ3OCK6IqzFXMxrjkCkwHTKcBVEHi8lOh/JQQGH2ZIyVUY/wmsFXDZoTwjXlQQFUm8yJcBCXG5lkJW6FvwspqzA8FRnSRErYyu4zCKQm+/QgUwJxVYF7a5a4Fgo7yk0Jf10rP+W16VJfEjIRR50TiDMRnurhK2VVLfRq3EzyrFhTABogolNJQC+JrCOy5c2VS5HNgn61S0Pxjxghx/fVCnHceTkk0YNsFhuLSj7r8wyUgbvTYzrYrj/baGz3c5CFwGWjTJiHWrBFi8WIhvvF9WZ0Hqh/ZZI1PloaxSlVVSckNmFy7JUtstb2eWEQO4GSfPn8zKnLkSK5VSNGfOdNLCSuupsb7DJqqn8Q5KE9F+vZNMcmH7+BBbzk4xmtoeEqVmX7t9SsXLhycHAq6czE8frxXbO7iuPRqcnv23OJO0hQRc+ea15PGmbfs3ERzHm5r6/kwtkBUProifgcPhw9X8fz9XJi+9FL/PEFS+TY0uIcuvniwmqQrsn37OWqi5j+DM9aAjq9evkr5+g26O+VF2u+mxuDB16oouiIdHegMDI5bBVHcPfdYCq1eHR7bcEA2SWj9+stUgroiaorbzxMN2TiekuA+yrZtwalUVprztrc3qonBFVF7aZVCGP+OHRjDYhD7bcDRT4mveNqWr29OTcYot4ZUAjTE668LceCAEH51X8XhUMbkpNSsEVwRbp1FdQ8+aB2mufLKcBS4PWdyQ4e2qEnY4FNcdfU+7G1jI9DD7dvnEZkhauJEId54w9pDzJDVM9nvDHlt7XIVRy+RIUNWqYmaf+tWLegbYN3eskWIFSuiK0EGfsY7cmS1KoOuyOHDL6iJmv+jzCNnJz9fm0OGOMHIHg7xDS6xZInWRrRs6PYrpWnhbfTofAwVdR4mWaqrN2uCewVkWdlhT2XKynQmuQ6995559Dt58nQv2bU43LOc6akIrfPcc7kWP0W/psasiGvUrimgBoyKUJk5c1LMcuHbu9e6VmuqVkK8pMpq+9FLpTsoMhexmZdfeGSDRzg4oOQhMTZyjsl6904d1uQRDh7IZD9EYN9A4DEOvpV444nHN3g4k8c7MrtyCO3TU7oI+JaK2Vp+1SGOtCdcYjpBzxJhKhS5EI/3nZxd72mHsMZRpN6PKMICaR2C5n5FyZsnL+pwFg4l878CqGbTslAhhQpFuvK40wMpSWLwQZmvuqBkbo1B9HQSUOTlPCpzQboEMcZAkQk5VuYz0De+TWNUxSIFZk/GrNAx0BsTu6BBCYL5vVkq9AXwLwrKL+f5IAxX8WcDMn0m5iDy/B1wRc6FKjIoWqBogaIFihYoWuCkskD+RmYhzYpufwhQRgC4hdYE4MYfjiYkj2SYd6OQQXFcodgPwO0UwRMQGwAfAjYCNkH543gWnWoBGL4v4BeAvwL2AuJYaQlD4xB4LgX8EhBik1TV4gT2Q+nTAPxQIOdOYQyXz7zbIdvDALbI7uegGM+mPgPg/C+fho2L13LIndvVg1wXOxToCfgTIMxB+bgMmCs6vGH6PGBgru0XG30I+2PAWkCujFIodLmE/LPYDBc3IQg3DrD5JCgId4XYB51vituekelBmMGATCtYbiW6Y5hL+123PsoShAB/BnRH42aj0z9gkx5Ra3ikiSEYNoIhTsmIM6My7uZ4vJ5yDYyLw5zhnHEj10QGhXEj0r4AFAvDZCR87AJJ/IBJ5nMWLhqhWggY3An8xwCh8Fw89SA/pFOFy4Y8NM4P+dDPJ8H+Spd9iUO9yMHjbCqQKg+HEPjC4alL++td9oUO+9nebh0Q4eERfv+mrc06RMInIV73OMjNhsEgWIyOhQEI/24tL5fy5pulXLlSynx/2iau40rr1kk5e7bEx8bC62/ZbEGMRQGKpaVTUBjtoQqkpETKRx+NyySFQ2fxYil79oxSMDhLH4OT1103TFZUcKwdXIjSUikff7xwjBi3JG++KfGRq+D2oO0SiQ55ww1XZlUkt/O76DU1XMcJx3zkSCnb2uI2Q2HRmzIlnE1ow+rqz2Rra1+/QvEdZT3V1DQJnR5Os4d0kybhhJ7xiF5IYgWa/aqrwgvW1jZCNDXdgqIpNSEbC+QveFPiq2QzRHt70M2gFI/zz0/54/TxOO3bb1vfOY2TbhRa/KMCHvsN49imSkpulTNm1JjQjAVy74QJp+OWxOUmRGM8h6KNjcbkrBJ41nkOhva8wcfz0Lfdhl2Vz7IiGRmZZ7PDfjiUzLZvH40h+VgTX2OB4ED4NTjgXWtCNMbTUFEENRJ0JdjX09haFi7E5i52dxnH62aLFkX/rqaLTcYgD8n39e0OTCQSorX156ZEc4Fs2HCxCck3nhM6TuDy7VpahJg1y7pNwFsF9H/ObfQcOU5a/W5A+7HduPFcU7K5QMrKBpmQfOPtb1/7ZspxIr+8ydbCC9FsPcOGWXeD/a79hRWJ/UfUW7ElJXjfeTtzr4R5tTdKhlh7MJghW16SWYunT8fCxWzcFbkwXpb2Ek0UqlKiM/R25gLp0WMDUMIPeXmJyO8mrbcc8cWOHCnEffcJMXWq1fHHR1mnxAFGsAtTOh5DpaVb0yOtGPMrq65uBYZoPNcUzrGzjfrB6nCcrNyc79xxhxCffGJNX/mcOTO3hUHOXITkde8obtSoNSY0c4FUVLyLkRZbSThHQd3/ZBuOgjk3XxOkf/bZQsyfn1qpffJJIdgy8unYH/nd4DbJUlp6CDq8Yko2x0tZIc8885HQyyasp/PnF9YyRy6kWb7c7i3DPUeMePEV12db1EIwt5BE4qhobn4BQ7tAX3lTiYp33tGC3TKwdm14taqq2nHJ9+nJiQQ2YSI6ecEFc4yfcDItOvbrJ+WXX+aiXhYGTS6cjhoVrmXQVv37v4hfcyMIUkZy1qzKSCu+kydjcHesMAwYtxR33RW+MBKJTXLo0AFBbJ4xD/qRMwCbQvcntbVSLlsWtzm6jt769dFaBk7gw3Y/yWhoZMA0NpgDwUbkfBdQGwzDlWvoUCHGYk2NK8GcOQ/EaUz+2xWXWuxZL5/88haf9n65i0wsQdZv7rnbwHkT5xV8cm7B0dMudJ1bt1r/nPXWW7jIsMHaow8vACeBV8HQ/wqCGrhASAxqNOBBwrBu0QWwwH7kuRpGfi9A3mSWUB0MCG8DFpZVxZtBGZzE+TZB96YwhZGVrdBaeLObp8HDd3DdH2cB7FKelYGjIIPpQEBcf2vaHQqW/0k4OootY8WBEPxSxS5AdzBqFB3aoPusWI0aBzEIdROA/3UbRakTEYcF8QAgVF8ch61D0YCAlwBaACeikYPIzDuIN4YySiFkhtD8COLvAZwYBVG0kPPwfuQTgGjzsEIoEFUGKNIHMAfA2lXIhldla4WsLIRBqi7dzg8FE4ALAU8B+I9IqhG60s+vtS0GXA7I/7AVJR1qpp7LmgED8EwNT7pMAVwKqAfgrE1OHO4jiB0ArqH/E7AKhtiNZ5e7gikQkyU6ayoLiyul2Cp0gK8Rnt7AxRLnChkPZmAPOflvKDQ4Z8sEngfaCdgPhbFYVXRFCxQtULRA0QIxWOD/p0o1VGkHOKYAAAAASUVORK5CYII="
        },
        398: function(t, e, n) {
            "use strict";
            n.r(e), e.default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAAEH5aXCAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAZKADAAQAAAABAAAAZAAAAAAMc/x7AAAb6klEQVR4Ae1dB5gUVbY+PUMOkoecEcGwIChpkWBCBVbXgAkXcFEXxSzP1RXTroqusK6RRTEg+MSAq6JiwIeAAcGEAoKkIScFiUOYrvf/VX2rb6Wu6u6ZAXXu91XXDeeee8IN56ZqkaJyRiMx7KeBPObGG9MjCKiHZcU+kXrlRNbukViFijZsjgLyZGBCE2SoiHf5CqKn25lUZvP9zUaR1Sh0HR4UJo2tQvSMJhZjxttGqNPJJwbzUbkYput5uGHUTvg3rjNhbIo8mawszt/uze1MFk+GTDAx3HalhejjD0Tqg4+6tsBEVq6wC7E9dmmKNFXOBb2TOqsh1ZhBQyUOsdrYlAeQsdUWvEPksTVOJApedkhNlcGOK3aPgx+WZjSURSCwjVmyxoOixObFaCXlKTkbmBD9zhWjHpT6x27OCsw0h5gp6t07LfG+8YIl8MZWrTdJMjEzF10OovLjln/hVyJ9Olh+/NrSNLErxQW9z+rKEtebuc0MB/ZboKT5hXGWX68F9JNHOjPDI/cE4U5mTvCRZFhlYSn18WxYbcW0z7OxlzGLiEP2OdLWbH1DrhJZr0kx0SJNOPzYirPpUymut5KQrTgzIi53uODMoAL2Szs04my+/cgxKHpNZn4wdpwhc2NrpZMd1jyeQiBkdqW7NRivt0IFkRmLRKa9JvLn653pjWKCwhx4HYHIlLOTdlUFOYCyrApkFVooN8TWy78cFKBdLzNrsF69J41VVTP8vWKxBcMmk2gWRhOp4SxEJbz8jD/Cy872xl/cxxvHmD7HWAWp5qRKsktnYRvWODNPfNwwaiHe7Ri3Nt8ZO+b2JCfApfCbb+rDLqiuD8KjazuRMdS6pjdOSYTvhjKLyJ2Kd5f8u44ib81zEBMYaIFKub8gmQzMaghxFEIIcpOE9PEx1ZPLBWfILlTjKio2EDxydVaYrPdO9D9VnVHhNJnwMCXqS3lZgO6zhs0nyYvLZ6C4qxvprzccqBPFslFXTpRyMt0Wk0pQ7zVSCUj2qKDfO7AQjP590RdN9cvkiQMWVV09aYiwRyw90azGqQq4HD3vhDdh+lYWKUTOYSPE2LTeMBrIgzqeQL+j5eutV/eznfduYxibYLjqbtUyFvSCG7lDXAD4Drwd5QZyhPcjtEHr6tk41yTab68jRJYtEflZasd2yI8qn7OQsNbOXBdeKpKLgWPiOIXDelNsuckoX6MgUEw0cO67WRdK0j/0THaCyY5VF2kDuTpZZMJn98DDzksimfZq0p/K9+zDydSWFT1jiSkutIXmUlaWm21ByddDRhoRiaFZicyqwmXlCROFQ0Ma0lv/IlLgam8LvxR5cowGFOKFXDfb4urQIMk6fRsxSipZ6yl+cUynoarS8qQli7Y4iQkrpuU2rFM+653XEFzA2/ccZ3ztehiknFFmSLdYypk5reEHJvI4VL/L7Cw0eTJ1mqnk1Ml6Ge7AuWObIygfvC7y4yZn3CeYUO742Rn33MPOcCJkq5pydEC4uWkEycYAwlk3ZuxSBfPMRS5iNC4oI9VpJiVoyEYk1LULYga9oDWJ2ZMNoHn27BJpbQ/pVsIegTItZ3PCoIcbRtL8XLRFpHothpxu9XKRjqhA5Z3ROhdMcRaSJ6dAFO+5sjiDFKojlzOZIaVwlWJV4UQotkneh2Y+Uom+75ACkL+2O5+jECbC+ugFK+RmN2CUMDlAfruLV3lS0pWG7bUeBTRQSN1vDyc6AKugKd+4PGrqQZGk3vulv0l9igJ0fKX+KBJQwo0CGwkGtkgT1OLTocJ+6OJbJGo0JqtYjmKnIjIHlfc1TCdnRkIYESgrRjBA/A025j9AYHaOVBgY/Auke2xLYlkoTYxpM4Jxej6ke0ya5VjgZFhN9oNKZjqb7n45IbZZZlsZw3+D0DlyGnkYY8rJBkdkuoG9yLAeBgEtT7fbhq5u2SIMGd2dKWd2EZk3Z2psnfR3JnhDKbstgptjWLZMENGIWywmrhpgLclw0G2IpzaeYzB+uplgntFPc9jqZ1pX9eUKRgW5QI1grttXKkScYwVhV/E5kFc+DP6tGMCPquOw+xWIWeWG3yBy/V0iP23G4tZZIgvn28mmJyb7MCa4h/lEkhPUDKEd3AtJQIQZONZxWjRVyoq0wGyoBobh/7yCNyyQJpAbbSmm054KFCPSghzyKBtLB/GgQk/UB6bqNB3I9LOOd2wnUhYUzJmLdwKiJgh8DYtALdt6skSO+GS6yMC+YBKFcKZWo6rIkb/D5tBqtJ1VXlMLUBiJHY3Ny4h74bQWqsLXLvM3MoVFCJgHUvVKVSijMBbZtcbR2KGN6x1jAqvAtC+KkJosUI241Zm5jPxVj3BoBL3DYiS21gHEyMUKACt+iGvMupaA43r1ZvhzkNftPp8pcmbP5MJxN/gnz3BDOcN7doo0Q3Vju1KOlMewdbVKtjLKoRGEMflzuRgqLZbD5ctPXAlaMA6YAo1ZrKzLgq80AM07GV2qXrtng7FU7qYhEK2LCcJzcC2QmiqrjpKJS8FlB5XoeFeq7Ag6ApT8ZmKO4EY/i/EBT1RX2TVpU/mokU2ySg8qvwT2WISohW70a/TvJe3qgGJq2OsM9Fx2jbI9hEMv8G5g3/4jBrP2eV50eszDd1ujdT0U3qWJyJsvimxZj6aDape/VGTsA+imQRVHdBK4Ll/P7fWzp/JnguNRHz0DIJ3OqCmHSWUs6AXVFPZk12AKefMoZ0Z3aMsGNGK0h88+Etm+A1vfWBI48QyRswaCOO5gpXDdW4HxZcEAhnyFuaijCXgYYW5UsaYYFFcGY0qkcJB8HMSeOyQUNBRgxKVY9X3G2TP5ZTJkLZho5E7yZYRAUEiONMY4G6QZNyaGUYNM17KZSNdesAS6wSxpgYEMGtiBXnIlqtdXc0RmfoBqhfbGribHzBHtJy7jYQkP9QMOZEQBQzvO1TWVUJJvUrlayuBFA8bXhTKicsGQfAMdQX8VLpE3qdvmXH4PKjcyIwoBOoNGUknyEU6nUqjs4W9SVChPowr9ORw4CZE2I8mslg+augWaotlvjbZugLAw88XlW2zD94ttTQ5wYdnc6Vkz4kaoh7GjkIferwYIzUWnUYDfDZB06pMDOoJSf6kESiVQZBIo8saOAfQEdMxng8Iu6Mny0MgxmcBvTLbgdyka/lvwT0OjX1VkXABR1oxgrbcS8DwI4oeZ2KKaNFa3+z3GjGGxDTIjW6YyZiRxxuMTMNAMks7OkYoDMhLTiH9kiigjRjAIfgEGOmTNgB/Ve+V0rPl6l6P8YLW4tBhB/e8Bi/WjjBnA0i8GxWDjhnMdPjnyNdrQsfBFdpHtJTDxLxCRHROrCrC4t1zk1vtEmrW0bFmuPLJq4tC1zFwIKxcRT05uD6sgjmi1DBjKUCSNoEFPg5QcU8tQzG6A7r1F/vdDdyw0AMv8y89Ejvu9M427xc2x8LBXasS2wQYOcaGMgInJYGJACJ7UyZT4B1+LtGkn0q2ZSOeeIuf9SaRTD0yuUgj9CKzc7IFptlp4qB7qDHYpGQETw8HEI8HZI6ZwSryJ3MCpVREG1Yzy/odFBl1tJjt+DsfMssCk37Fi4oBJBALbiFFF6qBNZM8EC2p3tFXcWy8l128pQiqDz8gbrHT9l4sXO20lxCDUgBU/K1MgI1Jd1mXcO+kEUfIj/2nF3IVjZX51wIBqWmNc/XautSI/5Tnso9R3rkjmSHt0OIHt1A8tj9GPQDf7gE5Pxn4KVa1Ccncq1UpQHLB82EX7UobogCsMXMfwurJgIlGlvYkpYpiH3SkJaQSJNmyK9awGVoaZ0ywJs72wHvi1ccYH1xETD4Q8EibN382A9uPhG4A3QhsPajDhXkr9uPYidz5k9UhhObb9ZK1CPgR61qAt6KvsYXlBcbQdq0bmkotTLhyRa1cTaYtdpKXYfV2H5VMWTgauvVHktvT4dtBaiPYx/EKRV1+xOgJqrN1R2LqD0fw5xheK2i3u/XJSbKN86MCjB9Az1PacP6yDM2s856k73jAZ0EuPyd6/r8AwLvc5xj7hEetyhzo3x3dDcx9HJ93pB8AYcytYZeLhyZU/ZE9kthiuG5g8AEjauD3ocg6lgYnNSE+ehoqh1a5So5YrZ0kGWf0aonfQO4g49ojXYcxPOGdbiGlMEKDaYQru4L55WoLt1On+oAedjOgp9G/GwnNUN2+WyMUYryaNDc9x+3CRS8/CdkNE/PvQq+jaYAkxnEDyc74NnQeI35gUXsN5TpjtSbWtqwYE52mROB9M2Jp4du0IhlUpZ3dL4lZl8PKc5pIayYFR4m5CbEGXXSwy/Q0ti4/3juucxzImw6byc3v34IYSHuVglci4kK77+kswh/HdiK2l0PCdZKTQozwLjiodeq7lD/pt3daZUq2CM6xC3CfR6zoFd2xnler/fn6idxzxgUwyYqS44VAxgDCFcMK7IlVrWnckuIMxb41K8b4nvGzBUTEnnCjS07+q2xndtcROcNJrd7+o3xXRgHZ7qhcz8kraD1qVSCIrfl+woTkXBmQnRYCtEUQGU7qdtshBcDu3B9thcflcp8hmxIwMUiNt5PWr9Hwl43/kbmcnopcal1f1oJuRj/VE20+ogYFzGhtMft9S5N4RyXCQ78yu2OK+KCg1Gf/v0Um/7mOD2CCz9SgnIwdklJ7o8C/6HpYvlmtSue+XizyB7pTXyW8eivMoX2J+gmq5CzcCPoWxen5Pa87OVZM5GEBTuTswaLoHQQWPG6woQe//PAaypDzjTRN7I7qlmJN/hd98X3gyVkymWyY5qyp7MTpWT4Y58Rp2lcjdj8IT4L6ZI3JaF+dUVwf12aa2ey0Fh97rO/gxIQhwhcjChbYyIbOhmeiSX5+EE3BLIVlwcVQ7kXMG4yBmxwDEieivP8V98m7BjZwUF0hVLKvu1BF5GamJYwKVQpb8qZm3Z2JWeIKOK3v/P28VGXNfsCasEtagh23sLszDCAGglfV41XMDO8JcJGiDEf1N9IKVqjiS0g4s/gb3htAB0IRJ5UhtodN8V+D+lf1nOdrbelSWxJs5lyzCSVJMSdlb8YBlOs6AJCY+jvzlcdimfTgTxB2X+focRC/OVyMEgDX8LCyxQTpwSj8bMqtcFbSHrj2wCIFq1wZz/Fp51vru+jUi33+LeTh6KxqBbPTgIbIjpaslFy/WBY8LZISQqGJYSTZ3pDwZI0eQQbqUJVkgKX9DFhz8q5bCuAZnt7IlgPmzxRGXJ1KumqCIlIyg/EJUgbpZE6IEk8kbN7LQLq4My5qSEWaGJDah7tc7KMwY8qp56yuMC9IZAcYEQVWP4VwQByHO64rXkaoDPh+RSFFqZEYUDqx9PYMKOdh33qKAsnvHMXI3xs2edemgCa1abmRQ9RAc3eR8mYNm0TmKtFBuw6idmy4TJCJtjeiUY+WkKbQzFc/RGWmIpbN7xs1HNOgHdNzp+rNiRC8MA2h/iOU2PJ1s8agxhIB6SXFcuzRkEnrEUZleDtPLdqN3p2UVxvZyZSDIAwMVsV9yANVmK/Y1NmeFtDRzqQRKJVAqgV+JBPS+/RfDEganXOwcVMV2bHncLqmMEcniIwZfAWZQ+2DkbpMdiCz8xTCVIPSQUwimpNj7kfZ4ToGYaSK0Aa0NEiL3ylc3HZgaxJEFxzMpiwH1KVT1ARbavoFh95MX6cGLCSK/RCgy6mCyVhbnwGIyEAUeB8PTosct5OKiRnEfh5pE5kJJz8N4fRnfCdlYXEWG4VUkhcEVSTpO11ZFJ3MZkF0N4TczkZaU8KNyoCTCrzbE5d9Q0njM9LmQVCJOFV9sheGcUR0I/3Y8l6P+lzPrYrGVVgyIKSEDY1Ict8xichfmxj8WQyk2ymJTCKaKV0IJvKtUrcSVwFbHb94eezyWYXCAJX85jldssz4/yuWJXKbjIfd+EuBqLLJJrcOwW4VF/LLYatqyBSdL0ZPtg7mAu+c49/4fQBS58yMn40KM6rB9KuHjablyQYkrQVFNYVbDzsC7X+ErH9gd8HM8FL0KSlqMvaxF80Xmf4EdhQU4c4MZOLdGHhovcuof/XLixCu2D++8BmdtJlCpk7CRPzzKwWp/ZN7YIlGIqYjK8hIIPOWgKULxxl2KO+4VufIWFWPtqPPzY/zoY1G5KVDI1YOhFDRHAythu+SSolBMVgoBKTn40OkYNOFrD7oiKGgqo0tnkVdmoptJbNFScMMGWV2TmpVURp9VvTpu1MOi5hduj8T2bOujre0o3pWI4vhxoB6H47N8OGmWgwyUZKGMxvLiTVGyB8FkrBCskfYAIVNBCPqHQ8Bx3ODe9yszcOf89xZBm7EmfXoHnOndEHz+Q5GObXY5uRc2M98HLPCEufFjcDb4RguvU4rbUTHOgOn8cRgKv3TqNi0HvnlbYBxaxUeHjDLIATdf//SXpDIYN+pmDOgRlEFYNowZMzAbaiwy613G+LsfMbAP7oubSFAG9eZUBvMcBtN+NmT0mD+C1LFedCngzW9ZVMDn4nKl3SHRRSlaaRG1aiHyDgbyKrCM6N77r8iQs1l9/IRmwQT90jDgKZ3q2I+r38BqMT/RysLDNBhdoY6SNXAhsEB6Y5NhRyh8AiCyQqCMxtgS4JVJHFGNir4Y4Fg2hcJH+cnFsy+JnHEePHD8BOtpx4osXxl2ksUEL7Yf0lWIgw37pHPUnZ9ICkncX50LZeAMc7GRbyEmftZOvtmNNG0lcngbDL4YC46CkBs1R82tad3D4Jdhyvoc/GBtXvE95h4wUTetg2KW4LwITNxVK3HuYwUUhv6N+NnlcE5SnI4SjuN4FZWyOfwLhKEKwXpTFcyvZ0EZXPCL5mjNKIuGOch0EOOEowLqQsgnnYHjgYMxoetStCYq0Pu6tfm4fToNn5p7AYd7MAbvBjHsjvxGVrZI0qpkQBjyFCrBBEwca2Ux6YnFzJCzW4BP5TA4jfdc6lHn6vU3L/r0wJ8HPfmgYfywwDAKdlsn8vfvw92ZJYbx4pOG8YdO1kes+QdDTcoaxrWXAPY7dXL/0Hh/+qFhXHSKRSf/nuJ4fLT70XsMY8m3uH+w3aKx8ID18e5pUwxjUF9+W955p0GXi/Ljrg4s07GpZM20lPoFgj5o1u+gVgTD0brp30/kMfThYR+XUtQYqGaxYJQK7Bf1fnGcyE3DQDKaUjBrcfQGp2KxcnoQb36N04SFyMqh6Y5EIBg9G9/w60TGvxldGcT+a1MGebrgcpH3sQRTCZYZuzc/F4NEy8htkG1QB+7bW1qoGmDiF5Nudp/pLoCF5sHEHMRaUepMCbRtLzJgkLVi4CcSaAIy7YldoO5+yYwLbCFQxLnIHNw6mJtXAXfvpq94HI8BF7mjVIrRUSapnCXTc4JAfBViNIPBmSPHB2Uy45lzK5RxzwhLMSmB00h8YhTWmNDsefmoLlo23/wy40Wn4E7E2jQQaaCTn8TV6BoJXCCcH2bg0+84mMQwj4vKcYY/6ZnwI9hlpDOqBe05jwNVXmee5cvFvjPmqd5UVwwrRH2cD38KM+MOXV2JaQS5bzEQQp8+w5p/uLOysVQoJzJlFu6Dd3KnBoeHny/yIgwOTFk8jo2FeCdOxUF8LIdk6gpht48cjrEUAztITOko8Tg+1rdXuvkd0vRtIciCKmoe2UuJ20zk5GrzJsySu2H5ApO0Ge+E5/GD2IbJXP6K4OGOlP68Dx/2/sYvt3/cfsBzQuhbF5GFwuEc6Nt5/vnDYtmlXjkALRhamBBBGcTHSkD55vhWkYAxJBdkGuZitpk70g/tBu6scVadieP/4ox6HK0ASnV3w2RiN54hg2HNDI2OnUvwY57FzB7GBwWvO4Wz72kiV/yPnhLdzytlTVta8L59TXRUCpL12+vi2KbMwfEYXse3NOqF8Y0hVUGNzjeDM7LnGSIrC7B7h1o9dbJ1nYy3gXtBaKdjHIyyLO7EiCUXDIWLsITCseK/k3DRcAn6eCi9Wy/Mny5ABWBnkIXLZU1Mw1FEBvbl9/ofPwrUK07svw/ZnhxZIVRcLpTx9OtYAsFE8bfgOMEdeiZuxWEeBh1HcpR4XN7BYQnUPq9LVZ3f9oKniGFBe9CnvoC+lIT+Fty82SIfTgsfyN2yMCRQtsEK2Y9vEfPiQDqOtWQqastTo9PJFQzLzaD8H4LT003Ztd36T5Y4TassHT8Swu/vF2BwCuxnfMqI4zZXPPgfTwIVgi3IZcg4Ma3CWD7NvpGYm4y934eaNKIu6A2rrR6uX7a25iG9YSw8/5i1nB4Vjfkpvk8guMGY28DubV4NX5I4EvjQ7896LyoWLxwrSt+OGOuWpbffQsUZ8hwumKz0IrViUurW/Behsvh4Qo7551NBOPzjueh48omwzd/IbCmdN4xHYyntKSiBH5ujokktLbBCPHQ1MCDzD1CqwooqAyHvQZ6tP+EM1Wbrm1isbjRb+GajIE1tW4ncPxaD+kkIZODefgmm7sWw2kBIYHX2wWspYwXo6ISDELDx/V1KhTALTh7yj1vRD6XdVlgbLEHc9DeRG/6eEQpkghLQLbBGv/4i9i3Qb69aaQlXUa/e+tBFf3VYaK3QsmilnXWRyBHHEFtmbvF8DODnoFUsTX/MsEqMYyJxGnqe91MRoFhJBcMb33/F+uR9kS0uNzYKhzX7fNSsux6CoGq7IQ7d8LtT8J2NYTjbtSlTRaiWfSNOO44JYzSSQogEZvC9aKK3ZKwURck+eGqiL78Cy/ZDrsEpQ+wUHmrus//DF6Nvx24iWiNn+el0TW5eKOG43Acz91Z3kl84skKYGUoZCeLuzlopihL0RGZH2LED1rFQC0+FTV8TY0JJOq7Ozp+L9a7xmE+8gmUgTCI5XmWjBJ3+OM4Br5P79ahU/rQUQkRYeDwH3RdGtiIjOUkfuzUO2DSfm2Pw7dBZ5PjueHfBh0saoTXVQKkYvNN1+zGab4UFzw9h8sMY8z7GnyJh/WrLNmuMUwZDunhTwxdiueZs7A7Cqonu0lYIUeMUSgMIbQZUcniRtZZUNHMMoqL40M/aS73wbdZkjQ1OSmlR8SE834Qtg6eoaj1QBTqSUigLcZ3/xNiu9C/+aJwEFhGYgMF+BJh8IBDgt5hQKNdj8IblkpnLSiEsMnErahIU079EWktmfBZvLkoxLlNkLU7AW+vSGZeXtUJUyYlJJL8d3/M3oxhLETMwv7gwyiE4JatU7yJTiCrE/BZFLv5eIce8S6iif31vfG8JX5a5EQLE8kDRuSJXiE4axphTYdY+AuW0/sW3Gqs1LMYE96pU56p0/jPxF6tCdIKwBHMeLJ07oaAjfzHKoXQKZQHovQMD9as6P8XlLzGF6AxAOc3Qaq7AMwgKqm+m0Zw9mE5JwkBHFJcJUMQ4tIQVJU2SIqOky3WUZ9TATd1yMAbK4CwYLopBSU3xWK6oFaXjNcy/apwJ4U/GSvBs/DMhpukH1ynyDi4VAaVDF+VwG6UpBNYSCuJS7RF4msFfC08VdCWHIczVJj5UHef6+5G2HaGd8PPLXPmo8QsRtwCpS/Gpq3wwzUWbUlcqgVIJlEqgVALZSeD/Ae9dXJXmmwPDAAAAAElFTkSuQmCC"
        },
        399: function(t, e, n) {
            "use strict";
            n.r(e), e.default = n.p + "static/media/settings.71f10705.png"
        },
        400: function(t, e, n) {},
        401: function(t, e, n) {},
        402: function(t, e, n) {},
        403: function(t, e, n) {},
        405: function(t, e, n) {
            "use strict";
            n.r(e);
            var i = n(0),
                r = n.n(i),
                o = n(20),
                s = n.n(o);
            n(188);
            Boolean("localhost" === window.location.hostname || "[::1]" === window.location.hostname || window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));
            var a = n(408),
                l = (n(189), n(45)),
                c = n(3),
                h = n(83),
                u = n(182),
                d = n(5);
            class p {}
            p.protocol = void 0;
            class f extends p {
                constructor(t, e, n) {
                    super(), this.positionX = 0, this.positionY = 0, this.positionZ = 0, this.intPositionX = 0, this.intPositionY = 0, this.intPositionZ = 0, this.velocityX = 0, this.velocityY = 0, this.velocityZ = 0, this.arcadeVelocityX = 0, this.arcadeVelocityY = 0, this.arcadeVelocityZ = 0, this.arcadeVelocityInfluenceX = 0, this.arcadeVelocityInfluenceY = 0, this.arcadeVelocityInfluenceZ = 0, this.velocityTargetX = 0, this.velocityTargetY = 0, this.velocityTargetZ = 0, this.viewVectorX = 0, this.viewVectorY = 0, this.viewVectorZ = 0, this.orientationX = 0, this.orientationY = 0, this.orientationZ = 0, this.orientationTargetX = 0, this.orientationTargetY = 0, this.orientationTargetZ = 0, this.up = !1, this.down = !1, this.left = !1, this.right = !1, this.run = !1, this.jump = !1, this.dance = !1, this.joystickEnabled = !1, this.joystickAngle = 0, this.positionX = t.position.x, this.positionY = t.position.y, this.positionZ = t.position.z, this.intPositionX = t.interpolatedPosition.x, this.intPositionY = t.interpolatedPosition.y, this.intPositionZ = t.interpolatedPosition.z, this.velocityX = t.velocity.x, this.velocityY = t.velocity.y, this.velocityZ = t.velocity.z, this.arcadeVelocityX = e.velocity.x, this.arcadeVelocityY = e.velocity.y, this.arcadeVelocityZ = e.velocity.z, this.arcadeVelocityInfluenceX = e.arcadeVelocityInfluence.x, this.arcadeVelocityInfluenceY = e.arcadeVelocityInfluence.y, this.arcadeVelocityInfluenceZ = e.arcadeVelocityInfluence.z, this.velocityTargetX = e.velocityTarget.x, this.velocityTargetY = e.velocityTarget.y, this.velocityTargetZ = e.velocityTarget.z, this.viewVectorX = e.viewVector.x, this.viewVectorY = e.viewVector.y, this.viewVectorZ = e.viewVector.z, this.orientationX = e.orientation.x, this.orientationY = e.orientation.y, this.orientationZ = e.orientation.z, this.orientationTargetX = e.orientationTarget.x, this.orientationTargetY = e.orientationTarget.y, this.orientationTargetZ = e.orientationTarget.z, this.up = n.up, this.down = n.down, this.left = n.left, this.right = n.right, this.jump = n.jump, this.run = n.run, this.dance = n.dance, this.joystickEnabled = e.joystickEnabled, this.joystickAngle = e.joystickAngle
                }
                static emptyCommand() {
                    return new this({
                        position: {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        interpolatedPosition: {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        velocity: {
                            x: 0,
                            y: 0,
                            z: 0
                        }
                    }, {
                        velocity: {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        arcadeVelocityInfluence: {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        velocityTarget: {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        viewVector: {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        orientation: {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        orientationTarget: {
                            x: 0,
                            y: 0,
                            z: 0
                        }
                    }, {
                        up: !1,
                        down: !1,
                        left: !1,
                        right: !1,
                        jump: !1,
                        run: !1,
                        dance: !1
                    })
                }
                static randomizeKeys(t) {
                    t.up = Math.random() >= .5, t.left = Math.random() >= .5, t.right = Math.random() >= .5, t.down = Math.random() >= .5, t.jump = Math.random() >= .5, t.run = Math.random() >= .5
                }
            }
            f.protocol = {
                positionX: {
                    type: d.a.Float32
                },
                positionY: {
                    type: d.a.Float32
                },
                positionZ: {
                    type: d.a.Float32
                },
                intPositionX: {
                    type: d.a.Float32
                },
                intPositionY: {
                    type: d.a.Float32
                },
                intPositionZ: {
                    type: d.a.Float32
                },
                velocityX: {
                    type: d.a.Float32
                },
                velocityY: {
                    type: d.a.Float32
                },
                velocityZ: {
                    type: d.a.Float32
                },
                arcadeVelocityX: {
                    type: d.a.Float32
                },
                arcadeVelocityY: {
                    type: d.a.Float32
                },
                arcadeVelocityZ: {
                    type: d.a.Float32
                },
                arcadeVelocityInfluenceX: {
                    type: d.a.Float32
                },
                arcadeVelocityInfluenceY: {
                    type: d.a.Float32
                },
                arcadeVelocityInfluenceZ: {
                    type: d.a.Float32
                },
                velocityTargetX: {
                    type: d.a.Float32
                },
                velocityTargetY: {
                    type: d.a.Float32
                },
                velocityTargetZ: {
                    type: d.a.Float32
                },
                viewVectorX: {
                    type: d.a.Float32
                },
                viewVectorY: {
                    type: d.a.Float32
                },
                viewVectorZ: {
                    type: d.a.Float32
                },
                orientationX: {
                    type: d.a.Float32
                },
                orientationY: {
                    type: d.a.Float32
                },
                orientationZ: {
                    type: d.a.Float32
                },
                orientationTargetX: {
                    type: d.a.Float32
                },
                orientationTargetY: {
                    type: d.a.Float32
                },
                orientationTargetZ: {
                    type: d.a.Float32
                },
                up: {
                    type: d.a.Boolean
                },
                down: {
                    type: d.a.Boolean
                },
                left: {
                    type: d.a.Boolean
                },
                right: {
                    type: d.a.Boolean
                },
                run: {
                    type: d.a.Boolean
                },
                jump: {
                    type: d.a.Boolean
                },
                dance: {
                    type: d.a.Boolean
                },
                joystickEnabled: {
                    type: d.a.Boolean
                },
                joystickAngle: {
                    type: d.a.Float32
                }
            };
            var m = f;
            class g {
                constructor() {
                    this.client = void 0, this.nid = 0, this.interpolatedPositionX = 0, this.interpolatedPositionY = -1e4, this.interpolatedPositionZ = 0, this.rotationX = 0, this.rotationY = 0, this.rotationZ = 0, this.tiltContainerPositionX = 0, this.tiltContainerPositionY = 0, this.tiltContainerPositionZ = 0, this.tiltContainerRotationX = 0, this.tiltContainerRotationY = 0, this.tiltContainerRotationZ = 0, this.faceString = "\ud83d\ude0e", this.name = "", this.hat = "none", this.videoSessionId = "", this.bodyColorR = 1, this.bodyColorG = 1, this.bodyColorB = 1, this.joystickEnabled = !1, this.joystickAngle = 0, this.characterSkinId = 0, this.clipName = "idle", this.fadeIn = 0
                }
                processCharTransformCommand(t) {
                    this.interpolatedPositionX = t.interpolatedPositionX, this.interpolatedPositionY = t.interpolatedPositionY, this.interpolatedPositionZ = t.interpolatedPositionZ, this.rotationX = t.rotationX, this.rotationY = t.rotationY, this.rotationZ = t.rotationZ, this.tiltContainerPositionX = t.tiltContainerPositionX, this.tiltContainerPositionY = t.tiltContainerPositionY, this.tiltContainerPositionZ = t.tiltContainerPositionZ, this.tiltContainerRotationX = t.tiltContainerRotationX, this.tiltContainerRotationY = t.tiltContainerRotationY, this.tiltContainerRotationZ = t.tiltContainerRotationZ
                }
                get x() {
                    return this.interpolatedPositionX
                }
                set x(t) {
                    this.interpolatedPositionX = t
                }
                get y() {
                    return this.interpolatedPositionY
                }
                set y(t) {
                    this.interpolatedPositionY = t
                }
            }
            g.protocol = void 0, g.protocol = {
                x: {
                    type: d.a.Float32
                },
                y: {
                    type: d.a.Float32
                },
                interpolatedPositionX: {
                    type: d.a.Float32
                },
                interpolatedPositionY: {
                    type: d.a.Float32
                },
                interpolatedPositionZ: {
                    type: d.a.Float32
                },
                rotationX: {
                    type: d.a.Float32
                },
                rotationY: {
                    type: d.a.Float32
                },
                rotationZ: {
                    type: d.a.Float32
                },
                tiltContainerPositionX: {
                    type: d.a.Float32
                },
                tiltContainerPositionY: {
                    type: d.a.Float32
                },
                tiltContainerPositionZ: {
                    type: d.a.Float32
                },
                tiltContainerRotationX: {
                    type: d.a.Float32
                },
                tiltContainerRotationY: {
                    type: d.a.Float32
                },
                tiltContainerRotationZ: {
                    type: d.a.Float32
                },
                faceString: {
                    type: d.a.UTF8String
                },
                name: {
                    type: d.a.UTF8String
                },
                hat: {
                    type: d.a.UTF8String
                },
                videoSessionId: {
                    type: d.a.UTF8String
                },
                bodyColorR: {
                    type: d.a.Float32
                },
                bodyColorG: {
                    type: d.a.Float32
                },
                bodyColorB: {
                    type: d.a.Float32
                },
                joystickEnabled: {
                    type: d.a.Boolean
                },
                joystickAngle: {
                    type: d.a.Float32
                },
                characterSkinId: {
                    type: d.a.UInt32
                },
                animationIndex: {
                    type: d.a.UInt32
                },
                clipName: {
                    type: d.a.ASCIIString
                },
                fadeIn: {
                    type: d.a.Float32
                }
            };
            var v = g;
            class y {
                constructor(t) {
                    this.entityId = void 0, this.entityId = t
                }
            }
            y.protocol = void 0, y.protocol = {
                entityId: d.a.UInt16
            };
            var x = y;
            class b extends p {
                constructor(t, e, n, i, r, o) {
                    super(), this.up = t, this.down = e, this.left = n, this.right = i, this.run = r, this.jump = o
                }
            }
            b.protocol = {
                up: {
                    type: d.a.Boolean
                },
                down: {
                    type: d.a.Boolean
                },
                left: {
                    type: d.a.Boolean
                },
                right: {
                    type: d.a.Boolean
                },
                run: {
                    type: d.a.Boolean
                },
                jump: {
                    type: d.a.Boolean
                }
            };
            var w = b;
            class _ extends p {
                constructor(t) {
                    super(), this.faceString = t
                }
            }
            _.protocol = {
                faceString: {
                    type: d.a.UTF8String
                }
            };
            var S = _;
            class M extends p {
                constructor(t) {
                    super(), this.name = t
                }
            }
            M.protocol = {
                name: {
                    type: d.a.UTF8String
                }
            };
            var A = M;
            class T extends p {
                constructor(t) {
                    super(), this.hat = t
                }
            }
            T.protocol = {
                hat: {
                    type: d.a.UTF8String
                }
            };
            class E extends p {
                constructor(t) {
                    super(), this.sessionId = t
                }
            }
            E.protocol = {
                sessionId: {
                    type: d.a.UTF8String
                }
            };
            class C extends p {
                constructor(t, e, n) {
                    super(), this.r = t, this.g = e, this.b = n
                }
            }
            C.protocol = {
                r: {
                    type: d.a.Float32
                },
                g: {
                    type: d.a.Float32
                },
                b: {
                    type: d.a.Float32
                }
            };
            var P = C;
            class L extends p {
                constructor(t) {
                    super(), this.newSkinId = t
                }
            }
            L.protocol = {
                newSkinId: {
                    type: d.a.UInt32
                }
            };
            var R = L;
            class I extends p {
                constructor(t, e) {
                    super(), this.interpolatedPositionX = 0, this.interpolatedPositionY = 0, this.interpolatedPositionZ = 0, this.rotationX = 0, this.rotationY = 0, this.rotationZ = 0, this.tiltContainerPositionX = 0, this.tiltContainerPositionY = 0, this.tiltContainerPositionZ = 0, this.tiltContainerRotationX = 0, this.tiltContainerRotationY = 0, this.tiltContainerRotationZ = 0, this.interpolatedPositionX = t.interpolatedPosition.x, this.interpolatedPositionY = t.interpolatedPosition.y, this.interpolatedPositionZ = t.interpolatedPosition.z, this.rotationX = e.rotation.x, this.rotationY = e.rotation.y, this.rotationZ = e.rotation.z, this.tiltContainerPositionX = e.tiltContainer.position.x, this.tiltContainerPositionY = e.tiltContainer.position.y, this.tiltContainerPositionZ = e.tiltContainer.position.z, this.tiltContainerRotationX = e.tiltContainer.rotation.x, this.tiltContainerRotationY = e.tiltContainer.rotation.y, this.tiltContainerRotationZ = e.tiltContainer.rotation.z
                }
            }
            I.protocol = {
                interpolatedPositionX: {
                    type: d.a.Float32
                },
                interpolatedPositionY: {
                    type: d.a.Float32
                },
                interpolatedPositionZ: {
                    type: d.a.Float32
                },
                rotationX: {
                    type: d.a.Float32
                },
                rotationY: {
                    type: d.a.Float32
                },
                rotationZ: {
                    type: d.a.Float32
                },
                tiltContainerPositionX: {
                    type: d.a.Float32
                },
                tiltContainerPositionY: {
                    type: d.a.Float32
                },
                tiltContainerPositionZ: {
                    type: d.a.Float32
                },
                tiltContainerRotationX: {
                    type: d.a.Float32
                },
                tiltContainerRotationY: {
                    type: d.a.Float32
                },
                tiltContainerRotationZ: {
                    type: d.a.Float32
                }
            };
            var F = I;
            class O extends p {
                constructor(t, e) {
                    super(), this.clipName = void 0, this.fadeIn = void 0, this.clipName = t, this.fadeIn = e
                }
            }
            O.protocol = {
                clipName: {
                    type: d.a.ASCIIString
                },
                fadeIn: {
                    type: d.a.Float32
                }
            };
            var N = O;
            var B = {
                    UPDATE_RATE: 30,
                    ID_BINARY_TYPE: d.a.UInt16,
                    TYPE_BINARY_TYPE: d.a.UInt8,
                    ID_PROPERTY_NAME: "nid",
                    TYPE_PROPERTY_NAME: "ntype",
                    protocols: {
                        entities: [
                            ["PlayerEntity", v]
                        ],
                        localMessages: [],
                        messages: [
                            ["IdentityCommand", x]
                        ],
                        commands: [
                            ["MoveCommand", m],
                            ["KeyCommand", w],
                            ["ChangeLookCommand", S],
                            ["ChangeNameCommand", A],
                            ["ChangeHatCommand", T],
                            ["ChangeVideoSessionCommand", E],
                            ["ChangeBodyColorCommand", P],
                            ["ChangeCharacterSkinCommand", R],
                            ["CharTransformCommand", F],
                            ["CharAnimationStateCommand", N]
                        ],
                        basics: []
                    }
                },
                D = n(80);
            const V = {
                parkourStarted: !1,
                parkourStartTimestamp: 0,
                bestCourseTime: 0,
                lastCourseTime: 0,
                parkourEnabled: !1
            };
            var j = n(181);
            n(197);
            const k = t => ({
                    type: "SET_USERNAME",
                    username: t
                }),
                U = t => ({
                    type: "SET_ROOM_ID",
                    roomId: t
                }),
                z = t => ({
                    type: "SET_ADMIN_MODE",
                    isAdminMode: t
                }),
                G = t => ({
                    type: "SET_CHAT_ENABLED",
                    isChatEnabled: t
                }),
                H = t => ({
                    type: "SET_CONNECTION_STATE",
                    newState: t
                });
            var W = n(17),
                Y = (n(200), n(49));
            var X = n(39),
                q = (n(201), n(203), n(206), n(208), n(60)),
                Q = n.n(q);
            X.initializeApp({
                apiKey: "AIzaSyBQ985qWDST-Tjtca0CE4oNh9ZRGBIC4P0",
                databaseURL: "https://dj3d-268321.firebaseio.com",
                authDomain: "dj3d-268321.firebaseapp.com",
                projectId: "dj3d-268321"
            });
            let Z = X.firestore(),
                J = X.database();
            X.auth().signInAnonymously().catch((function(t) {}));
            let K = X.functions().httpsCallable("createRoom"),
                $ = X.functions().httpsCallable("addToVideoQueue");
            let tt = X.functions().httpsCallable("getMatch");

            function et(t) {
                return Z.collection("roomData").doc(t).collection("chat")
            }

            function nt(t, e) {
                et(e).add(t)
            }
            const it = {
                gizmo_1: "a",
                gizmo_2: "a",
                gizmo_3: "a",
                gizmo_4: "a",
                gizmo_5: "a",
                gizmo_6: "a",
                ah_1: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1IT1VTTzI1UjZVQ1NDMjNSU09RTVgzMkxJT0tWTU1RNkpGWUxIQUZINDVMUjJOSU81Rk5RWEdHTElRJnNlY3JldD1EYWlzeVNvdXJDcmVhbQ==",
                ah_2: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1IT1VTTzI1UjZVQ1NDMjNSU09RTVgzMkxJT0tWTU1RNkpGWUxIQUZINDVMUjJOSU81Rk5RWEdHTElRJnNlY3JldD1CYXRXaW5nRGluZw==",
                ah_3: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1IT1VTTzI1UjZVQ1NDMjNSU09RTVgzMkxJT0tWTU1RNkpGWUxIQUZINDVMUjJOSU81Rk5RWEdHTElRJnNlY3JldD1NdWx0aVZpdGFtaW5DaGFsaw==",
                ah_4: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1IT1VTTzI1UjZVQ1NDMjNSU09RTVgzMkxJT0tWTU1RNkpGWUxIQUZINDVMUjJOSU81Rk5RWEdHTElRJnNlY3JldD1Qb290Um9vdFRvb3Q=",
                ah_5: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1IT1VTTzI1UjZVQ1NDMjNSU09RTVgzMkxJT0tWTU1RNkpGWUxIQUZINDVMUjJOSU81Rk5RWEdHTElRJnNlY3JldD1SaWNreUJvYmJ5Rmlyc3Q=",
                ah_6: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1IT1VTTzI1UjZVQ1NDMjNSU09RTVgzMkxJT0tWTU1RNkpGWUxIQUZINDVMUjJOSU81Rk5RWEdHTElRJnNlY3JldD1DaGlja2VuV2luZ0Rpbmc1Mw==",
                ah_7: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1IT1VTTzI1UjZVQ1NDMjNSU09RTVgzMkxJT0tWTU1RNkpGWUxIQUZINDVMUjJOSU81Rk5RWEdHTElRJnNlY3JldD1QaW5nUG9uZ0RpbmdEb25nMzE=",
                ah_8: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1IT1VTTzI1UjZVQ1NDMjNSU09RTVgzMkxJT0tWTU1RNkpGWUxIQUZINDVMUjJOSU81Rk5RWEdHTElRJnNlY3JldD1SaW5nUGluZ0Nob25nMTY=",
                ah_9: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1IT1VTTzI1UjZVQ1NDMjNSU09RTVgzMkxJT0tWTU1RNkpGWUxIQUZINDVMUjJOSU81Rk5RWEdHTElRJnNlY3JldD1Eb29kUG9vZFJvb2QxNQ==",
                ah_10: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1IT1VTTzI1UjZVQ1NDMjNSU09RTVgzMkxJT0tWTU1RNkpGWUxIQUZINDVMUjJOSU81Rk5RWEdHTElRJnNlY3JldD1NaWNrUmlja05pY2sxNA==",
                ah_11: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1IT1VTTzI1UjZVQ1NDMjNSU09RTVgzMkxJT0tWTU1RNkpGWUxIQUZINDVMUjJOSU81Rk5RWEdHTElRJnNlY3JldD1QaWNrTmlja1JpY2sxMg==",
                lx_1: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1MSU5YRElKVEpQUktFMlE0TllBM05RRldWTlVNUUlWVU9NUVBBWFg3STM1WERFQ05PN0RVVDJLWldRJnNlY3JldD1BcmdlbnRpbmEyMDIy",
                lx_2: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1MSU5YRElKVEpQUktFMlE0TllBM05RRldWTlVNUUlWVU9NUVBBWFg3STM1WERFQ05PN0RVVDJLWldRJnNlY3JldD1Xb3JsZHRvdXIyMDIy",
                lx_3: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1MSU5YRElKVEpQUktFMlE0TllBM05RRldWTlVNUUlWVU9NUVBBWFg3STM1WERFQ05PN0RVVDJLWldRJnNlY3JldD1BbWF6aW5nMjAyMg==",
                lx_4: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1MSU5YRElKVEpQUktFMlE0TllBM05RRldWTlVNUUlWVU9NUVBBWFg3STM1WERFQ05PN0RVVDJLWldRJnNlY3JldD1Sb2JvdDIwMjI=",
                lx_5: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1MSU5YRElKVEpQUktFMlE0TllBM05RRldWTlVNUUlWVU9NUVBBWFg3STM1WERFQ05PN0RVVDJLWldRJnNlY3JldD1Ib3JuczIwMjI=",
                lx_6: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1MSU5YRElKVEpQUktFMlE0TllBM05RRldWTlVNUUlWVU9NUVBBWFg3STM1WERFQ05PN0RVVDJLWldRJnNlY3JldD1SYWNpbmcyMDIy",
                lx_7: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1MSU5YRElKVEpQUktFMlE0TllBM05RRldWTlVNUUlWVU9NUVBBWFg3STM1WERFQ05PN0RVVDJLWldRJnNlY3JldD1QYWxlcm1vMjAyMg==",
                lx_8: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1MSU5YRElKVEpQUktFMlE0TllBM05RRldWTlVNUUlWVU9NUVBBWFg3STM1WERFQ05PN0RVVDJLWldRJnNlY3JldD1NZXhpY28yMDIy",
                lx_9: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1MSU5YRElKVEpQUktFMlE0TllBM05RRldWTlVNUUlWVU9NUVBBWFg3STM1WERFQ05PN0RVVDJLWldRJnNlY3JldD1BZnJpY2EyMDIy",
                lx_10: "aHR0cHM6Ly93d3cucmFuZGdhbGxlcnkuY29tL2FsZ28tY29sbGVjdGlvbi8/YWRkcmVzcz1MSU5YRElKVEpQUktFMlE0TllBM05RRldWTlVNUUlWVU9NUVBBWFg3STM1WERFQ05PN0RVVDJLWldRJnNlY3JldD1CYXJjZWxvbmEyMDIy"
            };

            function rt(t, e, n) {
                if (!window.gtag) return;
                let i = {
                    event_category: t
                };
                n && (i.event_label = n), window.gtag("event", e, i)
            }
            var ot = n(180),
                st = n(170),
                at = n.n(st);
            const lt = (t, e) => ({
                    type: "SET_WINDOW_OPEN",
                    windowId: t,
                    isOpen: e
                }),
                ct = t => ({
                    type: "TOGGLE_WINDOW_OPEN",
                    windowId: t,
                    isMobile: Lt.getState().ui.isMobile
                }),
                ht = (t, e) => ({
                    type: "SET_DOCK_VISIBLE",
                    windowId: t,
                    isVisible: e
                }),
                ut = t => ({
                    type: "SHOW_MODAL",
                    modalMessage: t
                });
            n(338);
            var dt = n(1);
            class pt extends r.a.PureComponent {
                constructor(t) {
                    super(t), this.state = {}
                }
                render() {
                    var t, e, n, i;
                    if (!this.props.disableRenderToggle && !this.props.transparentDisable && (null === (t = this.props.windows) || void 0 === t || null === (e = t[this.props.windowId]) || void 0 === e || !e.isOpen)) return null;
                    let r = {};
                    if (!this.props.transparentDisable || null !== (n = this.props.windows) && void 0 !== n && null !== (i = n[this.props.windowId]) && void 0 !== i && i.isOpen || (r.opacity = 0, r.pointerEvents = "none"), this.props.isMobile || this.props.forceCentering) {
                        let t = "DraggableWindow-MobileContainer";
                        return t += " DraggableWindow-TransparentBorder", Object(dt.jsx)("div", {
                            style: r,
                            className: t,
                            children: this.props.children
                        })
                    }
                    this.props.top && (r.top = this.props.top), this.props.left && (r.left = this.props.left), this.props.right && (r.right = this.props.right), this.props.bottom && (r.bottom = this.props.bottom);
                    let o = "DraggableWindow-DesktopContainer";
                    return this.props.styleTransparent || (o += " DraggableWindow-TransparentBorder"), Object(dt.jsx)(at.a, {
                        disabled: this.props.disableDrag,
                        children: Object(dt.jsx)("div", {
                            style: r,
                            className: o,
                            children: this.props.children
                        })
                    })
                }
            }
            const ft = {
                setWindowOpen: lt
            };
            var mt = Object(W.b)((function(t) {
                    const {
                        room: e
                    } = t;
                    return {
                        username: e.username,
                        windows: t.ui.windows,
                        isMobile: t.ui.isMobile
                    }
                }), ft)(pt),
                gt = n(340);
            const vt = [{
                    value: "none",
                    label: "None"
                }, {
                    value: "crown_red",
                    label: "Crown"
                }, {
                    value: "santa",
                    label: "Santa"
                }],
                yt = gt((() => {
                    rt("Customize", "Change Name V2")
                }), 1e3),
                xt = "\ud83d\ude0e";
            let bt = xt,
                wt = {
                    r: 1,
                    g: 1,
                    b: 1
                },
                _t = "";
            class St extends r.a.PureComponent {
                constructor(t) {
                    super(t), this.chooseEmoji = t => {
                        Mt(t.native), bt = t.native, Lt.dispatch({
                            type: "SET_USER_EMOJI",
                            newEmoji: t.native
                        }), this.setState({
                            currentEmoji: t.native
                        })
                    }, this.onClickEmojiStatus = () => {
                        this.setState({
                            showEmojiPicker: !0
                        })
                    }, this.onChangeName = t => {
                        let e = t.target.value;
                        _t = e, yt(), this.changeName(e)
                    }, this.stopEvent = t => {
                        t.stopPropagation(), t.nativeEvent.stopImmediatePropagation()
                    }, this.onChangeFace = t => {
                        let e = t.value;
                        rt("Customize", "Change Hat"), _e && ("none" === e ? _e.activeCharacter.removeHat() : _e.activeCharacter.changeHat(e), function(t) {
                            let e = new T(t);
                            It && Ht.addCommand(e)
                        }(e))
                    }, this.closeCustomizer = () => {
                        this.setState({
                            showEmojiPicker: !1
                        })
                    }, this.handleColorPick = t => {
                        if (null !== _e && void 0 !== _e && _e.activeCharacter) {
                            let e = t.rgb.r / 255,
                                n = t.rgb.g / 255,
                                i = t.rgb.b / 255;
                            _e.activeCharacter.changeCharacterColor(e, n, i), wt = {
                                r: e,
                                g: n,
                                b: i
                            }, Mt(bt, wt), Jt(e, n, i)
                        }
                    }, this.onClickSkinPickerBtn = () => {
                        rt("Customize", "Open Skin Picker"), this.props.toggleWindowOpen("SkinPicker")
                    }, this.state = {
                        showEmojiPicker: !1,
                        currentEmoji: xt
                    }
                }
                changeName(t) {
                    var e;
                    this.props.setUsername(t), e = t, _e && _e.activeCharacter && _e.activeCharacter.changeName(e), Zt(t)
                }
                renderCustomizer() {
                    return Object(dt.jsxs)("div", {
                        className: "EmojiPicker-Customizer",
                        children: [Object(dt.jsxs)("div", {
                            className: "EmojiPicker-Section",
                            children: [Object(dt.jsxs)("div", {
                                className: "EmojiPicker-SectionTitle",
                                children: [Object(dt.jsx)("span", {
                                    role: "img",
                                    "aria-label": "Hat Emoji",
                                    children: "\ud83d\udc51"
                                }), " ", "Hat"]
                            }), Object(dt.jsx)(Y.a, {
                                placeholder: "Choose Hat",
                                menuPlacement: "top",
                                options: vt,
                                onChange: this.onChangeFace,
                                isSearchable: !1
                            })]
                        }), Object(dt.jsxs)("div", {
                            className: "EmojiPicker-Section",
                            children: [Object(dt.jsxs)("div", {
                                className: "EmojiPicker-SectionTitle",
                                children: [Object(dt.jsx)("span", {
                                    role: "img",
                                    "aria-label": "Face Emoji",
                                    children: "\ud83d\ude0e"
                                }), " ", "Face"]
                            }), Object(dt.jsx)(j.a, {
                                title: "Change face!",
                                onSelect: this.chooseEmoji
                            })]
                        }), Object(dt.jsx)("div", {
                            className: "EmojiPicker-Section",
                            children: Object(dt.jsx)("div", {
                                className: "ColorPicker-Container",
                                children: Object(dt.jsx)(ot.a, {
                                    onChangeComplete: this.handleColorPick
                                })
                            })
                        }), Object(dt.jsx)("div", {
                            className: "EmojiPicker-DoneSection",
                            children: Object(dt.jsxs)("button", {
                                onClick: this.closeCustomizer,
                                className: "EmojiPicker-DoneButton",
                                children: [Object(dt.jsx)("span", {
                                    children: "DONE"
                                }), Object(dt.jsx)("i", {
                                    className: "material-icons md-light",
                                    children: "done"
                                })]
                            })
                        })]
                    })
                }
                render() {
                    return this.state.showEmojiPicker ? this.renderCustomizer() : Object(dt.jsx)(mt, {
                        disableDrag: !0,
                        bottom: 8,
                        right: 8,
                        windowId: "Customize",
                        children: Object(dt.jsxs)("div", {
                            className: "App-EmojiPicker",
                            children: [Object(dt.jsx)("div", {
                                children: Object(dt.jsx)("input", {
                                    onKeyDown: this.stopEvent,
                                    onKeyUp: this.stopEvent,
                                    className: "App-NameInput",
                                    maxLength: 11,
                                    onChange: this.onChangeName,
                                    type: "text",
                                    placeholder: "username (10 max)",
                                    value: this.props.username
                                })
                            }), Object(dt.jsxs)("div", {
                                className: "EmojiPicker-BottomContainer",
                                children: [!this.props.hideSkinPicker && Object(dt.jsx)("div", {
                                    onClick: this.onClickSkinPickerBtn,
                                    className: "EmojiPicker-ChooseSkinBtn",
                                    children: Object(dt.jsx)("img", {
                                        alt: "Choose Skin",
                                        className: "EmojiPicker-SkinImg",
                                        src: this.props.defaultThumbUrl || "images/skins/box.png"
                                    })
                                }), Object(dt.jsx)("div", {
                                    className: "EmojiPicker-Emoji",
                                    onClick: this.onClickEmojiStatus,
                                    children: this.state.currentEmoji
                                })]
                            })]
                        })
                    })
                }
            }

            function Mt(t, e) {
                e || (e = wt),
                    function(t, e) {
                        null === _e || void 0 === _e || _e.activeCharacter.changeCharacterFace(t, e)
                    }(t, e),
                    function(t) {
                        let e = new S(t);
                        It && Ht.addCommand(e);
                        zt && zt({
                            type: "ChangeLookCommand",
                            command: {
                                emoji: t
                            }
                        })
                    }(t), rt("Customize", "Change Face")
            }
            var At = Object(W.b)((function(t) {
                const {
                    room: e
                } = t;
                return {
                    username: e.username
                }
            }), {
                setUsername: k,
                toggleWindowOpen: ct
            })(St);
            const Tt = {
                roomId: "",
                username: "",
                userEmoji: xt,
                isAdminMode: !1,
                isChatEnabled: !1,
                videoQueueItems: [],
                connectionState: "CONNECTED",
                groupId: ""
            };
            const Et = n(351)(),
                Ct = {
                    isMobile: Et,
                    showModal: !1,
                    modalMessage: "",
                    windows: {
                        RoomCreator: {
                            offsetX: 0,
                            offsetY: 0,
                            isOpen: !Et,
                            inDock: !0
                        },
                        Chat: {
                            offsetX: 0,
                            offsetY: 0,
                            isOpen: !Et,
                            inDock: !1
                        },
                        ControlsWindow: {
                            offsetX: 0,
                            offsetY: 0,
                            isOpen: !Et,
                            inDock: !Et
                        },
                        VideoChatManager: {
                            offsetX: 0,
                            offsetY: 0,
                            isOpen: !Et,
                            inDock: !1
                        },
                        VideoQueue: {
                            offsetX: 0,
                            offsetY: 0,
                            isOpen: !Et,
                            inDock: !1
                        },
                        Parkour: {
                            offsetX: 0,
                            offsetY: 0,
                            isOpen: !1,
                            inDock: !1
                        },
                        YoutubeControls: {
                            offsetX: 0,
                            offsetY: 0,
                            isOpen: !Et,
                            inDock: !0
                        },
                        GraphicsQualityPicker: {
                            offsetX: 0,
                            offsetY: 0,
                            isOpen: !1,
                            inDock: !0
                        },
                        Customize: {
                            offsetX: 0,
                            offsetY: 0,
                            isOpen: !Et,
                            inDock: !0
                        },
                        Reddit: {
                            offsetX: 0,
                            offsetY: 0,
                            isOpen: !1,
                            inDock: !1
                        },
                        SkinPicker: {
                            offsetX: 0,
                            offsetY: 0,
                            isOpen: !1,
                            inDock: !1
                        }
                    }
                };
            var Pt = Object(D.a)({
                room: function() {
                    let t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tt,
                        n = arguments.length > 1 ? arguments[1] : void 0;
                    switch (n.type) {
                        case "SET_ROOM_ID":
                            return t = {...e
                            }, t.roomId = n.roomId, t;
                        case "SET_USERNAME":
                            return t = {...e
                            }, t.username = n.username, t;
                        case "SET_USER_EMOJI":
                            return t = {...e
                            }, t.userEmoji = n.newEmoji, t;
                        case "SET_ADMIN_MODE":
                            return t = {...e
                            }, t.isAdminMode = n.isAdminMode, t;
                        case "SET_CHAT_ENABLED":
                            return t = {...e
                            }, t.isChatEnabled = n.isChatEnabled, t;
                        case "SET_VIDEO_QUEUE_ITEMS":
                            return t = {...e
                            }, t.videoQueueItems = n.newItems, t;
                        case "SET_CONNECTION_STATE":
                            return t = {...e
                            }, t.connectionState = n.newState, t;
                        case "SET_GROUP_ID":
                            return t = {...e
                            }, t.groupId = n.newGroupId, t;
                        default:
                            return e
                    }
                },
                ui: function() {
                    let t = arguments.length > 1 ? arguments[1] : void 0,
                        e = {...arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ct
                        };
                    switch (t.type) {
                        case "SET_WINDOW_OPEN":
                            return e.windows = {...e.windows,
                                [t.windowId]: {...e.windows[t.windowId],
                                    isOpen: t.isOpen
                                }
                            }, e;
                        case "TOGGLE_WINDOW_OPEN":
                            if (t.isMobile)
                                for (const n in e.windows) n !== t.windowId && (e.windows[n] = {...e.windows[n],
                                    isOpen: !1
                                });
                            return e.windows = {...e.windows,
                                [t.windowId]: {...e.windows[t.windowId],
                                    isOpen: !e.windows[t.windowId].isOpen
                                }
                            }, e;
                        case "SET_DOCK_VISIBLE":
                            return e.windows = {...e.windows,
                                [t.windowId]: {...e.windows[t.windowId],
                                    inDock: t.isVisible
                                }
                            }, e;
                        case "SHOW_MODAL":
                            return e.showModal = !0, e.modalMessage = t.modalMessage, e;
                        default:
                            return e
                    }
                },
                parkour: function() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : V,
                        e = arguments.length > 1 ? arguments[1] : void 0,
                        n = {...t
                        };
                    switch (e.type) {
                        case "SET_PARKOUR_START_TIME":
                            return n.parkourStartTimestamp = e.timestamp, n;
                        case "SET_BEST_PARKOUR_COURSE_TIME_MS":
                            return n.bestCourseTime = e.deltaTime, n;
                        case "SET_PARKOUR_STARTED":
                            return n.parkourStarted = e.started, n;
                        case "SET_LAST_PARKOUR_COURSE_TIME_MS":
                            return n.lastCourseTime = e.deltaTime, n;
                        case "SET_PARKOUR_ENABLED":
                            return n.parkourEnabled = e.enabled, n;
                        default:
                            return t
                    }
                }
            });
            const Lt = Object(D.b)(Pt, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
            Lt.getState();
            const Rt = new d.a.Client(B, 100);
            let It = !1,
                Ft = "",
                Ot = !1,
                Nt = 500,
                Bt = 0;

            function Dt() {
                return Rt
            }

            function Vt(t) {
                let e = t;
                Ft = t, ei && (e = "ws://localhost:8080");
                try {
                    Rt.connect(e)
                } catch (n) {
                    console.error("Failure to connect", n)
                }
            }
            Rt.onConnect((t => {
                console.log("Connected to multiplayer server", t.text), It = !0, setTimeout((() => {
                    Zt(_t || Xt), qt.forEach((t => {
                        Ht.addCommand(t)
                    })), qt = []
                }), 5e3), Lt.dispatch(H("CONNECTED"))
            })), Rt.onClose((() => {
                console.log("connection closed"), Lt.dispatch(H("CONNECTING")), Ot ? Ot = !1 : (setTimeout((() => {
                    Vt(Ft), Bt++, Bt > 7 && (Nt = 1e3)
                }), Nt), It = !1)
            }));
            var jt = n(81);

            function kt(t) {
                if (0 === t) return _e && (null === _e || void 0 === _e ? void 0 : _e.defaultSkinGlbUrl) || "build/assets/boxman.glb";
                let e = jt.filter((e => e.id === t));
                return e.length > 0 ? "build/assets/skins/".concat(e[0].stringId, ".glb") : null
            }
            let Ut, zt, Gt, Ht = Dt(),
                Wt = new Map,
                Yt = 0,
                Xt = function() {
                    let t = Math.floor(9999 * Math.random());
                    return "user_".concat(t)
                }();
            let qt = [];

            function Qt() {
                if (!_e) return;
                _e.activeCharacter.changeCharacterFace("\ud83d\ude0e", {
                    r: 1,
                    g: 1,
                    b: 1
                }), _e.activeCharacter.changeName(Xt), Lt.dispatch(k(Xt));
                let t = {
                    r: Math.random(),
                    g: Math.random(),
                    b: Math.random()
                };
                _e.activeCharacter.changeCharacterColor(t.r, t.g, t.b), Mt(bt, t), wt.r = t.r, wt.g = t.g, wt.b = t.b, _e.activeCharacter.sendCharAnimationStateCommand = Kt, Jt(t.r, t.g, t.b)
            }

            function Zt(t) {
                let e = new A(t);
                It && Ht.addCommand(e), zt && zt({
                    type: "ChangeNameCommand",
                    command: {
                        name: t
                    }
                })
            }

            function Jt(t, e, n) {
                let i = new P(t, e, n);
                It ? Ht.addCommand(i) : qt.push(i), zt && zt({
                    type: "ChangeBodyColorCommand",
                    command: {
                        r: t,
                        g: e,
                        b: n
                    }
                })
            }

            function Kt(t, e) {
                let n = new N(t, e);
                It && Ht.addCommand(n), zt && zt({
                    type: "CharAnimationStateCommand",
                    command: n
                })
            }
            let $t = [],
                te = {},
                ee = new Set;

            function ne(t) {
                if (_e) {
                    let t = _e.activeCharacter;
                    t && $t.forEach((e => {
                        t.position.distanceTo(e.position) < 1 && async function(t) {
                            if (ee.has(t.name)) return;
                            Lt.dispatch(ut("You found a secret link! Please wait, redirecting..."));
                            let e = te[t.name];
                            e && e.data && e.data.url && setTimeout((() => {
                                const t = it[e.data.url];
                                t && (window.location.href = atob(t))
                            }), 3e3);
                            ee.add(t.name)
                        }(e)
                    }))
                }
            }
            n(352);
            class ie extends r.a.PureComponent {
                constructor(t) {
                    super(t), this.updateInterval = void 0, this.unsub = void 0, this.updateCurrentTime = () => {
                        this.props.started && this.setState({
                            currentTime: re(Date.now() - this.props.startTimestamp)
                        })
                    }, this.renderGlobalLeaderboard = () => {
                        let t = this.state.leaderboard.map(((t, e) => Object(dt.jsxs)("tr", {
                            children: [Object(dt.jsx)("td", {
                                children: t.username
                            }), Object(dt.jsx)("td", {
                                children: re(t.timeMs)
                            })]
                        }, e)));
                        return Object(dt.jsxs)("div", {
                            children: [Object(dt.jsx)("div", {
                                className: "ParkourTimer-Title",
                                children: "Leaderboard"
                            }), Object(dt.jsxs)("table", {
                                children: [Object(dt.jsx)("thead", {
                                    children: Object(dt.jsxs)("tr", {
                                        children: [Object(dt.jsx)("th", {
                                            children: "Name"
                                        }), Object(dt.jsx)("th", {
                                            children: "Time"
                                        })]
                                    })
                                }), Object(dt.jsx)("tbody", {
                                    children: t
                                })]
                            }), Object(dt.jsx)("hr", {})]
                        })
                    }, this.state = {
                        currentTime: "0:00",
                        leaderboard: []
                    }, this.updateInterval = setInterval(this.updateCurrentTime, 10)
                }
                componentDidUpdate(t) {
                    t.started && !this.props.started && this.setState({
                        currentTime: re(this.props.lastTime)
                    }), t.groupId !== this.props.groupId && this.props.groupId && (this.unsub && this.unsub(), this.unsub = Z.collection("leaderboard").doc(this.props.groupId).collection("times").orderBy("time", "asc").limit(3).onSnapshot((t => {
                        let e = [];
                        t.forEach((t => {
                            let n = t.data();
                            e.push({
                                username: n.username,
                                timeMs: n.time
                            })
                        })), this.setState({
                            leaderboard: e
                        })
                    })))
                }
                componentWillUnmount() {
                    this.updateInterval && clearInterval(this.updateInterval), this.unsub && this.unsub()
                }
                render() {
                    if (!this.props.enabled) return null;
                    let t = {};
                    return this.props.groupId && (t.width = "200px"), Object(dt.jsx)(mt, {
                        top: 180,
                        right: 8,
                        windowId: "Parkour",
                        children: Object(dt.jsxs)("div", {
                            style: t,
                            className: "ParkourTimer",
                            children: [this.props.groupId && this.renderGlobalLeaderboard(), Object(dt.jsx)("div", {
                                className: "ParkourTimer-Title",
                                children: "Parkour"
                            }), Object(dt.jsx)("div", {
                                children: "Time"
                            }), Object(dt.jsx)("div", {
                                children: this.state.currentTime
                            }), Object(dt.jsx)("br", {}), Object(dt.jsx)("div", {
                                children: "Best"
                            }), Object(dt.jsx)("div", {
                                children: re(this.props.bestTime)
                            })]
                        })
                    })
                }
            }

            function re(t) {
                var e = parseInt(t % 1e3),
                    n = parseInt(t / 1e3 % 60),
                    i = parseInt(t / 6e4 % 60);
                return (i = i < 10 ? "0" + i : i) + ":" + (n = n < 10 ? "0" + n : n) + "." + e
            }
            var oe = Object(W.b)((function(t) {
                return {
                    bestTime: t.parkour.bestCourseTime,
                    started: t.parkour.parkourStarted,
                    startTimestamp: t.parkour.parkourStartTimestamp,
                    lastTime: t.parkour.lastCourseTime,
                    enabled: t.parkour.parkourEnabled,
                    groupId: t.room.groupId
                }
            }))(ie);
            const se = "rooms";
            async function ae(t) {
                let e = await Z.collection(se).doc(t).get();
                return !!e.exists && e.data()
            }
            const le = t => ({
                    type: "SET_PARKOUR_START_TIME",
                    timestamp: t
                }),
                ce = t => ({
                    type: "SET_BEST_PARKOUR_COURSE_TIME_MS",
                    deltaTime: t
                }),
                he = t => ({
                    type: "SET_LAST_PARKOUR_COURSE_TIME_MS",
                    deltaTime: t
                }),
                ue = t => ({
                    type: "SET_PARKOUR_STARTED",
                    started: t
                }),
                de = t => ({
                    type: "SET_PARKOUR_ENABLED",
                    enabled: t
                });
            let pe, fe, me = !1,
                ge = 0,
                ve = 0;

            function ye(t) {
                if (_e) {
                    let t = _e.activeCharacter;
                    if (!t) return;
                    if (pe && fe && (t.position.distanceTo(pe.position) < 2 * pe.scale.x && (me ? Date.now() - ge > 3e3 && (ge = Date.now(), Lt.dispatch(le(ge))) : (me = !0, ge = Date.now(), Lt.dispatch(le(ge)), Lt.dispatch(ue(!0)), Lt.dispatch(de(!0)), Lt.getState().ui.isMobile || Lt.dispatch(lt("Parkour", !0)))), t.position.distanceTo(fe.position) < 2 * fe.scale.x && me)) {
                        let t = Date.now() - ge;
                        if (me = !1, !ve || t < ve) {
                            ve = t;
                            let e = Lt.getState().room.groupId;
                            if (e) {
                                !async function(t, e, n) {
                                    await Z.collection("leaderboard").doc(n).collection("times").add({
                                        username: t,
                                        time: e,
                                        timestamp: new Date
                                    })
                                }(Lt.getState().room.username, t, e)
                            }
                            Lt.dispatch(ce(t)),
                                function(t) {
                                    let e = Lt.getState();
                                    e.room.roomId && nt({
                                        author: e.room.username,
                                        text: t
                                    }, e.room.roomId)
                                }("[\ud83d\udc5f\u23f1 ".concat(re(t), "]"))
                        }
                        Lt.dispatch(he(t)), Lt.dispatch(ue(!1))
                    }
                }
            }
            const xe = new c.fb;
            let be, we, _e, Se;

            function Me(t) {
                _e = t
            }

            function Ae(t, e, n, i) {
                Ce(), we = e, _e = n,
                    function(t) {
                        var e, n = new h.b;
                        n.setSize(window.innerWidth, window.innerHeight), window.addEventListener("resize", (() => {
                            n.setSize(window.innerWidth, window.innerHeight)
                        }), !1), n.domElement.style.position = "absolute", n.domElement.style.top = "0px", n.domElement.style.zIndex = "-1", null === (e = _e) || void 0 === e || e.inputManager.setDomElement(n.domElement), be = n, t.forEach((t => {
                            let e = function(t) {
                                var e = document.getElementById(t.elementId);
                                if (!e) return;
                                e.style.height = "563px", e.style.width = "1000px";
                                var n = new h.a(e);
                                return n.userData.type = "youtube_player", n.position.set(t.position.x, t.position.y, t.position.z), n.rotation.set(t.rotation.x, t.rotation.y, t.rotation.z), n.scale.multiplyScalar(t.width / 1e3 * 1.0005), n
                            }(t);
                            e && xe.add(e)
                        }))
                    }(i), i.forEach((e => {
                        ! function(t, e) {
                            var n = new c.V(e.width, e.height),
                                i = new c.H(n, Te);
                            i.position.set(e.position.x, e.position.y, e.position.z), i.rotation.set(e.rotation.x, e.rotation.y, e.rotation.z), t.add(i)
                        }(t, e)
                    })), _e.renderer.domElement.style.pointerEvents = "none", be && document.body.appendChild(be.domElement), Se = new u.a(new c.rb(window.innerWidth, window.innerHeight), t, we), Se.visibleEdgeColor = new c.i(16777215), Se.hiddenEdgeColor = new c.i(16777215), n.composer.addPass(Se), _e.customUpdate = Pe
            }
            var Te = new c.I({
                color: 0,
                opacity: 0,
                side: c.k
            });

            function Ee(t, e) {
                var n;
                let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 100;
                if (t.children.length < 3) return;
                if (!e) return;
                t.updateMatrixWorld();
                let r = new c.sb,
                    o = new c.sb,
                    s = new c.sb,
                    a = !1,
                    l = !1,
                    u = !1;
                for (let c = 0; c < t.children.length; c++) {
                    let e = t.children[c];
                    "top_left" === e.userData.type && (e.getWorldPosition(s), a = !0), "top_right" === e.userData.type && (e.getWorldPosition(r), l = !0), "bottom_left" === e.userData.type && (e.getWorldPosition(o), u = !0)
                }
                if (!a || !l || !u) return void console.error("Error parsing css3d");
                let d = (new c.sb).subVectors(r, s),
                    p = (new c.sb).subVectors(o, s),
                    f = (new c.sb).crossVectors(p, d);
                f.normalize();
                let m = (new c.sb).subVectors(r, o);
                m.multiplyScalar(.5);
                let g = (new c.sb).addVectors(o, m),
                    v = (new c.sb).addVectors(g, f),
                    y = d.length(),
                    x = p.length();
                const b = new c.V(y, x),
                    w = new c.H(b, Te);
                w.position.copy(g), w.lookAt(v), w.updateMatrix();
                var _ = w.geometry.attributes.position.array;
                let S = new c.sb(_[0], _[1], _[2]);
                S.applyMatrix4(w.matrix);
                let M = (new c.sb).subVectors(S, g),
                    A = (new c.sb).subVectors(s, g),
                    T = M.angleTo(A);
                w.rotateOnWorldAxis(f, T), null === (n = _e) || void 0 === n || n.graphicsWorld.add(w), e.style.height = x * i + "px", e.style.width = y * i + "px";
                var E = new h.a(e);
                E.position.copy(g), E.scale.multiplyScalar(1 / i), E.lookAt(v), E.rotateOnWorldAxis(f, T), xe.add(E)
            }

            function Ce() {
                let t = [];
                for (let e = 0; e < xe.children.length; e++) {
                    let n = xe.children[e];
                    "youtube_player" !== n.userData.type && t.push(n)
                }
                for (let e = 0; e < t.length; e++) xe.remove(t[e])
            }

            function Pe(t) {
                we && be && be.render(xe, we),
                    function() {
                        if (_e && _e.activeCharacter) {
                            let t = new F(_e.activeCharacter.characterCapsule.physics.physical, _e.activeCharacter);
                            zt && zt({
                                type: "CharTransformCommand",
                                command: t
                            })
                        }
                        if (Gt && Gt(((t, e) => {
                                let n = Wt.get(e);
                                if ("CharTransformCommand" === t.type) {
                                    if (n) {
                                        const e = t.command;
                                        n.position.x = e.interpolatedPositionX, n.position.y = e.interpolatedPositionY, n.position.z = e.interpolatedPositionZ, n.rotation.x = e.rotationX, n.rotation.y = e.rotationY, n.rotation.z = e.rotationZ, n.tiltContainer.position.x = e.tiltContainerPositionX, n.tiltContainer.position.y = e.tiltContainerPositionY, n.tiltContainer.position.z = e.tiltContainerPositionZ, n.tiltContainer.rotation.x = e.tiltContainerRotationX, n.tiltContainer.rotation.y = e.tiltContainerRotationY, n.tiltContainer.rotation.z = e.tiltContainerRotationZ
                                    } else if (_e) {
                                        let t = "build/assets/boxman.glb";
                                        _e.loadingManager.loadGLTF(t, (t => {
                                            let n = new l.Character(t, !0);
                                            Wt.set(e, n), n.changeCharacterFace("\ud83d\ude0e", {
                                                r: 255,
                                                g: 255,
                                                b: 255
                                            }), n.faceString = "\ud83d\ude0e", t.scene.traverse((t => {
                                                t.frustumCulled = !1
                                            })), _e && (n.world = _e), n.setPhysicsEnabled(!1), null === _e || void 0 === _e || _e.add(n)
                                        }))
                                    }
                                } else if ("CharAnimationStateCommand" === t.type) n && n.setAnimation(t.command.clipName, t.command.fadeIn);
                                else if ("ChangeBodyColorCommand" === t.type) n && (n.changeCharacterColor(t.command.r, t.command.g, t.command.b), n.applyCharacterColor(), n.changeCharacterFace(n.faceString, n.bodyColor));
                                else if ("ChangeCharacterSkinCommand" === t.type) {
                                    if (n) {
                                        let e = kt(t.command.newSkinId);
                                        e && n.changeCharacterSkin(e)
                                    }
                                } else "ChangeNameCommand" === t.type ? n && n.changeName(t.command.name) : "ChangeLookCommand" === t.type && n && n.changeCharacterFace(t.command.emoji, n.bodyColor)
                            })), !It) return;
                        const t = Ht.readNetwork();
                        if (t.messages.forEach((t => {
                                "IdentityCommand" === t.protocol.name && (Yt = t.entityId)
                            })), _e && _e.activeCharacter) {
                            let t = new F(_e.activeCharacter.characterCapsule.physics.physical, _e.activeCharacter);
                            Ht.addCommand(t)
                        }
                        Ht.update(), t.entities.forEach((t => {
                            t.createEntities.forEach((t => {
                                if ("PlayerEntity" === t.protocol.name) {
                                    let e = t;
                                    if (t.nid === Yt) return;
                                    if (_e) {
                                        let n = "build/assets/boxman.glb";
                                        n = kt(e.characterSkinId) || n, _e.loadingManager.loadGLTF(n, (n => {
                                            let i = new l.Character(n, !0);
                                            n.scene.traverse((t => {
                                                t.frustumCulled = !1
                                            })), i.changeCharacterFace(e.faceString, {
                                                r: e.bodyColorR,
                                                g: e.bodyColorG,
                                                b: e.bodyColorB
                                            }), i.faceString = e.faceString, _e && (i.world = _e), i.setPhysicsEnabled(!1), i.changeName(e.name), i.changeHat(e.hat), i.videoSessionId = e.videoSessionId, i.setVideoTextureFromMap(), i.changeCharacterColor(e.bodyColorR, e.bodyColorG, e.bodyColorB), null === _e || void 0 === _e || _e.add(i), i.position.x = e.interpolatedPositionX, i.position.y = e.interpolatedPositionY, i.position.z = e.interpolatedPositionZ, i.rotation.x = e.rotationX, i.rotation.y = e.rotationY, i.rotation.z = e.rotationZ, i.tiltContainer.position.x = e.tiltContainerPositionX, i.tiltContainer.position.y = e.tiltContainerPositionY, i.tiltContainer.position.z = e.tiltContainerPositionZ, i.tiltContainer.rotation.x = e.tiltContainerRotationX, i.tiltContainer.rotation.y = e.tiltContainerRotationY, i.tiltContainer.rotation.z = e.tiltContainerRotationZ, i.setAnimation(e.clipName, e.fadeIn), i.joystickAngle = e.joystickAngle, i.joystickEnabled = e.joystickEnabled, Wt.set(t.nid, i)
                                        }))
                                    }
                                }
                            })), t.updateEntities.forEach((t => {
                                let e = t.nid;
                                if (e === Yt) return;
                                let n = Wt.get(e);
                                if (!n) return;
                                "interpolatedPositionX" === t.prop && (n.position.x = t.value), "interpolatedPositionY" === t.prop && (n.position.y = t.value), "interpolatedPositionZ" === t.prop && (n.position.z = t.value), "rotationX" === t.prop && (n.rotation.x = t.value), "rotationY" === t.prop && (n.rotation.y = t.value), "rotationZ" === t.prop && (n.rotation.z = t.value), "faceString" === t.prop && (n.changeCharacterFace(t.value, n.bodyColor), n.faceString = t.value), "name" === t.prop && n.changeName(t.value), "hat" === t.prop && n.changeHat(t.value), "videoSessionId" === t.prop && (n.videoSessionId = t.value, n.setVideoTextureFromMap());
                                let i = !1;
                                if ("bodyColorR" === t.prop && (i = !0, n.bodyColor.r = t.value), "bodyColorG" === t.prop && (i = !0, n.bodyColor.g = t.value), "bodyColorB" === t.prop && (i = !0, n.bodyColor.b = t.value), i && (n.applyCharacterColor(), n.changeCharacterFace(n.faceString, n.bodyColor)), "characterSkinId" === t.prop) {
                                    let e = kt(t.value);
                                    e && n.changeCharacterSkin(e)
                                }
                                "clipName" === t.prop && n.setAnimation(t.value, .1)
                            })), t.deleteEntities.forEach((t => {
                                let e = Wt.get(t);
                                e && (null === _e || void 0 === _e || _e.remove(e)), Wt.delete(t)
                            }))
                        }))
                    }(), ne(), ye()
            }
            n(353);
            var Le = n(41);
            const Re = Object(Le.a)({
                basename: "/"
            });
            var Ie = n(171),
                Fe = n.n(Ie),
                Oe = n(409);

            function Ne(t) {
                return "images/spaces/".concat(t, ".png")
            }
            const Be = ["default", "art", "forest", "living_room", "museum", "parkour"],
                De = ["algoanna", "gizmosphere", "algohouse", "apedrop2", "lynx", "lynxclub"];
            class Ve extends r.a.PureComponent {
                constructor(t) {
                    super(t), this.errorInterval = void 0, this.onClickLeaveRoom = () => {
                        window.location.href = "/"
                    }, this.createRoom = async() => {
                        this.setState({
                            status: "Creating room...",
                            isLoading: !0
                        }), this.state.isVideoChatEnabled && rt("Room", "Create Video Room");
                        try {
                            let t = Be[this.state.selectedSpaceIndex];
                            rt("Room", "Create Room", t);
                            let e = await K({
                                isAdminMode: !this.state.isFreeModeChecked,
                                isChatEnabled: this.state.isChatEnabled,
                                spaceId: t,
                                isVideoChatEnabled: this.state.isVideoChatEnabled,
                                isPubliclyListed: this.state.isPubliclyListed,
                                isProximityChatEnabled: this.state.isProximityChatEnabled,
                                isVideoQueueEnabled: this.state.isPubliclyListed,
                                subredditId: this.state.subredditId
                            });
                            "museum" === t && this.state.subredditId && rt("Reddit", "Create Reddit Room", this.state.subredditId), this.setState({
                                status: "Room created! Send the URL to friends!",
                                isLoading: !1
                            }), Re.replace("/".concat(this.props.path || "room", "/").concat(e.data.roomId)), this.setState({
                                url: window.location.href
                            })
                        } catch (t) {
                            console.log(t), this.setState({
                                isError: !0,
                                status: "Sorry, no rooms available now \ud83d\ude2d! Try again later.",
                                isLoading: !1
                            }), setTimeout((() => {
                                this.setState({
                                    isError: !1,
                                    status: "",
                                    timeoutLeft: 30
                                })
                            }), 3e4), this.errorInterval = setInterval((() => {
                                this.setState((t => ({
                                    timeoutLeft: t.timeoutLeft - 1
                                })))
                            }), 1e3)
                        }
                    }, this.getButtonText = () => this.state.isLoading ? "Loading..." : this.props.isInRoom ? "Leave Room" : "CREATE_ROOM", this.renderInRoom = () => Object(dt.jsxs)("div", {
                        children: [Object(dt.jsx)("div", {
                            className: "RoomCreator-Description",
                            children: Object(dt.jsx)(Oe.a, {
                                children: "Send this link to anyone who wants to join!"
                            })
                        }), Object(dt.jsxs)("div", {
                            className: "RoomCreator-CopyText",
                            children: [Object(dt.jsx)("input", {
                                className: "RoomCreator-Url",
                                type: "text",
                                value: this.state.url,
                                readOnly: !0
                            }), Object(dt.jsx)("button", {
                                onClick: this.onClickCopy,
                                className: "RoomCreator-CopyButton",
                                children: this.state.copied ? "Copied" : "Copy"
                            })]
                        })]
                    }), this.handleInputChange = t => {
                        const e = t.target;
                        "isPubliclyListed" === e.name && e.checked && this.setState({
                            isVideoChatEnabled: !1
                        }), this.setState({
                            [t.target.name]: e.checked
                        })
                    }, this.changeSpace = t => {
                        rt("Room", "Change Space"), this.setState((e => {
                            let n = e.selectedSpaceIndex + t;
                            return n < 0 ? n = Be.length - 1 : n >= Be.length && (n = 0), {
                                selectedSpaceIndex: n
                            }
                        }))
                    }, this.onKeyHandler = t => {
                        t.stopPropagation(), t.nativeEvent.stopImmediatePropagation()
                    }, this.handleSubredditIdChange = t => {
                        let e = t.target.value;
                        this.setState({
                            subredditId: e
                        })
                    }, this.renderPreloadImages = () => Be.map((t => Object(dt.jsx)("link", {
                        rel: "preload",
                        as: "image",
                        href: Ne(t)
                    }, t))), this.renderSolo = () => Object(dt.jsxs)("div", {
                        className: "RoomCreator-Description",
                        children: [this.renderPreloadImages(), Object(dt.jsx)("div", {
                            className: "RoomCreator-SoloDescription",
                            children: Object(dt.jsx)(Oe.a, {
                                children: "MULTIPLAYER_EXPLANATION"
                            })
                        }), Object(dt.jsx)("hr", {}), Object(dt.jsxs)("div", {
                            className: "RoomCreator-CheckBox",
                            children: [Object(dt.jsx)("input", {
                                type: "checkbox",
                                name: "isFreeModeChecked",
                                checked: this.state.isFreeModeChecked,
                                onChange: this.handleInputChange
                            }), Object(dt.jsx)(Oe.a, {
                                children: "ENABLE_FREE_MODE"
                            })]
                        }), Object(dt.jsxs)("div", {
                            className: "RoomCreator-CheckBox",
                            children: [Object(dt.jsx)("input", {
                                type: "checkbox",
                                name: "isChatEnabled",
                                checked: this.state.isChatEnabled,
                                onChange: this.handleInputChange
                            }), Object(dt.jsx)(Oe.a, {
                                children: "ENABLE_TEXT_CHAT"
                            })]
                        }), this.state.isVideoChatEnabled && Object(dt.jsxs)("div", {
                            className: "RoomCreator-CheckBox",
                            children: [Object(dt.jsx)("input", {
                                type: "checkbox",
                                name: "isProximityChatEnabled",
                                checked: this.state.isProximityChatEnabled,
                                onChange: this.handleInputChange,
                                readOnly: !0
                            }), Object(dt.jsx)(Oe.a, {
                                children: "ENABLE_PROXIMITY_AUDIO"
                            })]
                        }), Object(dt.jsxs)("div", {
                            className: "RoomCreator-SpaceSelect",
                            children: [Object(dt.jsx)("div", {
                                className: "RoomCreator-SpaceSelect-ArrowContainer",
                                children: Object(dt.jsx)("div", {
                                    children: Object(dt.jsx)("button", {
                                        onClick: () => this.changeSpace(-1),
                                        className: "RoomCreator-SpaceSelect-ArrowButton",
                                        children: Object(dt.jsx)("i", {
                                            className: "material-icons md-light",
                                            children: "navigate_before"
                                        })
                                    })
                                })
                            }), Object(dt.jsx)("div", {
                                children: Object(dt.jsx)("img", {
                                    alt: "Space Preview",
                                    src: Ne(Be[this.state.selectedSpaceIndex])
                                })
                            }), Object(dt.jsx)("div", {
                                className: "RoomCreator-SpaceSelect-ArrowContainer",
                                children: Object(dt.jsx)("div", {
                                    children: Object(dt.jsx)("button", {
                                        onClick: () => this.changeSpace(1),
                                        className: "RoomCreator-SpaceSelect-ArrowButton",
                                        children: Object(dt.jsx)("i", {
                                            className: "material-icons md-light",
                                            children: "navigate_next"
                                        })
                                    })
                                })
                            })]
                        }), "museum" === Be[this.state.selectedSpaceIndex] && Object(dt.jsxs)("div", {
                            className: "RoomCreator-RedditContainer",
                            children: [Object(dt.jsx)("div", {
                                className: "RoomCreator-RedditChip",
                                children: "r/"
                            }), Object(dt.jsx)("div", {
                                className: "RoomCreator-RedditInputContainer",
                                children: Object(dt.jsx)("input", {
                                    value: this.state.subredditId,
                                    onChange: this.handleSubredditIdChange,
                                    onKeyDown: this.onKeyHandler,
                                    className: "RoomCreator-RedditInput",
                                    type: "text"
                                })
                            })]
                        })]
                    }), this.onClickCopy = () => {
                        Fe()(this.state.url), this.setState({
                            copied: !0
                        })
                    };
                    let e = 0;
                    if (t.spaceId) {
                        let n = Be.indexOf(t.spaceId);
                        n >= 0 && (e = n)
                    }
                    this.state = {
                        isError: !1,
                        didCreateRoom: !1,
                        status: t.isInRoom ? "" : "Playing Solo",
                        isLoading: !1,
                        url: window.location.href,
                        copied: !1,
                        isFreeModeChecked: !0,
                        isChatEnabled: !0,
                        isVideoChatEnabled: !1,
                        timeoutLeft: 30,
                        isPubliclyListed: !1,
                        selectedSpaceIndex: e,
                        isProximityChatEnabled: !1,
                        subredditId: t.subredditId || "pics"
                    }
                }
                componentDidUpdate(t) {
                    t.roomId !== this.props.roomId && this.setState({
                        url: window.location.href
                    })
                }
                render() {
                    let t = "RoomCreator-Button";
                    return this.state.isError && (t += " RoomCreator-Disabled"), this.props.shardRoomScaling ? Object(dt.jsx)(mt, {
                        disableDrag: !0,
                        bottom: 8,
                        left: 8,
                        windowId: "RoomCreator",
                        children: Object(dt.jsx)("div", {
                            className: "RoomCreator",
                            children: Object(dt.jsx)("div", {
                                children: "CONNECTED" === this.props.connectionState ? "Connected!" : "Searching for players..."
                            })
                        })
                    }) : Object(dt.jsx)(mt, {
                        disableDrag: !0,
                        bottom: 8,
                        left: 8,
                        windowId: "RoomCreator",
                        children: Object(dt.jsxs)("div", {
                            className: "RoomCreator",
                            children: [Object(dt.jsx)("div", {
                                className: "RoomCreator-Title",
                                children: Object(dt.jsx)(Oe.a, {
                                    children: "MULTIPLAYER"
                                })
                            }), this.props.isInRoom ? this.renderInRoom() : this.renderSolo(), Object(dt.jsx)("button", {
                                className: t,
                                disabled: this.state.isLoading || this.state.isError,
                                onClick: this.props.isInRoom ? this.onClickLeaveRoom : this.createRoom,
                                children: Object(dt.jsx)(Oe.a, {
                                    children: this.getButtonText()
                                })
                            }), this.state.isError && Object(dt.jsxs)("div", {
                                children: ["Sorry, our servers are overloaded now! Please try again in", " ", this.state.timeoutLeft, " seconds!"]
                            }), this.props.isInRoom && Object(dt.jsx)("div", {
                                style: {
                                    color: "CONNECTED" === this.props.connectionState ? "rgb(18, 162, 4)" : "red"
                                },
                                className: "RoomCreator-ConnectionState",
                                children: this.props.connectionState
                            })]
                        })
                    })
                }
            }
            var je = Object(W.b)((function(t) {
                return {
                    isMobile: t.ui.isMobile,
                    connectionState: t.room.connectionState
                }
            }))(Ve);

            function ke(t) {
                if (null == document.getElementById("youtubeEmbedApi")) {
                    var e = document.createElement("script");
                    e.src = "https://www.youtube.com/iframe_api", e.id = "youtubeEmbedApi";
                    var n = document.getElementsByTagName("script")[0];
                    n.parentNode.insertBefore(e, n), window.onYouTubeIframeAPIReady = i
                } else i();

                function i() {
                    new window.YT.Player("youtube-iframe", {
                        playerVars: {
                            autoPlay: 1
                        },
                        events: {
                            onReady: r,
                            onStateChange: o
                        }
                    })
                }

                function r(e) {
                    t(e.target)
                }

                function o(t) {}
            }
            var Ue = n(114);
            n(356), n(357);
            const ze = n(358).parse(window.location.search);
            let Ge = "jfKfPfyJRdk";
            ze.v && (console.log(ze.v), Ge = ze.v);
            var He = function(t) {
                return t[t.UNSTARTED = -1] = "UNSTARTED", t[t.ENDED = 0] = "ENDED", t[t.PLAYING = 1] = "PLAYING", t[t.PAUSED = 2] = "PAUSED", t[t.BUFFERING = 3] = "BUFFERING", t[t.VIDEO_CUED = 5] = "VIDEO_CUED", t
            }(He || {});
            class We extends r.a.PureComponent {
                constructor(t) {
                    super(t), this.player = void 0, this.youtubeId = Ge, this.playingYoutubeId = Ge, this.startTimestamp = 0, this.watchdogInterval = void 0, this.isDraggingSlider = !1, this.seekTime = 0, this.serverTimeOffset = 0, this.serverIsPlaying = !0, this.didShowAdminMode = !1, this.twitchChannel = "", this.urlType = "Youtube", this.videoStatus = "LOADING", this.twitchPlayer = void 0, this.loadingRoomInfo = void 0, this.processRoomInfo = t => {
                        if ("LOADING" !== this.videoStatus) {
                            if (t) {
                                if (t.isAdminMode && (this.didShowAdminMode || this.setState({
                                        isAdminMode: !0 === t.isAdminMode,
                                        status: "Creator mode enabled. Only room creator can affect video."
                                    }), this.didShowAdminMode = !0), t.youtubeId || t.twitchChannel ? this.setState({
                                        isEmptyVideo: !1
                                    }) : this.setState({
                                        isEmptyVideo: !0
                                    }), "Youtube" === t.playerType) {
                                    if (t.startTimestamp || (t.startTimestamp = 0), t.youtubeId || (t.youtubeId = ""), this.state.isYoutubeLive !== t.isYoutubeLive && t.youtubeId === this.playingYoutubeId && t.isYoutubeLive && this.player && (this.playingYoutubeId = t.youtubeId, this.player.loadVideoById(t.youtubeId)), this.setState({
                                            isYoutubeLive: !0 === t.isYoutubeLive
                                        }), "YOUTUBE_READY" !== this.videoStatus) this.setState({
                                        playerType: "Youtube"
                                    });
                                    else if (this.player) {
                                        let e = Math.floor((Date.now() + this.serverTimeOffset - t.startTimestamp) / 1e3);
                                        t.seekTime && (e += t.seekTime), t.youtubeId !== this.playingYoutubeId && (t.isYoutubeLive ? (this.player.loadVideoById(t.youtubeId), this.playingYoutubeId = t.youtubeId) : (this.playingYoutubeId = t.youtubeId, this.player.loadVideoById(t.youtubeId, e))), t.isPlaying ? (this.player.playVideo(), this.setState({
                                            isPlaying: !0
                                        })) : (this.player.seekTo(t.seekTime, !0), this.player.pauseVideo(), this.setState({
                                            isPlaying: !1
                                        }))
                                    }
                                    this.serverIsPlaying = !!t.isPlaying, this.startTimestamp = t.startTimestamp ? t.startTimestamp : 0, this.seekTime = t.seekTime
                                }
                                "Twitch" === t.playerType && (this.twitchChannel = t.twitchChannel || "", "TWITCH_READY" === this.videoStatus ? this.loadTwitchByChannel(this.twitchChannel) : this.setState({
                                    playerType: "Twitch"
                                }))
                            }
                        } else this.loadingRoomInfo = t
                    }, this.updateVideoQueue = () => {
                        if (!this.props.videoQueueItems || 0 === this.props.videoQueueItems.length) return;
                        let t = Date.now() + this.serverTimeOffset,
                            e = this.props.videoQueueItems[0].serverTimestamp;
                        if (!e) return;
                        let n = e.toDate().getTime() - 1;
                        for (let r = 0; r < this.props.videoQueueItems.length; r++) {
                            var i;
                            let e = this.props.videoQueueItems[r];
                            if (!e.serverTimestamp) return;
                            let o = null === (i = e.serverTimestamp) || void 0 === i ? void 0 : i.toDate().getTime(),
                                s = 0;
                            s = o >= n ? o : n;
                            let a = 1e3 * e.duration;
                            if (e.skipped && e.skipTimestamp && (a = e.skipTimestamp - s), t >= s && t <= s + a) {
                                let t = {
                                    seekTime: 0,
                                    startTimestamp: s,
                                    youtubeId: e.youtubeId,
                                    playerType: "Youtube",
                                    isPlaying: !0
                                };
                                this.processRoomInfo(t);
                                break
                            }
                            n = s + a
                        }
                    }, this.startVideoWatchdog = () => {
                        this.watchdogInterval && clearInterval(this.watchdogInterval), this.watchdogInterval = setInterval((() => {
                            if (!this.player) return;
                            if (this.state.isYoutubeLive) return void(this.player.getPlayerState() === He.PAUSED && this.player.playVideo());
                            "Twitch" === this.state.playerType && this.watchdogInterval && clearInterval(this.watchdogInterval);
                            let t = this.player.getCurrentTime(),
                                e = this.player.getDuration();
                            if (!this.isDraggingSlider) {
                                this.setState({
                                    seekTime: Math.floor(t / e * 100)
                                });
                                let n = this.secondsToPlaybackString(t),
                                    i = this.secondsToPlaybackString(e);
                                this.setState({
                                    seekTimeString: n,
                                    durationString: i
                                })
                            }
                            if (!this.props.roomId) return;
                            let n = Math.floor((Date.now() + this.serverTimeOffset - this.startTimestamp) / 1e3);
                            if (n += this.seekTime, Math.abs(n - t) > 3) {
                                if (this.player.getDuration() > 0 && n > this.player.getDuration() && this.serverIsPlaying) return this.player.pauseVideo(), this.player.seekTo(n, !1), void this.setState({
                                    videoFinished: !0
                                });
                                this.serverIsPlaying ? (this.player.seekTo(n, !0), this.player.playVideo()) : (this.player.seekTo(this.seekTime, !1), this.player.pauseVideo())
                            }
                            this.setState({
                                videoFinished: !1
                            })
                        }), 1e3)
                    }, this.onPlayerReady = t => {
                        this.videoStatus = "YOUTUBE_READY", this.player = t, this.loadingRoomInfo ? (this.processRoomInfo(this.loadingRoomInfo), this.loadingRoomInfo = null) : this.youtubeId === Ge ? this.player.playVideo() : this.loadVideoById(this.youtubeId), this.setState({
                            durationString: this.secondsToPlaybackString(t.getDuration()),
                            volumeSliderValue: t.getVolume()
                        }), this.startVideoWatchdog()
                    }, this.getYoutubeId = t => {
                        var e = t.match(/^.*(youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/);
                        let n = t.match(/^(?:https?:\/\/)?(?:www\.|go\.)?twitch\.tv\/([a-z0-9_]+)($|\?)/);
                        return e && 11 === e[2].length ? {
                            type: "Youtube",
                            id: e[2]
                        } : !(!n || !n[1]) && {
                            type: "Twitch",
                            id: n[1]
                        }
                    }, this.handleUrlChange = t => {
                        let e = t.target.value,
                            n = this.getYoutubeId(e);
                        n && "Youtube" === n.type ? (this.youtubeId = n.id, this.urlType = "Youtube", this.setState({
                            playEnabled: !0,
                            isError: !1,
                            status: "",
                            inputText: e
                        })) : n && "Twitch" === n.type ? (this.twitchChannel = n.id, this.urlType = "Twitch", this.setState({
                            playEnabled: !0,
                            isError: !1,
                            status: "",
                            inputText: e
                        })) : this.setState({
                            playEnabled: !1,
                            isError: !0,
                            status: "Invalid URL! Example: https://www.youtube.com/watch?v=jfKfPfyJRdk",
                            inputText: e
                        })
                    }, this.loadVideoById = t => {
                        this.player && (this.youtubeId = t, this.playingYoutubeId = t, this.player.loadVideoById(t, 0))
                    }, this.loadTwitchByChannel = t => {
                        "Twitch" === this.state.playerType && this.twitchPlayer && this.twitchPlayer.setChannel(t)
                    }, this.onClickPlayNow = () => {
                        if (this.props.isVideoQueueEnabled) this.props.roomId && (this.setState({
                            inputText: "",
                            playEnabled: !1
                        }), $({
                            youtubeId: this.youtubeId,
                            roomId: this.props.roomId
                        }));
                        else if ("Youtube" === this.urlType ? (rt("Video", "Load Youtube"), "Youtube" !== this.state.playerType ? this.setState({
                                playerType: "Youtube"
                            }) : this.loadVideoById(this.youtubeId)) : "Twitch" === this.urlType && (rt("Video", "Load Twitch"), "Twitch" !== this.state.playerType ? this.setState({
                                playerType: "Twitch"
                            }) : this.loadTwitchByChannel(this.twitchChannel)), this.setState({
                                inputText: ""
                            }), this.props.roomId) {
                            "Youtube" === this.urlType ? async function(t, e, n, i) {
                                await Z.collection(se).doc(t).update({
                                    youtubeId: e,
                                    startTimestamp: n,
                                    seekTime: 0,
                                    isPlaying: !0,
                                    playerType: i,
                                    isYoutubeLive: !1
                                })
                            }(this.props.roomId, this.youtubeId, Date.now() + this.serverTimeOffset, "Youtube") : "Twitch" === this.urlType && async function(t, e) {
                                await Z.collection(se).doc(t).update({
                                    playerType: "Twitch",
                                    twitchChannel: e
                                })
                            }(this.props.roomId, this.twitchChannel), nt({
                                author: Lt.getState().room.username,
                                text: "[played a new ".concat(this.state.playerType, " video]")
                            }, this.props.roomId)
                        }
                    }, this.onBeforePlaybackSliderChange = t => {
                        this.isDraggingSlider = !0
                    }, this.onPlaybackSliderChange = t => {
                        if (this.setState({
                                seekTime: t
                            }), this.player) {
                            let e = this.player.getDuration(),
                                n = Math.floor(t / 100 * e);
                            this.seekTime = n, this.setState({
                                seekTimeString: this.secondsToPlaybackString(n)
                            }), this.player.seekTo(n, !1)
                        }
                    }, this.onAfterPlaybackSliderChange = t => {
                        if (this.isDraggingSlider = !1, this.player) {
                            let e = this.player.getDuration(),
                                n = Math.floor(t / 100 * e);
                            this.player.seekTo(n, !0), this.player.playVideo(), this.props.roomId && async function(t, e, n) {
                                await Z.collection(se).doc(t).update({
                                    seekTime: e,
                                    startTimestamp: Date.now()
                                })
                            }(this.props.roomId, n, this.serverTimeOffset)
                        }
                    }, this.onClickToggleMute = () => {
                        "YOUTUBE_READY" === this.videoStatus ? this.player && (this.player.isMuted() ? (this.player.unMute(), this.setState({
                            isMuted: !1,
                            volumeSliderValue: this.player.getVolume()
                        })) : (this.player.mute(), this.setState({
                            isMuted: !0,
                            volumeSliderValue: 0
                        }))) : "TWITCH_READY" === this.videoStatus && this.twitchPlayer && (this.state.isMuted ? (this.twitchPlayer.setMuted(!1), this.setState({
                            isMuted: !1
                        })) : (this.twitchPlayer.setMuted(!0), this.setState({
                            isMuted: !0
                        })))
                    }, this.onClickTogglePlay = () => {
                        if (this.player) {
                            this.player.getPlayerState() === He.PLAYING ? (this.player.pauseVideo(), this.setState({
                                isPlaying: !1
                            }), this.props.roomId && async function(t, e) {
                                await Z.collection(se).doc(t).update({
                                    isPlaying: !1,
                                    seekTime: e
                                })
                            }(this.props.roomId, this.player.getCurrentTime())) : (this.player.playVideo(), this.setState({
                                isPlaying: !0
                            }), this.props.roomId && async function(t, e) {
                                await Z.collection(se).doc(t).update({
                                    isPlaying: !0,
                                    startTimestamp: Date.now()
                                })
                            }(this.props.roomId, this.serverTimeOffset))
                        }
                    }, this.seekToLive = () => {
                        this.player && this.player.loadVideoById(this.playingYoutubeId)
                    }, this.onVolumeSliderChange = t => {
                        this.setState({
                            volumeSliderValue: t
                        }), "YOUTUBE_READY" === this.videoStatus ? this.player && this.player.setVolume(t) : "TWITCH_READY" === this.videoStatus && this.twitchPlayer && this.twitchPlayer.setVolume(t / 100)
                    }, this.onKeyHandler = t => {
                        "Enter" === t.key && this.onClickPlayNow(), t.stopPropagation(), t.nativeEvent.stopImmediatePropagation()
                    }, this.state = {
                        isEmptyVideo: !1,
                        playEnabled: !1,
                        isError: !1,
                        status: "",
                        inputText: "",
                        videoFinished: !1,
                        seekTime: 0,
                        durationString: "0:00",
                        seekTimeString: "0:00",
                        isPlaying: !0,
                        isMuted: !1,
                        volumeSliderValue: 20,
                        isAdminMode: !1,
                        playerType: "Youtube",
                        isYoutubeLive: !1
                    }, t.defaultVideo && (this.playingYoutubeId = t.defaultVideo), this.loadingRoomInfo = null
                }
                componentDidMount() {
                    this.props.started && ke(this.onPlayerReady), J.ref(".info/serverTimeOffset").on("value", (t => {
                        var e = t.val();
                        this.serverTimeOffset = e
                    })), setInterval(this.updateVideoQueue, 5e3)
                }
                componentWillUnmount() {
                    this.watchdogInterval && clearInterval(this.watchdogInterval)
                }
                componentDidUpdate(t, e) {
                    this.state.playerType !== e.playerType && (this.videoStatus = "LOADING", this.loadVideoPlayer()), this.props.roomId !== t.roomId && (this.watchdogInterval && clearInterval(this.watchdogInterval), this.props.roomId || this.setState({
                        isEmptyVideo: !1,
                        isYoutubeLive: !0
                    })), this.props.started && !t.started && (this.player || ke(this.onPlayerReady)), this.props.roomInfo && this.props.roomInfo !== t.roomInfo && this.processRoomInfo(this.props.roomInfo)
                }
                loadVideoPlayer() {
                    "Youtube" === this.state.playerType ? ke(this.onPlayerReady) : this.loadTwitchPlayer()
                }
                loadTwitchPlayer() {
                    var t = new Twitch.Embed("twitch-embed", {
                        width: "100%",
                        height: "100%",
                        channel: this.twitchChannel,
                        autoplay: !1,
                        parent: ["embed.example.com", "othersite.example.com"]
                    });
                    t.addEventListener(Twitch.Embed.VIDEO_READY, (() => {
                        this.videoStatus = "TWITCH_READY", this.loadingRoomInfo && (this.processRoomInfo(this.loadingRoomInfo), this.loadingRoomInfo = null);
                        var e = t.getPlayer();
                        this.twitchPlayer = e, e.play()
                    }))
                }
                secondsToPlaybackString(t) {
                    isNaN(t) && (t = 0);
                    let e = Math.floor(t / 3600),
                        n = Math.floor(t / 60 % 60) + "",
                        i = Math.floor(t) % 60 + "";
                    return i = i.padStart(2, "0"), e > 0 ? (n = n.padStart(2, "0"), "".concat(e, ":").concat(n, ":").concat(i)) : "".concat(n, ":").concat(i)
                }
                getStatus() {
                    return this.state.status
                }
                getIframe() {
                    if ("Youtube" === this.state.playerType) {
                        let t = this.playingYoutubeId;
                        t = this.playingYoutubeId === Ge && this.props.defaultVideo ? this.props.defaultVideo : Ge, this.props.roomId && (t = "");
                        let e = "0";
                        return ze.controls && (e = "1"), Object(dt.jsx)("iframe", {
                            id: "youtube-iframe",
                            title: "Youtube Player",
                            src: "https://www.youtube.com/embed/".concat(t, "?enablejsapi=1&autoplay=1&controls=").concat(e, "&fs=0&rel=0"),
                            frameBorder: "0",
                            allow: "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",
                            allowFullScreen: !0,
                            style: {
                                width: "100%"
                            }
                        })
                    }
                    return "Twitch" === this.state.playerType ? Object(dt.jsx)("div", {
                        style: {
                            width: "100%"
                        },
                        id: "twitch-embed"
                    }) : null
                }
                render() {
                    const t = this.state.isYoutubeLive || "jfKfPfyJRdk" === this.playingYoutubeId;
                    return Object(dt.jsxs)("div", {
                        children: [Object(dt.jsxs)("div", {
                            id: "youtubeContainer",
                            children: [this.state.isEmptyVideo && Object(dt.jsx)("div", {
                                style: {
                                    width: "100%"
                                },
                                className: "youtubeCover",
                                children: Object(dt.jsxs)("div", {
                                    className: "youtubeCover-Text",
                                    children: [Object(dt.jsxs)("div", {
                                        children: [Object(dt.jsx)(Oe.a, {
                                            children: "Room created"
                                        }), " \ud83e\udd18"]
                                    }), Object(dt.jsxs)("div", {
                                        children: [Object(dt.jsx)(Oe.a, {
                                            children: "Share the current URL to invite friends"
                                        }), " \ud83d\ude0e"]
                                    }), Object(dt.jsx)("br", {}), Object(dt.jsxs)("div", {
                                        children: [Object(dt.jsx)(Oe.a, {
                                            children: "Paste Youtube/Twitch URL to play videos"
                                        }), " \ud83d\udcfc"]
                                    })]
                                })
                            }), Object(dt.jsx)("div", {
                                className: this.props.isMobile ? "Youtube-CoverMobile" : ""
                            }), this.getIframe()]
                        }), Object(dt.jsx)(mt, {
                            disableDrag: !0,
                            bottom: 48,
                            left: "calc(50% - 150px)",
                            windowId: "YoutubeControls",
                            styleTransparent: !0,
                            children: Object(dt.jsxs)("div", {
                                className: "Youtube-Controls",
                                children: [this.state.status && Object(dt.jsx)("div", {
                                    className: "Youtube-Status",
                                    children: this.getStatus()
                                }), Object(dt.jsx)("div", {
                                    className: "Youtube-ControlsTitle",
                                    children: Object(dt.jsx)(Oe.a, {
                                        children: this.state.videoFinished ? "Video finished, paste new one" : this.props.isVideoQueueEnabled ? "Add to queue: Paste Youtube URL" : "Paste Youtube/Twitch URL"
                                    })
                                }), Object(dt.jsxs)("div", {
                                    children: [Object(dt.jsx)("input", {
                                        onChange: this.handleUrlChange,
                                        value: this.state.inputText,
                                        className: "Youtube-TextInput",
                                        onKeyDown: this.onKeyHandler,
                                        type: "text"
                                    }), Object(dt.jsx)("button", {
                                        disabled: !this.state.playEnabled,
                                        onClick: this.onClickPlayNow,
                                        className: "Youtube-PlayNow",
                                        children: this.props.isVideoQueueEnabled ? "Add" : "Play Now"
                                    })]
                                }), Object(dt.jsxs)("div", {
                                    className: "Youtube-SliderContainer",
                                    children: ["Youtube" === this.state.playerType && !t && Object(dt.jsxs)("div", {
                                        className: "Youtube-SeekContainer",
                                        children: [Object(dt.jsx)(Ue.a, {
                                            value: this.state.seekTime,
                                            disabled: this.props.isVideoQueueEnabled,
                                            onChange: this.onPlaybackSliderChange,
                                            onAfterChange: this.onAfterPlaybackSliderChange,
                                            onBeforeChange: this.onBeforePlaybackSliderChange,
                                            className: "Youtube-Slider",
                                            handleStyle: {
                                                width: 20,
                                                height: 20,
                                                marginTop: -8,
                                                backgroundColor: "#F40003",
                                                border: "none"
                                            },
                                            trackStyle: {
                                                backgroundColor: "#F40003"
                                            }
                                        }), Object(dt.jsxs)("div", {
                                            className: "Youtube-TimeText",
                                            children: [this.state.seekTimeString, " / ", this.state.durationString]
                                        })]
                                    }), t && Object(dt.jsx)("div", {
                                        onClick: this.seekToLive,
                                        className: "Youtube-LiveText",
                                        children: "Live"
                                    }), Object(dt.jsxs)("div", {
                                        className: "Youtube-TimeIndicator",
                                        children: ["Youtube" === this.state.playerType && !t && !this.props.isVideoQueueEnabled && Object(dt.jsx)("div", {
                                            children: Object(dt.jsx)("button", {
                                                className: "Youtube-PlaybackButton",
                                                onClick: this.onClickTogglePlay,
                                                children: Object(dt.jsx)("i", {
                                                    className: "material-icons md-light",
                                                    children: this.state.isPlaying ? "pause" : "play_arrow"
                                                })
                                            })
                                        }), Object(dt.jsx)("div", {
                                            children: Object(dt.jsx)("button", {
                                                className: "Youtube-PlaybackButton",
                                                onClick: this.onClickToggleMute,
                                                children: Object(dt.jsx)("i", {
                                                    className: "material-icons md-light",
                                                    children: this.state.isMuted ? "volume_off" : "volume_up"
                                                })
                                            })
                                        }), Object(dt.jsx)("div", {
                                            className: "Youtube-VolumeSlider",
                                            children: Object(dt.jsx)(Ue.a, {
                                                value: this.state.volumeSliderValue,
                                                onChange: this.onVolumeSliderChange
                                            })
                                        })]
                                    })]
                                })]
                            })
                        })]
                    })
                }
            }
            const Ye = {
                setAdminMode: z,
                setChatEnabled: G
            };
            var Xe = Object(W.b)((function(t) {
                return {
                    isMobile: t.ui.isMobile,
                    videoQueueItems: t.room.videoQueueItems
                }
            }), Ye)(We);
            n(106);
            class qe extends r.a.PureComponent {
                constructor() {
                    super(...arguments), this.onClickGoHome = () => {
                        let t = "";
                        this.props.roomType && (t = this.props.roomType), window.location.href = "/" + t
                    }
                }
                render() {
                    return Object(dt.jsx)("div", {
                        className: "ErrorModal",
                        children: Object(dt.jsxs)("div", {
                            className: "ErrorModal-Window",
                            children: [Object(dt.jsx)("div", {
                                children: "Room code not valid or expired!"
                            }), Object(dt.jsx)("button", {
                                onClick: this.onClickGoHome,
                                children: "Go Home"
                            })]
                        })
                    })
                }
            }
            var Qe = n(174);
            n(364);
            class Ze extends r.a.PureComponent {
                constructor() {
                    super(...arguments), this.renderStartButton = () => Object(dt.jsx)("button", {
                        onClick: this.props.onClickStart,
                        className: "App-ClickStart",
                        children: this.props.roomId ? "Join Room" : "PLAY"
                    }), this.renderLoading = () => Object(dt.jsx)("div", {
                        className: "GetStarted-LoadingContainer",
                        children: Object(dt.jsxs)("div", {
                            className: "lds-ellipsis",
                            children: [Object(dt.jsx)("div", {}), Object(dt.jsx)("div", {}), Object(dt.jsx)("div", {}), Object(dt.jsx)("div", {})]
                        })
                    })
                }
                render() {
                    return Object(dt.jsxs)("div", {
                        className: "App-ClickStartContainer",
                        children: [Object(dt.jsxs)("div", {
                            className: "GetStarted-RowMid",
                            children: [Object(dt.jsxs)("div", {
                                className: "GetStarted-Title",
                                children: [Object(dt.jsx)("img", {
                                    className: "GetStarted-Logo",
                                    alt: "Logo",
                                    src: n(365).default
                                }), Object(dt.jsx)("div", {
                                    className: "GetStarted-LogoText",
                                    children: this.props.subtitle ? this.props.subtitle : "Watch Youtube with friends in a 3D room!"
                                })]
                            }), this.props.isLoaded ? this.renderStartButton() : this.renderLoading()]
                        }), Object(dt.jsx)("div", {
                            className: "GetStarted-About",
                            children: Object(dt.jsx)("a", {
                                href: "/about",
                                children: "About"
                            })
                        }), Object(dt.jsx)("div", {
                            className: "GetStarted-TosContainer",
                            children: Object(dt.jsxs)("div", {
                                className: "GetStarted-Tos",
                                children: ["By using this site, you agree to DJ3D's", " ", Object(dt.jsx)("a", {
                                    href: "/terms",
                                    children: "Terms of Service"
                                }), ". Our", " ", Object(dt.jsx)("a", {
                                    href: "/privacy",
                                    children: "Privacy Policy"
                                }), " sets out how we handle your data. This site uses cookies to deliver its services and to analyze traffic."]
                            })
                        }), Object(dt.jsx)("div", {
                            className: "GetStarted-MangoBoxContainer",
                            children: Object(dt.jsx)("a", {
                                href: "https://www.mangobox.ai?utm_source=dj3d",
                                children: Object(dt.jsx)("img", {
                                    className: "GetStarted-Logo",
                                    alt: "Logo",
                                    src: n(366).default
                                })
                            })
                        })]
                    })
                }
            }
            n(367);
            var Je = n(175);
            class Ke extends r.a.Component {
                constructor(t) {
                    super(t), this.unsub = () => {}, this.chatRef = r.a.createRef(), this.onSendMessage = () => {
                        var t;
                        this.props.roomId && "" !== this.state.chatInput && (rt("Chat", "SendMessage"), nt({
                            author: this.props.username,
                            text: this.state.chatInput
                        }, this.props.roomId), this.setState({
                            chatInput: ""
                        }), null === (t = this.chatRef.current) || void 0 === t || t.blur())
                    }, this.renderMessages = () => this.state.messages.map((t => Object(dt.jsxs)("div", {
                        className: "Chat-Message",
                        children: [Object(dt.jsxs)("b", {
                            children: [t.author, ":"]
                        }), " ", t.text]
                    }, t.id))), this.addMessage = t => {
                        t.author || (t.author = "no_name"), this.setState((e => (e.messages.push(t), {
                            messages: e.messages
                        })))
                    }, this.onInputChange = t => {
                        this.setState({
                            chatInput: t.target.value
                        })
                    }, this.stopEvent = t => {
                        "Enter" === t.key && this.onSendMessage(), t.stopPropagation(), t.nativeEvent.stopImmediatePropagation()
                    }, this.state = {
                        chatInput: "",
                        messages: []
                    }
                }
                componentDidMount() {
                    this.props.roomId && (this.props.setDockVisible("Chat", !0), this.unsub = et(this.props.roomId).onSnapshot((t => {
                        t.docChanges().forEach((t => {
                            if ("added" === t.type) {
                                let e = t.doc.data();
                                e.id = t.doc.id, this.addMessage(e)
                            }
                        }))
                    })))
                }
                componentWillUnmount() {
                    this.unsub(), this.props.setDockVisible("Chat", !1)
                }
                render() {
                    return Object(dt.jsx)(mt, {
                        right: 8,
                        bottom: 150,
                        windowId: "Chat",
                        disableDrag: !0,
                        children: Object(dt.jsxs)("div", {
                            className: "Chat",
                            children: [Object(dt.jsx)("div", {
                                className: "Chat-MessageListContainer",
                                children: Object(dt.jsx)(Je.a, {
                                    className: "Chat-MessageList",
                                    children: this.renderMessages()
                                })
                            }), Object(dt.jsxs)("div", {
                                className: "RoomCreator-CopyText",
                                children: [Object(dt.jsx)("input", {
                                    id: "chatInput",
                                    className: "RoomCreator-Url",
                                    type: "text",
                                    value: this.state.chatInput,
                                    placeholder: "Chat",
                                    maxLength: 256,
                                    onChange: this.onInputChange,
                                    onKeyDown: this.stopEvent,
                                    ref: this.chatRef
                                }), Object(dt.jsx)("button", {
                                    onClick: this.onSendMessage,
                                    className: "RoomCreator-CopyButton",
                                    children: "Send"
                                })]
                            })]
                        })
                    })
                }
            }
            const $e = {
                setDockVisible: ht
            };
            var tn = Object(W.b)((function(t) {
                    return {
                        username: t.room.username
                    }
                }), $e)(Ke),
                en = n(111);
            n(368);

            function nn(t) {
                const e = Object(i.useRef)(null),
                    n = Object(i.useRef)(null);
                Object(i.useEffect)((() => {
                    if (e && e.current && t.videoTrack && (e.current.srcObject = new MediaStream([t.videoTrack]), !t.fullCenterVideo))
                        if (t.isLocalPerson) _e && _e.activeCharacter && _e.activeCharacter.setVideoTexture(e.current);
                        else if (_e) {
                        let i = !1;
                        _e.characters.forEach((r => {
                            r.videoSessionId === t.sessionId && (i = !0, e.current && r.setVideoTexture(e.current), n.current && r.setAudioChatElement(n.current))
                        })), i || _e.videoMap.set(t.sessionId, e.current)
                    }
                }), [t.videoTrack, t.isLocalPerson, t.sessionId, t.fullCenterVideo]), Object(i.useEffect)((() => {
                    if (n.current && t.audioTrack && (n.current.srcObject = new MediaStream([t.audioTrack])), !_e) return;
                    let e = !1;
                    _e.characters.forEach((i => {
                        i.videoSessionId === t.sessionId && (e = !0, n.current && i.setAudioChatElement(n.current))
                    })), e || n.current && _e.audioMap.set(t.sessionId, n.current)
                }), [t.audioTrack, t.sessionId]);
                let r = t.videoTrack && Object(dt.jsx)("video", {
                        className: t.fullCenterVideo ? "VideoChatManager-FullCenteredVideoTile" : "VideoChatManager-MyTile",
                        autoPlay: !0,
                        muted: !0,
                        playsInline: !0,
                        ref: e
                    }),
                    o = !t.isLocalPerson && t.audioTrack && Object(dt.jsx)("audio", {
                        autoPlay: !0,
                        playsInline: !0,
                        ref: n
                    });
                return t.fullCenterVideo ? Object(dt.jsxs)("div", {
                    className: "VideoChatManager-FullCenteredVideo",
                    children: [r, o]
                }) : Object(dt.jsxs)("span", {
                    style: {
                        position: "absolute"
                    },
                    children: [r, o]
                })
            }
            var rn = t => {
                    let {
                        parentId: e,
                        children: n
                    } = t;
                    const i = document.getElementById(e);
                    return i ? Object(o.createPortal)(n, i) : null
                },
                on = n(50);
            const sn = en.a.supportedBrowser().supported;

            function an(t) {
                const [e] = Object(i.useState)(en.a.createCallObject()), [n, r] = Object(i.useState)([]), [o, s] = Object(i.useState)(!1), [a, l] = Object(i.useState)(!1), [c, h] = Object(i.useState)(!1), [u, d] = Object(i.useState)(!1), [p, f] = Object(i.useState)(!1), [m, g] = Object(i.useState)(!1), [v, y] = Object(i.useState)(!1), [x, b] = Object(i.useState)([]), [w, _] = Object(i.useState)([]), [S, M] = Object(i.useState)(!1), [A, T] = Object(i.useState)(null), [C, P] = Object(i.useState)(null), L = Object(i.useRef)(null), R = Object(i.useCallback)((() => {
                    l(!1)
                }), []), I = Object(i.useCallback)((() => {
                    l(!0)
                }), []), F = Object(i.useCallback)((() => {
                    l(!0)
                }), []), O = Object(i.useCallback)((t => {
                    let e = {
                        deviceId: {
                            exact: t
                        }
                    };
                    navigator.mediaDevices.getUserMedia({
                        video: e
                    }).then((function(t) {
                        L.current && (L.current.srcObject = t)
                    })).catch((function(t) {
                        console.log("Something went wrong!")
                    }))
                }), []);
                Object(i.useEffect)((() => {
                    A && a && O(A)
                }), [A, a, S, O]), Object(i.useEffect)((() => {
                    Lt.dispatch(ht("VideoChatManager", !0))
                }), []);
                const N = Object(i.useCallback)((async() => {
                        try {
                            await navigator.mediaDevices.getUserMedia({
                                video: !0,
                                audio: !0
                            }), M(!0)
                        } catch (t) {
                            console.log(t), M(!1)
                        }
                    }), []),
                    B = Object(i.useCallback)((() => {
                        !o && t.roomUrl && (y(!0), e.join({
                            url: t.roomUrl,
                            audioSource: !1,
                            videoSource: !1
                        })), R()
                    }), [o, t.roomUrl, R, e]);
                Object(i.useEffect)((() => {
                    B()
                }), [B]);
                const D = Object(i.useCallback)((() => {
                        e && (e.leave(), g(!1), null !== _e && void 0 !== _e && _e.activeCharacter.videoSprite && (_e.activeCharacter.videoSprite.visible = !1))
                    }), [e]),
                    V = Object(i.useCallback)((() => {
                        e && (e.setLocalVideo(!1), null !== _e && void 0 !== _e && _e.activeCharacter.videoSprite && (_e.activeCharacter.videoSprite.visible = !1), rt("VideoChat", "Disable video"))
                    }), [e]),
                    j = Object(i.useCallback)((() => {
                        e && (e.setLocalVideo(!0), null !== _e && void 0 !== _e && _e.activeCharacter.videoSprite && (_e.activeCharacter.videoSprite.visible = !1), rt("VideoChat", "Enable video"))
                    }), [e]),
                    k = Object(i.useCallback)((() => {
                        e && (e.setLocalAudio(!1), rt("VideoChat", "Disable audio"))
                    }), [e]),
                    U = Object(i.useCallback)((() => {
                        e && (e.setLocalAudio(!0), rt("VideoChat", "Enable video"))
                    }), [e]),
                    z = Object(i.useCallback)((t => {
                        e && (e.setInputDevicesAsync({
                            videoDeviceId: t.value
                        }), T(t.value))
                    }), [e]),
                    G = Object(i.useCallback)((t => {
                        e && (e.setInputDevicesAsync({
                            audioDeviceId: t.value
                        }), P(t.value))
                    }), [e]),
                    H = Object(i.useCallback)((() => {
                        e && (e.startScreenShare(), f(!0), rt("VideoChat", "Start ScreenShare"))
                    }), [e]),
                    W = Object(i.useCallback)((() => {
                        e && (e.stopScreenShare(), f(!1), rt("VideoChat", "Stop ScreenShare"))
                    }), [e]),
                    X = Object(i.useCallback)((() => {
                        e.setInputDevicesAsync({
                            videoDeviceId: A,
                            audioDeviceId: C
                        })
                    }), [e, C, A]);
                if (Object(i.useEffect)((() => {
                        if (!e) return;
                        const t = ["joined-meeting", "left-meeting", "error"];

                        function n(t) {
                            switch (e.meetingState()) {
                                case "joined-meeting":
                                    rt("VideoChat", "Join Meeting"), s(!0), y(!1), Lt.getState().ui.isMobile && Lt.dispatch(lt("VideoChatManager", !1));
                                    break;
                                case "left-meeting":
                                    s(!1);
                                    break;
                                case "error":
                                    s(!1), y(!1)
                            }
                        }
                        n();
                        for (const i of t) e.on(i, n);
                        return function() {
                            for (const i of t) e.off(i, n)
                        }
                    }), [e]), Object(i.useEffect)((() => {
                        e && e.enumerateDevices().then((t => {
                            let e = [],
                                n = [],
                                i = !1,
                                r = !1;
                            t.devices.forEach((t => {
                                "videoinput" === t.kind && (e.push({
                                    label: t.label,
                                    value: t.deviceId
                                }), i || (T(t.deviceId), i = !0)), "audioinput" === t.kind && (n.push({
                                    label: t.label,
                                    value: t.deviceId
                                }), r || (P(t.deviceId), r = !0))
                            })), b(e), _(n)
                        }))
                    }), [e, S]), Object(i.useEffect)((() => {
                        if (!e) return;
                        const t = ["participant-joined", "participant-updated", "participant-left"];

                        function n(t) {
                            let n = e.participants(),
                                i = Object.keys(n).map((t => {
                                    let e = n[t];
                                    return "local" === t && (! function(t) {
                                        let e = new E(t);
                                        It && Ht.addCommand(e)
                                    }(e.session_id), n.local && (console.log(n.local), h(n.local.video), d(n.local.audio))), {
                                        videoTrack: e.videoTrack,
                                        audioTrack: e.audioTrack,
                                        sessionId: e.session_id,
                                        isLocal: "local" === t,
                                        screen: e.screen,
                                        screenVideoTrack: e.screenVideoTrack,
                                        screenAudioTrack: e.screenAudioTrack
                                    }
                                }));
                            r(i)
                        }
                        n();
                        for (const i of t) e.on(i, n);
                        return function() {
                            for (const i of t) e && e.off(i, n)
                        }
                    }), [e]), !t.started) return null;
                if (!sn) return Object(dt.jsx)("div", {
                    children: "Not supported"
                });
                let q = n.filter((t => !t.isLocal)).map((t => Object(dt.jsx)(nn, {
                        videoTrack: t.videoTrack,
                        audioTrack: t.audioTrack,
                        isLocalPerson: t.isLocal,
                        sessionId: t.sessionId
                    }, t.sessionId))),
                    Q = n.map((t => t.screenVideoTrack ? Object(dt.jsx)(rn, {
                        parentId: "youtubeContainer",
                        children: Object(dt.jsx)(nn, {
                            videoTrack: t.screenVideoTrack,
                            audioTrack: t.screenAudioTrack,
                            isLocalPerson: t.isLocal,
                            sessionId: t.sessionId,
                            fullCenterVideo: !0
                        }, t.sessionId + "_screenshare")
                    }) : null)),
                    Z = n.find((t => t.isLocal)),
                    J = null;
                Z && (J = Object(dt.jsx)(nn, {
                    videoTrack: Z.videoTrack,
                    audioTrack: Z.audioTrack,
                    isLocalPerson: Z.isLocal,
                    sessionId: Z.sessionId
                }, Z.sessionId));
                let K = x.find((t => t.value === A)) || null,
                    $ = w.find((t => t.value === C)) || null;
                return K || x.length > 0 && x[0].label && (K = x[0]), $ || w.length > 0 && w[0].label && ($ = w[0]), Object(dt.jsxs)("div", {
                    className: "VideoChatManager",
                    children: [Object(dt.jsx)("div", {
                        className: "VideoChatManager-OtherTiles",
                        children: q
                    }), Object(dt.jsx)(rn, {
                        parentId: "youtubeContainer",
                        children: Q
                    }), Object(dt.jsx)(mt, {
                        transparentDisable: !0,
                        bottom: 8,
                        right: 232,
                        windowId: "VideoChatManager",
                        children: Object(dt.jsx)("div", {
                            className: "VideoChatManager-TileContainer",
                            children: Object(dt.jsxs)("div", {
                                className: "VideoChatManager-MyTile",
                                children: [o && J, !m && Object(dt.jsx)("button", {
                                    disabled: v,
                                    className: "VideoChatManager-BtnJoin",
                                    onClick: F,
                                    children: v ? "Joining..." : "Join Video Chat"
                                }), o && Object(dt.jsx)("button", {
                                    className: "VideoChatManager-BtnSettings",
                                    onClick: I,
                                    children: Object(dt.jsx)("i", {
                                        className: "material-icons md-light",
                                        children: "settings"
                                    })
                                }), o && m && Object(dt.jsx)("button", {
                                    className: "VideoChatManager-BtnVideo",
                                    onClick: c ? V : j,
                                    children: Object(dt.jsx)(on.Tooltip, {
                                        position: "top",
                                        trigger: "mouseenter",
                                        title: c ? "Disable Camera" : "Enable Camera",
                                        hideOnClick: !1,
                                        children: Object(dt.jsx)("i", {
                                            className: "material-icons md-light",
                                            children: c ? "videocam" : "videocam_off"
                                        })
                                    })
                                }), o && Object(dt.jsx)("button", {
                                    className: "VideoChatManager-BtnScreenShare",
                                    onClick: p ? W : H,
                                    children: Object(dt.jsx)(on.Tooltip, {
                                        position: "top",
                                        trigger: "mouseenter",
                                        title: p ? "Stop Sharing" : "Share Screen",
                                        hideOnClick: !1,
                                        children: Object(dt.jsx)("i", {
                                            className: "material-icons md-light",
                                            children: p ? "stop_screen_share" : "screen_share"
                                        })
                                    })
                                }), o && m && Object(dt.jsx)("button", {
                                    className: "VideoChatManager-BtnAudio",
                                    onClick: u ? k : U,
                                    children: Object(dt.jsx)(on.Tooltip, {
                                        position: "top",
                                        trigger: "mouseenter",
                                        title: u ? "Mute mic" : "Un-mute mic",
                                        hideOnClick: !1,
                                        children: Object(dt.jsx)("i", {
                                            className: "material-icons md-light",
                                            children: u ? "mic" : "mic_off"
                                        })
                                    })
                                }), o && Object(dt.jsx)("button", {
                                    className: "VideoChatManager-BtnLeave",
                                    onClick: D,
                                    children: Object(dt.jsx)(on.Tooltip, {
                                        position: "top",
                                        trigger: "mouseenter",
                                        title: "Leave video chat",
                                        hideOnClick: !1,
                                        children: Object(dt.jsx)("i", {
                                            className: "material-icons md-light",
                                            children: "close"
                                        })
                                    })
                                })]
                            })
                        })
                    }), a && Object(dt.jsxs)("div", {
                        className: "VideoChatManager-Modal",
                        children: [Object(dt.jsx)("div", {
                            onClick: R,
                            className: "VideoChatManager-Modal-Background"
                        }), Object(dt.jsxs)("div", {
                            className: "VideoChatManager-Modal-Content",
                            children: [Object(dt.jsx)("div", {
                                className: "VideoModal-Title",
                                children: "Video Chat"
                            }), Object(dt.jsxs)("div", {
                                className: "VideoModal-Description",
                                children: ["This room has video chat enabled. Clicking 'Share' will share your video and audio with everyone in the room.", Object(dt.jsx)("u", {
                                    children: "You will need to enable browser permissions."
                                })]
                            }), S && Object(dt.jsxs)("div", {
                                children: [Object(dt.jsx)("div", {
                                    className: "VideoChatManager-PreviewContainer",
                                    children: Object(dt.jsx)("video", {
                                        ref: L,
                                        autoPlay: !0,
                                        className: "VideoChatManager-Preview"
                                    })
                                }), Object(dt.jsx)("div", {
                                    className: "VideoModal-SectionTitle",
                                    children: "Webcam"
                                }), Object(dt.jsx)(Y.a, {
                                    placeholder: "Choose Webcam",
                                    defaultValue: K,
                                    options: x,
                                    isSearchable: !1,
                                    onChange: z
                                }), Object(dt.jsx)("div", {
                                    className: "VideoModal-SectionTitle",
                                    children: "Microphone"
                                }), Object(dt.jsx)(Y.a, {
                                    placeholder: "Choose Microphone",
                                    defaultValue: $,
                                    options: w,
                                    isSearchable: !1,
                                    onChange: G
                                })]
                            }), Object(dt.jsx)("div", {
                                className: "VideoModal-BtnContainer",
                                children: Object(dt.jsx)("button", {
                                    className: "VideoModal-BtnDone",
                                    onClick: S ? () => {
                                        g(!0), l(!1), X()
                                    } : N,
                                    children: S ? o ? "Done" : "Join" : "Share Video/Audio"
                                })
                            })]
                        })]
                    })]
                })
            }
            n(370);
            async function ln(t, e) {
                let n = 0,
                    i = await async function(t) {
                        let e = "https://us-central1-dj3d-268321.cloudfunctions.net/redditApi3/posts/" + t;
                        return e += "?user_agent=" + Date.now() / 2, (await Q.a.get(e)).data
                    }(e);
                t && t.scene.traverse((async t => {
                    if (t.hasOwnProperty("userData") && "css3d" === t.userData.type && "post" === t.userData.reddit_type) {
                        let r = null;
                        for (let e = 0; e < t.children.length; e++) {
                            let n = t.children[e];
                            if ("title" === n.userData.reddit_type) {
                                r = n;
                                break
                            }
                        }
                        let o = i[n],
                            s = 40;
                        const a = document.createElement("div");
                        a.classList.add("RedditPost");
                        let l = !1;
                        if (o.url.includes("gfycat")) {
                            var e = /(?:http:|https:|)(?:\/\/|)(?:gfycat\.com\/(?:\w*\/)*)(\w+$)/gi.exec(o.url);
                            if (e && e.length >= 2) {
                                l = !0;
                                let t = "https://gfycat.com/ifr/".concat(e[1]);
                                a.appendChild(function(t) {
                                    const e = document.createElement("iframe");
                                    return e.src = t, e.style.width = "100%", e.style.height = "100%", e
                                }(t))
                            }
                        }
                        if (o.url.includes("imgur") && o.url.includes("gifv")) {
                            let t = o.url;
                            t = t.replace("gifv", "mp4"), t = t.replace("/imgur", "/i.imgur"), a.appendChild(cn(t)), l = !0
                        }
                        if ((o.url.includes("v.redd.it") || o.is_self) && (un(a, o.url), hn(), s = 100, l = !0), l || ("image" === o.post_hint ? a.appendChild(function(t) {
                                const e = document.createElement("img");
                                return e.src = t, e.style.width = "100%", e.style.height = "100%", e.style.objectFit = "contain", e.style.backgroundColor = "black", e
                            }(o.url)) : "video" === o.post_hint ? a.appendChild(cn(o.url)) : (un(a, o.url), hn(), s = 100, l = !0)), o.is_self && (s = 100), Ee(t, a, s), r) {
                            const t = document.createElement("div");
                            t.classList.add("RedditTitleContainer");
                            const e = document.createTextNode(o.title),
                                n = document.createElement("div");
                            n.classList.add("RedditTitleInnerContainer"), n.appendChild(e), t.appendChild(n), Ee(r, t, 100)
                        }
                        n++
                    }
                }))
            }

            function cn(t) {
                const e = document.createElement("video");
                return e.src = t, e.style.width = "100%", e.style.height = "100%", e.style.backgroundColor = "black", e.autoplay = !0, e.loop = !0, e.muted = !0, e
            }

            function hn() {
                if (!document.getElementById("reddit_api_lib")) {
                    let t = document.createElement("script");
                    t.id = "reddit_api_lib", t.setAttribute("src", "https://embed.redditmedia.com/widgets/platform.js"), document.head.appendChild(t)
                }
            }

            function un(t, e) {
                t.innerHTML = '\n  <blockquote class="reddit-card" data-card-created="'.concat(Date.now(), '">\n    <a href="').concat(e, '"></a>\n  </blockquote>\n'), t.style.backgroundColor = "white"
            }
            async function dn(t, e, n) {
                Ce();
                let i = 0,
                    r = await async function(t) {
                        return (await Q.a.get("https://us-central1-dj3d-268321.cloudfunctions.net/louvreApi/art/" + t)).data
                    }(n);
                t && t.scene.traverse((async t => {
                    if (!(i >= r.length) && t.hasOwnProperty("userData") && "css3d" === t.userData.type && "post" === t.userData.reddit_type) {
                        let e = null;
                        for (let i = 0; i < t.children.length; i++) {
                            let n = t.children[i];
                            if ("title" === n.userData.reddit_type) {
                                e = n;
                                break
                            }
                        }
                        let n = 40;
                        const o = document.createElement("div");
                        o.classList.add("RedditPost");
                        let s = "https://images.weserv.nl/?url=".concat(r[i].imageUrl);
                        if (o.appendChild(function(t) {
                                const e = document.createElement("img");
                                return e.src = t, e.style.width = "100%", e.style.height = "100%", e.style.objectFit = "contain", e.style.backgroundColor = "black", e
                            }(s)), Ee(t, o, n), e) {
                            const t = document.createElement("div");
                            t.classList.add("RedditTitleContainer");
                            const n = document.createTextNode(r[i].title),
                                o = document.createElement("div");
                            o.classList.add("RedditTitleInnerContainer"), o.appendChild(n), t.appendChild(o), Ee(e, t, 100)
                        }
                        i++
                    }
                }))
            }
            let pn = null;

            function fn(t, e) {
                if (pn = t, t.scene.traverse((t => {
                        if (t.hasOwnProperty("userData")) {
                            if ("open_url" === t.userData.type) {
                                let i = {
                                    id: t.userData.id,
                                    url: t.userData.url
                                };
                                t.material.transparent = !0, t.material.opacity = 0, e = t, n = i, $t.push(e), te[e.name] = {
                                    object: e,
                                    data: n
                                }
                            }
                            if ("parkour_start" === t.userData.type) {
                                ! function(t) {
                                    pe = t
                                }(t);
                                const e = new c.kb(.2, 4, 4),
                                    n = new c.I({
                                        color: 65280,
                                        transparent: !0,
                                        opacity: .5
                                    }),
                                    i = new c.H(e, n);
                                t.add(i)
                            }
                            if ("parkour_end" === t.userData.type) {
                                ! function(t) {
                                    fe = t
                                }(t);
                                const e = new c.kb(.2, 4, 4),
                                    n = new c.I({
                                        color: 16711680,
                                        transparent: !0,
                                        opacity: .5
                                    }),
                                    i = new c.H(e, n);
                                t.add(i)
                            }
                            if (t.userData.hasOwnProperty("opacity")) {
                                let e = t.userData.opacity;
                                t.material && (t.material.transparent = !0, t.material.opacity = e), t.traverse((t => {
                                    t.material && (t.material.transparent = !0, t.material.opacity = e)
                                }))
                            }
                        }
                        var e, n
                    })), null !== e && void 0 !== e && e.subredditId && ln(t, e.subredditId), "louvre" === (null === e || void 0 === e ? void 0 : e.groupId)) {
                    let n = e.roomId || Math.random() + "";
                    dn(t, e.groupId, n)
                }
            }

            function mn(t) {
                let e = null,
                    n = null;
                return t.scene.traverse((t => {
                    t.hasOwnProperty("userData") && "video" === t.userData.type && (e = {
                        elementId: "youtubeContainer",
                        width: 2 * t.scale.x,
                        height: 2 * t.scale.z,
                        position: {
                            x: t.position.x,
                            y: t.position.y,
                            z: t.position.z
                        },
                        rotation: {
                            x: t.rotation.x - Math.PI / 2,
                            y: -t.rotation.z,
                            z: t.rotation.y
                        }
                    }, n = t)
                })), n && t.scene.remove(n), e
            }
            class gn extends r.a.PureComponent {
                render() {
                    return Object(dt.jsx)("div", {
                        className: "ErrorModal",
                        children: Object(dt.jsxs)("div", {
                            className: "ErrorModal-Window",
                            children: [Object(dt.jsxs)("div", {
                                children: ["Are you still here?", " ", Object(dt.jsx)("span", {
                                    role: "img",
                                    "aria-label": "Thinking Emoji",
                                    children: "\ud83e\udd14"
                                })]
                            }), Object(dt.jsxs)("div", {
                                children: ["Move your mouse to stay active!", " ", Object(dt.jsx)("span", {
                                    role: "img",
                                    "aria-label": "Wave Emoji",
                                    children: "\ud83d\udc4b"
                                })]
                            })]
                        })
                    })
                }
            }

            function vn(t) {
                return window.localStorage ? localStorage.getItem(t) : ""
            }
            n(371);
            const yn = [{
                value: 1,
                label: "100%"
            }, {
                value: .8,
                label: "80%"
            }, {
                value: .5,
                label: "50%"
            }, {
                value: .2,
                label: "20%"
            }, {
                value: .1,
                label: "10%"
            }];
            class xn extends r.a.PureComponent {
                constructor(t) {
                    super(t), this.initialIndex = 2, this.statsParentRef = void 0, this.loadStats = () => {
                        this.statsParentRef.current && (null === _e || void 0 === _e || _e.loadStats(this.statsParentRef.current), this.forceUpdate())
                    }, this.onChangeQuality = t => {
                        let e = t.value;
                        _e && (_e.updateGraphicsQuality(e), function(t, e) {
                            if (!window.localStorage) return "";
                            localStorage.setItem(t, e)
                        }("GRAPHICS_QUALITY", e + ""), rt("Room", "Change Quality"))
                    }, this.state = {}, this.statsParentRef = r.a.createRef();
                    let e = vn("GRAPHICS_QUALITY");
                    if (e) {
                        let t = parseFloat(e);
                        if (!isNaN(t)) {
                            let e = yn.find((e => e.value === t));
                            void 0 !== e && (this.initialIndex = yn.indexOf(e))
                        }
                    }
                }
                componentDidMount() {
                    this.loadStats()
                }
                componentDidUpdate(t) {
                    t.isCharacterLoaded !== this.props.isCharacterLoaded && this.loadStats()
                }
                render() {
                    return Object(dt.jsx)(mt, {
                        top: 60,
                        right: 8,
                        disableRenderToggle: !0,
                        windowId: "GraphicsQualityPicker",
                        children: Object(dt.jsxs)("div", {
                            style: {
                                display: this.props.isWindowOpen ? "block" : "none"
                            },
                            className: "GraphicsQualityPicker",
                            children: [Object(dt.jsx)("div", {
                                className: "GraphicsQualityPicker-TitleMain",
                                children: "Settings"
                            }), Object(dt.jsx)("div", {
                                className: "GraphicsQualityPicker-TitleSub",
                                children: "Graphics Quality"
                            }), Object(dt.jsx)(Y.a, {
                                className: "GraphicsQualityPicker-Select",
                                defaultValue: yn[this.initialIndex],
                                options: yn,
                                isSearchable: !1,
                                onChange: this.onChangeQuality
                            }), Object(dt.jsx)("div", {
                                className: "GraphicsQualityPicker-TitleSub",
                                children: "FPS"
                            }), Object(dt.jsx)("div", {
                                ref: this.statsParentRef
                            })]
                        })
                    })
                }
            }
            var bn = Object(W.b)((function(t) {
                    var e, n;
                    return {
                        isWindowOpen: null === (e = t.ui.windows) || void 0 === e || null === (n = e.GraphicsQualityPicker) || void 0 === n ? void 0 : n.isOpen
                    }
                }))(xn),
                wn = n(112),
                _n = n.n(wn);
            n(376), n(377);
            let Sn, Mn = 0,
                An = 0;

            function Tn(t) {
                null === _e || void 0 === _e || _e.activeCharacter.triggerAction("up", !0), console.log("mobile controls"), t.stopPropagation()
            }

            function En(t) {
                null === _e || void 0 === _e || _e.activeCharacter.triggerAction("up", !1), t.stopPropagation()
            }

            function Cn(t) {
                null === _e || void 0 === _e || _e.activeCharacter.triggerAction("jump", !0), t.stopPropagation()
            }

            function Pn(t) {
                null === _e || void 0 === _e || _e.activeCharacter.triggerAction("jump", !1), t.stopPropagation()
            }

            function Ln(t) {
                return t.nativeEvent.stopImmediatePropagation(), !1
            }

            function Rn() {
                null === _e || void 0 === _e || _e.activeCharacter.disableJoystick(), null === _e || void 0 === _e || _e.activeCharacter.triggerAction("up", !1), null === _e || void 0 === _e || _e.activeCharacter.triggerAction("run", !1)
            }

            function In() {
                Sn && (clearInterval(Sn), Sn = null)
            }
            var Fn = Object(W.b)((function(t) {
                    return {
                        isMobile: t.ui.isMobile,
                        windows: t.ui.windows
                    }
                }))((function(t) {
                    i.useEffect((() => {
                        e.current && (e.current.ontouchstart = Tn, e.current.ontouchend = En, e.current.ontouchcancel = En), n.current && (n.current.ontouchstart = Cn, n.current.ontouchend = Pn, n.current.ontouchcancel = Pn), window.dispatchEvent(new Event("resize"))
                    }));
                    const e = i.useRef(null),
                        n = i.useRef(null);
                    if (!t.isMobile) return null;
                    let r;
                    for (r in t.windows)
                        if (t.windows[r].isOpen) return null;
                    return Object(dt.jsxs)("div", {
                        onContextMenu: Ln,
                        className: "MobileControls",
                        children: [Object(dt.jsx)(_n.a, {
                            options: {
                                mode: "static",
                                position: {
                                    bottom: "50%",
                                    left: "50%"
                                }
                            },
                            style: {
                                width: 100,
                                height: 100,
                                marginLeft: "8px"
                            },
                            onMove: (t, e) => {
                                ! function(t, e, n) {
                                    null === _e || void 0 === _e || _e.activeCharacter.enableJoystick(), null === _e || void 0 === _e || _e.activeCharacter.triggerAction("up", !0), n.distance > 40 ? null === _e || void 0 === _e || _e.activeCharacter.triggerAction("run", !0) : null === _e || void 0 === _e || _e.activeCharacter.triggerAction("run", !1), null === _e || void 0 === _e || _e.activeCharacter.sendJoystickAngle(t)
                                }(e.angle.radian, 0, e)
                            },
                            onEnd: Rn
                        }), Object(dt.jsxs)("div", {
                            className: "MobileControls-RightSide",
                            children: [" ", Object(dt.jsx)("button", {
                                className: "MobileControls-Button",
                                ref: n,
                                children: Object(dt.jsx)("i", {
                                    className: "material-icons md-light MobileControls-Icon ",
                                    children: "arrow_circle_up"
                                })
                            }), Object(dt.jsx)(_n.a, {
                                options: {
                                    mode: "static",
                                    position: {
                                        bottom: "50%",
                                        left: "50%"
                                    }
                                },
                                style: {
                                    width: 100,
                                    height: 100,
                                    marginRight: "8px"
                                },
                                onMove: (t, e) => {
                                    let n = e.angle.radian;
                                    var i, r, o, s;
                                    i = -Math.cos(n), r = Math.sin(n), o = 8, s = 8, Mn = i, An = r, Sn || (Sn = setInterval((() => {
                                        null === _e || void 0 === _e || _e.inputManager.handleMouseMove(Mn * o, An * s)
                                    }), 16))
                                },
                                onEnd: In
                            })]
                        })]
                    })
                })),
                On = n(176);
            n(388);
            class Nn extends r.a.PureComponent {
                constructor(t) {
                    super(t), this.state = {
                        shouldRender: !1
                    }
                }
                componentDidMount() {
                    document.addEventListener("pointerlockchange", (() => {
                        document.pointerLockElement ? this.setState({
                            shouldRender: !1
                        }) : this.setState({
                            shouldRender: !0
                        })
                    }), !1)
                }
                render() {
                    return this.state.shouldRender ? Object(dt.jsx)("div", {
                        className: "EnterPointerLock",
                        children: Object(dt.jsx)("div", {
                            className: "EnterPointerLock-Text animate-flicker",
                            children: "Click to look around"
                        })
                    }) : null
                }
            }
            const Bn = "queues",
                Dn = "videoQueues";
            let Vn = X.functions().httpsCallable("voteVideoQueue");
            n(389);
            class jn extends r.a.PureComponent {
                constructor(t) {
                    super(t), this.firestoreUnsub = () => {}, this.refreshTimer = void 0, this.firestoreVoteUnsub = () => {}, this.lastVoteQueueItemId = "", this.onClickVote = (t, e) => {
                        var n, i;
                        null !== (n = this.state.localVoteMap) && void 0 !== n && null !== (i = n[t]) && void 0 !== i && i[e] || (Vn({
                            roomId: this.props.roomId || "",
                            queueItemId: t,
                            type: e
                        }), this.setState((n => {
                            let i = {...n.localVoteMap
                            };
                            i[t] || (i[t] = {
                                skip: !1,
                                upvote: !1
                            }), i[t][e] = !0;
                            let r = {...n.voteMap
                            };
                            return r[t] || (r[t] = {
                                skips: 0,
                                upvotes: 0
                            }), "skip" === e && r[t].skips++, "upvote" === e && r[t].upvotes++, {
                                localVoteMap: i,
                                voteMap: r
                            }
                        })))
                    }, this.state = {
                        queueItems: [],
                        voteMap: {},
                        localVoteMap: {}
                    }
                }
                componentDidMount() {
                    this.props.roomId && this.listenToVideoQueue(this.props.roomId), Lt.dispatch(ht("VideoQueue", !0)), this.refreshTimer = setInterval((() => {
                        this.forceUpdate()
                    }), 5e3)
                }
                componentDidUpdate(t) {
                    t.roomId !== this.props.roomId && this.props.roomId && this.listenToVideoQueue(this.props.roomId)
                }
                listenToVideoQueue(t) {
                    this.firestoreUnsub = Z.collection(Bn).doc(t).collection(Dn).orderBy("serverTimestamp", "asc").onSnapshot((t => {
                        let e = [];
                        t.forEach((t => {
                            let n = t.data();
                            n.id = t.id, e.push(n)
                        })), this.setState({
                            queueItems: e
                        }), this.props.setVideoQueueItems(e)
                    }))
                }
                listenToVideoQueueItem(t, e) {
                    this.firestoreVoteUnsub = Z.collection(Bn).doc(t).collection(Dn).doc(e).collection("votes").onSnapshot((t => {
                        let n = {};
                        t.forEach((t => {
                            let i = t.data();
                            n[e] || (n[e] = {
                                skips: 0,
                                upvotes: 0
                            }), i.skip && n[e].skips++, i.upvote && n[e].upvotes++
                        })), this.setState({
                            voteMap: n
                        })
                    }))
                }
                componentWillUnmount() {
                    this.firestoreUnsub && this.firestoreUnsub(), this.refreshTimer && clearInterval(this.refreshTimer), Lt.dispatch(ht("VideoQueue", !1))
                }
                renderVideoList() {
                    if (!this.state.queueItems || this.state.queueItems.length < 1) return null;
                    let t = this.state.queueItems[0].serverTimestamp,
                        e = Date.now();
                    if (!t) return null;
                    let n = t.toDate().getTime() - 1,
                        i = [],
                        r = 0;
                    for (let g = 0; g < this.state.queueItems.length; g++) {
                        var o;
                        let t = this.state.queueItems[g];
                        if (!t.serverTimestamp) return;
                        let v = null === (o = t.serverTimestamp) || void 0 === o ? void 0 : o.toDate().getTime(),
                            y = 0;
                        y = v >= n ? v : n;
                        let x = 1e3 * t.duration;
                        if (t.skipped && t.skipTimestamp && (x = t.skipTimestamp - y), e > y + x);
                        else {
                            var s, a, l, c, h, u, d, p;
                            let e = !0 === (null === (s = this.state.localVoteMap) || void 0 === s || null === (a = s[t.id]) || void 0 === a ? void 0 : a.upvote),
                                n = !0 === (null === (l = this.state.localVoteMap) || void 0 === l || null === (c = l[t.id]) || void 0 === c ? void 0 : c.skip),
                                o = (null === (h = this.state.voteMap) || void 0 === h || null === (u = h[t.id]) || void 0 === u ? void 0 : u.upvotes) || 0,
                                g = (null === (d = this.state.voteMap) || void 0 === d || null === (p = d[t.id]) || void 0 === p ? void 0 : p.skips) || 0;
                            0 === r && this.props.roomId && this.lastVoteQueueItemId !== t.id && (this.firestoreVoteUnsub(), this.lastVoteQueueItemId = t.id, this.listenToVideoQueueItem(this.props.roomId, t.id), f = this.props.roomId, m = t.videoTitle, Z.collection("presence").doc(f).update({
                                videoTitle: m
                            })), i.push(Object(dt.jsxs)("div", {
                                className: "VideoQueue-List-Item",
                                children: [Object(dt.jsxs)("div", {
                                    children: [Object(dt.jsx)("img", {
                                        alt: "Video queue thumbnail",
                                        className: "VideoQueue-List-Image",
                                        src: t.thumbUrl
                                    }), t.videoTitle]
                                }), 0 === r && Object(dt.jsxs)("div", {
                                    className: "VideoQueue-VoteButton-Container",
                                    children: [Object(dt.jsx)("button", {
                                        className: "VideoQueue-VoteButton VideoQueue-VoteButton-Upvote " + (e ? "VideoQueue-VoteButton-Voted" : ""),
                                        onClick: () => this.onClickVote(t.id, "upvote"),
                                        children: Object(dt.jsxs)("div", {
                                            className: "VideoQueue-VoteButton-Content",
                                            children: [Object(dt.jsx)("i", {
                                                className: "material-icons md-light",
                                                children: "favorite"
                                            }), Object(dt.jsx)("div", {
                                                children: o
                                            })]
                                        })
                                    }), Object(dt.jsx)("button", {
                                        className: "VideoQueue-VoteButton VideoQueue-VoteButton-Skip " + (n ? "VideoQueue-VoteButton-Voted" : ""),
                                        onClick: () => this.onClickVote(t.id, "skip"),
                                        children: Object(dt.jsxs)("div", {
                                            className: "VideoQueue-VoteButton-Content",
                                            children: [Object(dt.jsx)("i", {
                                                className: "material-icons md-light",
                                                children: "skip_next"
                                            }), Object(dt.jsx)("div", {
                                                children: g
                                            })]
                                        })
                                    })]
                                }), 0 === r && Object(dt.jsx)("hr", {})]
                            }, t.id)), r++
                        }
                        n = y + x
                    }
                    var f, m;
                    return i
                }
                render() {
                    return Object(dt.jsx)(mt, {
                        left: 8,
                        bottom: 220,
                        windowId: "VideoQueue",
                        children: Object(dt.jsxs)("div", {
                            className: "VideoQueue",
                            children: [Object(dt.jsx)("div", {
                                className: "VideoQueue-Title",
                                children: "Video Queue"
                            }), Object(dt.jsx)("div", {
                                className: "VideoQueue-List",
                                children: this.renderVideoList()
                            })]
                        })
                    })
                }
            }
            const kn = {
                setVideoQueueItems: t => ({
                    type: "SET_VIDEO_QUEUE_ITEMS",
                    newItems: t
                })
            };
            var Un = Object(W.b)(null, kn)(jn);
            const zn = [{
                keys: ["W", "A", "S", "D"],
                desc: "Movement"
            }, {
                keys: ["Space"],
                desc: "Jump"
            }, {
                keys: ["Shift"],
                desc: "Sprint"
            }, {
                keys: ["F"],
                desc: "Dance"
            }, {
                keys: ["Enter"],
                desc: "Chat"
            }, {
                keys: ["V"],
                desc: "Hide Char (for you)"
            }, {
                keys: ["ESC"],
                desc: "Use Mouse"
            }];
            class Gn extends r.a.PureComponent {
                componentDidMount() {
                    setTimeout((() => {
                        this.props.setWindowOpen("ControlsWindow", !1)
                    }), 3e4)
                }
                renderControls() {
                    return zn.map((t => {
                        let e = [];
                        return e.push(t.keys.map((t => Object(dt.jsx)("span", {
                            className: "key",
                            children: t
                        }, t)))), e.push(Object(dt.jsx)("span", {
                            className: "ctrl-desc",
                            children: " " + t.desc + " "
                        }, "desc#" + t.desc)), Object(dt.jsx)("div", {
                            className: "info-row",
                            children: e
                        }, t.desc)
                    }))
                }
                render() {
                    return Object(dt.jsx)(mt, {
                        top: 8,
                        left: 8,
                        windowId: "ControlsWindow",
                        children: Object(dt.jsx)("div", {
                            className: "info-box",
                            children: Object(dt.jsxs)("div", {
                                id: "controls-menu",
                                className: "info-card",
                                children: [Object(dt.jsx)("div", {
                                    className: "info-title",
                                    children: "Controls:"
                                }), this.renderControls()]
                            })
                        })
                    })
                }
            }
            const Hn = {
                setWindowOpen: lt
            };
            var Wn = Object(W.b)(null, Hn)(Gn);
            n(390), n(391);
            const Yn = [{
                img: n(162).default,
                windowId: "Customize",
                tooltip: "Customize"
            }, {
                img: n(162).default,
                windowId: "RoomCreator",
                tooltip: "Rooms"
            }, {
                img: n(392).default,
                windowId: "Chat",
                tooltip: "Text Chat"
            }, {
                img: n(393).default,
                windowId: "ControlsWindow",
                tooltip: "Controls"
            }, {
                img: n(394).default,
                windowId: "VideoChatManager",
                tooltip: "Video Chat"
            }, {
                img: n(395).default,
                windowId: "VideoQueue",
                tooltip: "Video Queue"
            }, {
                img: n(396).default,
                windowId: "Parkour",
                tooltip: "Parkour"
            }, {
                img: n(397).default,
                windowId: "YoutubeControls",
                tooltip: "Video Controls"
            }, {
                img: n(398).default,
                windowId: "Reddit",
                tooltip: "Change Subreddit"
            }, {
                img: n(399).default,
                windowId: "GraphicsQualityPicker",
                tooltip: "Settings"
            }];
            class Xn extends r.a.PureComponent {
                constructor(t) {
                    super(t), this.renderButtons = () => Yn.map((t => {
                        let e = !1;
                        if ("Parkour" === t.windowId && this.props.parkourEnabled && (e = !0), !e && !this.props.windows[t.windowId].inDock) return null;
                        let n = Object(dt.jsx)("img", {
                            alt: t.tooltip,
                            className: "Dock-Button-Img",
                            src: t.img
                        });
                        "Customize" === t.windowId && (n = Object(dt.jsx)("div", {
                            className: "Dock-Button-Emoji",
                            children: this.props.userEmoji
                        }));
                        let i = this.props.windows[t.windowId].isOpen;
                        return Object(dt.jsx)(on.Tooltip, {
                            position: "top",
                            trigger: "mouseenter",
                            title: t.tooltip,
                            hideOnClick: !1,
                            disabled: this.props.isMobile,
                            children: Object(dt.jsxs)("div", {
                                className: "Dock-ButtonContainer",
                                children: [Object(dt.jsx)("button", {
                                    className: "Dock-Button",
                                    onClick: () => this.props.toggleWindowOpen(t.windowId),
                                    children: n
                                }), Object(dt.jsx)("div", {
                                    className: "Dock-Indicator",
                                    style: {
                                        backgroundColor: i ? "rgba(255, 255, 255,0.7)" : "transparent"
                                    }
                                })]
                            })
                        }, t.windowId)
                    })), this.state = {}
                }
                render() {
                    return Object(dt.jsx)("div", {
                        className: "DockContainer",
                        children: Object(dt.jsx)("div", {
                            className: "Dock",
                            children: this.renderButtons()
                        })
                    })
                }
            }
            var qn = Object(W.b)((function(t) {
                const {
                    room: e
                } = t;
                return {
                    username: e.username,
                    windows: t.ui.windows,
                    parkourEnabled: t.parkour.parkourEnabled,
                    userEmoji: t.room.userEmoji,
                    isMobile: t.ui.isMobile
                }
            }), {
                setWindowOpen: lt,
                toggleWindowOpen: ct
            })(Xn);
            n(400);
            class Qn extends r.a.PureComponent {
                constructor(t) {
                    super(t), this.changeSubreddit = () => {
                        pn && (Ce(), ln(pn, this.state.subredditId), this.props.roomId && async function(t, e) {
                            await Z.collection(se).doc(t).update({
                                subredditId: e
                            })
                        }(this.props.roomId, this.state.subredditId))
                    }, this.stopEvent = t => {
                        "Enter" === t.key && this.changeSubreddit(), t.stopPropagation(), t.nativeEvent.stopImmediatePropagation()
                    }, this.onInputChange = t => {
                        this.setState({
                            subredditId: t.target.value
                        })
                    }, this.state = {
                        subredditId: ""
                    }
                }
                render() {
                    return Object(dt.jsx)(mt, {
                        forceCentering: !0,
                        windowId: "Reddit",
                        children: Object(dt.jsxs)("div", {
                            className: "RedditSettings",
                            children: [Object(dt.jsx)("div", {
                                className: "RedditSettings-Title",
                                children: "Choose Subreddit"
                            }), Object(dt.jsxs)("div", {
                                className: "RoomCreator-CopyText",
                                children: [Object(dt.jsx)("input", {
                                    className: "RoomCreator-Url",
                                    type: "text",
                                    value: this.state.subredditId,
                                    placeholder: "subreddit",
                                    maxLength: 256,
                                    onChange: this.onInputChange,
                                    onKeyDown: this.stopEvent
                                }), Object(dt.jsx)("button", {
                                    onClick: this.changeSubreddit,
                                    className: "RoomCreator-CopyButton",
                                    children: "Send"
                                })]
                            })]
                        })
                    })
                }
            }
            var Zn = Object(W.b)((function(t) {
                return {
                    roomId: t.room.roomId
                }
            }))(Qn);
            n(401);
            class Jn extends r.a.PureComponent {
                renderItems(t) {
                    return jt.map((e => t.includes(e.id) ? Object(dt.jsx)(Kn, {
                        selected: !1,
                        stringId: e.stringId,
                        skinId: e.id
                    }, e.stringId) : null))
                }
                render() {
                    let t = [0, 1, 2, 3];
                    return this.props.include && (t = this.props.include), Object(dt.jsx)(mt, {
                        windowId: "SkinPicker",
                        forceCentering: !0,
                        children: Object(dt.jsx)("div", {
                            className: "SkinPicker",
                            children: this.renderItems(t)
                        })
                    })
                }
            }

            function Kn(t) {
                const e = Object(W.c)();
                return Object(dt.jsx)("div", {
                    onClick: () => {
                        let n = kt(t.skinId);
                        _e && n && _e.activeCharacter.changeCharacterSkin(n),
                            function(t) {
                                let e = new R(t);
                                It ? Ht.addCommand(e) : qt.push(e), zt && zt({
                                    type: "ChangeCharacterSkinCommand",
                                    command: {
                                        newSkinId: t
                                    }
                                })
                            }(t.skinId), e(lt("SkinPicker", !1)), rt("Customize", "Pick Skin")
                    },
                    className: "SkinPicker-Item",
                    children: Object(dt.jsx)("img", {
                        className: "SkinPicker-Item-Img",
                        alt: "stringId",
                        src: "images/skins/".concat(t.stringId, ".png")
                    })
                })
            }
            class $n extends r.a.PureComponent {
                render() {
                    return Object(dt.jsx)("div", {
                        id: "youtubeContainer",
                        children: Object(dt.jsx)("iframe", {
                            id: "youtube-iframe",
                            title: "Youtube Player",
                            src: "https://www.youtube.com/embed/".concat(this.props.videoId, "?enablejsapi=1&autoplay=1&controls=1&fs=0&rel=0"),
                            frameBorder: "0",
                            allow: "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",
                            allowFullScreen: !0,
                            style: {
                                width: "100%"
                            }
                        })
                    })
                }
            }
            class ti extends r.a.PureComponent {
                render() {
                    return Object(dt.jsx)("div", {
                        className: "ErrorModal",
                        children: Object(dt.jsx)("div", {
                            className: "ErrorModal-Window",
                            children: Object(dt.jsx)("div", {
                                children: this.props.message
                            })
                        })
                    })
                }
            }
            const ei = !1;
            class ni extends r.a.Component {
                constructor(t) {
                    var e, n, i, r;
                    super(t), this.world = void 0, this.idleTimeout = void 0, this.spaceId = "default", this.isProximityChatEnabled = !1, this.subredditId = "", this.unsub = () => {}, this.unsubTicket = () => {}, this.groupId = "", this.checkForShardScaling = () => {
                        this.props.shardRoomScaling && (this.subredditId && (this.groupId = this.subredditId), this.props.groupId && (this.groupId = this.props.groupId), this.props.setGroupId(this.groupId), this.getTicketAndWait())
                    }, this.listenForTicket = async t => {
                        this.unsubTicket(), this.unsubTicket = Z.collection("tickets").doc(t).onSnapshot((t => {
                            if (!t.exists) return;
                            let e = t.data();
                            if (e.canceled) return this.unsubTicket(), void this.getTicketAndWait();
                            e.roomId && (this.setState({
                                forcedRoomId: e.roomId
                            }), this.unsubTicket())
                        }))
                    }, this.getTicketAndWait = async() => {
                        if (this.groupId) try {
                            let t = (await tt({
                                groupId: this.groupId
                            })).data;
                            this.listenForTicket(t)
                        } catch {
                            this.unsubTicket(), this.getTicketAndWait()
                        }
                    }, this.onClickStart = () => {
                        this.state.isCharacterLoaded && (this.world && this.world.inputManager.pointerLock && this.world.inputManager.domElement.requestPointerLock(), this.setState({
                            started: !0
                        }))
                    }, this.handleOnActive = () => {
                        this.idleTimeout && clearTimeout(this.idleTimeout), this.setState({
                            isIdle: !1
                        })
                    }, this.handleOnIdle = () => {
                        "https://dj3d.io/" !== window.location.href && (this.setState({
                            isIdle: !0
                        }), this.idleTimeout = setTimeout((() => {
                            window.location.href = "https://dj3d.io/"
                        }), 3e4))
                    }, this.analyticsPing = () => {
                        rt("Ping", "30s")
                    };
                    let o = (null === (e = t.match) || void 0 === e || null === (n = e.params) || void 0 === n ? void 0 : n.spaceId) || "default";
                    this.props.spaceId && (o = this.props.spaceId), this.spaceId = o;
                    let s = null === (i = t.match) || void 0 === i || null === (r = i.params) || void 0 === r ? void 0 : r.subredditId;
                    s && (this.spaceId = "museum", this.subredditId = s);
                    let a = "";
                    this.props.match && this.props.match.params.roomId && (a = this.props.match.params.roomId), this.props.simpleVideoPlayer && this.props.setDockVisible("YoutubeControls", !1), this.state = {
                        started: !1,
                        isInvalidRoom: !1,
                        isCharacterLoaded: !1,
                        isChatEnabled: !1,
                        isVideoChatEnabled: !1,
                        videoChatUrl: "",
                        isIdle: !1,
                        isVideoQueueEnabled: this.props.forceVideoQueueEnabled || !1,
                        roomInfo: null,
                        forcedRoomId: a
                    }
                }
                async componentDidMount() {
                    let t = this.getRoomId();
                    if (t) {
                        let e = await ae(t);
                        this.listenToRoom(), e && e.spaceId && (this.spaceId = e.spaceId, "museum" === this.spaceId ? (this.subredditId = e.subredditId || "pics", this.props.setDockVisible("Reddit", !0)) : this.props.setDockVisible("Reddit", !1)), this.connectToRoom(t, e), Lt.dispatch(U(t))
                    }
                    this.loadNewWorld(this.spaceId), this.checkForShardScaling(), ei && Vt()
                }
                listenToRoom() {
                    let t = this.getRoomId();
                    t && (this.unsub(), this.unsub = Z.collection(se).doc(t).onSnapshot((t => {
                        let e = t.data();
                        this.setState({
                            roomInfo: e
                        }), e.subredditId !== this.subredditId && e.subredditId && ln(pn, e.subredditId), this.props.setChatEnabled(!0 === e.isChatEnabled), this.props.setAdminMode(!0 === e.isAdminMode)
                    })))
                }
                loadNewWorld(t) {
                    let e = document.getElementById("canvas");
                    e && e.remove(), this.props.setParkourEnabled(!1);
                    let n = "world.glb";
                    t && (Be.includes(t) || De.includes(t)) && "default" !== t && (n = "/scenes/".concat(t, ".glb"));
                    let i = {};
                    this.props.defaultSkinGlbUrl && (i.initialCharacterSkinURL = this.props.defaultSkinGlbUrl);
                    let r = new l.World(i);
                    Me(r);
                    let o = function() {
                        let t = vn("GRAPHICS_QUALITY");
                        if (t) {
                            let e = parseFloat(t);
                            if (!isNaN(e)) return e
                        }
                        return .5
                    }();
                    r.updateGraphicsQuality(o), this.world = r, void 0 !== this.isProximityChatEnabled && (r.isProximityChatEnabled = this.isProximityChatEnabled), r.cameraOperator.theta = 0, r.cameraOperator.phi = 0, r.onCharacterLoaded = () => {
                        Qt(), Et && r.inputManager.setPointerLock(!1), this.setState({
                            isCharacterLoaded: !0
                        })
                    }, r.loadingManager.loadGLTF(n, (t => {
                        r.loadScene(t), fn(t, {
                            subredditId: this.subredditId,
                            groupId: this.props.groupId,
                            roomId: this.getRoomId()
                        });
                        let e = mn(t),
                            n = r.graphicsWorld,
                            i = r.camera,
                            o = [];
                        e ? o.push(e) : this.props.disableVideoPlayer || o.push({
                            elementId: "youtubeContainer",
                            width: 20,
                            height: 11.5,
                            position: {
                                x: 0,
                                y: 6,
                                z: -10
                            },
                            rotation: {
                                x: 0,
                                y: 0,
                                z: 0
                            }
                        }), Ae(n, i, r, o)
                    }))
                }
                async componentDidUpdate(t, e) {
                    if (this.props.match && t.match && this.props.match.params.roomId !== t.match.params.roomId) {
                        let t = this.props.match.params.roomId;
                        void 0 === t && (t = ""), this.setState({
                            forcedRoomId: t
                        })
                    }
                    if (e.forcedRoomId !== this.getRoomId()) {
                        let t = this.getRoomId();
                        if (t) {
                            Lt.dispatch(U(t));
                            let e = await ae(t);
                            if (this.listenToRoom(), e && e.spaceId) {
                                if (!("_matchmaker" === e.creatorUid)) {
                                    let t = e.spaceId;
                                    "museum" === t ? (this.subredditId = e.subredditId || "pics", this.props.setDockVisible("Reddit", !0)) : this.props.setDockVisible("Reddit", !1), t !== this.spaceId && (this.loadNewWorld(t), this.spaceId = t)
                                }
                            }
                            "louvre" === this.props.groupId && dn(pn, this.props.groupId, t), this.connectToRoom(t, e)
                        } else {
                            Dt() && (Rt && (Rt.disconnect(), Ot = !0), this.props.setDockVisible("VideoChatManager", !1), this.props.setDockVisible("VideoQueue", !1), this.props.setDockVisible("Reddit", !1), this.props.setDockVisible("Parkour", !1), this.setState({
                                isCharacterLoaded: !1,
                                isChatEnabled: !1,
                                isVideoChatEnabled: !1,
                                videoChatUrl: "",
                                isIdle: !1,
                                isVideoQueueEnabled: !1,
                                roomInfo: null
                            }, (() => {
                                this.loadNewWorld("default")
                            })))
                        }
                    }
                    let n = t.spaceId || "default";
                    this.props.spaceId !== n && this.props.spaceId && (this.loadNewWorld(this.props.spaceId), this.spaceId = this.props.spaceId, document.exitPointerLock()), t.connectionState !== this.props.connectionState && "DISCONNECTED" === this.props.connectionState && (this.unsubTicket(), this.checkForShardScaling()), t.shardRoomScaling !== this.props.shardRoomScaling && this.checkForShardScaling(), !t.forceVideoQueueEnabled && this.props.forceVideoQueueEnabled && this.setState({
                        isVideoQueueEnabled: !0
                    })
                }
                async connectToRoom(t, e) {
                    if (e) {
                        let t = !0 === e.isVideoQueueEnabled;
                        this.props.forceVideoQueueEnabled && (t = !0), this.setState({
                            isChatEnabled: !0 === e.isChatEnabled,
                            isVideoQueueEnabled: t
                        }), this.isProximityChatEnabled = e.isProximityChatEnabled || !1, this.world && (this.world.isProximityChatEnabled = this.isProximityChatEnabled)
                    }
                    e && e.isVideoChatEnabled && e.videoChatUrl && this.setState({
                            isVideoChatEnabled: !0,
                            videoChatUrl: e.videoChatUrl
                        }),
                        function(t) {
                            if (t) {
                                if (!window.joinRoom) return;
                                const e = {
                                        appId: "dj3d"
                                    },
                                    n = window.joinRoom(e, t);
                                n.onPeerJoin((t => console.log("".concat(t, " joined")))), n.onPeerLeave((t => {
                                    console.log("".concat(t, " left"));
                                    let e = Wt.get(t);
                                    e && (null === _e || void 0 === _e || _e.remove(e))
                                })), Ut = n;
                                const [i, r] = n.makeAction("action");
                                zt = i, Gt = r
                            }
                        }(t)
                }
                setInvalidRoom() {
                    let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    this.setState({
                        isInvalidRoom: t
                    })
                }
                isInRoom() {
                    return "" !== this.getRoomId()
                }
                getRoomId() {
                    return this.state.forcedRoomId
                }
                getVideoPlayer() {
                    return this.props.disableVideoPlayer ? null : this.props.simpleVideoPlayer ? Object(dt.jsx)($n, {
                        videoId: this.props.simpleVideoPlayer
                    }) : Object(dt.jsx)(Xe, {
                        isVideoChat: this.state.isVideoChatEnabled,
                        roomId: this.getRoomId(),
                        started: this.state.started,
                        isVideoQueueEnabled: this.state.isVideoQueueEnabled,
                        roomInfo: this.state.roomInfo
                    })
                }
                render() {
                    return Object(dt.jsxs)("div", {
                        className: "App",
                        children: [this.getVideoPlayer(), Object(dt.jsx)(At, {
                            isInRoom: this.isInRoom(),
                            defaultThumbUrl: this.props.defaultSkinThumbUrl,
                            hideSkinPicker: this.props.hideSkinPicker
                        }), Object(dt.jsx)(je, {
                            isInRoom: this.isInRoom(),
                            spaceId: this.spaceId,
                            roomId: this.getRoomId(),
                            subredditId: this.subredditId,
                            shardRoomScaling: this.props.shardRoomScaling
                        }), this.state.isInvalidRoom && !this.props.ignoreServerIssues && Object(dt.jsx)(qe, {}), this.props.showModal && Object(dt.jsx)(ti, {
                            message: this.props.modalMessage
                        }), Object(dt.jsx)(On.CSSTransitionGroup, {
                            transitionName: "FadeOut",
                            transitionLeaveTimeout: 200,
                            transitionEnterTimeout: 0,
                            children: !this.state.started && Object(dt.jsx)(Ze, {
                                onClickStart: this.onClickStart,
                                isLoaded: this.state.isCharacterLoaded,
                                roomId: this.getRoomId(),
                                subtitle: this.props.getStartedSubtitle,
                                groupId: this.props.groupId
                            })
                        }), this.state.isChatEnabled && Object(dt.jsx)(tn, {
                            roomId: this.getRoomId()
                        }), this.state.isCharacterLoaded && this.state.isVideoChatEnabled && Object(dt.jsx)(an, {
                            started: this.state.isVideoChatEnabled,
                            roomUrl: this.state.videoChatUrl
                        }), Object(dt.jsx)(Qe.a, {
                            timeout: 9e5,
                            onActive: this.handleOnActive,
                            onIdle: this.handleOnIdle,
                            throttle: 3e4,
                            onAction: this.analyticsPing
                        }), this.state.isIdle && Object(dt.jsx)(gn, {}), Object(dt.jsx)(bn, {
                            isCharacterLoaded: this.state.isCharacterLoaded
                        }), Object(dt.jsx)(Fn, {
                            isCharacterLoaded: this.state.isCharacterLoaded
                        }), Object(dt.jsx)(Nn, {}), Object(dt.jsx)(oe, {}), this.state.isVideoQueueEnabled && Object(dt.jsx)(Un, {
                            roomId: this.getRoomId()
                        }), Object(dt.jsx)(Wn, {}), Object(dt.jsx)(Zn, {}), Object(dt.jsx)(Jn, {
                            include: this.props.customSkinIds
                        }), Object(dt.jsx)(qn, {})]
                    })
                }
            }
            const ii = {
                setAdminMode: z,
                setChatEnabled: G,
                setParkourEnabled: de,
                setDockVisible: ht,
                setGroupId: t => ({
                    type: "SET_GROUP_ID",
                    newGroupId: t
                })
            };
            var ri = Object(W.b)((function(t) {
                return {
                    connectionState: t.room.connectionState,
                    showModal: t.ui.showModal,
                    modalMessage: t.ui.modalMessage
                }
            }), ii)(ni);
            n(402);
            class oi extends r.a.PureComponent {
                render() {
                    return Object(dt.jsx)("div", {
                        className: "About",
                        children: Object(dt.jsxs)("div", {
                            children: [Object(dt.jsxs)("div", {
                                className: "About-Me",
                                children: ["DJ3D, built by ", Object(dt.jsx)("a", {
                                    href: "https://neelmango.com/",
                                    children: "NeelMango"
                                })]
                            }), Object(dt.jsx)("br", {}), Object(dt.jsxs)("div", {
                                children: ["Rendering: ", Object(dt.jsx)("a", {
                                    href: "https://threejs.org/",
                                    children: "three.js"
                                })]
                            }), Object(dt.jsxs)("div", {
                                children: ["Character controller:", " ", Object(dt.jsx)("a", {
                                    href: "https://github.com/swift502/Sketchbook",
                                    children: "Sketchbook by swift502"
                                })]
                            }), Object(dt.jsxs)("div", {
                                children: ["Multiplayer:", " ", Object(dt.jsx)("a", {
                                    href: "https://github.com/timetocode/nengi",
                                    children: "nengi by timetocode"
                                })]
                            })]
                        })
                    })
                }
            }
            n(163);

            function si() {
                return Object(dt.jsxs)("div", {
                    className: "TermsOfService",
                    children: [Object(dt.jsx)("h2", {
                        children: "DJ3D Terms of Service"
                    }), Object(dt.jsx)("h3", {
                        children: "1. Terms"
                    }), Object(dt.jsxs)("p", {
                        children: ["By accessing the website at", " ", Object(dt.jsx)("a", {
                            href: "https://dj3d.io",
                            children: "https://dj3d.io"
                        }), ", you are agreeing to be bound by these terms of service, all applicable laws and regulations, and agree that you are responsible for compliance with any applicable local laws. If you do not agree with any of these terms, you are prohibited from using or accessing this site. The materials contained in this website are protected by applicable copyright and trademark law."]
                    }), Object(dt.jsx)("p", {
                        children: "By using this application, you agree that you are at least 18 years old."
                    }), Object(dt.jsx)("h3", {
                        children: "2. Use License"
                    }), Object(dt.jsxs)("ol", {
                        type: "a",
                        children: [Object(dt.jsxs)("li", {
                            children: ["Permission is granted to temporarily download one copy of the materials (information or software) on DJ3D's website for personal, non-commercial transitory viewing only. This is the grant of a license, not a transfer of title, and under this license you may not:", Object(dt.jsxs)("ol", {
                                type: "i",
                                children: [Object(dt.jsx)("li", {
                                    children: "modify or copy the materials;"
                                }), Object(dt.jsx)("li", {
                                    children: "use the materials for any commercial purpose, or for any public display (commercial or non-commercial);"
                                }), Object(dt.jsx)("li", {
                                    children: "attempt to decompile or reverse engineer any software contained on DJ3D's website;"
                                }), Object(dt.jsx)("li", {
                                    children: "remove any copyright or other proprietary notations from the materials; or"
                                }), Object(dt.jsx)("li", {
                                    children: 'transfer the materials to another person or "mirror" the materials on any other server.'
                                })]
                            })]
                        }), Object(dt.jsx)("li", {
                            children: "This license shall automatically terminate if you violate any of these restrictions and may be terminated by DJ3D at any time. Upon terminating your viewing of these materials or upon the termination of this license, you must destroy any downloaded materials in your possession whether in electronic or printed format."
                        })]
                    }), Object(dt.jsx)("h3", {
                        children: "3. Disclaimer"
                    }), Object(dt.jsxs)("ol", {
                        type: "a",
                        children: [Object(dt.jsx)("li", {
                            children: "The materials on DJ3D's website are provided on an 'as is' basis. DJ3D makes no warranties, expressed or implied, and hereby disclaims and negates all other warranties including, without limitation, implied warranties or conditions of merchantability, fitness for a particular purpose, or non-infringement of intellectual property or other violation of rights."
                        }), Object(dt.jsx)("li", {
                            children: "Further, DJ3D does not warrant or make any representations concerning the accuracy, likely results, or reliability of the use of the materials on its website or otherwise relating to such materials or on any sites linked to this site."
                        })]
                    }), Object(dt.jsx)("h3", {
                        children: "4. Limitations"
                    }), Object(dt.jsx)("p", {
                        children: "In no event shall DJ3D or its suppliers be liable for any damages (including, without limitation, damages for loss of data or profit, or due to business interruption) arising out of the use or inability to use the materials on DJ3D's website, even if DJ3D or a DJ3D authorized representative has been notified orally or in writing of the possibility of such damage. Because some jurisdictions do not allow limitations on implied warranties, or limitations of liability for consequential or incidental damages, these limitations may not apply to you."
                    }), Object(dt.jsx)("h3", {
                        children: "5. Accuracy of materials"
                    }), Object(dt.jsx)("p", {
                        children: "The materials appearing on DJ3D's website could include technical, typographical, or photographic errors. DJ3D does not warrant that any of the materials on its website are accurate, complete or current. DJ3D may make changes to the materials contained on its website at any time without notice. However DJ3D does not make any commitment to update the materials."
                    }), Object(dt.jsx)("h3", {
                        children: "6. Links"
                    }), Object(dt.jsx)("p", {
                        children: "DJ3D has not reviewed all of the sites linked to its website and is not responsible for the contents of any such linked site. The inclusion of any link does not imply endorsement by DJ3D of the site. Use of any such linked website is at the user's own risk."
                    }), Object(dt.jsx)("h3", {
                        children: "7. Modifications"
                    }), Object(dt.jsx)("p", {
                        children: "DJ3D may revise these terms of service for its website at any time without notice. By using this website you are agreeing to be bound by the then current version of these terms of service."
                    }), Object(dt.jsx)("h3", {
                        children: "8. Governing Law"
                    }), Object(dt.jsx)("p", {
                        children: "These terms and conditions are governed by and construed in accordance with the laws of CA and you irrevocably submit to the exclusive jurisdiction of the courts in that State or location."
                    })]
                })
            }

            function ai() {
                return Object(dt.jsxs)("div", {
                    className: "TermsOfService",
                    children: [Object(dt.jsx)("h2", {
                        children: "Privacy Policy"
                    }), Object(dt.jsxs)("p", {
                        children: ["Your privacy is important to us. It is DJ3D's policy to respect your privacy regarding any information we may collect from you across our website, ", Object(dt.jsx)("a", {
                            href: "https://dj3d.io",
                            children: "https://dj3d.io"
                        }), ", and other sites we own and operate."]
                    }), Object(dt.jsx)("p", {
                        children: "We only ask for personal information when we truly need it to provide a service to you. We collect it by fair and lawful means, with your knowledge and consent. We also let you know why we\u2019re collecting it and how it will be used."
                    }), Object(dt.jsx)("p", {
                        children: "We only retain collected information for as long as necessary to provide you with your requested service. What data we store, we\u2019ll protect within commercially acceptable means to prevent loss and theft, as well as unauthorized access, disclosure, copying, use or modification."
                    }), Object(dt.jsx)("p", {
                        children: "We don\u2019t share any personally identifying information publicly or with third-parties, except when required to by law."
                    }), Object(dt.jsx)("p", {
                        children: "Our website may link to external sites that are not operated by us. Please be aware that we have no control over the content and practices of these sites, and cannot accept responsibility or liability for their respective privacy policies."
                    }), Object(dt.jsx)("p", {
                        children: "You are free to refuse our request for your personal information, with the understanding that we may be unable to provide you with some of your desired services."
                    }), Object(dt.jsx)("p", {
                        children: "Your continued use of our website will be regarded as acceptance of our practices around privacy and personal information. If you have any questions about how we handle user data and personal information, feel free to contact us."
                    }), Object(dt.jsx)("p", {
                        children: "This policy is effective as of 24 April 2020."
                    })]
                })
            }
            var li = n(177),
                ci = n(115);
            n(403);
            const hi = new li.a;
            let ui, di = !1;

            function pi(t) {
                const [e, n] = Object(i.useState)(!1);
                return Object(dt.jsxs)("div", {
                    children: [Object(dt.jsx)("div", {
                        id: "controls-menu"
                    }), !e && Object(dt.jsxs)("div", {
                        className: "RoomTester-Instructions",
                        children: [Object(dt.jsx)("div", {
                            children: "DJ3D Map Tester"
                        }), Object(dt.jsx)("div", {
                            children: "Drag .glb map files to the bottom left"
                        }), Object(dt.jsx)("a", {
                            href: "https://www.notion.so/DJ3D-Custom-Maps-ec5fff7688b2429ab29e9558d37cfd14",
                            children: "Full documentation"
                        })]
                    }), Object(dt.jsx)(At, {
                        isInRoom: !1
                    }), e && Object(dt.jsx)(Xe, {
                        isVideoChat: !1,
                        roomId: void 0,
                        started: !0,
                        roomInfo: null
                    }), Object(dt.jsx)(fi, {
                        setDidLoad: n
                    }), Object(dt.jsx)(mi, {
                        setDidLoad: n
                    }), Object(dt.jsx)(Nn, {})]
                })
            }

            function fi(t) {
                const [e, n] = Object(i.useState)(!1), r = Object(i.useCallback)((e => {
                    e.forEach((e => {
                        const i = new FileReader;
                        i.onabort = () => console.log("file reading was aborted"), i.onerror = () => console.log("file reading has failed"), i.onload = () => {
                            const e = i.result;
                            hi.parse(e, "", (e => {
                                t.setDidLoad(!0),
                                    function(t) {
                                        let e = document.getElementById("canvas");
                                        e && e.remove();
                                        let n = new l.World;
                                        n.cameraOperator.theta = 0, n.cameraOperator.phi = 0, n.updateGraphicsQuality(1), n.loadScene(t), fn(t);
                                        let i = mn(t);
                                        n.onCharacterLoaded = () => {
                                            Qt()
                                        };
                                        let r = n.graphicsWorld,
                                            o = n.camera,
                                            s = [];
                                        i ? (console.log("got defaultz"), s.push(i)) : s.push({
                                            elementId: "youtubeContainer",
                                            width: 20,
                                            height: 11.5,
                                            position: {
                                                x: 0,
                                                y: 6,
                                                z: -10
                                            },
                                            rotation: {
                                                x: 0,
                                                y: 0,
                                                z: 0
                                            }
                                        }), Ae(r, o, n, s), n.inputManager.domElement.requestPointerLock(), di = !0, ui = n
                                    }(e), n(!0)
                            }), (t => console.log(t)))
                        }, i.readAsArrayBuffer(e)
                    }))
                }), [t]), {
                    getRootProps: o,
                    getInputProps: s
                } = Object(ci.a)({
                    onDrop: r
                });
                return e ? null : Object(dt.jsxs)("div", {...o({
                        className: "dropzone"
                    }),
                    children: [Object(dt.jsx)("b", {
                        children: "Map Uploader"
                    }), Object(dt.jsx)("input", {...s()
                    }), Object(dt.jsx)("p", {
                        children: "Drag .glb file here"
                    }), Object(dt.jsx)("div", {
                        children: "Or, click to upload"
                    })]
                })
            }

            function mi(t) {
                const [e] = Object(i.useState)(!1), {
                    setDidLoad: n
                } = t, r = Object(i.useCallback)((t => {
                    t.forEach((t => {
                        const e = new FileReader;
                        e.onabort = () => console.log("file reading was aborted"), e.onerror = () => console.log("file reading has failed"), e.onload = () => {
                            const t = e.result;
                            hi.parse(t, "", (t => {
                                di ? ui && ui.activeCharacter.loadGLTF(t) : function(t) {
                                    let e = document.getElementById("canvas");
                                    e && e.remove();
                                    let n = new l.World;
                                    ui = n, Me(n), n.updateGraphicsQuality(1), n.onCharacterLoaded = () => {
                                        n.activeCharacter.loadGLTF(t)
                                    }, n.cameraOperator.theta = 0, n.cameraOperator.phi = 0, n.loadingManager.loadGLTF("world.glb", (t => {
                                        n.loadScene(t);
                                        let e = mn(t),
                                            i = n.graphicsWorld,
                                            r = n.camera,
                                            o = [];
                                        e ? o.push(e) : o.push({
                                            elementId: "youtubeContainer",
                                            width: 20,
                                            height: 11.5,
                                            position: {
                                                x: 0,
                                                y: 6,
                                                z: -10
                                            },
                                            rotation: {
                                                x: 0,
                                                y: 0,
                                                z: 0
                                            }
                                        }), Ae(i, r, n, o)
                                    }))
                                }(t), n(!0)
                            }), (t => console.log(t)))
                        }, e.readAsArrayBuffer(t)
                    }))
                }), [n]), {
                    getRootProps: o,
                    getInputProps: s
                } = Object(ci.a)({
                    onDrop: r
                });
                return e ? null : Object(dt.jsxs)("div", {...o({
                        className: "dropzone-character"
                    }),
                    children: [Object(dt.jsx)("b", {
                        children: "Character Uploader"
                    }), Object(dt.jsx)("input", {...s()
                    }), Object(dt.jsx)("p", {
                        children: "Drag character .glb file here"
                    }), Object(dt.jsx)("div", {
                        children: "Or, click to upload"
                    })]
                })
            }

            function gi(t) {
                let e = "louvre" === t.id ? {
                    spaceId: "museum",
                    groupId: "louvre",
                    simpleVideoPlayer: "jfKfPfyJRdk",
                    getStartedSubtitle: "The Louvre MMO. All assets from https://collections.louvre.fr/en/. Enjoy!"
                } : null;
                return e ? Object(dt.jsx)(ri, {
                    shardRoomScaling: !0,
                    ...e
                }) : null
            }
            class vi extends r.a.Component {
                render() {
                    return Object(dt.jsx)(a.c, {
                        history: Re,
                        children: Object(dt.jsxs)(a.d, {
                            children: [Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/about",
                                component: oi
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/terms",
                                component: si
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/privacy",
                                component: ai
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/s/:spaceId",
                                component: ri
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/louvre",
                                render: t => Object(dt.jsx)(gi, {
                                    id: "louvre"
                                })
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/r/:subredditId",
                                render: t => Object(dt.jsx)(ri, {
                                    simpleVideoPlayer: "jfKfPfyJRdk",
                                    shardRoomScaling: !0,
                                    ...t
                                })
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/algoanna",
                                render: t => Object(dt.jsx)(ri, {
                                    spaceId: "algoanna",
                                    groupId: "algoanna",
                                    shardRoomScaling: !0,
                                    simpleVideoPlayer: "XhzpxjuwZy0",
                                    ignoreServerIssues: !0,
                                    getStartedSubtitle: "Al Goanna Secret Drop! Jump around to find the links!",
                                    ...t
                                })
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/AlgoHouse",
                                render: t => Object(dt.jsx)(ri, {
                                    groupId: "algohouse",
                                    spaceId: "algohouse",
                                    shardRoomScaling: !0,
                                    simpleVideoPlayer: "218ELDhIiGY",
                                    ignoreServerIssues: !0,
                                    customSkinIds: [4, 5, 6, 7],
                                    defaultSkinThumbUrl: "images/skins/gorilla_yellow.png",
                                    defaultSkinGlbUrl: "build/assets/skins/gorilla_yellow.glb",
                                    getStartedSubtitle: "Algo House Lounge",
                                    ...t
                                })
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/apedrop2",
                                render: t => Object(dt.jsx)(ri, {
                                    groupId: "apedrop2",
                                    spaceId: "apedrop2",
                                    shardRoomScaling: !0,
                                    simpleVideoPlayer: "hb1fepHU_Jg",
                                    ignoreServerIssues: !0,
                                    customSkinIds: [4, 5, 6, 7],
                                    defaultSkinThumbUrl: "images/skins/gorilla_yellow.png",
                                    defaultSkinGlbUrl: "build/assets/skins/gorilla_yellow.glb",
                                    getStartedSubtitle: "Algo House Lounge (Drop 2)",
                                    ...t
                                })
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/lynxsecretroom",
                                render: t => Object(dt.jsx)(ri, {
                                    groupId: "lynx",
                                    spaceId: "lynx",
                                    shardRoomScaling: !0,
                                    simpleVideoPlayer: "jfKfPfyJRdk",
                                    ignoreServerIssues: !0,
                                    customSkinIds: [8, 6, 1, 2],
                                    defaultSkinGlbUrl: "build/assets/skins/lynx.glb",
                                    defaultSkinThumbUrl: "images/skins/lynx.png",
                                    getStartedSubtitle: "Lynx Lounge",
                                    ...t
                                })
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/lynxclub",
                                render: t => Object(dt.jsx)(ri, {
                                    groupId: "lynxclub",
                                    spaceId: "lynxclub",
                                    shardRoomScaling: !0,
                                    simpleVideoPlayer: "jfKfPfyJRdk",
                                    ignoreServerIssues: !0,
                                    customSkinIds: [8, 6, 1, 2],
                                    defaultSkinGlbUrl: "build/assets/skins/lynx.glb",
                                    defaultSkinThumbUrl: "images/skins/lynx.png",
                                    getStartedSubtitle: "Lynx Club",
                                    ...t
                                })
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/gizmosphere",
                                render: t => Object(dt.jsx)(ri, {
                                    spaceId: "gizmosphere",
                                    groupId: "gizmosphere",
                                    shardRoomScaling: !0,
                                    simpleVideoPlayer: "jfKfPfyJRdk",
                                    ignoreServerIssues: !0,
                                    getStartedSubtitle: "GizmoSphere secret drop! Jump around to find hidden links.",
                                    ...t
                                })
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/room/:roomId",
                                component: ri
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "build",
                                component: pi
                            }), Object(dt.jsx)(a.b, {
                                exact: !0,
                                path: "/burningman",
                                children: Object(dt.jsx)(a.a, {
                                    to: "/s/art"
                                })
                            }), Object(dt.jsx)(a.b, {
                                path: "/",
                                component: ri
                            })]
                        })
                    })
                }
            }
            var yi = n(116),
                xi = n(84),
                bi = n(179);
            yi.a.use(xi.d).use(bi.a).init({
                resources: {
                    en: {
                        translation: {
                            CREATE_ROOM: "Create Room",
                            ENABLE_FREE_MODE: "Anyone in your room can change video",
                            ENABLE_TEXT_CHAT: "Enable Text Chat",
                            ENABLE_PUBLIC_ROOM_LIST: "Show in public room list",
                            ENABLE_VIDEO_CHAT: "Enable Video Chat (beta)",
                            MULTIPLAYER: "Multiplayer",
                            MULTIPLAYER_EXPLANATION: "Create a room to invite friends (50 max)",
                            ENABLE_PROXIMITY_AUDIO: "Enable Proximity Audio",
                            ENABLE_VIDEO_QUEUE: "Enable video queue"
                        }
                    },
                    "pt-BR": {
                        translation: {
                            CREATE_ROOM: "Criar quarto",
                            ENABLE_FREE_MODE: "Qualquer pessoa na sua sala pode alterar o v\xeddeo",
                            ENABLE_TEXT_CHAT: "Habilitar chat de texto",
                            ENABLE_PUBLIC_ROOM_LIST: "Mostrar na lista de salas p\xfablicas",
                            ENABLE_VIDEO_CHAT: "Ativar chat de v\xeddeo (beta)",
                            MULTIPLAYER: "Multijogador",
                            MULTIPLAYER_EXPLANATION: "Crie uma sala para convidar amigos (m\xe1ximo 50)",
                            ENABLE_PROXIMITY_AUDIO: "Ativar \xe1udio de proximidade",
                            ENABLE_VIDEO_QUEUE: "Habilitar fila de v\xeddeo"
                        }
                    },
                    pt: {
                        translation: {
                            CREATE_ROOM: "Criar quarto",
                            ENABLE_FREE_MODE: "Qualquer pessoa na sua sala pode alterar o v\xeddeo",
                            ENABLE_TEXT_CHAT: "Habilitar chat de texto",
                            ENABLE_PUBLIC_ROOM_LIST: "Mostrar na lista de salas p\xfablicas",
                            ENABLE_VIDEO_CHAT: "Ativar chat de v\xeddeo (beta)",
                            MULTIPLAYER: "Multijogador",
                            MULTIPLAYER_EXPLANATION: "Crie uma sala para convidar amigos (m\xe1ximo 50)",
                            ENABLE_PROXIMITY_AUDIO: "Ativar \xe1udio de proximidade",
                            ENABLE_VIDEO_QUEUE: "Habilitar fila de v\xeddeo"
                        }
                    }
                },
                fallbackLng: "en",
                keySeparator: !1,
                interpolation: {
                    escapeValue: !1
                }
            });
            yi.a;
            s.a.render(Object(dt.jsx)(W.a, {
                store: Lt,
                children: Object(dt.jsx)(vi, {})
            }), document.getElementById("root")), "serviceWorker" in navigator && navigator.serviceWorker.ready.then((t => {
                t.unregister()
            })).catch((t => {
                console.error(t.message)
            }))
        },
        45: function(t, e, n) {
            window,
            t.exports = function(t) {
                var e = {};

                function n(i) {
                    if (e[i]) return e[i].exports;
                    var r = e[i] = {
                        i: i,
                        l: !1,
                        exports: {}
                    };
                    return t[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports
                }
                return n.m = t, n.c = e, n.d = function(t, e, i) {
                    n.o(t, e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: i
                    })
                }, n.r = function(t) {
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                        value: "Module"
                    }), Object.defineProperty(t, "__esModule", {
                        value: !0
                    })
                }, n.t = function(t, e) {
                    if (1 & e && (t = n(t)), 8 & e) return t;
                    if (4 & e && "object" == typeof t && t && t.__esModule) return t;
                    var i = Object.create(null);
                    if (n.r(i), Object.defineProperty(i, "default", {
                            enumerable: !0,
                            value: t
                        }), 2 & e && "string" != typeof t)
                        for (var r in t) n.d(i, r, function(e) {
                            return t[e]
                        }.bind(null, r));
                    return i
                }, n.n = function(t) {
                    var e = t && t.__esModule ? function() {
                        return t.default
                    } : function() {
                        return t
                    };
                    return n.d(e, "a", e), e
                }, n.o = function(t, e) {
                    return Object.prototype.hasOwnProperty.call(t, e)
                }, n.p = "", n(n.s = 39)
            }([function(t, e, n) {
                "use strict";
                n.r(e), n.d(e, "ACESFilmicToneMapping", (function() {
                    return nt
                })), n.d(e, "AddEquation", (function() {
                    return A
                })), n.d(e, "AddOperation", (function() {
                    return J
                })), n.d(e, "AdditiveAnimationBlendMode", (function() {
                    return Ye
                })), n.d(e, "AdditiveBlending", (function() {
                    return w
                })), n.d(e, "AlphaFormat", (function() {
                    return Bt
                })), n.d(e, "AlwaysDepth", (function() {
                    return z
                })), n.d(e, "AlwaysStencilFunc", (function() {
                    return Mn
                })), n.d(e, "AmbientLight", (function() {
                    return Vu
                })), n.d(e, "AmbientLightProbe", (function() {
                    return sd
                })), n.d(e, "AnimationClip", (function() {
                    return jh
                })), n.d(e, "AnimationLoader", (function() {
                    return Xh
                })), n.d(e, "AnimationMixer", (function() {
                    return Bd
                })), n.d(e, "AnimationObjectGroup", (function() {
                    return Od
                })), n.d(e, "AnimationUtils", (function() {
                    return Th
                })), n.d(e, "ArcCurve", (function() {
                    return eu
                })), n.d(e, "ArrayCamera", (function() {
                    return Ka
                })), n.d(e, "ArrowHelper", (function() {
                    return Ap
                })), n.d(e, "Audio", (function() {
                    return vd
                })), n.d(e, "AudioAnalyser", (function() {
                    return Sd
                })), n.d(e, "AudioContext", (function() {
                    return id
                })), n.d(e, "AudioListener", (function() {
                    return gd
                })), n.d(e, "AudioLoader", (function() {
                    return rd
                })), n.d(e, "AxesHelper", (function() {
                    return Tp
                })), n.d(e, "AxisHelper", (function() {
                    return Pf
                })), n.d(e, "BackSide", (function() {
                    return m
                })), n.d(e, "BasicDepthPacking", (function() {
                    return on
                })), n.d(e, "BasicShadowMap", (function() {
                    return h
                })), n.d(e, "BinaryTextureLoader", (function() {
                    return Of
                })), n.d(e, "Bone", (function() {
                    return Dl
                })), n.d(e, "BooleanKeyframeTrack", (function() {
                    return Ih
                })), n.d(e, "BoundingBoxHelper", (function() {
                    return Lf
                })), n.d(e, "Box2", (function() {
                    return Yd
                })), n.d(e, "Box3", (function() {
                    return hi
                })), n.d(e, "Box3Helper", (function() {
                    return bp
                })), n.d(e, "BoxBufferGeometry", (function() {
                    return Ao
                })), n.d(e, "BoxGeometry", (function() {
                    return Ao
                })), n.d(e, "BoxHelper", (function() {
                    return xp
                })), n.d(e, "BufferAttribute", (function() {
                    return Dr
                })), n.d(e, "BufferGeometry", (function() {
                    return ro
                })), n.d(e, "BufferGeometryLoader", (function() {
                    return Yu
                })), n.d(e, "ByteType", (function() {
                    return At
                })), n.d(e, "Cache", (function() {
                    return Uh
                })), n.d(e, "Camera", (function() {
                    return Io
                })), n.d(e, "CameraHelper", (function() {
                    return gp
                })), n.d(e, "CanvasRenderer", (function() {
                    return Bf
                })), n.d(e, "CanvasTexture", (function() {
                    return pc
                })), n.d(e, "CatmullRomCurve3", (function() {
                    return au
                })), n.d(e, "CineonToneMapping", (function() {
                    return et
                })), n.d(e, "CircleBufferGeometry", (function() {
                    return mc
                })), n.d(e, "CircleGeometry", (function() {
                    return mc
                })), n.d(e, "ClampToEdgeWrapping", (function() {
                    return dt
                })), n.d(e, "Clock", (function() {
                    return hd
                })), n.d(e, "Color", (function() {
                    return Fr
                })), n.d(e, "ColorKeyframeTrack", (function() {
                    return Fh
                })), n.d(e, "CompressedTexture", (function() {
                    return dc
                })), n.d(e, "CompressedTextureLoader", (function() {
                    return qh
                })), n.d(e, "ConeBufferGeometry", (function() {
                    return vc
                })), n.d(e, "ConeGeometry", (function() {
                    return vc
                })), n.d(e, "CubeCamera", (function() {
                    return Bo
                })), n.d(e, "CubeReflectionMapping", (function() {
                    return ot
                })), n.d(e, "CubeRefractionMapping", (function() {
                    return st
                })), n.d(e, "CubeTexture", (function() {
                    return Do
                })), n.d(e, "CubeTextureLoader", (function() {
                    return Zh
                })), n.d(e, "CubeUVReflectionMapping", (function() {
                    return ct
                })), n.d(e, "CubeUVRefractionMapping", (function() {
                    return ht
                })), n.d(e, "CubicBezierCurve", (function() {
                    return uu
                })), n.d(e, "CubicBezierCurve3", (function() {
                    return du
                })), n.d(e, "CubicInterpolant", (function() {
                    return Ch
                })), n.d(e, "CullFaceBack", (function() {
                    return a
                })), n.d(e, "CullFaceFront", (function() {
                    return l
                })), n.d(e, "CullFaceFrontBack", (function() {
                    return c
                })), n.d(e, "CullFaceNone", (function() {
                    return s
                })), n.d(e, "Curve", (function() {
                    return $h
                })), n.d(e, "CurvePath", (function() {
                    return xu
                })), n.d(e, "CustomBlending", (function() {
                    return M
                })), n.d(e, "CustomToneMapping", (function() {
                    return it
                })), n.d(e, "CylinderBufferGeometry", (function() {
                    return gc
                })), n.d(e, "CylinderGeometry", (function() {
                    return gc
                })), n.d(e, "Cylindrical", (function() {
                    return Hd
                })), n.d(e, "DataTexture", (function() {
                    return Vl
                })), n.d(e, "DataTexture2DArray", (function() {
                    return ls
                })), n.d(e, "DataTexture3D", (function() {
                    return cs
                })), n.d(e, "DataTextureLoader", (function() {
                    return Jh
                })), n.d(e, "DataUtils", (function() {
                    return Pp
                })), n.d(e, "DecrementStencilOp", (function() {
                    return pn
                })), n.d(e, "DecrementWrapStencilOp", (function() {
                    return mn
                })), n.d(e, "DefaultLoadingManager", (function() {
                    return Gh
                })), n.d(e, "DepthFormat", (function() {
                    return zt
                })), n.d(e, "DepthStencilFormat", (function() {
                    return Gt
                })), n.d(e, "DepthTexture", (function() {
                    return fc
                })), n.d(e, "DirectionalLight", (function() {
                    return Du
                })), n.d(e, "DirectionalLightHelper", (function() {
                    return pp
                })), n.d(e, "DiscreteInterpolant", (function() {
                    return Lh
                })), n.d(e, "DodecahedronBufferGeometry", (function() {
                    return xc
                })), n.d(e, "DodecahedronGeometry", (function() {
                    return xc
                })), n.d(e, "DoubleSide", (function() {
                    return g
                })), n.d(e, "DstAlphaFactor", (function() {
                    return B
                })), n.d(e, "DstColorFactor", (function() {
                    return V
                })), n.d(e, "DynamicBufferAttribute", (function() {
                    return xf
                })), n.d(e, "DynamicCopyUsage", (function() {
                    return In
                })), n.d(e, "DynamicDrawUsage", (function() {
                    return Tn
                })), n.d(e, "DynamicReadUsage", (function() {
                    return Pn
                })), n.d(e, "EdgesGeometry", (function() {
                    return Mc
                })), n.d(e, "EdgesHelper", (function() {
                    return Rf
                })), n.d(e, "EllipseCurve", (function() {
                    return tu
                })), n.d(e, "EqualDepth", (function() {
                    return W
                })), n.d(e, "EqualStencilFunc", (function() {
                    return xn
                })), n.d(e, "EquirectangularReflectionMapping", (function() {
                    return at
                })), n.d(e, "EquirectangularRefractionMapping", (function() {
                    return lt
                })), n.d(e, "Euler", (function() {
                    return qi
                })), n.d(e, "EventDispatcher", (function() {
                    return Bn
                })), n.d(e, "ExtrudeBufferGeometry", (function() {
                    return $c
                })), n.d(e, "ExtrudeGeometry", (function() {
                    return $c
                })), n.d(e, "FaceColors", (function() {
                    return lf
                })), n.d(e, "FileLoader", (function() {
                    return Yh
                })), n.d(e, "FlatShading", (function() {
                    return v
                })), n.d(e, "Float16BufferAttribute", (function() {
                    return Wr
                })), n.d(e, "Float32Attribute", (function() {
                    return Ef
                })), n.d(e, "Float32BufferAttribute", (function() {
                    return Yr
                })), n.d(e, "Float64Attribute", (function() {
                    return Cf
                })), n.d(e, "Float64BufferAttribute", (function() {
                    return Xr
                })), n.d(e, "FloatType", (function() {
                    return Lt
                })), n.d(e, "Fog", (function() {
                    return al
                })), n.d(e, "FogExp2", (function() {
                    return sl
                })), n.d(e, "Font", (function() {
                    return $u
                })), n.d(e, "FontLoader", (function() {
                    return ed
                })), n.d(e, "FrontSide", (function() {
                    return f
                })), n.d(e, "Frustum", (function() {
                    return Uo
                })), n.d(e, "GLBufferAttribute", (function() {
                    return jd
                })), n.d(e, "GLSL1", (function() {
                    return On
                })), n.d(e, "GLSL3", (function() {
                    return Nn
                })), n.d(e, "GammaEncoding", (function() {
                    return Ke
                })), n.d(e, "GreaterDepth", (function() {
                    return X
                })), n.d(e, "GreaterEqualDepth", (function() {
                    return Y
                })), n.d(e, "GreaterEqualStencilFunc", (function() {
                    return Sn
                })), n.d(e, "GreaterStencilFunc", (function() {
                    return wn
                })), n.d(e, "GridHelper", (function() {
                    return lp
                })), n.d(e, "Group", (function() {
                    return $a
                })), n.d(e, "HalfFloatType", (function() {
                    return Rt
                })), n.d(e, "HemisphereLight", (function() {
                    return Su
                })), n.d(e, "HemisphereLightHelper", (function() {
                    return ap
                })), n.d(e, "HemisphereLightProbe", (function() {
                    return od
                })), n.d(e, "IcosahedronBufferGeometry", (function() {
                    return eh
                })), n.d(e, "IcosahedronGeometry", (function() {
                    return eh
                })), n.d(e, "ImageBitmapLoader", (function() {
                    return Ju
                })), n.d(e, "ImageLoader", (function() {
                    return Qh
                })), n.d(e, "ImageUtils", (function() {
                    return Kn
                })), n.d(e, "ImmediateRenderObject", (function() {
                    return Zd
                })), n.d(e, "IncrementStencilOp", (function() {
                    return dn
                })), n.d(e, "IncrementWrapStencilOp", (function() {
                    return fn
                })), n.d(e, "InstancedBufferAttribute", (function() {
                    return Wu
                })), n.d(e, "InstancedBufferGeometry", (function() {
                    return Hu
                })), n.d(e, "InstancedInterleavedBuffer", (function() {
                    return Vd
                })), n.d(e, "InstancedMesh", (function() {
                    return Yl
                })), n.d(e, "Int16Attribute", (function() {
                    return Sf
                })), n.d(e, "Int16BufferAttribute", (function() {
                    return Ur
                })), n.d(e, "Int32Attribute", (function() {
                    return Af
                })), n.d(e, "Int32BufferAttribute", (function() {
                    return Gr
                })), n.d(e, "Int8Attribute", (function() {
                    return bf
                })), n.d(e, "Int8BufferAttribute", (function() {
                    return Vr
                })), n.d(e, "IntType", (function() {
                    return Ct
                })), n.d(e, "InterleavedBuffer", (function() {
                    return cl
                })), n.d(e, "InterleavedBufferAttribute", (function() {
                    return ul
                })), n.d(e, "Interpolant", (function() {
                    return Eh
                })), n.d(e, "InterpolateDiscrete", (function() {
                    return je
                })), n.d(e, "InterpolateLinear", (function() {
                    return ke
                })), n.d(e, "InterpolateSmooth", (function() {
                    return Ue
                })), n.d(e, "InvertStencilOp", (function() {
                    return gn
                })), n.d(e, "JSONLoader", (function() {
                    return Df
                })), n.d(e, "KeepStencilOp", (function() {
                    return hn
                })), n.d(e, "KeyframeTrack", (function() {
                    return Rh
                })), n.d(e, "LOD", (function() {
                    return Ll
                })), n.d(e, "LatheBufferGeometry", (function() {
                    return nh
                })), n.d(e, "LatheGeometry", (function() {
                    return nh
                })), n.d(e, "Layers", (function() {
                    return Qi
                })), n.d(e, "LensFlare", (function() {
                    return jf
                })), n.d(e, "LessDepth", (function() {
                    return G
                })), n.d(e, "LessEqualDepth", (function() {
                    return H
                })), n.d(e, "LessEqualStencilFunc", (function() {
                    return bn
                })), n.d(e, "LessStencilFunc", (function() {
                    return yn
                })), n.d(e, "Light", (function() {
                    return _u
                })), n.d(e, "LightProbe", (function() {
                    return Uu
                })), n.d(e, "Line", (function() {
                    return $l
                })), n.d(e, "Line3", (function() {
                    return Qd
                })), n.d(e, "LineBasicMaterial", (function() {
                    return Xl
                })), n.d(e, "LineCurve", (function() {
                    return pu
                })), n.d(e, "LineCurve3", (function() {
                    return fu
                })), n.d(e, "LineDashedMaterial", (function() {
                    return Mh
                })), n.d(e, "LineLoop", (function() {
                    return ic
                })), n.d(e, "LinePieces", (function() {
                    return sf
                })), n.d(e, "LineSegments", (function() {
                    return nc
                })), n.d(e, "LineStrip", (function() {
                    return of
                })), n.d(e, "LinearEncoding", (function() {
                    return Ze
                })), n.d(e, "LinearFilter", (function() {
                    return xt
                })), n.d(e, "LinearInterpolant", (function() {
                    return Ph
                })), n.d(e, "LinearMipMapLinearFilter", (function() {
                    return St
                })), n.d(e, "LinearMipMapNearestFilter", (function() {
                    return wt
                })), n.d(e, "LinearMipmapLinearFilter", (function() {
                    return _t
                })), n.d(e, "LinearMipmapNearestFilter", (function() {
                    return bt
                })), n.d(e, "LinearToneMapping", (function() {
                    return $
                })), n.d(e, "Loader", (function() {
                    return Hh
                })), n.d(e, "LoaderUtils", (function() {
                    return Gu
                })), n.d(e, "LoadingManager", (function() {
                    return zh
                })), n.d(e, "LogLuvEncoding", (function() {
                    return tn
                })), n.d(e, "LoopOnce", (function() {
                    return Be
                })), n.d(e, "LoopPingPong", (function() {
                    return Ve
                })), n.d(e, "LoopRepeat", (function() {
                    return De
                })), n.d(e, "LuminanceAlphaFormat", (function() {
                    return kt
                })), n.d(e, "LuminanceFormat", (function() {
                    return jt
                })), n.d(e, "MOUSE", (function() {
                    return r
                })), n.d(e, "Material", (function() {
                    return Tr
                })), n.d(e, "MaterialLoader", (function() {
                    return zu
                })), n.d(e, "Math", (function() {
                    return qn
                })), n.d(e, "MathUtils", (function() {
                    return qn
                })), n.d(e, "Matrix3", (function() {
                    return Zn
                })), n.d(e, "Matrix4", (function() {
                    return Vi
                })), n.d(e, "MaxEquation", (function() {
                    return P
                })), n.d(e, "Mesh", (function() {
                    return So
                })), n.d(e, "MeshBasicMaterial", (function() {
                    return Or
                })), n.d(e, "MeshDepthMaterial", (function() {
                    return Ha
                })), n.d(e, "MeshDistanceMaterial", (function() {
                    return Wa
                })), n.d(e, "MeshFaceMaterial", (function() {
                    return hf
                })), n.d(e, "MeshLambertMaterial", (function() {
                    return _h
                })), n.d(e, "MeshMatcapMaterial", (function() {
                    return Sh
                })), n.d(e, "MeshNormalMaterial", (function() {
                    return wh
                })), n.d(e, "MeshPhongMaterial", (function() {
                    return xh
                })), n.d(e, "MeshPhysicalMaterial", (function() {
                    return yh
                })), n.d(e, "MeshStandardMaterial", (function() {
                    return vh
                })), n.d(e, "MeshToonMaterial", (function() {
                    return bh
                })), n.d(e, "MinEquation", (function() {
                    return C
                })), n.d(e, "MirroredRepeatWrapping", (function() {
                    return pt
                })), n.d(e, "MixOperation", (function() {
                    return Z
                })), n.d(e, "MultiMaterial", (function() {
                    return uf
                })), n.d(e, "MultiplyBlending", (function() {
                    return S
                })), n.d(e, "MultiplyOperation", (function() {
                    return Q
                })), n.d(e, "NearestFilter", (function() {
                    return ft
                })), n.d(e, "NearestMipMapLinearFilter", (function() {
                    return yt
                })), n.d(e, "NearestMipMapNearestFilter", (function() {
                    return gt
                })), n.d(e, "NearestMipmapLinearFilter", (function() {
                    return vt
                })), n.d(e, "NearestMipmapNearestFilter", (function() {
                    return mt
                })), n.d(e, "NeverDepth", (function() {
                    return U
                })), n.d(e, "NeverStencilFunc", (function() {
                    return vn
                })), n.d(e, "NoBlending", (function() {
                    return x
                })), n.d(e, "NoColors", (function() {
                    return af
                })), n.d(e, "NoToneMapping", (function() {
                    return K
                })), n.d(e, "NormalAnimationBlendMode", (function() {
                    return We
                })), n.d(e, "NormalBlending", (function() {
                    return b
                })), n.d(e, "NotEqualDepth", (function() {
                    return q
                })), n.d(e, "NotEqualStencilFunc", (function() {
                    return _n
                })), n.d(e, "NumberKeyframeTrack", (function() {
                    return Oh
                })), n.d(e, "Object3D", (function() {
                    return cr
                })), n.d(e, "ObjectLoader", (function() {
                    return Xu
                })), n.d(e, "ObjectSpaceNormalMap", (function() {
                    return ln
                })), n.d(e, "OctahedronBufferGeometry", (function() {
                    return ih
                })), n.d(e, "OctahedronGeometry", (function() {
                    return ih
                })), n.d(e, "OneFactor", (function() {
                    return R
                })), n.d(e, "OneMinusDstAlphaFactor", (function() {
                    return D
                })), n.d(e, "OneMinusDstColorFactor", (function() {
                    return j
                })), n.d(e, "OneMinusSrcAlphaFactor", (function() {
                    return N
                })), n.d(e, "OneMinusSrcColorFactor", (function() {
                    return F
                })), n.d(e, "OrthographicCamera", (function() {
                    return Nu
                })), n.d(e, "PCFShadowMap", (function() {
                    return u
                })), n.d(e, "PCFSoftShadowMap", (function() {
                    return d
                })), n.d(e, "PMREMGenerator", (function() {
                    return Qp
                })), n.d(e, "ParametricBufferGeometry", (function() {
                    return rh
                })), n.d(e, "ParametricGeometry", (function() {
                    return rh
                })), n.d(e, "Particle", (function() {
                    return pf
                })), n.d(e, "ParticleBasicMaterial", (function() {
                    return gf
                })), n.d(e, "ParticleSystem", (function() {
                    return ff
                })), n.d(e, "ParticleSystemMaterial", (function() {
                    return vf
                })), n.d(e, "Path", (function() {
                    return bu
                })), n.d(e, "PerspectiveCamera", (function() {
                    return Fo
                })), n.d(e, "Plane", (function() {
                    return pr
                })), n.d(e, "PlaneBufferGeometry", (function() {
                    return Ho
                })), n.d(e, "PlaneGeometry", (function() {
                    return Ho
                })), n.d(e, "PlaneHelper", (function() {
                    return wp
                })), n.d(e, "PointCloud", (function() {
                    return df
                })), n.d(e, "PointCloudMaterial", (function() {
                    return mf
                })), n.d(e, "PointLight", (function() {
                    return Ou
                })), n.d(e, "PointLightHelper", (function() {
                    return ip
                })), n.d(e, "Points", (function() {
                    return cc
                })), n.d(e, "PointsMaterial", (function() {
                    return rc
                })), n.d(e, "PolarGridHelper", (function() {
                    return cp
                })), n.d(e, "PolyhedronBufferGeometry", (function() {
                    return yc
                })), n.d(e, "PolyhedronGeometry", (function() {
                    return yc
                })), n.d(e, "PositionalAudio", (function() {
                    return _d
                })), n.d(e, "PropertyBinding", (function() {
                    return Fd
                })), n.d(e, "PropertyMixer", (function() {
                    return Md
                })), n.d(e, "QuadraticBezierCurve", (function() {
                    return mu
                })), n.d(e, "QuadraticBezierCurve3", (function() {
                    return gu
                })), n.d(e, "Quaternion", (function() {
                    return si
                })), n.d(e, "QuaternionKeyframeTrack", (function() {
                    return Bh
                })), n.d(e, "QuaternionLinearInterpolant", (function() {
                    return Nh
                })), n.d(e, "REVISION", (function() {
                    return i
                })), n.d(e, "RGBADepthPacking", (function() {
                    return sn
                })), n.d(e, "RGBAFormat", (function() {
                    return Vt
                })), n.d(e, "RGBAIntegerFormat", (function() {
                    return Qt
                })), n.d(e, "RGBA_ASTC_10x10_Format", (function() {
                    return ye
                })), n.d(e, "RGBA_ASTC_10x5_Format", (function() {
                    return me
                })), n.d(e, "RGBA_ASTC_10x6_Format", (function() {
                    return ge
                })), n.d(e, "RGBA_ASTC_10x8_Format", (function() {
                    return ve
                })), n.d(e, "RGBA_ASTC_12x10_Format", (function() {
                    return xe
                })), n.d(e, "RGBA_ASTC_12x12_Format", (function() {
                    return be
                })), n.d(e, "RGBA_ASTC_4x4_Format", (function() {
                    return ae
                })), n.d(e, "RGBA_ASTC_5x4_Format", (function() {
                    return le
                })), n.d(e, "RGBA_ASTC_5x5_Format", (function() {
                    return ce
                })), n.d(e, "RGBA_ASTC_6x5_Format", (function() {
                    return he
                })), n.d(e, "RGBA_ASTC_6x6_Format", (function() {
                    return ue
                })), n.d(e, "RGBA_ASTC_8x5_Format", (function() {
                    return de
                })), n.d(e, "RGBA_ASTC_8x6_Format", (function() {
                    return pe
                })), n.d(e, "RGBA_ASTC_8x8_Format", (function() {
                    return fe
                })), n.d(e, "RGBA_BPTC_Format", (function() {
                    return we
                })), n.d(e, "RGBA_ETC2_EAC_Format", (function() {
                    return se
                })), n.d(e, "RGBA_PVRTC_2BPPV1_Format", (function() {
                    return ie
                })), n.d(e, "RGBA_PVRTC_4BPPV1_Format", (function() {
                    return ne
                })), n.d(e, "RGBA_S3TC_DXT1_Format", (function() {
                    return Jt
                })), n.d(e, "RGBA_S3TC_DXT3_Format", (function() {
                    return Kt
                })), n.d(e, "RGBA_S3TC_DXT5_Format", (function() {
                    return $t
                })), n.d(e, "RGBDEncoding", (function() {
                    return rn
                })), n.d(e, "RGBEEncoding", (function() {
                    return $e
                })), n.d(e, "RGBEFormat", (function() {
                    return Ut
                })), n.d(e, "RGBFormat", (function() {
                    return Dt
                })), n.d(e, "RGBIntegerFormat", (function() {
                    return qt
                })), n.d(e, "RGBM16Encoding", (function() {
                    return nn
                })), n.d(e, "RGBM7Encoding", (function() {
                    return en
                })), n.d(e, "RGB_ETC1_Format", (function() {
                    return re
                })), n.d(e, "RGB_ETC2_Format", (function() {
                    return oe
                })), n.d(e, "RGB_PVRTC_2BPPV1_Format", (function() {
                    return ee
                })), n.d(e, "RGB_PVRTC_4BPPV1_Format", (function() {
                    return te
                })), n.d(e, "RGB_S3TC_DXT1_Format", (function() {
                    return Zt
                })), n.d(e, "RGFormat", (function() {
                    return Yt
                })), n.d(e, "RGIntegerFormat", (function() {
                    return Xt
                })), n.d(e, "RawShaderMaterial", (function() {
                    return gh
                })), n.d(e, "Ray", (function() {
                    return Di
                })), n.d(e, "Raycaster", (function() {
                    return kd
                })), n.d(e, "RectAreaLight", (function() {
                    return ju
                })), n.d(e, "RedFormat", (function() {
                    return Ht
                })), n.d(e, "RedIntegerFormat", (function() {
                    return Wt
                })), n.d(e, "ReinhardToneMapping", (function() {
                    return tt
                })), n.d(e, "RepeatWrapping", (function() {
                    return ut
                })), n.d(e, "ReplaceStencilOp", (function() {
                    return un
                })), n.d(e, "ReverseSubtractEquation", (function() {
                    return E
                })), n.d(e, "RingBufferGeometry", (function() {
                    return oh
                })), n.d(e, "RingGeometry", (function() {
                    return oh
                })), n.d(e, "SRGB8_ALPHA8_ASTC_10x10_Format", (function() {
                    return Fe
                })), n.d(e, "SRGB8_ALPHA8_ASTC_10x5_Format", (function() {
                    return Le
                })), n.d(e, "SRGB8_ALPHA8_ASTC_10x6_Format", (function() {
                    return Re
                })), n.d(e, "SRGB8_ALPHA8_ASTC_10x8_Format", (function() {
                    return Ie
                })), n.d(e, "SRGB8_ALPHA8_ASTC_12x10_Format", (function() {
                    return Oe
                })), n.d(e, "SRGB8_ALPHA8_ASTC_12x12_Format", (function() {
                    return Ne
                })), n.d(e, "SRGB8_ALPHA8_ASTC_4x4_Format", (function() {
                    return _e
                })), n.d(e, "SRGB8_ALPHA8_ASTC_5x4_Format", (function() {
                    return Se
                })), n.d(e, "SRGB8_ALPHA8_ASTC_5x5_Format", (function() {
                    return Me
                })), n.d(e, "SRGB8_ALPHA8_ASTC_6x5_Format", (function() {
                    return Ae
                })), n.d(e, "SRGB8_ALPHA8_ASTC_6x6_Format", (function() {
                    return Te
                })), n.d(e, "SRGB8_ALPHA8_ASTC_8x5_Format", (function() {
                    return Ee
                })), n.d(e, "SRGB8_ALPHA8_ASTC_8x6_Format", (function() {
                    return Ce
                })), n.d(e, "SRGB8_ALPHA8_ASTC_8x8_Format", (function() {
                    return Pe
                })), n.d(e, "Scene", (function() {
                    return ll
                })), n.d(e, "SceneUtils", (function() {
                    return Vf
                })), n.d(e, "ShaderChunk", (function() {
                    return Wo
                })), n.d(e, "ShaderLib", (function() {
                    return Xo
                })), n.d(e, "ShaderMaterial", (function() {
                    return Ro
                })), n.d(e, "ShadowMaterial", (function() {
                    return mh
                })), n.d(e, "Shape", (function() {
                    return wu
                })), n.d(e, "ShapeBufferGeometry", (function() {
                    return sh
                })), n.d(e, "ShapeGeometry", (function() {
                    return sh
                })), n.d(e, "ShapePath", (function() {
                    return Ku
                })), n.d(e, "ShapeUtils", (function() {
                    return Zc
                })), n.d(e, "ShortType", (function() {
                    return Tt
                })), n.d(e, "Skeleton", (function() {
                    return Ul
                })), n.d(e, "SkeletonHelper", (function() {
                    return np
                })), n.d(e, "SkinnedMesh", (function() {
                    return Bl
                })), n.d(e, "SmoothShading", (function() {
                    return y
                })), n.d(e, "Sphere", (function() {
                    return Pi
                })), n.d(e, "SphereBufferGeometry", (function() {
                    return ah
                })), n.d(e, "SphereGeometry", (function() {
                    return ah
                })), n.d(e, "Spherical", (function() {
                    return Gd
                })), n.d(e, "SphericalHarmonics3", (function() {
                    return ku
                })), n.d(e, "SplineCurve", (function() {
                    return vu
                })), n.d(e, "SpotLight", (function() {
                    return Pu
                })), n.d(e, "SpotLightHelper", (function() {
                    return Kd
                })), n.d(e, "Sprite", (function() {
                    return Tl
                })), n.d(e, "SpriteMaterial", (function() {
                    return dl
                })), n.d(e, "SrcAlphaFactor", (function() {
                    return O
                })), n.d(e, "SrcAlphaSaturateFactor", (function() {
                    return k
                })), n.d(e, "SrcColorFactor", (function() {
                    return I
                })), n.d(e, "StaticCopyUsage", (function() {
                    return Rn
                })), n.d(e, "StaticDrawUsage", (function() {
                    return An
                })), n.d(e, "StaticReadUsage", (function() {
                    return Cn
                })), n.d(e, "StereoCamera", (function() {
                    return cd
                })), n.d(e, "StreamCopyUsage", (function() {
                    return Fn
                })), n.d(e, "StreamDrawUsage", (function() {
                    return En
                })), n.d(e, "StreamReadUsage", (function() {
                    return Ln
                })), n.d(e, "StringKeyframeTrack", (function() {
                    return Dh
                })), n.d(e, "SubtractEquation", (function() {
                    return T
                })), n.d(e, "SubtractiveBlending", (function() {
                    return _
                })), n.d(e, "TOUCH", (function() {
                    return o
                })), n.d(e, "TangentSpaceNormalMap", (function() {
                    return an
                })), n.d(e, "TetrahedronBufferGeometry", (function() {
                    return lh
                })), n.d(e, "TetrahedronGeometry", (function() {
                    return lh
                })), n.d(e, "TextBufferGeometry", (function() {
                    return ch
                })), n.d(e, "TextGeometry", (function() {
                    return ch
                })), n.d(e, "Texture", (function() {
                    return ti
                })), n.d(e, "TextureLoader", (function() {
                    return Kh
                })), n.d(e, "TorusBufferGeometry", (function() {
                    return hh
                })), n.d(e, "TorusGeometry", (function() {
                    return hh
                })), n.d(e, "TorusKnotBufferGeometry", (function() {
                    return uh
                })), n.d(e, "TorusKnotGeometry", (function() {
                    return uh
                })), n.d(e, "Triangle", (function() {
                    return Mr
                })), n.d(e, "TriangleFanDrawMode", (function() {
                    return Qe
                })), n.d(e, "TriangleStripDrawMode", (function() {
                    return qe
                })), n.d(e, "TrianglesDrawMode", (function() {
                    return Xe
                })), n.d(e, "TubeBufferGeometry", (function() {
                    return dh
                })), n.d(e, "TubeGeometry", (function() {
                    return dh
                })), n.d(e, "UVMapping", (function() {
                    return rt
                })), n.d(e, "Uint16Attribute", (function() {
                    return Mf
                })), n.d(e, "Uint16BufferAttribute", (function() {
                    return zr
                })), n.d(e, "Uint32Attribute", (function() {
                    return Tf
                })), n.d(e, "Uint32BufferAttribute", (function() {
                    return Hr
                })), n.d(e, "Uint8Attribute", (function() {
                    return wf
                })), n.d(e, "Uint8BufferAttribute", (function() {
                    return jr
                })), n.d(e, "Uint8ClampedAttribute", (function() {
                    return _f
                })), n.d(e, "Uint8ClampedBufferAttribute", (function() {
                    return kr
                })), n.d(e, "Uniform", (function() {
                    return Dd
                })), n.d(e, "UniformsLib", (function() {
                    return Yo
                })), n.d(e, "UniformsUtils", (function() {
                    return Co
                })), n.d(e, "UnsignedByteType", (function() {
                    return Mt
                })), n.d(e, "UnsignedInt248Type", (function() {
                    return Nt
                })), n.d(e, "UnsignedIntType", (function() {
                    return Pt
                })), n.d(e, "UnsignedShort4444Type", (function() {
                    return It
                })), n.d(e, "UnsignedShort5551Type", (function() {
                    return Ft
                })), n.d(e, "UnsignedShort565Type", (function() {
                    return Ot
                })), n.d(e, "UnsignedShortType", (function() {
                    return Et
                })), n.d(e, "VSMShadowMap", (function() {
                    return p
                })), n.d(e, "Vector2", (function() {
                    return Qn
                })), n.d(e, "Vector3", (function() {
                    return ai
                })), n.d(e, "Vector4", (function() {
                    return ni
                })), n.d(e, "VectorKeyframeTrack", (function() {
                    return Vh
                })), n.d(e, "Vertex", (function() {
                    return yf
                })), n.d(e, "VertexColors", (function() {
                    return cf
                })), n.d(e, "VideoTexture", (function() {
                    return uc
                })), n.d(e, "WebGL1Renderer", (function() {
                    return ol
                })), n.d(e, "WebGLCubeRenderTarget", (function() {
                    return Vo
                })), n.d(e, "WebGLMultipleRenderTargets", (function() {
                    return ri
                })), n.d(e, "WebGLMultisampleRenderTarget", (function() {
                    return oi
                })), n.d(e, "WebGLRenderTarget", (function() {
                    return ii
                })), n.d(e, "WebGLRenderTargetCube", (function() {
                    return Nf
                })), n.d(e, "WebGLRenderer", (function() {
                    return rl
                })), n.d(e, "WebGLUtils", (function() {
                    return Ja
                })), n.d(e, "WireframeGeometry", (function() {
                    return ph
                })), n.d(e, "WireframeHelper", (function() {
                    return If
                })), n.d(e, "WrapAroundEnding", (function() {
                    return He
                })), n.d(e, "XHRLoader", (function() {
                    return Ff
                })), n.d(e, "ZeroCurvatureEnding", (function() {
                    return ze
                })), n.d(e, "ZeroFactor", (function() {
                    return L
                })), n.d(e, "ZeroSlopeEnding", (function() {
                    return Ge
                })), n.d(e, "ZeroStencilOp", (function() {
                    return cn
                })), n.d(e, "sRGBEncoding", (function() {
                    return Je
                }));
                const i = "129",
                    r = {
                        LEFT: 0,
                        MIDDLE: 1,
                        RIGHT: 2,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2
                    },
                    o = {
                        ROTATE: 0,
                        PAN: 1,
                        DOLLY_PAN: 2,
                        DOLLY_ROTATE: 3
                    },
                    s = 0,
                    a = 1,
                    l = 2,
                    c = 3,
                    h = 0,
                    u = 1,
                    d = 2,
                    p = 3,
                    f = 0,
                    m = 1,
                    g = 2,
                    v = 1,
                    y = 2,
                    x = 0,
                    b = 1,
                    w = 2,
                    _ = 3,
                    S = 4,
                    M = 5,
                    A = 100,
                    T = 101,
                    E = 102,
                    C = 103,
                    P = 104,
                    L = 200,
                    R = 201,
                    I = 202,
                    F = 203,
                    O = 204,
                    N = 205,
                    B = 206,
                    D = 207,
                    V = 208,
                    j = 209,
                    k = 210,
                    U = 0,
                    z = 1,
                    G = 2,
                    H = 3,
                    W = 4,
                    Y = 5,
                    X = 6,
                    q = 7,
                    Q = 0,
                    Z = 1,
                    J = 2,
                    K = 0,
                    $ = 1,
                    tt = 2,
                    et = 3,
                    nt = 4,
                    it = 5,
                    rt = 300,
                    ot = 301,
                    st = 302,
                    at = 303,
                    lt = 304,
                    ct = 306,
                    ht = 307,
                    ut = 1e3,
                    dt = 1001,
                    pt = 1002,
                    ft = 1003,
                    mt = 1004,
                    gt = 1004,
                    vt = 1005,
                    yt = 1005,
                    xt = 1006,
                    bt = 1007,
                    wt = 1007,
                    _t = 1008,
                    St = 1008,
                    Mt = 1009,
                    At = 1010,
                    Tt = 1011,
                    Et = 1012,
                    Ct = 1013,
                    Pt = 1014,
                    Lt = 1015,
                    Rt = 1016,
                    It = 1017,
                    Ft = 1018,
                    Ot = 1019,
                    Nt = 1020,
                    Bt = 1021,
                    Dt = 1022,
                    Vt = 1023,
                    jt = 1024,
                    kt = 1025,
                    Ut = Vt,
                    zt = 1026,
                    Gt = 1027,
                    Ht = 1028,
                    Wt = 1029,
                    Yt = 1030,
                    Xt = 1031,
                    qt = 1032,
                    Qt = 1033,
                    Zt = 33776,
                    Jt = 33777,
                    Kt = 33778,
                    $t = 33779,
                    te = 35840,
                    ee = 35841,
                    ne = 35842,
                    ie = 35843,
                    re = 36196,
                    oe = 37492,
                    se = 37496,
                    ae = 37808,
                    le = 37809,
                    ce = 37810,
                    he = 37811,
                    ue = 37812,
                    de = 37813,
                    pe = 37814,
                    fe = 37815,
                    me = 37816,
                    ge = 37817,
                    ve = 37818,
                    ye = 37819,
                    xe = 37820,
                    be = 37821,
                    we = 36492,
                    _e = 37840,
                    Se = 37841,
                    Me = 37842,
                    Ae = 37843,
                    Te = 37844,
                    Ee = 37845,
                    Ce = 37846,
                    Pe = 37847,
                    Le = 37848,
                    Re = 37849,
                    Ie = 37850,
                    Fe = 37851,
                    Oe = 37852,
                    Ne = 37853,
                    Be = 2200,
                    De = 2201,
                    Ve = 2202,
                    je = 2300,
                    ke = 2301,
                    Ue = 2302,
                    ze = 2400,
                    Ge = 2401,
                    He = 2402,
                    We = 2500,
                    Ye = 2501,
                    Xe = 0,
                    qe = 1,
                    Qe = 2,
                    Ze = 3e3,
                    Je = 3001,
                    Ke = 3007,
                    $e = 3002,
                    tn = 3003,
                    en = 3004,
                    nn = 3005,
                    rn = 3006,
                    on = 3200,
                    sn = 3201,
                    an = 0,
                    ln = 1,
                    cn = 0,
                    hn = 7680,
                    un = 7681,
                    dn = 7682,
                    pn = 7683,
                    fn = 34055,
                    mn = 34056,
                    gn = 5386,
                    vn = 512,
                    yn = 513,
                    xn = 514,
                    bn = 515,
                    wn = 516,
                    _n = 517,
                    Sn = 518,
                    Mn = 519,
                    An = 35044,
                    Tn = 35048,
                    En = 35040,
                    Cn = 35045,
                    Pn = 35049,
                    Ln = 35041,
                    Rn = 35046,
                    In = 35050,
                    Fn = 35042,
                    On = "100",
                    Nn = "300 es";
                class Bn {
                    addEventListener(t, e) {
                        void 0 === this._listeners && (this._listeners = {});
                        const n = this._listeners;
                        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                    }
                    hasEventListener(t, e) {
                        if (void 0 === this._listeners) return !1;
                        const n = this._listeners;
                        return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                    }
                    removeEventListener(t, e) {
                        if (void 0 === this._listeners) return;
                        const n = this._listeners[t];
                        if (void 0 !== n) {
                            const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                        }
                    }
                    dispatchEvent(t) {
                        if (void 0 === this._listeners) return;
                        const e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            const n = e.slice(0);
                            for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                            t.target = null
                        }
                    }
                }
                const Dn = [];
                for (let kf = 0; kf < 256; kf++) Dn[kf] = (kf < 16 ? "0" : "") + kf.toString(16);
                let Vn = 1234567;
                const jn = Math.PI / 180,
                    kn = 180 / Math.PI;

                function Un() {
                    const t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0;
                    return (Dn[255 & t] + Dn[t >> 8 & 255] + Dn[t >> 16 & 255] + Dn[t >> 24 & 255] + "-" + Dn[255 & e] + Dn[e >> 8 & 255] + "-" + Dn[e >> 16 & 15 | 64] + Dn[e >> 24 & 255] + "-" + Dn[63 & n | 128] + Dn[n >> 8 & 255] + "-" + Dn[n >> 16 & 255] + Dn[n >> 24 & 255] + Dn[255 & i] + Dn[i >> 8 & 255] + Dn[i >> 16 & 255] + Dn[i >> 24 & 255]).toUpperCase()
                }

                function zn(t, e, n) {
                    return Math.max(e, Math.min(n, t))
                }

                function Gn(t, e) {
                    return (t % e + e) % e
                }

                function Hn(t, e, n) {
                    return (1 - n) * t + n * e
                }

                function Wn(t) {
                    return 0 == (t & t - 1) && 0 !== t
                }

                function Yn(t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                }

                function Xn(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                }
                var qn = Object.freeze({
                    __proto__: null,
                    DEG2RAD: jn,
                    RAD2DEG: kn,
                    generateUUID: Un,
                    clamp: zn,
                    euclideanModulo: Gn,
                    mapLinear: function(t, e, n, i, r) {
                        return i + (t - e) * (r - i) / (n - e)
                    },
                    inverseLerp: function(t, e, n) {
                        return t !== e ? (n - t) / (e - t) : 0
                    },
                    lerp: Hn,
                    damp: function(t, e, n, i) {
                        return Hn(t, e, 1 - Math.exp(-n * i))
                    },
                    pingpong: function(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        return e - Math.abs(Gn(t, 2 * e) - e)
                    },
                    smoothstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                    },
                    randInt: function(t, e) {
                        return t + Math.floor(Math.random() * (e - t + 1))
                    },
                    randFloat: function(t, e) {
                        return t + Math.random() * (e - t)
                    },
                    randFloatSpread: function(t) {
                        return t * (.5 - Math.random())
                    },
                    seededRandom: function(t) {
                        return void 0 !== t && (Vn = t % 2147483647), Vn = 16807 * Vn % 2147483647, (Vn - 1) / 2147483646
                    },
                    degToRad: function(t) {
                        return t * jn
                    },
                    radToDeg: function(t) {
                        return t * kn
                    },
                    isPowerOfTwo: Wn,
                    ceilPowerOfTwo: Yn,
                    floorPowerOfTwo: Xn,
                    setQuaternionFromProperEuler: function(t, e, n, i, r) {
                        const o = Math.cos,
                            s = Math.sin,
                            a = o(n / 2),
                            l = s(n / 2),
                            c = o((e + i) / 2),
                            h = s((e + i) / 2),
                            u = o((e - i) / 2),
                            d = s((e - i) / 2),
                            p = o((i - e) / 2),
                            f = s((i - e) / 2);
                        switch (r) {
                            case "XYX":
                                t.set(a * h, l * u, l * d, a * c);
                                break;
                            case "YZY":
                                t.set(l * d, a * h, l * u, a * c);
                                break;
                            case "ZXZ":
                                t.set(l * u, l * d, a * h, a * c);
                                break;
                            case "XZX":
                                t.set(a * h, l * f, l * p, a * c);
                                break;
                            case "YXY":
                                t.set(l * p, a * h, l * f, a * c);
                                break;
                            case "ZYZ":
                                t.set(l * f, l * p, a * h, a * c);
                                break;
                            default:
                                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                        }
                    }
                });
                class Qn {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        this.x = t, this.y = e
                    }
                    get width() {
                        return this.x
                    }
                    set width(t) {
                        this.x = t
                    }
                    get height() {
                        return this.y
                    }
                    set height(t) {
                        this.y = t
                    }
                    set(t, e) {
                        return this.x = t, this.y = e, this
                    }
                    setScalar(t) {
                        return this.x = t, this.y = t, this
                    }
                    setX(t) {
                        return this.x = t, this
                    }
                    setY(t) {
                        return this.y = t, this
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y)
                    }
                    copy(t) {
                        return this.x = t.x, this.y = t.y, this
                    }
                    add(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                    }
                    addScalar(t) {
                        return this.x += t, this.y += t, this
                    }
                    addVectors(t, e) {
                        return this.x = t.x + e.x, this.y = t.y + e.y, this
                    }
                    addScaledVector(t, e) {
                        return this.x += t.x * e, this.y += t.y * e, this
                    }
                    sub(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                    }
                    subScalar(t) {
                        return this.x -= t, this.y -= t, this
                    }
                    subVectors(t, e) {
                        return this.x = t.x - e.x, this.y = t.y - e.y, this
                    }
                    multiply(t) {
                        return this.x *= t.x, this.y *= t.y, this
                    }
                    multiplyScalar(t) {
                        return this.x *= t, this.y *= t, this
                    }
                    divide(t) {
                        return this.x /= t.x, this.y /= t.y, this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            i = t.elements;
                        return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                    }
                    clamp(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                    }
                    clampScalar(t, e) {
                        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                    }
                    round() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                    }
                    roundToZero() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                    }
                    negate() {
                        return this.x = -this.x, this.y = -this.y, this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y
                    }
                    cross(t) {
                        return this.x * t.y - this.y * t.x
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    angle() {
                        return Math.atan2(-this.y, -this.x) + Math.PI
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y;
                        return e * e + n * n
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, e) {
                        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                    }
                    lerpVectors(t, e, n) {
                        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y
                    }
                    fromArray(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this.x = t[e], this.y = t[e + 1], this
                    }
                    toArray() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return t[e] = this.x, t[e + 1] = this.y, t
                    }
                    fromBufferAttribute(t, e, n) {
                        return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                    }
                    rotateAround(t, e) {
                        const n = Math.cos(e),
                            i = Math.sin(e),
                            r = this.x - t.x,
                            o = this.y - t.y;
                        return this.x = r * n - o * i + t.x, this.y = r * i + o * n + t.y, this
                    }
                    random() {
                        return this.x = Math.random(), this.y = Math.random(), this
                    }
                }
                Qn.prototype.isVector2 = !0;
                class Zn {
                    constructor() {
                        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                    }
                    set(t, e, n, i, r, o, s, a, l) {
                        const c = this.elements;
                        return c[0] = t, c[1] = i, c[2] = s, c[3] = e, c[4] = r, c[5] = a, c[6] = n, c[7] = o, c[8] = l, this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                    }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                    }
                    extractBasis(t, e, n) {
                        return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                    }
                    setFromMatrix4(t) {
                        const e = t.elements;
                        return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this)
                    }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            i = e.elements,
                            r = this.elements,
                            o = n[0],
                            s = n[3],
                            a = n[6],
                            l = n[1],
                            c = n[4],
                            h = n[7],
                            u = n[2],
                            d = n[5],
                            p = n[8],
                            f = i[0],
                            m = i[3],
                            g = i[6],
                            v = i[1],
                            y = i[4],
                            x = i[7],
                            b = i[2],
                            w = i[5],
                            _ = i[8];
                        return r[0] = o * f + s * v + a * b, r[3] = o * m + s * y + a * w, r[6] = o * g + s * x + a * _, r[1] = l * f + c * v + h * b, r[4] = l * m + c * y + h * w, r[7] = l * g + c * x + h * _, r[2] = u * f + d * v + p * b, r[5] = u * m + d * y + p * w, r[8] = u * g + d * x + p * _, this
                    }
                    multiplyScalar(t) {
                        const e = this.elements;
                        return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                    }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            o = t[4],
                            s = t[5],
                            a = t[6],
                            l = t[7],
                            c = t[8];
                        return e * o * c - e * s * l - n * r * c + n * s * a + i * r * l - i * o * a
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            o = t[4],
                            s = t[5],
                            a = t[6],
                            l = t[7],
                            c = t[8],
                            h = c * o - s * l,
                            u = s * a - c * r,
                            d = l * r - o * a,
                            p = e * h + n * u + i * d;
                        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const f = 1 / p;
                        return t[0] = h * f, t[1] = (i * l - c * n) * f, t[2] = (s * n - i * o) * f, t[3] = u * f, t[4] = (c * e - i * a) * f, t[5] = (i * r - s * e) * f, t[6] = d * f, t[7] = (n * a - l * e) * f, t[8] = (o * e - n * r) * f, this
                    }
                    transpose() {
                        let t;
                        const e = this.elements;
                        return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                    }
                    getNormalMatrix(t) {
                        return this.setFromMatrix4(t).invert().transpose()
                    }
                    transposeIntoArray(t) {
                        const e = this.elements;
                        return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                    }
                    setUvTransform(t, e, n, i, r, o, s) {
                        const a = Math.cos(r),
                            l = Math.sin(r);
                        return this.set(n * a, n * l, -n * (a * o + l * s) + o + t, -i * l, i * a, -i * (-l * o + a * s) + s + e, 0, 0, 1), this
                    }
                    scale(t, e) {
                        const n = this.elements;
                        return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
                    }
                    rotate(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t),
                            i = this.elements,
                            r = i[0],
                            o = i[3],
                            s = i[6],
                            a = i[1],
                            l = i[4],
                            c = i[7];
                        return i[0] = e * r + n * a, i[3] = e * o + n * l, i[6] = e * s + n * c, i[1] = -n * r + e * a, i[4] = -n * o + e * l, i[7] = -n * s + e * c, this
                    }
                    translate(t, e) {
                        const n = this.elements;
                        return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let i = 0; i < 9; i++)
                            if (e[i] !== n[i]) return !1;
                        return !0
                    }
                    fromArray(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                        return this
                    }
                    toArray() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = this.elements;
                        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                    }
                    clone() {
                        return (new this.constructor).fromArray(this.elements)
                    }
                }
                let Jn;
                Zn.prototype.isMatrix3 = !0;
                class Kn {
                    static getDataURL(t) {
                        if (/^data:/i.test(t.src)) return t.src;
                        if ("undefined" == typeof HTMLCanvasElement) return t.src;
                        let e;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === Jn && (Jn = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Jn.width = t.width, Jn.height = t.height;
                            const n = Jn.getContext("2d");
                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Jn
                        }
                        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                    }
                }
                let $n = 0;
                class ti extends Bn {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ti.DEFAULT_IMAGE,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ti.DEFAULT_MAPPING,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : dt,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : dt,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : xt,
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : _t,
                            s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : Vt,
                            a = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : Mt,
                            l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1,
                            c = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : Ze;
                        super(), Object.defineProperty(this, "id", {
                            value: $n++
                        }), this.uuid = Un(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = o, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = a, this.offset = new Qn(0, 0), this.repeat = new Qn(1, 1), this.center = new Qn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Zn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null
                    }
                    updateMatrix() {
                        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                        const n = {
                            metadata: {
                                version: 4.5,
                                type: "Texture",
                                generator: "Texture.toJSON"
                            },
                            uuid: this.uuid,
                            name: this.name,
                            mapping: this.mapping,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            type: this.type,
                            encoding: this.encoding,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment
                        };
                        if (void 0 !== this.image) {
                            const i = this.image;
                            if (void 0 === i.uuid && (i.uuid = Un()), !e && void 0 === t.images[i.uuid]) {
                                let e;
                                if (Array.isArray(i)) {
                                    e = [];
                                    for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(ei(i[t].image)) : e.push(ei(i[t]))
                                } else e = ei(i);
                                t.images[i.uuid] = {
                                    uuid: i.uuid,
                                    url: e
                                }
                            }
                            n.image = i.uuid
                        }
                        return e || (t.textures[this.uuid] = n), n
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    transformUv(t) {
                        if (this.mapping !== rt) return t;
                        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                            case ut:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case dt:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case pt:
                                1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                        }
                        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                            case ut:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case dt:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case pt:
                                1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                        }
                        return this.flipY && (t.y = 1 - t.y), t
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                }

                function ei(t) {
                    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? Kn.getDataURL(t) : t.data ? {
                        data: Array.prototype.slice.call(t.data),
                        width: t.width,
                        height: t.height,
                        type: t.data.constructor.name
                    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
                }
                ti.DEFAULT_IMAGE = void 0, ti.DEFAULT_MAPPING = rt, ti.prototype.isTexture = !0;
                class ni {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        this.x = t, this.y = e, this.z = n, this.w = i
                    }
                    get width() {
                        return this.z
                    }
                    set width(t) {
                        this.z = t
                    }
                    get height() {
                        return this.w
                    }
                    set height(t) {
                        this.w = t
                    }
                    set(t, e, n, i) {
                        return this.x = t, this.y = e, this.z = n, this.w = i, this
                    }
                    setScalar(t) {
                        return this.x = t, this.y = t, this.z = t, this.w = t, this
                    }
                    setX(t) {
                        return this.x = t, this
                    }
                    setY(t) {
                        return this.y = t, this
                    }
                    setZ(t) {
                        return this.z = t, this
                    }
                    setW(t) {
                        return this.w = t, this
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            case 3:
                                this.w = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z, this.w)
                    }
                    copy(t) {
                        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                    }
                    add(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                    }
                    addScalar(t) {
                        return this.x += t, this.y += t, this.z += t, this.w += t, this
                    }
                    addVectors(t, e) {
                        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                    }
                    addScaledVector(t, e) {
                        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                    }
                    sub(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                    }
                    subScalar(t) {
                        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                    }
                    subVectors(t, e) {
                        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                    }
                    multiply(t) {
                        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
                    }
                    multiplyScalar(t) {
                        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                    }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = this.w,
                            o = t.elements;
                        return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r, this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    setAxisAngleFromQuaternion(t) {
                        this.w = 2 * Math.acos(t.w);
                        const e = Math.sqrt(1 - t.w * t.w);
                        return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                    }
                    setAxisAngleFromRotationMatrix(t) {
                        let e, n, i, r;
                        const o = t.elements,
                            s = o[0],
                            a = o[4],
                            l = o[8],
                            c = o[1],
                            h = o[5],
                            u = o[9],
                            d = o[2],
                            p = o[6],
                            f = o[10];
                        if (Math.abs(a - c) < .01 && Math.abs(l - d) < .01 && Math.abs(u - p) < .01) {
                            if (Math.abs(a + c) < .1 && Math.abs(l + d) < .1 && Math.abs(u + p) < .1 && Math.abs(s + h + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                            e = Math.PI;
                            const t = (s + 1) / 2,
                                o = (h + 1) / 2,
                                m = (f + 1) / 2,
                                g = (a + c) / 4,
                                v = (l + d) / 4,
                                y = (u + p) / 4;
                            return t > o && t > m ? t < .01 ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = g / n, r = v / n) : o > m ? o < .01 ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(o), n = g / i, r = y / i) : m < .01 ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(m), n = v / r, i = y / r), this.set(n, i, r, e), this
                        }
                        let m = Math.sqrt((p - u) * (p - u) + (l - d) * (l - d) + (c - a) * (c - a));
                        return Math.abs(m) < .001 && (m = 1), this.x = (p - u) / m, this.y = (l - d) / m, this.z = (c - a) / m, this.w = Math.acos((s + h + f - 1) / 2), this
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                    }
                    clamp(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                    }
                    clampScalar(t, e) {
                        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                    }
                    round() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                    }
                    roundToZero() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                    }
                    negate() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, e) {
                        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                    }
                    lerpVectors(t, e, n) {
                        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                    }
                    fromArray(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                    }
                    toArray() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                    }
                    fromBufferAttribute(t, e, n) {
                        return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                    }
                    random() {
                        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                    }
                }
                ni.prototype.isVector4 = !0;
                class ii extends Bn {
                    constructor(t, e, n) {
                        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new ni(0, 0, t, e), this.scissorTest = !1, this.viewport = new ni(0, 0, t, e), n = n || {}, this.texture = new ti(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = 1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : xt, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
                    }
                    setTexture(t) {
                        t.image = {
                            width: this.width,
                            height: this.height,
                            depth: this.depth
                        }, this.texture = t
                    }
                    setSize(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                        this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.image = {...this.texture.image
                        }, this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                ii.prototype.isWebGLRenderTarget = !0;
                class ri extends ii {
                    constructor(t, e, n) {
                        super(t, e);
                        const i = this.texture;
                        this.texture = [];
                        for (let r = 0; r < n; r++) this.texture[r] = i.clone()
                    }
                    setSize(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                        if (this.width !== t || this.height !== e || this.depth !== n) {
                            this.width = t, this.height = e, this.depth = n;
                            for (let i = 0, r = this.texture.length; i < r; i++) this.texture[i].image.width = t, this.texture[i].image.height = e, this.texture[i].image.depth = n;
                            this.dispose()
                        }
                        return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
                    }
                    copy(t) {
                        this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
                        for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone();
                        return this
                    }
                }
                ri.prototype.isWebGLMultipleRenderTargets = !0;
                class oi extends ii {
                    constructor(t, e, n) {
                        super(t, e, n), this.samples = 4
                    }
                    copy(t) {
                        return super.copy.call(this, t), this.samples = t.samples, this
                    }
                }
                oi.prototype.isWebGLMultisampleRenderTarget = !0;
                class si {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        this._x = t, this._y = e, this._z = n, this._w = i
                    }
                    static slerp(t, e, n, i) {
                        return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, i)
                    }
                    static slerpFlat(t, e, n, i, r, o, s) {
                        let a = n[i + 0],
                            l = n[i + 1],
                            c = n[i + 2],
                            h = n[i + 3];
                        const u = r[o + 0],
                            d = r[o + 1],
                            p = r[o + 2],
                            f = r[o + 3];
                        if (0 === s) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = c, void(t[e + 3] = h);
                        if (1 === s) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = f);
                        if (h !== f || a !== u || l !== d || c !== p) {
                            let t = 1 - s;
                            const e = a * u + l * d + c * p + h * f,
                                n = e >= 0 ? 1 : -1,
                                i = 1 - e * e;
                            if (i > Number.EPSILON) {
                                const r = Math.sqrt(i),
                                    o = Math.atan2(r, e * n);
                                t = Math.sin(t * o) / r, s = Math.sin(s * o) / r
                            }
                            const r = s * n;
                            if (a = a * t + u * r, l = l * t + d * r, c = c * t + p * r, h = h * t + f * r, t === 1 - s) {
                                const t = 1 / Math.sqrt(a * a + l * l + c * c + h * h);
                                a *= t, l *= t, c *= t, h *= t
                            }
                        }
                        t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h
                    }
                    static multiplyQuaternionsFlat(t, e, n, i, r, o) {
                        const s = n[i],
                            a = n[i + 1],
                            l = n[i + 2],
                            c = n[i + 3],
                            h = r[o],
                            u = r[o + 1],
                            d = r[o + 2],
                            p = r[o + 3];
                        return t[e] = s * p + c * h + a * d - l * u, t[e + 1] = a * p + c * u + l * h - s * d, t[e + 2] = l * p + c * d + s * u - a * h, t[e + 3] = c * p - s * h - a * u - l * d, t
                    }
                    get x() {
                        return this._x
                    }
                    set x(t) {
                        this._x = t, this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(t) {
                        this._y = t, this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(t) {
                        this._z = t, this._onChangeCallback()
                    }
                    get w() {
                        return this._w
                    }
                    set w(t) {
                        this._w = t, this._onChangeCallback()
                    }
                    set(t, e, n, i) {
                        return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
                    }
                    clone() {
                        return new this.constructor(this._x, this._y, this._z, this._w)
                    }
                    copy(t) {
                        return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                    }
                    setFromEuler(t, e) {
                        if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                        const n = t._x,
                            i = t._y,
                            r = t._z,
                            o = t._order,
                            s = Math.cos,
                            a = Math.sin,
                            l = s(n / 2),
                            c = s(i / 2),
                            h = s(r / 2),
                            u = a(n / 2),
                            d = a(i / 2),
                            p = a(r / 2);
                        switch (o) {
                            case "XYZ":
                                this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                                break;
                            case "YXZ":
                                this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                                break;
                            case "ZXY":
                                this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                                break;
                            case "ZYX":
                                this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                                break;
                            case "YZX":
                                this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                                break;
                            case "XZY":
                                this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                                break;
                            default:
                                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
                        }
                        return !1 !== e && this._onChangeCallback(), this
                    }
                    setFromAxisAngle(t, e) {
                        const n = e / 2,
                            i = Math.sin(n);
                        return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
                    }
                    setFromRotationMatrix(t) {
                        const e = t.elements,
                            n = e[0],
                            i = e[4],
                            r = e[8],
                            o = e[1],
                            s = e[5],
                            a = e[9],
                            l = e[2],
                            c = e[6],
                            h = e[10],
                            u = n + s + h;
                        if (u > 0) {
                            const t = .5 / Math.sqrt(u + 1);
                            this._w = .25 / t, this._x = (c - a) * t, this._y = (r - l) * t, this._z = (o - i) * t
                        } else if (n > s && n > h) {
                            const t = 2 * Math.sqrt(1 + n - s - h);
                            this._w = (c - a) / t, this._x = .25 * t, this._y = (i + o) / t, this._z = (r + l) / t
                        } else if (s > h) {
                            const t = 2 * Math.sqrt(1 + s - n - h);
                            this._w = (r - l) / t, this._x = (i + o) / t, this._y = .25 * t, this._z = (a + c) / t
                        } else {
                            const t = 2 * Math.sqrt(1 + h - n - s);
                            this._w = (o - i) / t, this._x = (r + l) / t, this._y = (a + c) / t, this._z = .25 * t
                        }
                        return this._onChangeCallback(), this
                    }
                    setFromUnitVectors(t, e) {
                        let n = t.dot(e) + 1;
                        return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
                    }
                    angleTo(t) {
                        return 2 * Math.acos(Math.abs(zn(this.dot(t), -1, 1)))
                    }
                    rotateTowards(t, e) {
                        const n = this.angleTo(t);
                        if (0 === n) return this;
                        const i = Math.min(1, e / n);
                        return this.slerp(t, i), this
                    }
                    identity() {
                        return this.set(0, 0, 0, 1)
                    }
                    invert() {
                        return this.conjugate()
                    }
                    conjugate() {
                        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                    }
                    dot(t) {
                        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                    }
                    lengthSq() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    }
                    length() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    }
                    normalize() {
                        let t = this.length();
                        return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                    }
                    multiply(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyQuaternions(t, this)
                    }
                    multiplyQuaternions(t, e) {
                        const n = t._x,
                            i = t._y,
                            r = t._z,
                            o = t._w,
                            s = e._x,
                            a = e._y,
                            l = e._z,
                            c = e._w;
                        return this._x = n * c + o * s + i * l - r * a, this._y = i * c + o * a + r * s - n * l, this._z = r * c + o * l + n * a - i * s, this._w = o * c - n * s - i * a - r * l, this._onChangeCallback(), this
                    }
                    slerp(t, e) {
                        if (0 === e) return this;
                        if (1 === e) return this.copy(t);
                        const n = this._x,
                            i = this._y,
                            r = this._z,
                            o = this._w;
                        let s = o * t._w + n * t._x + i * t._y + r * t._z;
                        if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
                        const a = 1 - s * s;
                        if (a <= Number.EPSILON) {
                            const t = 1 - e;
                            return this._w = t * o + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                        }
                        const l = Math.sqrt(a),
                            c = Math.atan2(l, s),
                            h = Math.sin((1 - e) * c) / l,
                            u = Math.sin(e * c) / l;
                        return this._w = o * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
                    }
                    slerpQuaternions(t, e, n) {
                        this.copy(t).slerp(e, n)
                    }
                    equals(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                    }
                    fromArray(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                    }
                    toArray() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                    }
                    fromBufferAttribute(t, e) {
                        return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                    }
                    _onChange(t) {
                        return this._onChangeCallback = t, this
                    }
                    _onChangeCallback() {}
                }
                si.prototype.isQuaternion = !0;
                class ai {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        this.x = t, this.y = e, this.z = n
                    }
                    set(t, e, n) {
                        return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
                    }
                    setScalar(t) {
                        return this.x = t, this.y = t, this.z = t, this
                    }
                    setX(t) {
                        return this.x = t, this
                    }
                    setY(t) {
                        return this.y = t, this
                    }
                    setZ(t) {
                        return this.z = t, this
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z)
                    }
                    copy(t) {
                        return this.x = t.x, this.y = t.y, this.z = t.z, this
                    }
                    add(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                    }
                    addScalar(t) {
                        return this.x += t, this.y += t, this.z += t, this
                    }
                    addVectors(t, e) {
                        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                    }
                    addScaledVector(t, e) {
                        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                    }
                    sub(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                    }
                    subScalar(t) {
                        return this.x -= t, this.y -= t, this.z -= t, this
                    }
                    subVectors(t, e) {
                        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                    }
                    multiply(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                    }
                    multiplyScalar(t) {
                        return this.x *= t, this.y *= t, this.z *= t, this
                    }
                    multiplyVectors(t, e) {
                        return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                    }
                    applyEuler(t) {
                        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(ci.setFromEuler(t))
                    }
                    applyAxisAngle(t, e) {
                        return this.applyQuaternion(ci.setFromAxisAngle(t, e))
                    }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements;
                        return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
                    }
                    applyNormalMatrix(t) {
                        return this.applyMatrix3(t).normalize()
                    }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements,
                            o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                        return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o, this
                    }
                    applyQuaternion(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.x,
                            o = t.y,
                            s = t.z,
                            a = t.w,
                            l = a * e + o * i - s * n,
                            c = a * n + s * e - r * i,
                            h = a * i + r * n - o * e,
                            u = -r * e - o * n - s * i;
                        return this.x = l * a + u * -r + c * -s - h * -o, this.y = c * a + u * -o + h * -r - l * -s, this.z = h * a + u * -s + l * -o - c * -r, this
                    }
                    project(t) {
                        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                    }
                    unproject(t) {
                        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                    }
                    transformDirection(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements;
                        return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
                    }
                    divide(t) {
                        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                    }
                    clamp(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                    }
                    clampScalar(t, e) {
                        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                    }
                    round() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                    }
                    roundToZero() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                    }
                    negate() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, e) {
                        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                    }
                    lerpVectors(t, e, n) {
                        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
                    }
                    cross(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                    }
                    crossVectors(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            o = e.x,
                            s = e.y,
                            a = e.z;
                        return this.x = i * a - r * s, this.y = r * o - n * a, this.z = n * s - i * o, this
                    }
                    projectOnVector(t) {
                        const e = t.lengthSq();
                        if (0 === e) return this.set(0, 0, 0);
                        const n = t.dot(this) / e;
                        return this.copy(t).multiplyScalar(n)
                    }
                    projectOnPlane(t) {
                        return li.copy(this).projectOnVector(t), this.sub(li)
                    }
                    reflect(t) {
                        return this.sub(li.copy(t).multiplyScalar(2 * this.dot(t)))
                    }
                    angleTo(t) {
                        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (0 === e) return Math.PI / 2;
                        const n = this.dot(t) / e;
                        return Math.acos(zn(n, -1, 1))
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y,
                            i = this.z - t.z;
                        return e * e + n * n + i * i
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                    }
                    setFromSpherical(t) {
                        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                    }
                    setFromSphericalCoords(t, e, n) {
                        const i = Math.sin(e) * t;
                        return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
                    }
                    setFromCylindrical(t) {
                        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                    }
                    setFromCylindricalCoords(t, e, n) {
                        return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
                    }
                    setFromMatrixPosition(t) {
                        const e = t.elements;
                        return this.x = e[12], this.y = e[13], this.z = e[14], this
                    }
                    setFromMatrixScale(t) {
                        const e = this.setFromMatrixColumn(t, 0).length(),
                            n = this.setFromMatrixColumn(t, 1).length(),
                            i = this.setFromMatrixColumn(t, 2).length();
                        return this.x = e, this.y = n, this.z = i, this
                    }
                    setFromMatrixColumn(t, e) {
                        return this.fromArray(t.elements, 4 * e)
                    }
                    setFromMatrix3Column(t, e) {
                        return this.fromArray(t.elements, 3 * e)
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z
                    }
                    fromArray(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                    }
                    toArray() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                    }
                    fromBufferAttribute(t, e, n) {
                        return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                    }
                    random() {
                        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                    }
                }
                ai.prototype.isVector3 = !0;
                const li = new ai,
                    ci = new si;
                class hi {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ai(1 / 0, 1 / 0, 1 / 0),
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ai(-1 / 0, -1 / 0, -1 / 0);
                        this.min = t, this.max = e
                    }
                    set(t, e) {
                        return this.min.copy(t), this.max.copy(e), this
                    }
                    setFromArray(t) {
                        let e = 1 / 0,
                            n = 1 / 0,
                            i = 1 / 0,
                            r = -1 / 0,
                            o = -1 / 0,
                            s = -1 / 0;
                        for (let a = 0, l = t.length; a < l; a += 3) {
                            const l = t[a],
                                c = t[a + 1],
                                h = t[a + 2];
                            l < e && (e = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > o && (o = c), h > s && (s = h)
                        }
                        return this.min.set(e, n, i), this.max.set(r, o, s), this
                    }
                    setFromBufferAttribute(t) {
                        let e = 1 / 0,
                            n = 1 / 0,
                            i = 1 / 0,
                            r = -1 / 0,
                            o = -1 / 0,
                            s = -1 / 0;
                        for (let a = 0, l = t.count; a < l; a++) {
                            const l = t.getX(a),
                                c = t.getY(a),
                                h = t.getZ(a);
                            l < e && (e = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > o && (o = c), h > s && (s = h)
                        }
                        return this.min.set(e, n, i), this.max.set(r, o, s), this
                    }
                    setFromPoints(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                        return this
                    }
                    setFromCenterAndSize(t, e) {
                        const n = di.copy(e).multiplyScalar(.5);
                        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                    }
                    setFromObject(t) {
                        return this.makeEmpty(), this.expandByObject(t)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                    }
                    getCenter(t) {
                        return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new ai), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(t) {
                        return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new ai), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                    }
                    expandByPoint(t) {
                        return this.min.min(t), this.max.max(t), this
                    }
                    expandByVector(t) {
                        return this.min.sub(t), this.max.add(t), this
                    }
                    expandByScalar(t) {
                        return this.min.addScalar(-t), this.max.addScalar(t), this
                    }
                    expandByObject(t) {
                        t.updateWorldMatrix(!1, !1);
                        const e = t.geometry;
                        void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), pi.copy(e.boundingBox), pi.applyMatrix4(t.matrixWorld), this.union(pi));
                        const n = t.children;
                        for (let i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
                        return this
                    }
                    containsPoint(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                    }
                    containsBox(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                    }
                    getParameter(t, e) {
                        return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new ai), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                    }
                    intersectsBox(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                    }
                    intersectsSphere(t) {
                        return this.clampPoint(t.center, di), di.distanceToSquared(t.center) <= t.radius * t.radius
                    }
                    intersectsPlane(t) {
                        let e, n;
                        return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                    }
                    intersectsTriangle(t) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(bi), wi.subVectors(this.max, bi), fi.subVectors(t.a, bi), mi.subVectors(t.b, bi), gi.subVectors(t.c, bi), vi.subVectors(mi, fi), yi.subVectors(gi, mi), xi.subVectors(fi, gi);
                        let e = [0, -vi.z, vi.y, 0, -yi.z, yi.y, 0, -xi.z, xi.y, vi.z, 0, -vi.x, yi.z, 0, -yi.x, xi.z, 0, -xi.x, -vi.y, vi.x, 0, -yi.y, yi.x, 0, -xi.y, xi.x, 0];
                        return !!Mi(e, fi, mi, gi, wi) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Mi(e, fi, mi, gi, wi) && (_i.crossVectors(vi, yi), e = [_i.x, _i.y, _i.z], Mi(e, fi, mi, gi, wi)))
                    }
                    clampPoint(t, e) {
                        return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new ai), e.copy(t).clamp(this.min, this.max)
                    }
                    distanceToPoint(t) {
                        return di.copy(t).clamp(this.min, this.max).sub(t).length()
                    }
                    getBoundingSphere(t) {
                        return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(di).length(), t
                    }
                    intersect(t) {
                        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                    }
                    union(t) {
                        return this.min.min(t.min), this.max.max(t.max), this
                    }
                    applyMatrix4(t) {
                        return this.isEmpty() || (ui[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), ui[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), ui[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), ui[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), ui[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), ui[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), ui[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), ui[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(ui)), this
                    }
                    translate(t) {
                        return this.min.add(t), this.max.add(t), this
                    }
                    equals(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }
                hi.prototype.isBox3 = !0;
                const ui = [new ai, new ai, new ai, new ai, new ai, new ai, new ai, new ai],
                    di = new ai,
                    pi = new hi,
                    fi = new ai,
                    mi = new ai,
                    gi = new ai,
                    vi = new ai,
                    yi = new ai,
                    xi = new ai,
                    bi = new ai,
                    wi = new ai,
                    _i = new ai,
                    Si = new ai;

                function Mi(t, e, n, i, r) {
                    for (let o = 0, s = t.length - 3; o <= s; o += 3) {
                        Si.fromArray(t, o);
                        const s = r.x * Math.abs(Si.x) + r.y * Math.abs(Si.y) + r.z * Math.abs(Si.z),
                            a = e.dot(Si),
                            l = n.dot(Si),
                            c = i.dot(Si);
                        if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > s) return !1
                    }
                    return !0
                }
                const Ai = new hi,
                    Ti = new ai,
                    Ei = new ai,
                    Ci = new ai;
                class Pi {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ai,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
                        this.center = t, this.radius = e
                    }
                    set(t, e) {
                        return this.center.copy(t), this.radius = e, this
                    }
                    setFromPoints(t, e) {
                        const n = this.center;
                        void 0 !== e ? n.copy(e) : Ai.setFromPoints(t).getCenter(n);
                        let i = 0;
                        for (let r = 0, o = t.length; r < o; r++) i = Math.max(i, n.distanceToSquared(t[r]));
                        return this.radius = Math.sqrt(i), this
                    }
                    copy(t) {
                        return this.center.copy(t.center), this.radius = t.radius, this
                    }
                    isEmpty() {
                        return this.radius < 0
                    }
                    makeEmpty() {
                        return this.center.set(0, 0, 0), this.radius = -1, this
                    }
                    containsPoint(t) {
                        return t.distanceToSquared(this.center) <= this.radius * this.radius
                    }
                    distanceToPoint(t) {
                        return t.distanceTo(this.center) - this.radius
                    }
                    intersectsSphere(t) {
                        const e = this.radius + t.radius;
                        return t.center.distanceToSquared(this.center) <= e * e
                    }
                    intersectsBox(t) {
                        return t.intersectsSphere(this)
                    }
                    intersectsPlane(t) {
                        return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                    }
                    clampPoint(t, e) {
                        const n = this.center.distanceToSquared(t);
                        return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new ai), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                    }
                    getBoundingBox(t) {
                        return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new hi), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
                    }
                    applyMatrix4(t) {
                        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                    }
                    translate(t) {
                        return this.center.add(t), this
                    }
                    expandByPoint(t) {
                        Ci.subVectors(t, this.center);
                        const e = Ci.lengthSq();
                        if (e > this.radius * this.radius) {
                            const t = Math.sqrt(e),
                                n = .5 * (t - this.radius);
                            this.center.add(Ci.multiplyScalar(n / t)), this.radius += n
                        }
                        return this
                    }
                    union(t) {
                        return Ei.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(Ti.copy(t.center).add(Ei)), this.expandByPoint(Ti.copy(t.center).sub(Ei)), this
                    }
                    equals(t) {
                        return t.center.equals(this.center) && t.radius === this.radius
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                const Li = new ai,
                    Ri = new ai,
                    Ii = new ai,
                    Fi = new ai,
                    Oi = new ai,
                    Ni = new ai,
                    Bi = new ai;
                class Di {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ai,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ai(0, 0, -1);
                        this.origin = t, this.direction = e
                    }
                    set(t, e) {
                        return this.origin.copy(t), this.direction.copy(e), this
                    }
                    copy(t) {
                        return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                    }
                    at(t, e) {
                        return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new ai), e.copy(this.direction).multiplyScalar(t).add(this.origin)
                    }
                    lookAt(t) {
                        return this.direction.copy(t).sub(this.origin).normalize(), this
                    }
                    recast(t) {
                        return this.origin.copy(this.at(t, Li)), this
                    }
                    closestPointToPoint(t, e) {
                        void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new ai), e.subVectors(t, this.origin);
                        const n = e.dot(this.direction);
                        return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                    }
                    distanceToPoint(t) {
                        return Math.sqrt(this.distanceSqToPoint(t))
                    }
                    distanceSqToPoint(t) {
                        const e = Li.subVectors(t, this.origin).dot(this.direction);
                        return e < 0 ? this.origin.distanceToSquared(t) : (Li.copy(this.direction).multiplyScalar(e).add(this.origin), Li.distanceToSquared(t))
                    }
                    distanceSqToSegment(t, e, n, i) {
                        Ri.copy(t).add(e).multiplyScalar(.5), Ii.copy(e).sub(t).normalize(), Fi.copy(this.origin).sub(Ri);
                        const r = .5 * t.distanceTo(e),
                            o = -this.direction.dot(Ii),
                            s = Fi.dot(this.direction),
                            a = -Fi.dot(Ii),
                            l = Fi.lengthSq(),
                            c = Math.abs(1 - o * o);
                        let h, u, d, p;
                        if (c > 0)
                            if (h = o * a - s, u = o * s - a, p = r * c, h >= 0)
                                if (u >= -p)
                                    if (u <= p) {
                                        const t = 1 / c;
                                        h *= t, u *= t, d = h * (h + o * u + 2 * s) + u * (o * h + u + 2 * a) + l
                                    } else u = r, h = Math.max(0, -(o * u + s)), d = -h * h + u * (u + 2 * a) + l;
                        else u = -r, h = Math.max(0, -(o * u + s)), d = -h * h + u * (u + 2 * a) + l;
                        else u <= -p ? (h = Math.max(0, -(-o * r + s)), u = h > 0 ? -r : Math.min(Math.max(-r, -a), r), d = -h * h + u * (u + 2 * a) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -a), r), d = u * (u + 2 * a) + l) : (h = Math.max(0, -(o * r + s)), u = h > 0 ? r : Math.min(Math.max(-r, -a), r), d = -h * h + u * (u + 2 * a) + l);
                        else u = o > 0 ? -r : r, h = Math.max(0, -(o * u + s)), d = -h * h + u * (u + 2 * a) + l;
                        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(Ii).multiplyScalar(u).add(Ri), d
                    }
                    intersectSphere(t, e) {
                        Li.subVectors(t.center, this.origin);
                        const n = Li.dot(this.direction),
                            i = Li.dot(Li) - n * n,
                            r = t.radius * t.radius;
                        if (i > r) return null;
                        const o = Math.sqrt(r - i),
                            s = n - o,
                            a = n + o;
                        return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e)
                    }
                    intersectsSphere(t) {
                        return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                    }
                    distanceToPlane(t) {
                        const e = t.normal.dot(this.direction);
                        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                        const n = -(this.origin.dot(t.normal) + t.constant) / e;
                        return n >= 0 ? n : null
                    }
                    intersectPlane(t, e) {
                        const n = this.distanceToPlane(t);
                        return null === n ? null : this.at(n, e)
                    }
                    intersectsPlane(t) {
                        const e = t.distanceToPoint(this.origin);
                        return 0 === e || t.normal.dot(this.direction) * e < 0
                    }
                    intersectBox(t, e) {
                        let n, i, r, o, s, a;
                        const l = 1 / this.direction.x,
                            c = 1 / this.direction.y,
                            h = 1 / this.direction.z,
                            u = this.origin;
                        return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, o = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, o = (t.min.y - u.y) * c), n > o || r > i ? null : ((r > n || n != n) && (n = r), (o < i || i != i) && (i = o), h >= 0 ? (s = (t.min.z - u.z) * h, a = (t.max.z - u.z) * h) : (s = (t.max.z - u.z) * h, a = (t.min.z - u.z) * h), n > a || s > i ? null : ((s > n || n != n) && (n = s), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                    }
                    intersectsBox(t) {
                        return null !== this.intersectBox(t, Li)
                    }
                    intersectTriangle(t, e, n, i, r) {
                        Oi.subVectors(e, t), Ni.subVectors(n, t), Bi.crossVectors(Oi, Ni);
                        let o, s = this.direction.dot(Bi);
                        if (s > 0) {
                            if (i) return null;
                            o = 1
                        } else {
                            if (!(s < 0)) return null;
                            o = -1, s = -s
                        }
                        Fi.subVectors(this.origin, t);
                        const a = o * this.direction.dot(Ni.crossVectors(Fi, Ni));
                        if (a < 0) return null;
                        const l = o * this.direction.dot(Oi.cross(Fi));
                        if (l < 0) return null;
                        if (a + l > s) return null;
                        const c = -o * Fi.dot(Bi);
                        return c < 0 ? null : this.at(c / s, r)
                    }
                    applyMatrix4(t) {
                        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                    }
                    equals(t) {
                        return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                class Vi {
                    constructor() {
                        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                    }
                    set(t, e, n, i, r, o, s, a, l, c, h, u, d, p, f, m) {
                        const g = this.elements;
                        return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = o, g[9] = s, g[13] = a, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    }
                    clone() {
                        return (new Vi).fromArray(this.elements)
                    }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                    }
                    copyPosition(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                    }
                    setFromMatrix3(t) {
                        const e = t.elements;
                        return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
                    }
                    extractBasis(t, e, n) {
                        return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                    }
                    makeBasis(t, e, n) {
                        return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                    }
                    extractRotation(t) {
                        const e = this.elements,
                            n = t.elements,
                            i = 1 / ji.setFromMatrixColumn(t, 0).length(),
                            r = 1 / ji.setFromMatrixColumn(t, 1).length(),
                            o = 1 / ji.setFromMatrixColumn(t, 2).length();
                        return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                    }
                    makeRotationFromEuler(t) {
                        t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                        const e = this.elements,
                            n = t.x,
                            i = t.y,
                            r = t.z,
                            o = Math.cos(n),
                            s = Math.sin(n),
                            a = Math.cos(i),
                            l = Math.sin(i),
                            c = Math.cos(r),
                            h = Math.sin(r);
                        if ("XYZ" === t.order) {
                            const t = o * c,
                                n = o * h,
                                i = s * c,
                                r = s * h;
                            e[0] = a * c, e[4] = -a * h, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -s * a, e[2] = r - t * l, e[6] = i + n * l, e[10] = o * a
                        } else if ("YXZ" === t.order) {
                            const t = a * c,
                                n = a * h,
                                i = l * c,
                                r = l * h;
                            e[0] = t + r * s, e[4] = i * s - n, e[8] = o * l, e[1] = o * h, e[5] = o * c, e[9] = -s, e[2] = n * s - i, e[6] = r + t * s, e[10] = o * a
                        } else if ("ZXY" === t.order) {
                            const t = a * c,
                                n = a * h,
                                i = l * c,
                                r = l * h;
                            e[0] = t - r * s, e[4] = -o * h, e[8] = i + n * s, e[1] = n + i * s, e[5] = o * c, e[9] = r - t * s, e[2] = -o * l, e[6] = s, e[10] = o * a
                        } else if ("ZYX" === t.order) {
                            const t = o * c,
                                n = o * h,
                                i = s * c,
                                r = s * h;
                            e[0] = a * c, e[4] = i * l - n, e[8] = t * l + r, e[1] = a * h, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = s * a, e[10] = o * a
                        } else if ("YZX" === t.order) {
                            const t = o * a,
                                n = o * l,
                                i = s * a,
                                r = s * l;
                            e[0] = a * c, e[4] = r - t * h, e[8] = i * h + n, e[1] = h, e[5] = o * c, e[9] = -s * c, e[2] = -l * c, e[6] = n * h + i, e[10] = t - r * h
                        } else if ("XZY" === t.order) {
                            const t = o * a,
                                n = o * l,
                                i = s * a,
                                r = s * l;
                            e[0] = a * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = o * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = s * c, e[10] = r * h + t
                        }
                        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                    }
                    makeRotationFromQuaternion(t) {
                        return this.compose(Ui, t, zi)
                    }
                    lookAt(t, e, n) {
                        const i = this.elements;
                        return Wi.subVectors(t, e), 0 === Wi.lengthSq() && (Wi.z = 1), Wi.normalize(), Gi.crossVectors(n, Wi), 0 === Gi.lengthSq() && (1 === Math.abs(n.z) ? Wi.x += 1e-4 : Wi.z += 1e-4, Wi.normalize(), Gi.crossVectors(n, Wi)), Gi.normalize(), Hi.crossVectors(Wi, Gi), i[0] = Gi.x, i[4] = Hi.x, i[8] = Wi.x, i[1] = Gi.y, i[5] = Hi.y, i[9] = Wi.y, i[2] = Gi.z, i[6] = Hi.z, i[10] = Wi.z, this
                    }
                    multiply(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this)
                    }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            i = e.elements,
                            r = this.elements,
                            o = n[0],
                            s = n[4],
                            a = n[8],
                            l = n[12],
                            c = n[1],
                            h = n[5],
                            u = n[9],
                            d = n[13],
                            p = n[2],
                            f = n[6],
                            m = n[10],
                            g = n[14],
                            v = n[3],
                            y = n[7],
                            x = n[11],
                            b = n[15],
                            w = i[0],
                            _ = i[4],
                            S = i[8],
                            M = i[12],
                            A = i[1],
                            T = i[5],
                            E = i[9],
                            C = i[13],
                            P = i[2],
                            L = i[6],
                            R = i[10],
                            I = i[14],
                            F = i[3],
                            O = i[7],
                            N = i[11],
                            B = i[15];
                        return r[0] = o * w + s * A + a * P + l * F, r[4] = o * _ + s * T + a * L + l * O, r[8] = o * S + s * E + a * R + l * N, r[12] = o * M + s * C + a * I + l * B, r[1] = c * w + h * A + u * P + d * F, r[5] = c * _ + h * T + u * L + d * O, r[9] = c * S + h * E + u * R + d * N, r[13] = c * M + h * C + u * I + d * B, r[2] = p * w + f * A + m * P + g * F, r[6] = p * _ + f * T + m * L + g * O, r[10] = p * S + f * E + m * R + g * N, r[14] = p * M + f * C + m * I + g * B, r[3] = v * w + y * A + x * P + b * F, r[7] = v * _ + y * T + x * L + b * O, r[11] = v * S + y * E + x * R + b * N, r[15] = v * M + y * C + x * I + b * B, this
                    }
                    multiplyScalar(t) {
                        const e = this.elements;
                        return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                    }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[4],
                            i = t[8],
                            r = t[12],
                            o = t[1],
                            s = t[5],
                            a = t[9],
                            l = t[13],
                            c = t[2],
                            h = t[6],
                            u = t[10],
                            d = t[14];
                        return t[3] * (+r * a * h - i * l * h - r * s * u + n * l * u + i * s * d - n * a * d) + t[7] * (+e * a * d - e * l * u + r * o * u - i * o * d + i * l * c - r * a * c) + t[11] * (+e * l * h - e * s * d - r * o * h + n * o * d + r * s * c - n * l * c) + t[15] * (-i * s * c - e * a * h + e * s * u + i * o * h - n * o * u + n * a * c)
                    }
                    transpose() {
                        const t = this.elements;
                        let e;
                        return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                    }
                    setPosition(t, e, n) {
                        const i = this.elements;
                        return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            o = t[4],
                            s = t[5],
                            a = t[6],
                            l = t[7],
                            c = t[8],
                            h = t[9],
                            u = t[10],
                            d = t[11],
                            p = t[12],
                            f = t[13],
                            m = t[14],
                            g = t[15],
                            v = h * m * l - f * u * l + f * a * d - s * m * d - h * a * g + s * u * g,
                            y = p * u * l - c * m * l - p * a * d + o * m * d + c * a * g - o * u * g,
                            x = c * f * l - p * h * l + p * s * d - o * f * d - c * s * g + o * h * g,
                            b = p * h * a - c * f * a - p * s * u + o * f * u + c * s * m - o * h * m,
                            w = e * v + n * y + i * x + r * b;
                        if (0 === w) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const _ = 1 / w;
                        return t[0] = v * _, t[1] = (f * u * r - h * m * r - f * i * d + n * m * d + h * i * g - n * u * g) * _, t[2] = (s * m * r - f * a * r + f * i * l - n * m * l - s * i * g + n * a * g) * _, t[3] = (h * a * r - s * u * r - h * i * l + n * u * l + s * i * d - n * a * d) * _, t[4] = y * _, t[5] = (c * m * r - p * u * r + p * i * d - e * m * d - c * i * g + e * u * g) * _, t[6] = (p * a * r - o * m * r - p * i * l + e * m * l + o * i * g - e * a * g) * _, t[7] = (o * u * r - c * a * r + c * i * l - e * u * l - o * i * d + e * a * d) * _, t[8] = x * _, t[9] = (p * h * r - c * f * r - p * n * d + e * f * d + c * n * g - e * h * g) * _, t[10] = (o * f * r - p * s * r + p * n * l - e * f * l - o * n * g + e * s * g) * _, t[11] = (c * s * r - o * h * r - c * n * l + e * h * l + o * n * d - e * s * d) * _, t[12] = b * _, t[13] = (c * f * i - p * h * i + p * n * u - e * f * u - c * n * m + e * h * m) * _, t[14] = (p * s * i - o * f * i - p * n * a + e * f * a + o * n * m - e * s * m) * _, t[15] = (o * h * i - c * s * i + c * n * a - e * h * a - o * n * u + e * s * u) * _, this
                    }
                    scale(t) {
                        const e = this.elements,
                            n = t.x,
                            i = t.y,
                            r = t.z;
                        return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
                    }
                    getMaxScaleOnAxis() {
                        const t = this.elements,
                            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                        return Math.sqrt(Math.max(e, n, i))
                    }
                    makeTranslation(t, e, n) {
                        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
                    }
                    makeRotationX(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                    }
                    makeRotationY(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                    }
                    makeRotationZ(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    }
                    makeRotationAxis(t, e) {
                        const n = Math.cos(e),
                            i = Math.sin(e),
                            r = 1 - n,
                            o = t.x,
                            s = t.y,
                            a = t.z,
                            l = r * o,
                            c = r * s;
                        return this.set(l * o + n, l * s - i * a, l * a + i * s, 0, l * s + i * a, c * s + n, c * a - i * o, 0, l * a - i * s, c * a + i * o, r * a * a + n, 0, 0, 0, 0, 1), this
                    }
                    makeScale(t, e, n) {
                        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                    }
                    makeShear(t, e, n, i, r, o) {
                        return this.set(1, n, r, 0, t, 1, o, 0, e, i, 1, 0, 0, 0, 0, 1), this
                    }
                    compose(t, e, n) {
                        const i = this.elements,
                            r = e._x,
                            o = e._y,
                            s = e._z,
                            a = e._w,
                            l = r + r,
                            c = o + o,
                            h = s + s,
                            u = r * l,
                            d = r * c,
                            p = r * h,
                            f = o * c,
                            m = o * h,
                            g = s * h,
                            v = a * l,
                            y = a * c,
                            x = a * h,
                            b = n.x,
                            w = n.y,
                            _ = n.z;
                        return i[0] = (1 - (f + g)) * b, i[1] = (d + x) * b, i[2] = (p - y) * b, i[3] = 0, i[4] = (d - x) * w, i[5] = (1 - (u + g)) * w, i[6] = (m + v) * w, i[7] = 0, i[8] = (p + y) * _, i[9] = (m - v) * _, i[10] = (1 - (u + f)) * _, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                    }
                    decompose(t, e, n) {
                        const i = this.elements;
                        let r = ji.set(i[0], i[1], i[2]).length();
                        const o = ji.set(i[4], i[5], i[6]).length(),
                            s = ji.set(i[8], i[9], i[10]).length();
                        this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], ki.copy(this);
                        const a = 1 / r,
                            l = 1 / o,
                            c = 1 / s;
                        return ki.elements[0] *= a, ki.elements[1] *= a, ki.elements[2] *= a, ki.elements[4] *= l, ki.elements[5] *= l, ki.elements[6] *= l, ki.elements[8] *= c, ki.elements[9] *= c, ki.elements[10] *= c, e.setFromRotationMatrix(ki), n.x = r, n.y = o, n.z = s, this
                    }
                    makePerspective(t, e, n, i, r, o) {
                        void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                        const s = this.elements,
                            a = 2 * r / (e - t),
                            l = 2 * r / (n - i),
                            c = (e + t) / (e - t),
                            h = (n + i) / (n - i),
                            u = -(o + r) / (o - r),
                            d = -2 * o * r / (o - r);
                        return s[0] = a, s[4] = 0, s[8] = c, s[12] = 0, s[1] = 0, s[5] = l, s[9] = h, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = u, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
                    }
                    makeOrthographic(t, e, n, i, r, o) {
                        const s = this.elements,
                            a = 1 / (e - t),
                            l = 1 / (n - i),
                            c = 1 / (o - r),
                            h = (e + t) * a,
                            u = (n + i) * l,
                            d = (o + r) * c;
                        return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -h, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -u, s[2] = 0, s[6] = 0, s[10] = -2 * c, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let i = 0; i < 16; i++)
                            if (e[i] !== n[i]) return !1;
                        return !0
                    }
                    fromArray(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                        return this
                    }
                    toArray() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = this.elements;
                        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                    }
                }
                Vi.prototype.isMatrix4 = !0;
                const ji = new ai,
                    ki = new Vi,
                    Ui = new ai(0, 0, 0),
                    zi = new ai(1, 1, 1),
                    Gi = new ai,
                    Hi = new ai,
                    Wi = new ai,
                    Yi = new Vi,
                    Xi = new si;
                class qi {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : qi.DefaultOrder;
                        this._x = t, this._y = e, this._z = n, this._order = i
                    }
                    get x() {
                        return this._x
                    }
                    set x(t) {
                        this._x = t, this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(t) {
                        this._y = t, this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(t) {
                        this._z = t, this._onChangeCallback()
                    }
                    get order() {
                        return this._order
                    }
                    set order(t) {
                        this._order = t, this._onChangeCallback()
                    }
                    set(t, e, n, i) {
                        return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this
                    }
                    clone() {
                        return new this.constructor(this._x, this._y, this._z, this._order)
                    }
                    copy(t) {
                        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                    }
                    setFromRotationMatrix(t, e, n) {
                        const i = t.elements,
                            r = i[0],
                            o = i[4],
                            s = i[8],
                            a = i[1],
                            l = i[5],
                            c = i[9],
                            h = i[2],
                            u = i[6],
                            d = i[10];
                        switch (e = e || this._order) {
                            case "XYZ":
                                this._y = Math.asin(zn(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                                break;
                            case "YXZ":
                                this._x = Math.asin(-zn(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                                break;
                            case "ZXY":
                                this._x = Math.asin(zn(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, r));
                                break;
                            case "ZYX":
                                this._y = Math.asin(-zn(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-o, l));
                                break;
                            case "YZX":
                                this._z = Math.asin(zn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(s, d));
                                break;
                            case "XZY":
                                this._z = Math.asin(-zn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                                break;
                            default:
                                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                        }
                        return this._order = e, !1 !== n && this._onChangeCallback(), this
                    }
                    setFromQuaternion(t, e, n) {
                        return Yi.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Yi, e, n)
                    }
                    setFromVector3(t, e) {
                        return this.set(t.x, t.y, t.z, e || this._order)
                    }
                    reorder(t) {
                        return Xi.setFromEuler(this), this.setFromQuaternion(Xi, t)
                    }
                    equals(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                    }
                    fromArray(t) {
                        return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                    }
                    toArray() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                    }
                    toVector3(t) {
                        return t ? t.set(this._x, this._y, this._z) : new ai(this._x, this._y, this._z)
                    }
                    _onChange(t) {
                        return this._onChangeCallback = t, this
                    }
                    _onChangeCallback() {}
                }
                qi.prototype.isEuler = !0, qi.DefaultOrder = "XYZ", qi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
                class Qi {
                    constructor() {
                        this.mask = 1
                    }
                    set(t) {
                        this.mask = 1 << t
                    }
                    enable(t) {
                        this.mask |= 1 << t
                    }
                    enableAll() {
                        this.mask = -1
                    }
                    toggle(t) {
                        this.mask ^= 1 << t
                    }
                    disable(t) {
                        this.mask &= ~(1 << t)
                    }
                    disableAll() {
                        this.mask = 0
                    }
                    test(t) {
                        return 0 != (this.mask & t.mask)
                    }
                }
                let Zi = 0;
                const Ji = new ai,
                    Ki = new si,
                    $i = new Vi,
                    tr = new ai,
                    er = new ai,
                    nr = new ai,
                    ir = new si,
                    rr = new ai(1, 0, 0),
                    or = new ai(0, 1, 0),
                    sr = new ai(0, 0, 1),
                    ar = {
                        type: "added"
                    },
                    lr = {
                        type: "removed"
                    };
                class cr extends Bn {
                    constructor() {
                        super(), Object.defineProperty(this, "id", {
                            value: Zi++
                        }), this.uuid = Un(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = cr.DefaultUp.clone();
                        const t = new ai,
                            e = new qi,
                            n = new si,
                            i = new ai(1, 1, 1);
                        e._onChange((function() {
                            n.setFromEuler(e, !1)
                        })), n._onChange((function() {
                            e.setFromQuaternion(n, void 0, !1)
                        })), Object.defineProperties(this, {
                            position: {
                                configurable: !0,
                                enumerable: !0,
                                value: t
                            },
                            rotation: {
                                configurable: !0,
                                enumerable: !0,
                                value: e
                            },
                            quaternion: {
                                configurable: !0,
                                enumerable: !0,
                                value: n
                            },
                            scale: {
                                configurable: !0,
                                enumerable: !0,
                                value: i
                            },
                            modelViewMatrix: {
                                value: new Vi
                            },
                            normalMatrix: {
                                value: new Zn
                            }
                        }), this.matrix = new Vi, this.matrixWorld = new Vi, this.matrixAutoUpdate = cr.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Qi, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                    }
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(t) {
                        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                    }
                    applyQuaternion(t) {
                        return this.quaternion.premultiply(t), this
                    }
                    setRotationFromAxisAngle(t, e) {
                        this.quaternion.setFromAxisAngle(t, e)
                    }
                    setRotationFromEuler(t) {
                        this.quaternion.setFromEuler(t, !0)
                    }
                    setRotationFromMatrix(t) {
                        this.quaternion.setFromRotationMatrix(t)
                    }
                    setRotationFromQuaternion(t) {
                        this.quaternion.copy(t)
                    }
                    rotateOnAxis(t, e) {
                        return Ki.setFromAxisAngle(t, e), this.quaternion.multiply(Ki), this
                    }
                    rotateOnWorldAxis(t, e) {
                        return Ki.setFromAxisAngle(t, e), this.quaternion.premultiply(Ki), this
                    }
                    rotateX(t) {
                        return this.rotateOnAxis(rr, t)
                    }
                    rotateY(t) {
                        return this.rotateOnAxis(or, t)
                    }
                    rotateZ(t) {
                        return this.rotateOnAxis(sr, t)
                    }
                    translateOnAxis(t, e) {
                        return Ji.copy(t).applyQuaternion(this.quaternion), this.position.add(Ji.multiplyScalar(e)), this
                    }
                    translateX(t) {
                        return this.translateOnAxis(rr, t)
                    }
                    translateY(t) {
                        return this.translateOnAxis(or, t)
                    }
                    translateZ(t) {
                        return this.translateOnAxis(sr, t)
                    }
                    localToWorld(t) {
                        return t.applyMatrix4(this.matrixWorld)
                    }
                    worldToLocal(t) {
                        return t.applyMatrix4($i.copy(this.matrixWorld).invert())
                    }
                    lookAt(t, e, n) {
                        t.isVector3 ? tr.copy(t) : tr.set(t, e, n);
                        const i = this.parent;
                        this.updateWorldMatrix(!0, !1), er.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? $i.lookAt(er, tr, this.up) : $i.lookAt(tr, er, this.up), this.quaternion.setFromRotationMatrix($i), i && ($i.extractRotation(i.matrixWorld), Ki.setFromRotationMatrix($i), this.quaternion.premultiply(Ki.invert()))
                    }
                    add(t) {
                        if (arguments.length > 1) {
                            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                            return this
                        }
                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(ar)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                    }
                    remove(t) {
                        if (arguments.length > 1) {
                            for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                            return this
                        }
                        const e = this.children.indexOf(t);
                        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(lr)), this
                    }
                    removeFromParent() {
                        const t = this.parent;
                        return null !== t && t.remove(this), this
                    }
                    clear() {
                        for (let t = 0; t < this.children.length; t++) {
                            const e = this.children[t];
                            e.parent = null, e.dispatchEvent(lr)
                        }
                        return this.children.length = 0, this
                    }
                    attach(t) {
                        return this.updateWorldMatrix(!0, !1), $i.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), $i.multiply(t.parent.matrixWorld)), t.applyMatrix4($i), this.add(t), t.updateWorldMatrix(!1, !0), this
                    }
                    getObjectById(t) {
                        return this.getObjectByProperty("id", t)
                    }
                    getObjectByName(t) {
                        return this.getObjectByProperty("name", t)
                    }
                    getObjectByProperty(t, e) {
                        if (this[t] === e) return this;
                        for (let n = 0, i = this.children.length; n < i; n++) {
                            const i = this.children[n].getObjectByProperty(t, e);
                            if (void 0 !== i) return i
                        }
                    }
                    getWorldPosition(t) {
                        return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new ai), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                    }
                    getWorldQuaternion(t) {
                        return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new si), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(er, t, nr), t
                    }
                    getWorldScale(t) {
                        return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new ai), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(er, ir, t), t
                    }
                    getWorldDirection(t) {
                        void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new ai), this.updateWorldMatrix(!0, !1);
                        const e = this.matrixWorld.elements;
                        return t.set(e[8], e[9], e[10]).normalize()
                    }
                    raycast() {}
                    traverse(t) {
                        t(this);
                        const e = this.children;
                        for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
                    }
                    traverseVisible(t) {
                        if (!1 === this.visible) return;
                        t(this);
                        const e = this.children;
                        for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
                    }
                    traverseAncestors(t) {
                        const e = this.parent;
                        null !== e && (t(e), e.traverseAncestors(t))
                    }
                    updateMatrix() {
                        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                    }
                    updateMatrixWorld(t) {
                        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                        const e = this.children;
                        for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
                    }
                    updateWorldMatrix(t, e) {
                        const n = this.parent;
                        if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                            const t = this.children;
                            for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
                        }
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t,
                            n = {};
                        e && (t = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {},
                            skeletons: {},
                            animations: {}
                        }, n.metadata = {
                            version: 4.5,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                        const i = {};

                        function r(e, n) {
                            return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                        }
                        if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isMesh || this.isLine || this.isPoints) {
                            i.geometry = r(t.geometries, this.geometry);
                            const e = this.geometry.parameters;
                            if (void 0 !== e && void 0 !== e.shapes) {
                                const n = e.shapes;
                                if (Array.isArray(n))
                                    for (let e = 0, i = n.length; e < i; e++) {
                                        const i = n[e];
                                        r(t.shapes, i)
                                    } else r(t.shapes, n)
                            }
                        }
                        if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                            if (Array.isArray(this.material)) {
                                const e = [];
                                for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                                i.material = e
                            } else i.material = r(t.materials, this.material);
                        if (this.children.length > 0) {
                            i.children = [];
                            for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object)
                        }
                        if (this.animations.length > 0) {
                            i.animations = [];
                            for (let e = 0; e < this.animations.length; e++) {
                                const n = this.animations[e];
                                i.animations.push(r(t.animations, n))
                            }
                        }
                        if (e) {
                            const e = o(t.geometries),
                                i = o(t.materials),
                                r = o(t.textures),
                                s = o(t.images),
                                a = o(t.shapes),
                                l = o(t.skeletons),
                                c = o(t.animations);
                            e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c)
                        }
                        return n.object = i, n;

                        function o(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                delete i.metadata, e.push(i)
                            }
                            return e
                        }
                    }
                    clone(t) {
                        return (new this.constructor).copy(this, t)
                    }
                    copy(t) {
                        let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                            for (let n = 0; n < t.children.length; n++) {
                                const e = t.children[n];
                                this.add(e.clone())
                            }
                        return this
                    }
                }
                cr.DefaultUp = new ai(0, 1, 0), cr.DefaultMatrixAutoUpdate = !0, cr.prototype.isObject3D = !0;
                const hr = new ai,
                    ur = new ai,
                    dr = new Zn;
                class pr {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ai(1, 0, 0),
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        this.normal = t, this.constant = e
                    }
                    set(t, e) {
                        return this.normal.copy(t), this.constant = e, this
                    }
                    setComponents(t, e, n, i) {
                        return this.normal.set(t, e, n), this.constant = i, this
                    }
                    setFromNormalAndCoplanarPoint(t, e) {
                        return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                    }
                    setFromCoplanarPoints(t, e, n) {
                        const i = hr.subVectors(n, e).cross(ur.subVectors(t, e)).normalize();
                        return this.setFromNormalAndCoplanarPoint(i, t), this
                    }
                    copy(t) {
                        return this.normal.copy(t.normal), this.constant = t.constant, this
                    }
                    normalize() {
                        const t = 1 / this.normal.length();
                        return this.normal.multiplyScalar(t), this.constant *= t, this
                    }
                    negate() {
                        return this.constant *= -1, this.normal.negate(), this
                    }
                    distanceToPoint(t) {
                        return this.normal.dot(t) + this.constant
                    }
                    distanceToSphere(t) {
                        return this.distanceToPoint(t.center) - t.radius
                    }
                    projectPoint(t, e) {
                        return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new ai), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                    }
                    intersectLine(t, e) {
                        void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new ai);
                        const n = t.delta(hr),
                            i = this.normal.dot(n);
                        if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                        const r = -(t.start.dot(this.normal) + this.constant) / i;
                        return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
                    }
                    intersectsLine(t) {
                        const e = this.distanceToPoint(t.start),
                            n = this.distanceToPoint(t.end);
                        return e < 0 && n > 0 || n < 0 && e > 0
                    }
                    intersectsBox(t) {
                        return t.intersectsPlane(this)
                    }
                    intersectsSphere(t) {
                        return t.intersectsPlane(this)
                    }
                    coplanarPoint(t) {
                        return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new ai), t.copy(this.normal).multiplyScalar(-this.constant)
                    }
                    applyMatrix4(t, e) {
                        const n = e || dr.getNormalMatrix(t),
                            i = this.coplanarPoint(hr).applyMatrix4(t),
                            r = this.normal.applyMatrix3(n).normalize();
                        return this.constant = -i.dot(r), this
                    }
                    translate(t) {
                        return this.constant -= t.dot(this.normal), this
                    }
                    equals(t) {
                        return t.normal.equals(this.normal) && t.constant === this.constant
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                pr.prototype.isPlane = !0;
                const fr = new ai,
                    mr = new ai,
                    gr = new ai,
                    vr = new ai,
                    yr = new ai,
                    xr = new ai,
                    br = new ai,
                    wr = new ai,
                    _r = new ai,
                    Sr = new ai;
                class Mr {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ai,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ai,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new ai;
                        this.a = t, this.b = e, this.c = n
                    }
                    static getNormal(t, e, n, i) {
                        void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new ai), i.subVectors(n, e), fr.subVectors(t, e), i.cross(fr);
                        const r = i.lengthSq();
                        return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                    }
                    static getBarycoord(t, e, n, i, r) {
                        fr.subVectors(i, e), mr.subVectors(n, e), gr.subVectors(t, e);
                        const o = fr.dot(fr),
                            s = fr.dot(mr),
                            a = fr.dot(gr),
                            l = mr.dot(mr),
                            c = mr.dot(gr),
                            h = o * l - s * s;
                        if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new ai), 0 === h) return r.set(-2, -1, -1);
                        const u = 1 / h,
                            d = (l * a - s * c) * u,
                            p = (o * c - s * a) * u;
                        return r.set(1 - d - p, p, d)
                    }
                    static containsPoint(t, e, n, i) {
                        return this.getBarycoord(t, e, n, i, vr), vr.x >= 0 && vr.y >= 0 && vr.x + vr.y <= 1
                    }
                    static getUV(t, e, n, i, r, o, s, a) {
                        return this.getBarycoord(t, e, n, i, vr), a.set(0, 0), a.addScaledVector(r, vr.x), a.addScaledVector(o, vr.y), a.addScaledVector(s, vr.z), a
                    }
                    static isFrontFacing(t, e, n, i) {
                        return fr.subVectors(n, e), mr.subVectors(t, e), fr.cross(mr).dot(i) < 0
                    }
                    set(t, e, n) {
                        return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                    }
                    setFromPointsAndIndices(t, e, n, i) {
                        return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                    }
                    getArea() {
                        return fr.subVectors(this.c, this.b), mr.subVectors(this.a, this.b), .5 * fr.cross(mr).length()
                    }
                    getMidpoint(t) {
                        return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new ai), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    }
                    getNormal(t) {
                        return Mr.getNormal(this.a, this.b, this.c, t)
                    }
                    getPlane(t) {
                        return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new pr), t.setFromCoplanarPoints(this.a, this.b, this.c)
                    }
                    getBarycoord(t, e) {
                        return Mr.getBarycoord(t, this.a, this.b, this.c, e)
                    }
                    getUV(t, e, n, i, r) {
                        return Mr.getUV(t, this.a, this.b, this.c, e, n, i, r)
                    }
                    containsPoint(t) {
                        return Mr.containsPoint(t, this.a, this.b, this.c)
                    }
                    isFrontFacing(t) {
                        return Mr.isFrontFacing(this.a, this.b, this.c, t)
                    }
                    intersectsBox(t) {
                        return t.intersectsTriangle(this)
                    }
                    closestPointToPoint(t, e) {
                        void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new ai);
                        const n = this.a,
                            i = this.b,
                            r = this.c;
                        let o, s;
                        yr.subVectors(i, n), xr.subVectors(r, n), wr.subVectors(t, n);
                        const a = yr.dot(wr),
                            l = xr.dot(wr);
                        if (a <= 0 && l <= 0) return e.copy(n);
                        _r.subVectors(t, i);
                        const c = yr.dot(_r),
                            h = xr.dot(_r);
                        if (c >= 0 && h <= c) return e.copy(i);
                        const u = a * h - c * l;
                        if (u <= 0 && a >= 0 && c <= 0) return o = a / (a - c), e.copy(n).addScaledVector(yr, o);
                        Sr.subVectors(t, r);
                        const d = yr.dot(Sr),
                            p = xr.dot(Sr);
                        if (p >= 0 && d <= p) return e.copy(r);
                        const f = d * l - a * p;
                        if (f <= 0 && l >= 0 && p <= 0) return s = l / (l - p), e.copy(n).addScaledVector(xr, s);
                        const m = c * p - d * h;
                        if (m <= 0 && h - c >= 0 && d - p >= 0) return br.subVectors(r, i), s = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(br, s);
                        const g = 1 / (m + f + u);
                        return o = f * g, s = u * g, e.copy(n).addScaledVector(yr, o).addScaledVector(xr, s)
                    }
                    equals(t) {
                        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                    }
                }
                let Ar = 0;
                class Tr extends Bn {
                    constructor() {
                        super(), Object.defineProperty(this, "id", {
                            value: Ar++
                        }), this.uuid = Un(), this.name = "", this.type = "Material", this.fog = !0, this.blending = b, this.side = f, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = O, this.blendDst = N, this.blendEquation = A, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = H, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Mn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = hn, this.stencilZFail = hn, this.stencilZPass = hn, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
                    }
                    onBuild() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() {
                        return this.onBeforeCompile.toString()
                    }
                    setValues(t) {
                        if (void 0 !== t)
                            for (const e in t) {
                                const n = t[e];
                                if (void 0 === n) {
                                    console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                                    continue
                                }
                                if ("shading" === e) {
                                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === v;
                                    continue
                                }
                                const i = this[e];
                                void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                            }
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        e && (t = {
                            textures: {},
                            images: {}
                        });
                        const n = {
                            metadata: {
                                version: 4.5,
                                type: "Material",
                                generator: "Material.toJSON"
                            }
                        };

                        function i(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                delete i.metadata, e.push(i)
                            }
                            return e
                        }
                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== b && (n.blending = this.blending), this.side !== f && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                            const e = i(t.textures),
                                r = i(t.images);
                            e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                        }
                        return n
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                        const e = t.clippingPlanes;
                        let n = null;
                        if (null !== e) {
                            const t = e.length;
                            n = new Array(t);
                            for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
                        }
                        return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                }
                Tr.prototype.isMaterial = !0;
                const Er = {
                        aliceblue: 15792383,
                        antiquewhite: 16444375,
                        aqua: 65535,
                        aquamarine: 8388564,
                        azure: 15794175,
                        beige: 16119260,
                        bisque: 16770244,
                        black: 0,
                        blanchedalmond: 16772045,
                        blue: 255,
                        blueviolet: 9055202,
                        brown: 10824234,
                        burlywood: 14596231,
                        cadetblue: 6266528,
                        chartreuse: 8388352,
                        chocolate: 13789470,
                        coral: 16744272,
                        cornflowerblue: 6591981,
                        cornsilk: 16775388,
                        crimson: 14423100,
                        cyan: 65535,
                        darkblue: 139,
                        darkcyan: 35723,
                        darkgoldenrod: 12092939,
                        darkgray: 11119017,
                        darkgreen: 25600,
                        darkgrey: 11119017,
                        darkkhaki: 12433259,
                        darkmagenta: 9109643,
                        darkolivegreen: 5597999,
                        darkorange: 16747520,
                        darkorchid: 10040012,
                        darkred: 9109504,
                        darksalmon: 15308410,
                        darkseagreen: 9419919,
                        darkslateblue: 4734347,
                        darkslategray: 3100495,
                        darkslategrey: 3100495,
                        darkturquoise: 52945,
                        darkviolet: 9699539,
                        deeppink: 16716947,
                        deepskyblue: 49151,
                        dimgray: 6908265,
                        dimgrey: 6908265,
                        dodgerblue: 2003199,
                        firebrick: 11674146,
                        floralwhite: 16775920,
                        forestgreen: 2263842,
                        fuchsia: 16711935,
                        gainsboro: 14474460,
                        ghostwhite: 16316671,
                        gold: 16766720,
                        goldenrod: 14329120,
                        gray: 8421504,
                        green: 32768,
                        greenyellow: 11403055,
                        grey: 8421504,
                        honeydew: 15794160,
                        hotpink: 16738740,
                        indianred: 13458524,
                        indigo: 4915330,
                        ivory: 16777200,
                        khaki: 15787660,
                        lavender: 15132410,
                        lavenderblush: 16773365,
                        lawngreen: 8190976,
                        lemonchiffon: 16775885,
                        lightblue: 11393254,
                        lightcoral: 15761536,
                        lightcyan: 14745599,
                        lightgoldenrodyellow: 16448210,
                        lightgray: 13882323,
                        lightgreen: 9498256,
                        lightgrey: 13882323,
                        lightpink: 16758465,
                        lightsalmon: 16752762,
                        lightseagreen: 2142890,
                        lightskyblue: 8900346,
                        lightslategray: 7833753,
                        lightslategrey: 7833753,
                        lightsteelblue: 11584734,
                        lightyellow: 16777184,
                        lime: 65280,
                        limegreen: 3329330,
                        linen: 16445670,
                        magenta: 16711935,
                        maroon: 8388608,
                        mediumaquamarine: 6737322,
                        mediumblue: 205,
                        mediumorchid: 12211667,
                        mediumpurple: 9662683,
                        mediumseagreen: 3978097,
                        mediumslateblue: 8087790,
                        mediumspringgreen: 64154,
                        mediumturquoise: 4772300,
                        mediumvioletred: 13047173,
                        midnightblue: 1644912,
                        mintcream: 16121850,
                        mistyrose: 16770273,
                        moccasin: 16770229,
                        navajowhite: 16768685,
                        navy: 128,
                        oldlace: 16643558,
                        olive: 8421376,
                        olivedrab: 7048739,
                        orange: 16753920,
                        orangered: 16729344,
                        orchid: 14315734,
                        palegoldenrod: 15657130,
                        palegreen: 10025880,
                        paleturquoise: 11529966,
                        palevioletred: 14381203,
                        papayawhip: 16773077,
                        peachpuff: 16767673,
                        peru: 13468991,
                        pink: 16761035,
                        plum: 14524637,
                        powderblue: 11591910,
                        purple: 8388736,
                        rebeccapurple: 6697881,
                        red: 16711680,
                        rosybrown: 12357519,
                        royalblue: 4286945,
                        saddlebrown: 9127187,
                        salmon: 16416882,
                        sandybrown: 16032864,
                        seagreen: 3050327,
                        seashell: 16774638,
                        sienna: 10506797,
                        silver: 12632256,
                        skyblue: 8900331,
                        slateblue: 6970061,
                        slategray: 7372944,
                        slategrey: 7372944,
                        snow: 16775930,
                        springgreen: 65407,
                        steelblue: 4620980,
                        tan: 13808780,
                        teal: 32896,
                        thistle: 14204888,
                        tomato: 16737095,
                        turquoise: 4251856,
                        violet: 15631086,
                        wheat: 16113331,
                        white: 16777215,
                        whitesmoke: 16119285,
                        yellow: 16776960,
                        yellowgreen: 10145074
                    },
                    Cr = {
                        h: 0,
                        s: 0,
                        l: 0
                    },
                    Pr = {
                        h: 0,
                        s: 0,
                        l: 0
                    };

                function Lr(t, e, n) {
                    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
                }

                function Rr(t) {
                    return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                }

                function Ir(t) {
                    return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                }
                class Fr {
                    constructor(t, e, n) {
                        return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
                    }
                    set(t) {
                        return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                    }
                    setScalar(t) {
                        return this.r = t, this.g = t, this.b = t, this
                    }
                    setHex(t) {
                        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                    }
                    setRGB(t, e, n) {
                        return this.r = t, this.g = e, this.b = n, this
                    }
                    setHSL(t, e, n) {
                        if (t = Gn(t, 1), e = zn(e, 0, 1), n = zn(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                        else {
                            const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                                r = 2 * n - i;
                            this.r = Lr(r, i, t + 1 / 3), this.g = Lr(r, i, t), this.b = Lr(r, i, t - 1 / 3)
                        }
                        return this
                    }
                    setStyle(t) {
                        function e(e) {
                            void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                        }
                        let n;
                        if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                            let t;
                            const i = n[1],
                                r = n[2];
                            switch (i) {
                                case "rgb":
                                case "rgba":
                                    if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this;
                                    if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this;
                                    break;
                                case "hsl":
                                case "hsla":
                                    if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                                        const n = parseFloat(t[1]) / 360,
                                            i = parseInt(t[2], 10) / 100,
                                            r = parseInt(t[3], 10) / 100;
                                        return e(t[4]), this.setHSL(n, i, r)
                                    }
                            }
                        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                            const t = n[1],
                                e = t.length;
                            if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                            if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                        }
                        return t && t.length > 0 ? this.setColorName(t) : this
                    }
                    setColorName(t) {
                        const e = Er[t.toLowerCase()];
                        return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
                    }
                    clone() {
                        return new this.constructor(this.r, this.g, this.b)
                    }
                    copy(t) {
                        return this.r = t.r, this.g = t.g, this.b = t.b, this
                    }
                    copyGammaToLinear(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
                        return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                    }
                    copyLinearToGamma(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
                        const n = e > 0 ? 1 / e : 1;
                        return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
                    }
                    convertGammaToLinear(t) {
                        return this.copyGammaToLinear(this, t), this
                    }
                    convertLinearToGamma(t) {
                        return this.copyLinearToGamma(this, t), this
                    }
                    copySRGBToLinear(t) {
                        return this.r = Rr(t.r), this.g = Rr(t.g), this.b = Rr(t.b), this
                    }
                    copyLinearToSRGB(t) {
                        return this.r = Ir(t.r), this.g = Ir(t.g), this.b = Ir(t.b), this
                    }
                    convertSRGBToLinear() {
                        return this.copySRGBToLinear(this), this
                    }
                    convertLinearToSRGB() {
                        return this.copyLinearToSRGB(this), this
                    }
                    getHex() {
                        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b
                    }
                    getHexString() {
                        return ("000000" + this.getHex().toString(16)).slice(-6)
                    }
                    getHSL(t) {
                        void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                            h: 0,
                            s: 0,
                            l: 0
                        });
                        const e = this.r,
                            n = this.g,
                            i = this.b,
                            r = Math.max(e, n, i),
                            o = Math.min(e, n, i);
                        let s, a;
                        const l = (o + r) / 2;
                        if (o === r) s = 0, a = 0;
                        else {
                            const t = r - o;
                            switch (a = l <= .5 ? t / (r + o) : t / (2 - r - o), r) {
                                case e:
                                    s = (n - i) / t + (n < i ? 6 : 0);
                                    break;
                                case n:
                                    s = (i - e) / t + 2;
                                    break;
                                case i:
                                    s = (e - n) / t + 4
                            }
                            s /= 6
                        }
                        return t.h = s, t.s = a, t.l = l, t
                    }
                    getStyle() {
                        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                    }
                    offsetHSL(t, e, n) {
                        return this.getHSL(Cr), Cr.h += t, Cr.s += e, Cr.l += n, this.setHSL(Cr.h, Cr.s, Cr.l), this
                    }
                    add(t) {
                        return this.r += t.r, this.g += t.g, this.b += t.b, this
                    }
                    addColors(t, e) {
                        return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                    }
                    addScalar(t) {
                        return this.r += t, this.g += t, this.b += t, this
                    }
                    sub(t) {
                        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                    }
                    multiply(t) {
                        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                    }
                    multiplyScalar(t) {
                        return this.r *= t, this.g *= t, this.b *= t, this
                    }
                    lerp(t, e) {
                        return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                    }
                    lerpColors(t, e, n) {
                        return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
                    }
                    lerpHSL(t, e) {
                        this.getHSL(Cr), t.getHSL(Pr);
                        const n = Hn(Cr.h, Pr.h, e),
                            i = Hn(Cr.s, Pr.s, e),
                            r = Hn(Cr.l, Pr.l, e);
                        return this.setHSL(n, i, r), this
                    }
                    equals(t) {
                        return t.r === this.r && t.g === this.g && t.b === this.b
                    }
                    fromArray(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                    }
                    toArray() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                    }
                    fromBufferAttribute(t, e) {
                        return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                    }
                    toJSON() {
                        return this.getHex()
                    }
                }
                Fr.NAMES = Er, Fr.prototype.isColor = !0, Fr.prototype.r = 1, Fr.prototype.g = 1, Fr.prototype.b = 1;
                class Or extends Tr {
                    constructor(t) {
                        super(), this.type = "MeshBasicMaterial", this.color = new Fr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this
                    }
                }
                Or.prototype.isMeshBasicMaterial = !0;
                const Nr = new ai,
                    Br = new Qn;
                class Dr {
                    constructor(t, e, n) {
                        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = An, this.updateRange = {
                            offset: 0,
                            count: -1
                        }, this.version = 0
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                    setUsage(t) {
                        return this.usage = t, this
                    }
                    copy(t) {
                        return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
                    }
                    copyAt(t, e, n) {
                        t *= this.itemSize, n *= e.itemSize;
                        for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                        return this
                    }
                    copyArray(t) {
                        return this.array.set(t), this
                    }
                    copyColorsArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Fr), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                        }
                        return this
                    }
                    copyVector2sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new Qn), e[n++] = r.x, e[n++] = r.y
                        }
                        return this
                    }
                    copyVector3sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new ai), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                        }
                        return this
                    }
                    copyVector4sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new ni), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                        }
                        return this
                    }
                    applyMatrix3(t) {
                        if (2 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++) Br.fromBufferAttribute(this, e), Br.applyMatrix3(t), this.setXY(e, Br.x, Br.y);
                        else if (3 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++) Nr.fromBufferAttribute(this, e), Nr.applyMatrix3(t), this.setXYZ(e, Nr.x, Nr.y, Nr.z);
                        return this
                    }
                    applyMatrix4(t) {
                        for (let e = 0, n = this.count; e < n; e++) Nr.x = this.getX(e), Nr.y = this.getY(e), Nr.z = this.getZ(e), Nr.applyMatrix4(t), this.setXYZ(e, Nr.x, Nr.y, Nr.z);
                        return this
                    }
                    applyNormalMatrix(t) {
                        for (let e = 0, n = this.count; e < n; e++) Nr.x = this.getX(e), Nr.y = this.getY(e), Nr.z = this.getZ(e), Nr.applyNormalMatrix(t), this.setXYZ(e, Nr.x, Nr.y, Nr.z);
                        return this
                    }
                    transformDirection(t) {
                        for (let e = 0, n = this.count; e < n; e++) Nr.x = this.getX(e), Nr.y = this.getY(e), Nr.z = this.getZ(e), Nr.transformDirection(t), this.setXYZ(e, Nr.x, Nr.y, Nr.z);
                        return this
                    }
                    set(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this.array.set(t, e), this
                    }
                    getX(t) {
                        return this.array[t * this.itemSize]
                    }
                    setX(t, e) {
                        return this.array[t * this.itemSize] = e, this
                    }
                    getY(t) {
                        return this.array[t * this.itemSize + 1]
                    }
                    setY(t, e) {
                        return this.array[t * this.itemSize + 1] = e, this
                    }
                    getZ(t) {
                        return this.array[t * this.itemSize + 2]
                    }
                    setZ(t, e) {
                        return this.array[t * this.itemSize + 2] = e, this
                    }
                    getW(t) {
                        return this.array[t * this.itemSize + 3]
                    }
                    setW(t, e) {
                        return this.array[t * this.itemSize + 3] = e, this
                    }
                    setXY(t, e, n) {
                        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
                    }
                    setXYZ(t, e, n, i) {
                        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
                    }
                    setXYZW(t, e, n, i, r) {
                        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
                    }
                    onUpload(t) {
                        return this.onUploadCallback = t, this
                    }
                    clone() {
                        return new this.constructor(this.array, this.itemSize).copy(this)
                    }
                    toJSON() {
                        const t = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.prototype.slice.call(this.array),
                            normalized: this.normalized
                        };
                        return "" !== this.name && (t.name = this.name), this.usage !== An && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
                    }
                }
                Dr.prototype.isBufferAttribute = !0;
                class Vr extends Dr {
                    constructor(t, e, n) {
                        super(new Int8Array(t), e, n)
                    }
                }
                class jr extends Dr {
                    constructor(t, e, n) {
                        super(new Uint8Array(t), e, n)
                    }
                }
                class kr extends Dr {
                    constructor(t, e, n) {
                        super(new Uint8ClampedArray(t), e, n)
                    }
                }
                class Ur extends Dr {
                    constructor(t, e, n) {
                        super(new Int16Array(t), e, n)
                    }
                }
                class zr extends Dr {
                    constructor(t, e, n) {
                        super(new Uint16Array(t), e, n)
                    }
                }
                class Gr extends Dr {
                    constructor(t, e, n) {
                        super(new Int32Array(t), e, n)
                    }
                }
                class Hr extends Dr {
                    constructor(t, e, n) {
                        super(new Uint32Array(t), e, n)
                    }
                }
                class Wr extends Dr {
                    constructor(t, e, n) {
                        super(new Uint16Array(t), e, n)
                    }
                }
                Wr.prototype.isFloat16BufferAttribute = !0;
                class Yr extends Dr {
                    constructor(t, e, n) {
                        super(new Float32Array(t), e, n)
                    }
                }
                class Xr extends Dr {
                    constructor(t, e, n) {
                        super(new Float64Array(t), e, n)
                    }
                }

                function qr(t) {
                    if (0 === t.length) return -1 / 0;
                    let e = t[0];
                    for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
                    return e
                }
                const Qr = {
                    Int8Array: Int8Array,
                    Uint8Array: Uint8Array,
                    Uint8ClampedArray: Uint8ClampedArray,
                    Int16Array: Int16Array,
                    Uint16Array: Uint16Array,
                    Int32Array: Int32Array,
                    Uint32Array: Uint32Array,
                    Float32Array: Float32Array,
                    Float64Array: Float64Array
                };

                function Zr(t, e) {
                    return new Qr[t](e)
                }
                let Jr = 0;
                const Kr = new Vi,
                    $r = new cr,
                    to = new ai,
                    eo = new hi,
                    no = new hi,
                    io = new ai;
                class ro extends Bn {
                    constructor() {
                        super(), Object.defineProperty(this, "id", {
                            value: Jr++
                        }), this.uuid = Un(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                            start: 0,
                            count: 1 / 0
                        }, this.userData = {}
                    }
                    getIndex() {
                        return this.index
                    }
                    setIndex(t) {
                        return Array.isArray(t) ? this.index = new(qr(t) > 65535 ? Hr : zr)(t, 1) : this.index = t, this
                    }
                    getAttribute(t) {
                        return this.attributes[t]
                    }
                    setAttribute(t, e) {
                        return this.attributes[t] = e, this
                    }
                    deleteAttribute(t) {
                        return delete this.attributes[t], this
                    }
                    hasAttribute(t) {
                        return void 0 !== this.attributes[t]
                    }
                    addGroup(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        this.groups.push({
                            start: t,
                            count: e,
                            materialIndex: n
                        })
                    }
                    clearGroups() {
                        this.groups = []
                    }
                    setDrawRange(t, e) {
                        this.drawRange.start = t, this.drawRange.count = e
                    }
                    applyMatrix4(t) {
                        const e = this.attributes.position;
                        void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                        const n = this.attributes.normal;
                        if (void 0 !== n) {
                            const e = (new Zn).getNormalMatrix(t);
                            n.applyNormalMatrix(e), n.needsUpdate = !0
                        }
                        const i = this.attributes.tangent;
                        return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                    }
                    applyQuaternion(t) {
                        return Kr.makeRotationFromQuaternion(t), this.applyMatrix4(Kr), this
                    }
                    rotateX(t) {
                        return Kr.makeRotationX(t), this.applyMatrix4(Kr), this
                    }
                    rotateY(t) {
                        return Kr.makeRotationY(t), this.applyMatrix4(Kr), this
                    }
                    rotateZ(t) {
                        return Kr.makeRotationZ(t), this.applyMatrix4(Kr), this
                    }
                    translate(t, e, n) {
                        return Kr.makeTranslation(t, e, n), this.applyMatrix4(Kr), this
                    }
                    scale(t, e, n) {
                        return Kr.makeScale(t, e, n), this.applyMatrix4(Kr), this
                    }
                    lookAt(t) {
                        return $r.lookAt(t), $r.updateMatrix(), this.applyMatrix4($r.matrix), this
                    }
                    center() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(to).negate(), this.translate(to.x, to.y, to.z), this
                    }
                    setFromPoints(t) {
                        const e = [];
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            e.push(i.x, i.y, i.z || 0)
                        }
                        return this.setAttribute("position", new Yr(e, 3)), this
                    }
                    computeBoundingBox() {
                        null === this.boundingBox && (this.boundingBox = new hi);
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new ai(-1 / 0, -1 / 0, -1 / 0), new ai(1 / 0, 1 / 0, 1 / 0));
                        if (void 0 !== t) {
                            if (this.boundingBox.setFromBufferAttribute(t), e)
                                for (let n = 0, i = e.length; n < i; n++) {
                                    const t = e[n];
                                    eo.setFromBufferAttribute(t), this.morphTargetsRelative ? (io.addVectors(this.boundingBox.min, eo.min), this.boundingBox.expandByPoint(io), io.addVectors(this.boundingBox.max, eo.max), this.boundingBox.expandByPoint(io)) : (this.boundingBox.expandByPoint(eo.min), this.boundingBox.expandByPoint(eo.max))
                                }
                        } else this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere && (this.boundingSphere = new Pi);
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new ai, 1 / 0);
                        if (t) {
                            const n = this.boundingSphere.center;
                            if (eo.setFromBufferAttribute(t), e)
                                for (let t = 0, r = e.length; t < r; t++) {
                                    const n = e[t];
                                    no.setFromBufferAttribute(n), this.morphTargetsRelative ? (io.addVectors(eo.min, no.min), eo.expandByPoint(io), io.addVectors(eo.max, no.max), eo.expandByPoint(io)) : (eo.expandByPoint(no.min), eo.expandByPoint(no.max))
                                }
                            eo.getCenter(n);
                            let i = 0;
                            for (let e = 0, r = t.count; e < r; e++) io.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(io));
                            if (e)
                                for (let r = 0, o = e.length; r < o; r++) {
                                    const o = e[r],
                                        s = this.morphTargetsRelative;
                                    for (let e = 0, r = o.count; e < r; e++) io.fromBufferAttribute(o, e), s && (to.fromBufferAttribute(t, e), io.add(to)), i = Math.max(i, n.distanceToSquared(io))
                                }
                            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                    computeFaceNormals() {}
                    computeTangents() {
                        const t = this.index,
                            e = this.attributes;
                        if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                        const n = t.array,
                            i = e.position.array,
                            r = e.normal.array,
                            o = e.uv.array,
                            s = i.length / 3;
                        void 0 === e.tangent && this.setAttribute("tangent", new Dr(new Float32Array(4 * s), 4));
                        const a = e.tangent.array,
                            l = [],
                            c = [];
                        for (let A = 0; A < s; A++) l[A] = new ai, c[A] = new ai;
                        const h = new ai,
                            u = new ai,
                            d = new ai,
                            p = new Qn,
                            f = new Qn,
                            m = new Qn,
                            g = new ai,
                            v = new ai;

                        function y(t, e, n) {
                            h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(o, 2 * t), f.fromArray(o, 2 * e), m.fromArray(o, 2 * n), u.sub(h), d.sub(h), f.sub(p), m.sub(p);
                            const r = 1 / (f.x * m.y - m.x * f.y);
                            isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), v.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v))
                        }
                        let x = this.groups;
                        0 === x.length && (x = [{
                            start: 0,
                            count: n.length
                        }]);
                        for (let A = 0, T = x.length; A < T; ++A) {
                            const t = x[A],
                                e = t.start;
                            for (let i = e, r = e + t.count; i < r; i += 3) y(n[i + 0], n[i + 1], n[i + 2])
                        }
                        const b = new ai,
                            w = new ai,
                            _ = new ai,
                            S = new ai;

                        function M(t) {
                            _.fromArray(r, 3 * t), S.copy(_);
                            const e = l[t];
                            b.copy(e), b.sub(_.multiplyScalar(_.dot(e))).normalize(), w.crossVectors(S, e);
                            const n = w.dot(c[t]) < 0 ? -1 : 1;
                            a[4 * t] = b.x, a[4 * t + 1] = b.y, a[4 * t + 2] = b.z, a[4 * t + 3] = n
                        }
                        for (let A = 0, T = x.length; A < T; ++A) {
                            const t = x[A],
                                e = t.start;
                            for (let i = e, r = e + t.count; i < r; i += 3) M(n[i + 0]), M(n[i + 1]), M(n[i + 2])
                        }
                    }
                    computeVertexNormals() {
                        const t = this.index,
                            e = this.getAttribute("position");
                        if (void 0 !== e) {
                            let n = this.getAttribute("normal");
                            if (void 0 === n) n = new Dr(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                            else
                                for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                            const i = new ai,
                                r = new ai,
                                o = new ai,
                                s = new ai,
                                a = new ai,
                                l = new ai,
                                c = new ai,
                                h = new ai;
                            if (t)
                                for (let u = 0, d = t.count; u < d; u += 3) {
                                    const d = t.getX(u + 0),
                                        p = t.getX(u + 1),
                                        f = t.getX(u + 2);
                                    i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), o.fromBufferAttribute(e, f), c.subVectors(o, r), h.subVectors(i, r), c.cross(h), s.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), s.add(c), a.add(c), l.add(c), n.setXYZ(d, s.x, s.y, s.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(f, l.x, l.y, l.z)
                                } else
                                    for (let t = 0, u = e.count; t < u; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), c.subVectors(o, r), h.subVectors(i, r), c.cross(h), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
                            this.normalizeNormals(), n.needsUpdate = !0
                        }
                    }
                    merge(t, e) {
                        if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        const n = this.attributes;
                        for (const i in n) {
                            if (void 0 === t.attributes[i]) continue;
                            const r = n[i].array,
                                o = t.attributes[i],
                                s = o.array,
                                a = o.itemSize * e,
                                l = Math.min(s.length, r.length - a);
                            for (let t = 0, e = a; t < l; t++, e++) r[e] = s[t]
                        }
                        return this
                    }
                    normalizeNormals() {
                        const t = this.attributes.normal;
                        for (let e = 0, n = t.count; e < n; e++) io.fromBufferAttribute(t, e), io.normalize(), t.setXYZ(e, io.x, io.y, io.z)
                    }
                    toNonIndexed() {
                        function t(t, e) {
                            const n = t.array,
                                i = t.itemSize,
                                r = t.normalized,
                                o = new n.constructor(e.length * i);
                            let s = 0,
                                a = 0;
                            for (let l = 0, c = e.length; l < c; l++) {
                                s = e[l] * i;
                                for (let t = 0; t < i; t++) o[a++] = n[s++]
                            }
                            return new Dr(o, i, r)
                        }
                        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                        const e = new ro,
                            n = this.index.array,
                            i = this.attributes;
                        for (const s in i) {
                            const r = t(i[s], n);
                            e.setAttribute(s, r)
                        }
                        const r = this.morphAttributes;
                        for (const s in r) {
                            const i = [],
                                o = r[s];
                            for (let e = 0, r = o.length; e < r; e++) {
                                const r = t(o[e], n);
                                i.push(r)
                            }
                            e.morphAttributes[s] = i
                        }
                        e.morphTargetsRelative = this.morphTargetsRelative;
                        const o = this.groups;
                        for (let s = 0, a = o.length; s < a; s++) {
                            const t = o[s];
                            e.addGroup(t.start, t.count, t.materialIndex)
                        }
                        return e
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.5,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON"
                            }
                        };
                        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                            const e = this.parameters;
                            for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                            return t
                        }
                        t.data = {
                            attributes: {}
                        };
                        const e = this.index;
                        null !== e && (t.data.index = {
                            type: e.array.constructor.name,
                            array: Array.prototype.slice.call(e.array)
                        });
                        const n = this.attributes;
                        for (const a in n) {
                            const e = n[a];
                            t.data.attributes[a] = e.toJSON(t.data)
                        }
                        const i = {};
                        let r = !1;
                        for (const a in this.morphAttributes) {
                            const e = this.morphAttributes[a],
                                n = [];
                            for (let i = 0, r = e.length; i < r; i++) {
                                const r = e[i];
                                n.push(r.toJSON(t.data))
                            }
                            n.length > 0 && (i[a] = n, r = !0)
                        }
                        r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
                        const o = this.groups;
                        o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
                        const s = this.boundingSphere;
                        return null !== s && (t.data.boundingSphere = {
                            center: s.center.toArray(),
                            radius: s.radius
                        }), t
                    }
                    clone() {
                        return (new ro).copy(this)
                    }
                    copy(t) {
                        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                        const e = {};
                        this.name = t.name;
                        const n = t.index;
                        null !== n && this.setIndex(n.clone(e));
                        const i = t.attributes;
                        for (const l in i) {
                            const t = i[l];
                            this.setAttribute(l, t.clone(e))
                        }
                        const r = t.morphAttributes;
                        for (const l in r) {
                            const t = [],
                                n = r[l];
                            for (let i = 0, r = n.length; i < r; i++) t.push(n[i].clone(e));
                            this.morphAttributes[l] = t
                        }
                        this.morphTargetsRelative = t.morphTargetsRelative;
                        const o = t.groups;
                        for (let l = 0, c = o.length; l < c; l++) {
                            const t = o[l];
                            this.addGroup(t.start, t.count, t.materialIndex)
                        }
                        const s = t.boundingBox;
                        null !== s && (this.boundingBox = s.clone());
                        const a = t.boundingSphere;
                        return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                ro.prototype.isBufferGeometry = !0;
                const oo = new Vi,
                    so = new Di,
                    ao = new Pi,
                    lo = new ai,
                    co = new ai,
                    ho = new ai,
                    uo = new ai,
                    po = new ai,
                    fo = new ai,
                    mo = new ai,
                    go = new ai,
                    vo = new ai,
                    yo = new Qn,
                    xo = new Qn,
                    bo = new Qn,
                    wo = new ai,
                    _o = new ai;
                class So extends cr {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ro,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Or;
                        super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
                    }
                    copy(t) {
                        return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
                    }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.material,
                            r = this.matrixWorld;
                        if (void 0 === i) return;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), ao.copy(n.boundingSphere), ao.applyMatrix4(r), !1 === t.ray.intersectsSphere(ao)) return;
                        if (oo.copy(r).invert(), so.copy(t.ray).applyMatrix4(oo), null !== n.boundingBox && !1 === so.intersectsBox(n.boundingBox)) return;
                        let o;
                        if (n.isBufferGeometry) {
                            const r = n.index,
                                s = n.attributes.position,
                                a = n.morphAttributes.position,
                                l = n.morphTargetsRelative,
                                c = n.attributes.uv,
                                h = n.attributes.uv2,
                                u = n.groups,
                                d = n.drawRange;
                            if (null !== r)
                                if (Array.isArray(i))
                                    for (let n = 0, p = u.length; n < p; n++) {
                                        const p = u[n],
                                            f = i[p.materialIndex];
                                        for (let n = Math.max(p.start, d.start), i = Math.min(p.start + p.count, d.start + d.count); n < i; n += 3) {
                                            const i = r.getX(n),
                                                u = r.getX(n + 1),
                                                d = r.getX(n + 2);
                                            o = Mo(this, f, t, so, s, a, l, c, h, i, u, d), o && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = p.materialIndex, e.push(o))
                                        }
                                    } else
                                        for (let n = Math.max(0, d.start), p = Math.min(r.count, d.start + d.count); n < p; n += 3) {
                                            const u = r.getX(n),
                                                d = r.getX(n + 1),
                                                p = r.getX(n + 2);
                                            o = Mo(this, i, t, so, s, a, l, c, h, u, d, p), o && (o.faceIndex = Math.floor(n / 3), e.push(o))
                                        } else if (void 0 !== s)
                                            if (Array.isArray(i))
                                                for (let n = 0, p = u.length; n < p; n++) {
                                                    const r = u[n],
                                                        p = i[r.materialIndex];
                                                    for (let n = Math.max(r.start, d.start), i = Math.min(r.start + r.count, d.start + d.count); n < i; n += 3) o = Mo(this, p, t, so, s, a, l, c, h, n, n + 1, n + 2), o && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = r.materialIndex, e.push(o))
                                                } else
                                                    for (let n = Math.max(0, d.start), p = Math.min(s.count, d.start + d.count); n < p; n += 3) o = Mo(this, i, t, so, s, a, l, c, h, n, n + 1, n + 2), o && (o.faceIndex = Math.floor(n / 3), e.push(o))
                        } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }

                function Mo(t, e, n, i, r, o, s, a, l, c, h, u) {
                    lo.fromBufferAttribute(r, c), co.fromBufferAttribute(r, h), ho.fromBufferAttribute(r, u);
                    const d = t.morphTargetInfluences;
                    if (e.morphTargets && o && d) {
                        mo.set(0, 0, 0), go.set(0, 0, 0), vo.set(0, 0, 0);
                        for (let t = 0, e = o.length; t < e; t++) {
                            const e = d[t],
                                n = o[t];
                            0 !== e && (uo.fromBufferAttribute(n, c), po.fromBufferAttribute(n, h), fo.fromBufferAttribute(n, u), s ? (mo.addScaledVector(uo, e), go.addScaledVector(po, e), vo.addScaledVector(fo, e)) : (mo.addScaledVector(uo.sub(lo), e), go.addScaledVector(po.sub(co), e), vo.addScaledVector(fo.sub(ho), e)))
                        }
                        lo.add(mo), co.add(go), ho.add(vo)
                    }
                    t.isSkinnedMesh && (t.boneTransform(c, lo), t.boneTransform(h, co), t.boneTransform(u, ho));
                    const p = function(t, e, n, i, r, o, s, a) {
                        let l;
                        if (l = e.side === m ? i.intersectTriangle(s, o, r, !0, a) : i.intersectTriangle(r, o, s, e.side !== g, a), null === l) return null;
                        _o.copy(a), _o.applyMatrix4(t.matrixWorld);
                        const c = n.ray.origin.distanceTo(_o);
                        return c < n.near || c > n.far ? null : {
                            distance: c,
                            point: _o.clone(),
                            object: t
                        }
                    }(t, e, n, i, lo, co, ho, wo);
                    if (p) {
                        a && (yo.fromBufferAttribute(a, c), xo.fromBufferAttribute(a, h), bo.fromBufferAttribute(a, u), p.uv = Mr.getUV(wo, lo, co, ho, yo, xo, bo, new Qn)), l && (yo.fromBufferAttribute(l, c), xo.fromBufferAttribute(l, h), bo.fromBufferAttribute(l, u), p.uv2 = Mr.getUV(wo, lo, co, ho, yo, xo, bo, new Qn));
                        const t = {
                            a: c,
                            b: h,
                            c: u,
                            normal: new ai,
                            materialIndex: 0
                        };
                        Mr.getNormal(lo, co, ho, t.normal), p.face = t
                    }
                    return p
                }
                So.prototype.isMesh = !0;
                class Ao extends ro {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1,
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
                        super(), this.type = "BoxGeometry", this.parameters = {
                            width: t,
                            height: e,
                            depth: n,
                            widthSegments: i,
                            heightSegments: r,
                            depthSegments: o
                        };
                        const s = this;
                        i = Math.floor(i), r = Math.floor(r), o = Math.floor(o);
                        const a = [],
                            l = [],
                            c = [],
                            h = [];
                        let u = 0,
                            d = 0;

                        function p(t, e, n, i, r, o, p, f, m, g, v) {
                            const y = o / m,
                                x = p / g,
                                b = o / 2,
                                w = p / 2,
                                _ = f / 2,
                                S = m + 1,
                                M = g + 1;
                            let A = 0,
                                T = 0;
                            const E = new ai;
                            for (let s = 0; s < M; s++) {
                                const o = s * x - w;
                                for (let a = 0; a < S; a++) {
                                    const u = a * y - b;
                                    E[t] = u * i, E[e] = o * r, E[n] = _, l.push(E.x, E.y, E.z), E[t] = 0, E[e] = 0, E[n] = f > 0 ? 1 : -1, c.push(E.x, E.y, E.z), h.push(a / m), h.push(1 - s / g), A += 1
                                }
                            }
                            for (let s = 0; s < g; s++)
                                for (let t = 0; t < m; t++) {
                                    const e = u + t + S * s,
                                        n = u + t + S * (s + 1),
                                        i = u + (t + 1) + S * (s + 1),
                                        r = u + (t + 1) + S * s;
                                    a.push(e, n, r), a.push(n, i, r), T += 6
                                }
                            s.addGroup(d, T, v), d += T, u += A
                        }
                        p("z", "y", "x", -1, -1, n, e, t, o, r, 0), p("z", "y", "x", 1, -1, n, e, -t, o, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, o, 2), p("x", "z", "y", 1, -1, t, n, -e, i, o, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new Yr(l, 3)), this.setAttribute("normal", new Yr(c, 3)), this.setAttribute("uv", new Yr(h, 2))
                    }
                }

                function To(t) {
                    const e = {};
                    for (const n in t) {
                        e[n] = {};
                        for (const i in t[n]) {
                            const r = t[n][i];
                            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                        }
                    }
                    return e
                }

                function Eo(t) {
                    const e = {};
                    for (let n = 0; n < t.length; n++) {
                        const i = To(t[n]);
                        for (const t in i) e[t] = i[t]
                    }
                    return e
                }
                const Co = {
                    clone: To,
                    merge: Eo
                };
                var Po = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                    Lo = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
                class Ro extends Tr {
                    constructor(t) {
                        super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = Po, this.fragmentShader = Lo, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                            derivatives: !1,
                            fragDepth: !1,
                            drawBuffers: !1,
                            shaderTextureLOD: !1
                        }, this.defaultAttributeValues = {
                            color: [1, 1, 1],
                            uv: [0, 0],
                            uv2: [0, 0]
                        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
                    }
                    copy(t) {
                        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = To(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        e.glslVersion = this.glslVersion, e.uniforms = {};
                        for (const i in this.uniforms) {
                            const n = this.uniforms[i].value;
                            n && n.isTexture ? e.uniforms[i] = {
                                type: "t",
                                value: n.toJSON(t).uuid
                            } : n && n.isColor ? e.uniforms[i] = {
                                type: "c",
                                value: n.getHex()
                            } : n && n.isVector2 ? e.uniforms[i] = {
                                type: "v2",
                                value: n.toArray()
                            } : n && n.isVector3 ? e.uniforms[i] = {
                                type: "v3",
                                value: n.toArray()
                            } : n && n.isVector4 ? e.uniforms[i] = {
                                type: "v4",
                                value: n.toArray()
                            } : n && n.isMatrix3 ? e.uniforms[i] = {
                                type: "m3",
                                value: n.toArray()
                            } : n && n.isMatrix4 ? e.uniforms[i] = {
                                type: "m4",
                                value: n.toArray()
                            } : e.uniforms[i] = {
                                value: n
                            }
                        }
                        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                        const n = {};
                        for (const i in this.extensions) !0 === this.extensions[i] && (n[i] = !0);
                        return Object.keys(n).length > 0 && (e.extensions = n), e
                    }
                }
                Ro.prototype.isShaderMaterial = !0;
                class Io extends cr {
                    constructor() {
                        super(), this.type = "Camera", this.matrixWorldInverse = new Vi, this.projectionMatrix = new Vi, this.projectionMatrixInverse = new Vi
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                    }
                    getWorldDirection(t) {
                        void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new ai), this.updateWorldMatrix(!0, !1);
                        const e = this.matrixWorld.elements;
                        return t.set(-e[8], -e[9], -e[10]).normalize()
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    updateWorldMatrix(t, e) {
                        super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                Io.prototype.isCamera = !0;
                class Fo extends Io {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 50,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2e3;
                        super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                    }
                    setFocalLength(t) {
                        const e = .5 * this.getFilmHeight() / t;
                        this.fov = 2 * kn * Math.atan(e), this.updateProjectionMatrix()
                    }
                    getFocalLength() {
                        const t = Math.tan(.5 * jn * this.fov);
                        return .5 * this.getFilmHeight() / t
                    }
                    getEffectiveFOV() {
                        return 2 * kn * Math.atan(Math.tan(.5 * jn * this.fov) / this.zoom)
                    }
                    getFilmWidth() {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    }
                    getFilmHeight() {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    }
                    setViewOffset(t, e, n, i, r, o) {
                        this.aspect = t / e, null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const t = this.near;
                        let e = t * Math.tan(.5 * jn * this.fov) / this.zoom,
                            n = 2 * e,
                            i = this.aspect * n,
                            r = -.5 * i;
                        const o = this.view;
                        if (null !== this.view && this.view.enabled) {
                            const t = o.fullWidth,
                                s = o.fullHeight;
                            r += o.offsetX * i / t, e -= o.offsetY * n / s, i *= o.width / t, n *= o.height / s
                        }
                        const s = this.filmOffset;
                        0 !== s && (r += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                    }
                }
                Fo.prototype.isPerspectiveCamera = !0;
                const Oo = 90,
                    No = 1;
                class Bo extends cr {
                    constructor(t, e, n) {
                        if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                        this.renderTarget = n;
                        const i = new Fo(Oo, No, t, e);
                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new ai(1, 0, 0)), this.add(i);
                        const r = new Fo(Oo, No, t, e);
                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new ai(-1, 0, 0)), this.add(r);
                        const o = new Fo(Oo, No, t, e);
                        o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new ai(0, 1, 0)), this.add(o);
                        const s = new Fo(Oo, No, t, e);
                        s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new ai(0, -1, 0)), this.add(s);
                        const a = new Fo(Oo, No, t, e);
                        a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new ai(0, 0, 1)), this.add(a);
                        const l = new Fo(Oo, No, t, e);
                        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new ai(0, 0, -1)), this.add(l)
                    }
                    update(t, e) {
                        null === this.parent && this.updateMatrixWorld();
                        const n = this.renderTarget,
                            [i, r, o, s, a, l] = this.children,
                            c = t.xr.enabled,
                            h = t.getRenderTarget();
                        t.xr.enabled = !1;
                        const u = n.texture.generateMipmaps;
                        n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, o), t.setRenderTarget(n, 3), t.render(e, s), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c
                    }
                }
                class Do extends ti {
                    constructor(t, e, n, i, r, o, s, a, l, c) {
                        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : ot, n, i, r, o, s = void 0 !== s ? s : Dt, a, l, c), this._needsFlipEnvMap = !0, this.flipY = !1
                    }
                    get images() {
                        return this.image
                    }
                    set images(t) {
                        this.image = t
                    }
                }
                Do.prototype.isCubeTexture = !0;
                class Vo extends ii {
                    constructor(t, e, n) {
                        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new Do(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : xt, this.texture._needsFlipEnvMap = !1
                    }
                    fromEquirectangularTexture(t, e) {
                        this.texture.type = e.type, this.texture.format = Vt, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                        const n = {
                                uniforms: {
                                    tEquirect: {
                                        value: null
                                    }
                                },
                                vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                                fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                            },
                            i = new Ao(5, 5, 5),
                            r = new Ro({
                                name: "CubemapFromEquirect",
                                uniforms: To(n.uniforms),
                                vertexShader: n.vertexShader,
                                fragmentShader: n.fragmentShader,
                                side: m,
                                blending: x
                            });
                        r.uniforms.tEquirect.value = e;
                        const o = new So(i, r),
                            s = e.minFilter;
                        return e.minFilter === _t && (e.minFilter = xt), new Bo(1, 10, this).update(t, o), e.minFilter = s, o.geometry.dispose(), o.material.dispose(), this
                    }
                    clear(t, e, n, i) {
                        const r = t.getRenderTarget();
                        for (let o = 0; o < 6; o++) t.setRenderTarget(this, o), t.clear(e, n, i);
                        t.setRenderTarget(r)
                    }
                }
                Vo.prototype.isWebGLCubeRenderTarget = !0;
                const jo = new Pi,
                    ko = new ai;
                class Uo {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new pr,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new pr,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new pr,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new pr,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : new pr,
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : new pr;
                        this.planes = [t, e, n, i, r, o]
                    }
                    set(t, e, n, i, r, o) {
                        const s = this.planes;
                        return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(o), this
                    }
                    copy(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                        return this
                    }
                    setFromProjectionMatrix(t) {
                        const e = this.planes,
                            n = t.elements,
                            i = n[0],
                            r = n[1],
                            o = n[2],
                            s = n[3],
                            a = n[4],
                            l = n[5],
                            c = n[6],
                            h = n[7],
                            u = n[8],
                            d = n[9],
                            p = n[10],
                            f = n[11],
                            m = n[12],
                            g = n[13],
                            v = n[14],
                            y = n[15];
                        return e[0].setComponents(s - i, h - a, f - u, y - m).normalize(), e[1].setComponents(s + i, h + a, f + u, y + m).normalize(), e[2].setComponents(s + r, h + l, f + d, y + g).normalize(), e[3].setComponents(s - r, h - l, f - d, y - g).normalize(), e[4].setComponents(s - o, h - c, f - p, y - v).normalize(), e[5].setComponents(s + o, h + c, f + p, y + v).normalize(), this
                    }
                    intersectsObject(t) {
                        const e = t.geometry;
                        return null === e.boundingSphere && e.computeBoundingSphere(), jo.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(jo)
                    }
                    intersectsSprite(t) {
                        return jo.center.set(0, 0, 0), jo.radius = .7071067811865476, jo.applyMatrix4(t.matrixWorld), this.intersectsSphere(jo)
                    }
                    intersectsSphere(t) {
                        const e = this.planes,
                            n = t.center,
                            i = -t.radius;
                        for (let r = 0; r < 6; r++)
                            if (e[r].distanceToPoint(n) < i) return !1;
                        return !0
                    }
                    intersectsBox(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++) {
                            const i = e[n];
                            if (ko.x = i.normal.x > 0 ? t.max.x : t.min.x, ko.y = i.normal.y > 0 ? t.max.y : t.min.y, ko.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(ko) < 0) return !1
                        }
                        return !0
                    }
                    containsPoint(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (e[n].distanceToPoint(t) < 0) return !1;
                        return !0
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }

                function zo() {
                    let t = null,
                        e = !1,
                        n = null,
                        i = null;

                    function r(e, o) {
                        n(e, o), i = t.requestAnimationFrame(r)
                    }
                    return {
                        start: function() {
                            !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0)
                        },
                        stop: function() {
                            t.cancelAnimationFrame(i), e = !1
                        },
                        setAnimationLoop: function(t) {
                            n = t
                        },
                        setContext: function(e) {
                            t = e
                        }
                    }
                }

                function Go(t, e) {
                    const n = e.isWebGL2,
                        i = new WeakMap;
                    return {
                        get: function(t) {
                            return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                        },
                        remove: function(e) {
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const n = i.get(e);
                            n && (t.deleteBuffer(n.buffer), i.delete(e))
                        },
                        update: function(e, r) {
                            if (e.isGLBufferAttribute) {
                                const t = i.get(e);
                                return void((!t || t.version < e.version) && i.set(e, {
                                    buffer: e.buffer,
                                    type: e.type,
                                    bytesPerElement: e.elementSize,
                                    version: e.version
                                }))
                            }
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const o = i.get(e);
                            void 0 === o ? i.set(e, function(e, i) {
                                const r = e.array,
                                    o = e.usage,
                                    s = t.createBuffer();
                                t.bindBuffer(i, s), t.bufferData(i, r, o), e.onUploadCallback();
                                let a = 5126;
                                return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (a = 5121), {
                                    buffer: s,
                                    type: a,
                                    bytesPerElement: r.BYTES_PER_ELEMENT,
                                    version: e.version
                                }
                            }(e, r)) : o.version < e.version && (function(e, i, r) {
                                const o = i.array,
                                    s = i.updateRange;
                                t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, o) : (n ? t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1)
                            }(o.buffer, e, r), o.version = e.version)
                        }
                    }
                }
                class Ho extends ro {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        super(), this.type = "PlaneGeometry", this.parameters = {
                            width: t,
                            height: e,
                            widthSegments: n,
                            heightSegments: i
                        };
                        const r = t / 2,
                            o = e / 2,
                            s = Math.floor(n),
                            a = Math.floor(i),
                            l = s + 1,
                            c = a + 1,
                            h = t / s,
                            u = e / a,
                            d = [],
                            p = [],
                            f = [],
                            m = [];
                        for (let g = 0; g < c; g++) {
                            const t = g * u - o;
                            for (let e = 0; e < l; e++) {
                                const n = e * h - r;
                                p.push(n, -t, 0), f.push(0, 0, 1), m.push(e / s), m.push(1 - g / a)
                            }
                        }
                        for (let g = 0; g < a; g++)
                            for (let t = 0; t < s; t++) {
                                const e = t + l * g,
                                    n = t + l * (g + 1),
                                    i = t + 1 + l * (g + 1),
                                    r = t + 1 + l * g;
                                d.push(e, n, r), d.push(n, i, r)
                            }
                        this.setIndex(d), this.setAttribute("position", new Yr(p, 3)), this.setAttribute("normal", new Yr(f, 3)), this.setAttribute("uv", new Yr(m, 2))
                    }
                }
                const Wo = {
                        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                        begin_vertex: "vec3 transformed = vec3( position );",
                        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                        color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                        color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                        color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                        color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
                        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                        lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                        map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                        normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                        clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                        transmission_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );\n\tvec3 f90 = vec3( 1.0 );\n\tvec3 f_transmission = totalTransmission * getIBLVolumeRefraction(\n\t\tnormal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance);\n\tdiffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );\n#endif",
                        transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\tfloat NdotV = saturate(dot(n, viewDir));\n\t\tvec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);\n\t\tvec3 specularColor = f0 * brdf.x + f90 * brdf.y;\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif",
                        uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                        uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                        uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                        cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef USE_TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t\tfloat thicknessFactor = thickness;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\tvec3 rawDiffuseColor = diffuseColor.rgb;\n\t#include <transmission_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}",
                        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                        shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
                    },
                    Yo = {
                        common: {
                            diffuse: {
                                value: new Fr(16777215)
                            },
                            opacity: {
                                value: 1
                            },
                            map: {
                                value: null
                            },
                            uvTransform: {
                                value: new Zn
                            },
                            uv2Transform: {
                                value: new Zn
                            },
                            alphaMap: {
                                value: null
                            }
                        },
                        specularmap: {
                            specularMap: {
                                value: null
                            }
                        },
                        envmap: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            reflectivity: {
                                value: 1
                            },
                            refractionRatio: {
                                value: .98
                            },
                            maxMipLevel: {
                                value: 0
                            }
                        },
                        aomap: {
                            aoMap: {
                                value: null
                            },
                            aoMapIntensity: {
                                value: 1
                            }
                        },
                        lightmap: {
                            lightMap: {
                                value: null
                            },
                            lightMapIntensity: {
                                value: 1
                            }
                        },
                        emissivemap: {
                            emissiveMap: {
                                value: null
                            }
                        },
                        bumpmap: {
                            bumpMap: {
                                value: null
                            },
                            bumpScale: {
                                value: 1
                            }
                        },
                        normalmap: {
                            normalMap: {
                                value: null
                            },
                            normalScale: {
                                value: new Qn(1, 1)
                            }
                        },
                        displacementmap: {
                            displacementMap: {
                                value: null
                            },
                            displacementScale: {
                                value: 1
                            },
                            displacementBias: {
                                value: 0
                            }
                        },
                        roughnessmap: {
                            roughnessMap: {
                                value: null
                            }
                        },
                        metalnessmap: {
                            metalnessMap: {
                                value: null
                            }
                        },
                        gradientmap: {
                            gradientMap: {
                                value: null
                            }
                        },
                        fog: {
                            fogDensity: {
                                value: 25e-5
                            },
                            fogNear: {
                                value: 1
                            },
                            fogFar: {
                                value: 2e3
                            },
                            fogColor: {
                                value: new Fr(16777215)
                            }
                        },
                        lights: {
                            ambientLightColor: {
                                value: []
                            },
                            lightProbe: {
                                value: []
                            },
                            directionalLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    color: {}
                                }
                            },
                            directionalLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {}
                                }
                            },
                            directionalShadowMap: {
                                value: []
                            },
                            directionalShadowMatrix: {
                                value: []
                            },
                            spotLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    direction: {},
                                    distance: {},
                                    coneCos: {},
                                    penumbraCos: {},
                                    decay: {}
                                }
                            },
                            spotLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {}
                                }
                            },
                            spotShadowMap: {
                                value: []
                            },
                            spotShadowMatrix: {
                                value: []
                            },
                            pointLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    decay: {},
                                    distance: {}
                                }
                            },
                            pointLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                    shadowCameraNear: {},
                                    shadowCameraFar: {}
                                }
                            },
                            pointShadowMap: {
                                value: []
                            },
                            pointShadowMatrix: {
                                value: []
                            },
                            hemisphereLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    skyColor: {},
                                    groundColor: {}
                                }
                            },
                            rectAreaLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    width: {},
                                    height: {}
                                }
                            },
                            ltc_1: {
                                value: null
                            },
                            ltc_2: {
                                value: null
                            }
                        },
                        points: {
                            diffuse: {
                                value: new Fr(16777215)
                            },
                            opacity: {
                                value: 1
                            },
                            size: {
                                value: 1
                            },
                            scale: {
                                value: 1
                            },
                            map: {
                                value: null
                            },
                            alphaMap: {
                                value: null
                            },
                            uvTransform: {
                                value: new Zn
                            }
                        },
                        sprite: {
                            diffuse: {
                                value: new Fr(16777215)
                            },
                            opacity: {
                                value: 1
                            },
                            center: {
                                value: new Qn(.5, .5)
                            },
                            rotation: {
                                value: 0
                            },
                            map: {
                                value: null
                            },
                            alphaMap: {
                                value: null
                            },
                            uvTransform: {
                                value: new Zn
                            }
                        }
                    },
                    Xo = {
                        basic: {
                            uniforms: Eo([Yo.common, Yo.specularmap, Yo.envmap, Yo.aomap, Yo.lightmap, Yo.fog]),
                            vertexShader: Wo.meshbasic_vert,
                            fragmentShader: Wo.meshbasic_frag
                        },
                        lambert: {
                            uniforms: Eo([Yo.common, Yo.specularmap, Yo.envmap, Yo.aomap, Yo.lightmap, Yo.emissivemap, Yo.fog, Yo.lights, {
                                emissive: {
                                    value: new Fr(0)
                                }
                            }]),
                            vertexShader: Wo.meshlambert_vert,
                            fragmentShader: Wo.meshlambert_frag
                        },
                        phong: {
                            uniforms: Eo([Yo.common, Yo.specularmap, Yo.envmap, Yo.aomap, Yo.lightmap, Yo.emissivemap, Yo.bumpmap, Yo.normalmap, Yo.displacementmap, Yo.fog, Yo.lights, {
                                emissive: {
                                    value: new Fr(0)
                                },
                                specular: {
                                    value: new Fr(1118481)
                                },
                                shininess: {
                                    value: 30
                                }
                            }]),
                            vertexShader: Wo.meshphong_vert,
                            fragmentShader: Wo.meshphong_frag
                        },
                        standard: {
                            uniforms: Eo([Yo.common, Yo.envmap, Yo.aomap, Yo.lightmap, Yo.emissivemap, Yo.bumpmap, Yo.normalmap, Yo.displacementmap, Yo.roughnessmap, Yo.metalnessmap, Yo.fog, Yo.lights, {
                                emissive: {
                                    value: new Fr(0)
                                },
                                roughness: {
                                    value: 1
                                },
                                metalness: {
                                    value: 0
                                },
                                envMapIntensity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: Wo.meshphysical_vert,
                            fragmentShader: Wo.meshphysical_frag
                        },
                        toon: {
                            uniforms: Eo([Yo.common, Yo.aomap, Yo.lightmap, Yo.emissivemap, Yo.bumpmap, Yo.normalmap, Yo.displacementmap, Yo.gradientmap, Yo.fog, Yo.lights, {
                                emissive: {
                                    value: new Fr(0)
                                }
                            }]),
                            vertexShader: Wo.meshtoon_vert,
                            fragmentShader: Wo.meshtoon_frag
                        },
                        matcap: {
                            uniforms: Eo([Yo.common, Yo.bumpmap, Yo.normalmap, Yo.displacementmap, Yo.fog, {
                                matcap: {
                                    value: null
                                }
                            }]),
                            vertexShader: Wo.meshmatcap_vert,
                            fragmentShader: Wo.meshmatcap_frag
                        },
                        points: {
                            uniforms: Eo([Yo.points, Yo.fog]),
                            vertexShader: Wo.points_vert,
                            fragmentShader: Wo.points_frag
                        },
                        dashed: {
                            uniforms: Eo([Yo.common, Yo.fog, {
                                scale: {
                                    value: 1
                                },
                                dashSize: {
                                    value: 1
                                },
                                totalSize: {
                                    value: 2
                                }
                            }]),
                            vertexShader: Wo.linedashed_vert,
                            fragmentShader: Wo.linedashed_frag
                        },
                        depth: {
                            uniforms: Eo([Yo.common, Yo.displacementmap]),
                            vertexShader: Wo.depth_vert,
                            fragmentShader: Wo.depth_frag
                        },
                        normal: {
                            uniforms: Eo([Yo.common, Yo.bumpmap, Yo.normalmap, Yo.displacementmap, {
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: Wo.normal_vert,
                            fragmentShader: Wo.normal_frag
                        },
                        sprite: {
                            uniforms: Eo([Yo.sprite, Yo.fog]),
                            vertexShader: Wo.sprite_vert,
                            fragmentShader: Wo.sprite_frag
                        },
                        background: {
                            uniforms: {
                                uvTransform: {
                                    value: new Zn
                                },
                                t2D: {
                                    value: null
                                }
                            },
                            vertexShader: Wo.background_vert,
                            fragmentShader: Wo.background_frag
                        },
                        cube: {
                            uniforms: Eo([Yo.envmap, {
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: Wo.cube_vert,
                            fragmentShader: Wo.cube_frag
                        },
                        equirect: {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: Wo.equirect_vert,
                            fragmentShader: Wo.equirect_frag
                        },
                        distanceRGBA: {
                            uniforms: Eo([Yo.common, Yo.displacementmap, {
                                referencePosition: {
                                    value: new ai
                                },
                                nearDistance: {
                                    value: 1
                                },
                                farDistance: {
                                    value: 1e3
                                }
                            }]),
                            vertexShader: Wo.distanceRGBA_vert,
                            fragmentShader: Wo.distanceRGBA_frag
                        },
                        shadow: {
                            uniforms: Eo([Yo.lights, Yo.fog, {
                                color: {
                                    value: new Fr(0)
                                },
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: Wo.shadow_vert,
                            fragmentShader: Wo.shadow_frag
                        }
                    };

                function qo(t, e, n, i, r) {
                    const o = new Fr(0);
                    let s, a, l = 0,
                        c = null,
                        h = 0,
                        u = null;

                    function d(t, e) {
                        n.buffers.color.setClear(t.r, t.g, t.b, e, r)
                    }
                    return {
                        getClearColor: function() {
                            return o
                        },
                        setClearColor: function(t) {
                            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                            o.set(t), l = e, d(o, l)
                        },
                        getClearAlpha: function() {
                            return l
                        },
                        setClearAlpha: function(t) {
                            l = t, d(o, l)
                        },
                        render: function(n, r) {
                            let p = !1,
                                g = !0 === r.isScene ? r.background : null;
                            g && g.isTexture && (g = e.get(g));
                            const v = t.xr,
                                y = v.getSession && v.getSession();
                            y && "additive" === y.environmentBlendMode && (g = null), null === g ? d(o, l) : g && g.isColor && (d(g, 1), p = !0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || g.mapping === ct) ? (void 0 === a && (a = new So(new Ao(1, 1, 1), new Ro({
                                name: "BackgroundCubeMaterial",
                                uniforms: To(Xo.cube.uniforms),
                                vertexShader: Xo.cube.vertexShader,
                                fragmentShader: Xo.cube.fragmentShader,
                                side: m,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function(t, e, n) {
                                this.matrixWorld.copyPosition(n.matrixWorld)
                            }, Object.defineProperty(a.material, "envMap", {
                                get: function() {
                                    return this.uniforms.envMap.value
                                }
                            }), i.update(a)), a.material.uniforms.envMap.value = g, a.material.uniforms.flipEnvMap.value = g.isCubeTexture && g._needsFlipEnvMap ? -1 : 1, c === g && h === g.version && u === t.toneMapping || (a.material.needsUpdate = !0, c = g, h = g.version, u = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : g && g.isTexture && (void 0 === s && (s = new So(new Ho(2, 2), new Ro({
                                name: "BackgroundMaterial",
                                uniforms: To(Xo.background.uniforms),
                                vertexShader: Xo.background.vertexShader,
                                fragmentShader: Xo.background.fragmentShader,
                                side: f,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            })), s.geometry.deleteAttribute("normal"), Object.defineProperty(s.material, "map", {
                                get: function() {
                                    return this.uniforms.t2D.value
                                }
                            }), i.update(s)), s.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), s.material.uniforms.uvTransform.value.copy(g.matrix), c === g && h === g.version && u === t.toneMapping || (s.material.needsUpdate = !0, c = g, h = g.version, u = t.toneMapping), n.unshift(s, s.geometry, s.material, 0, 0, null))
                        }
                    }
                }

                function Qo(t, e, n, i) {
                    const r = t.getParameter(34921),
                        o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                        s = i.isWebGL2 || null !== o,
                        a = {},
                        l = d(null);
                    let c = l;

                    function h(e) {
                        return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e)
                    }

                    function u(e) {
                        return i.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e)
                    }

                    function d(t) {
                        const e = [],
                            n = [],
                            i = [];
                        for (let o = 0; o < r; o++) e[o] = 0, n[o] = 0, i[o] = 0;
                        return {
                            geometry: null,
                            program: null,
                            wireframe: !1,
                            newAttributes: e,
                            enabledAttributes: n,
                            attributeDivisors: i,
                            object: t,
                            attributes: {},
                            index: null
                        }
                    }

                    function p() {
                        const t = c.newAttributes;
                        for (let e = 0, n = t.length; e < n; e++) t[e] = 0
                    }

                    function f(t) {
                        m(t, 0)
                    }

                    function m(n, r) {
                        const o = c.newAttributes,
                            s = c.enabledAttributes,
                            a = c.attributeDivisors;
                        o[n] = 1, 0 === s[n] && (t.enableVertexAttribArray(n), s[n] = 1), a[n] !== r && ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r)
                    }

                    function g() {
                        const e = c.newAttributes,
                            n = c.enabledAttributes;
                        for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
                    }

                    function v(e, n, r, o, s, a) {
                        !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, o, s, a) : t.vertexAttribIPointer(e, n, r, s, a)
                    }

                    function y() {
                        x(), c !== l && (c = l, h(c.object))
                    }

                    function x() {
                        l.geometry = null, l.program = null, l.wireframe = !1
                    }
                    return {
                        setup: function(r, l, u, y, x) {
                            let b = !1;
                            if (s) {
                                const e = function(e, n, r) {
                                    const s = !0 === r.wireframe;
                                    let l = a[e.id];
                                    void 0 === l && (l = {}, a[e.id] = l);
                                    let c = l[n.id];
                                    void 0 === c && (c = {}, l[n.id] = c);
                                    let h = c[s];
                                    return void 0 === h && (h = d(i.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), c[s] = h), h
                                }(y, u, l);
                                c !== e && (c = e, h(c.object)), b = function(t, e) {
                                    const n = c.attributes,
                                        i = t.attributes;
                                    let r = 0;
                                    for (const o in i) {
                                        const t = n[o],
                                            e = i[o];
                                        if (void 0 === t) return !0;
                                        if (t.attribute !== e) return !0;
                                        if (t.data !== e.data) return !0;
                                        r++
                                    }
                                    return c.attributesNum !== r || c.index !== e
                                }(y, x), b && function(t, e) {
                                    const n = {},
                                        i = t.attributes;
                                    let r = 0;
                                    for (const o in i) {
                                        const t = i[o],
                                            e = {};
                                        e.attribute = t, t.data && (e.data = t.data), n[o] = e, r++
                                    }
                                    c.attributes = n, c.attributesNum = r, c.index = e
                                }(y, x)
                            } else {
                                const t = !0 === l.wireframe;
                                c.geometry === y.id && c.program === u.id && c.wireframe === t || (c.geometry = y.id, c.program = u.id, c.wireframe = t, b = !0)
                            }!0 === r.isInstancedMesh && (b = !0), null !== x && n.update(x, 34963), b && (function(r, o, s, a) {
                                if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                                p();
                                const l = a.attributes,
                                    c = s.getAttributes(),
                                    h = o.defaultAttributeValues;
                                for (const e in c) {
                                    const i = c[e];
                                    if (i >= 0) {
                                        const o = l[e];
                                        if (void 0 !== o) {
                                            const e = o.normalized,
                                                r = o.itemSize,
                                                s = n.get(o);
                                            if (void 0 === s) continue;
                                            const l = s.buffer,
                                                c = s.type,
                                                h = s.bytesPerElement;
                                            if (o.isInterleavedBufferAttribute) {
                                                const n = o.data,
                                                    s = n.stride,
                                                    u = o.offset;
                                                n && n.isInstancedInterleavedBuffer ? (m(i, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : f(i), t.bindBuffer(34962, l), v(i, r, c, e, s * h, u * h)
                                            } else o.isInstancedBufferAttribute ? (m(i, o.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)) : f(i), t.bindBuffer(34962, l), v(i, r, c, e, 0, 0)
                                        } else if ("instanceMatrix" === e) {
                                            const e = n.get(r.instanceMatrix);
                                            if (void 0 === e) continue;
                                            const o = e.buffer,
                                                s = e.type;
                                            m(i + 0, 1), m(i + 1, 1), m(i + 2, 1), m(i + 3, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(i + 0, 4, s, !1, 64, 0), t.vertexAttribPointer(i + 1, 4, s, !1, 64, 16), t.vertexAttribPointer(i + 2, 4, s, !1, 64, 32), t.vertexAttribPointer(i + 3, 4, s, !1, 64, 48)
                                        } else if ("instanceColor" === e) {
                                            const e = n.get(r.instanceColor);
                                            if (void 0 === e) continue;
                                            const o = e.buffer,
                                                s = e.type;
                                            m(i, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(i, 3, s, !1, 12, 0)
                                        } else if (void 0 !== h) {
                                            const n = h[e];
                                            if (void 0 !== n) switch (n.length) {
                                                case 2:
                                                    t.vertexAttrib2fv(i, n);
                                                    break;
                                                case 3:
                                                    t.vertexAttrib3fv(i, n);
                                                    break;
                                                case 4:
                                                    t.vertexAttrib4fv(i, n);
                                                    break;
                                                default:
                                                    t.vertexAttrib1fv(i, n)
                                            }
                                        }
                                    }
                                }
                                g()
                            }(r, l, u, y), null !== x && t.bindBuffer(34963, n.get(x).buffer))
                        },
                        reset: y,
                        resetDefaultState: x,
                        dispose: function() {
                            y();
                            for (const t in a) {
                                const e = a[t];
                                for (const t in e) {
                                    const n = e[t];
                                    for (const t in n) u(n[t].object), delete n[t];
                                    delete e[t]
                                }
                                delete a[t]
                            }
                        },
                        releaseStatesOfGeometry: function(t) {
                            if (void 0 === a[t.id]) return;
                            const e = a[t.id];
                            for (const n in e) {
                                const t = e[n];
                                for (const e in t) u(t[e].object), delete t[e];
                                delete e[n]
                            }
                            delete a[t.id]
                        },
                        releaseStatesOfProgram: function(t) {
                            for (const e in a) {
                                const n = a[e];
                                if (void 0 === n[t.id]) continue;
                                const i = n[t.id];
                                for (const t in i) u(i[t].object), delete i[t];
                                delete n[t.id]
                            }
                        },
                        initAttributes: p,
                        enableAttribute: f,
                        disableUnusedAttributes: g
                    }
                }

                function Zo(t, e, n, i) {
                    const r = i.isWebGL2;
                    let o;
                    this.setMode = function(t) {
                        o = t
                    }, this.render = function(e, i) {
                        t.drawArrays(o, e, i), n.update(i, o, 1)
                    }, this.renderInstances = function(i, s, a) {
                        if (0 === a) return;
                        let l, c;
                        if (r) l = t, c = "drawArraysInstanced";
                        else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        l[c](o, i, s, a), n.update(s, o, a)
                    }
                }

                function Jo(t, e, n) {
                    let i;

                    function r(e) {
                        if ("highp" === e) {
                            if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                            e = "mediump"
                        }
                        return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                    }
                    const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
                    let s = void 0 !== n.precision ? n.precision : "highp";
                    const a = r(s);
                    a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a);
                    const l = o || e.has("WEBGL_draw_buffers"),
                        c = !0 === n.logarithmicDepthBuffer,
                        h = t.getParameter(34930),
                        u = t.getParameter(35660),
                        d = t.getParameter(3379),
                        p = t.getParameter(34076),
                        f = t.getParameter(34921),
                        m = t.getParameter(36347),
                        g = t.getParameter(36348),
                        v = t.getParameter(36349),
                        y = u > 0,
                        x = o || e.has("OES_texture_float");
                    return {
                        isWebGL2: o,
                        drawBuffers: l,
                        getMaxAnisotropy: function() {
                            if (void 0 !== i) return i;
                            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                                const n = e.get("EXT_texture_filter_anisotropic");
                                i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                            } else i = 0;
                            return i
                        },
                        getMaxPrecision: r,
                        precision: s,
                        logarithmicDepthBuffer: c,
                        maxTextures: h,
                        maxVertexTextures: u,
                        maxTextureSize: d,
                        maxCubemapSize: p,
                        maxAttributes: f,
                        maxVertexUniforms: m,
                        maxVaryings: g,
                        maxFragmentUniforms: v,
                        vertexTextures: y,
                        floatFragmentTextures: x,
                        floatVertexTextures: y && x,
                        maxSamples: o ? t.getParameter(36183) : 0
                    }
                }

                function Ko(t) {
                    const e = this;
                    let n = null,
                        i = 0,
                        r = !1,
                        o = !1;
                    const s = new pr,
                        a = new Zn,
                        l = {
                            value: null,
                            needsUpdate: !1
                        };

                    function c() {
                        l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
                    }

                    function h(t, n, i, r) {
                        const o = null !== t ? t.length : 0;
                        let c = null;
                        if (0 !== o) {
                            if (c = l.value, !0 !== r || null === c) {
                                const e = i + 4 * o,
                                    r = n.matrixWorldInverse;
                                a.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                                for (let n = 0, l = i; n !== o; ++n, l += 4) s.copy(t[n]).applyMatrix4(r, a), s.normal.toArray(c, l), c[l + 3] = s.constant
                            }
                            l.value = c, l.needsUpdate = !0
                        }
                        return e.numPlanes = o, e.numIntersection = 0, c
                    }
                    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, o) {
                        const s = 0 !== t.length || e || 0 !== i || r;
                        return r = e, n = h(t, o, 0), i = t.length, s
                    }, this.beginShadows = function() {
                        o = !0, h(null)
                    }, this.endShadows = function() {
                        o = !1, c()
                    }, this.setState = function(e, s, a) {
                        const u = e.clippingPlanes,
                            d = e.clipIntersection,
                            p = e.clipShadows,
                            f = t.get(e);
                        if (!r || null === u || 0 === u.length || o && !p) o ? h(null) : c();
                        else {
                            const t = o ? 0 : i,
                                e = 4 * t;
                            let r = f.clippingState || null;
                            l.value = r, r = h(u, s, e, a);
                            for (let i = 0; i !== e; ++i) r[i] = n[i];
                            f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                        }
                    }
                }

                function $o(t) {
                    let e = new WeakMap;

                    function n(t, e) {
                        return e === at ? t.mapping = ot : e === lt && (t.mapping = st), t
                    }

                    function i(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", i);
                        const r = e.get(n);
                        void 0 !== r && (e.delete(n), r.dispose())
                    }
                    return {
                        get: function(r) {
                            if (r && r.isTexture) {
                                const o = r.mapping;
                                if (o === at || o === lt) {
                                    if (e.has(r)) return n(e.get(r).texture, r.mapping); {
                                        const o = r.image;
                                        if (o && o.height > 0) {
                                            const s = t.getRenderTarget(),
                                                a = new Vo(o.height / 2);
                                            return a.fromEquirectangularTexture(t, r), e.set(r, a), t.setRenderTarget(s), r.addEventListener("dispose", i), n(a.texture, r.mapping)
                                        }
                                        return null
                                    }
                                }
                            }
                            return r
                        },
                        dispose: function() {
                            e = new WeakMap
                        }
                    }
                }

                function ts(t) {
                    const e = {};

                    function n(n) {
                        if (void 0 !== e[n]) return e[n];
                        let i;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                i = t.getExtension(n)
                        }
                        return e[n] = i, i
                    }
                    return {
                        has: function(t) {
                            return null !== n(t)
                        },
                        init: function(t) {
                            t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float")
                        },
                        get: function(t) {
                            const e = n(t);
                            return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                        }
                    }
                }

                function es(t, e, n, i) {
                    const r = {},
                        o = new WeakMap;

                    function s(t) {
                        const a = t.target;
                        null !== a.index && e.remove(a.index);
                        for (const n in a.attributes) e.remove(a.attributes[n]);
                        a.removeEventListener("dispose", s), delete r[a.id];
                        const l = o.get(a);
                        l && (e.remove(l), o.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
                    }

                    function a(t) {
                        const n = [],
                            i = t.index,
                            r = t.attributes.position;
                        let s = 0;
                        if (null !== i) {
                            const t = i.array;
                            s = i.version;
                            for (let e = 0, i = t.length; e < i; e += 3) {
                                const i = t[e + 0],
                                    r = t[e + 1],
                                    o = t[e + 2];
                                n.push(i, r, r, o, o, i)
                            }
                        } else {
                            const t = r.array;
                            s = r.version;
                            for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                                const t = e + 0,
                                    i = e + 1,
                                    r = e + 2;
                                n.push(t, i, i, r, r, t)
                            }
                        }
                        const a = new(qr(n) > 65535 ? Hr : zr)(n, 1);
                        a.version = s;
                        const l = o.get(t);
                        l && e.remove(l), o.set(t, a)
                    }
                    return {
                        get: function(t, e) {
                            return !0 === r[e.id] || (e.addEventListener("dispose", s), r[e.id] = !0, n.memory.geometries++), e
                        },
                        update: function(t) {
                            const n = t.attributes;
                            for (const r in n) e.update(n[r], 34962);
                            const i = t.morphAttributes;
                            for (const r in i) {
                                const t = i[r];
                                for (let n = 0, i = t.length; n < i; n++) e.update(t[n], 34962)
                            }
                        },
                        getWireframeAttribute: function(t) {
                            const e = o.get(t);
                            if (e) {
                                const n = t.index;
                                null !== n && e.version < n.version && a(t)
                            } else a(t);
                            return o.get(t)
                        }
                    }
                }

                function ns(t, e, n, i) {
                    const r = i.isWebGL2;
                    let o, s, a;
                    this.setMode = function(t) {
                        o = t
                    }, this.setIndex = function(t) {
                        s = t.type, a = t.bytesPerElement
                    }, this.render = function(e, i) {
                        t.drawElements(o, i, s, e * a), n.update(i, o, 1)
                    }, this.renderInstances = function(i, l, c) {
                        if (0 === c) return;
                        let h, u;
                        if (r) h = t, u = "drawElementsInstanced";
                        else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        h[u](o, l, s, i * a, c), n.update(l, o, c)
                    }
                }

                function is(t) {
                    const e = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };
                    return {
                        memory: {
                            geometries: 0,
                            textures: 0
                        },
                        render: e,
                        programs: null,
                        autoReset: !0,
                        reset: function() {
                            e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                        },
                        update: function(t, n, i) {
                            switch (e.calls++, n) {
                                case 4:
                                    e.triangles += i * (t / 3);
                                    break;
                                case 1:
                                    e.lines += i * (t / 2);
                                    break;
                                case 3:
                                    e.lines += i * (t - 1);
                                    break;
                                case 2:
                                    e.lines += i * t;
                                    break;
                                case 0:
                                    e.points += i * t;
                                    break;
                                default:
                                    console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                            }
                        }
                    }
                }

                function rs(t, e) {
                    return t[0] - e[0]
                }

                function os(t, e) {
                    return Math.abs(e[1]) - Math.abs(t[1])
                }

                function ss(t) {
                    const e = {},
                        n = new Float32Array(8),
                        i = [];
                    for (let r = 0; r < 8; r++) i[r] = [r, 0];
                    return {
                        update: function(r, o, s, a) {
                            const l = r.morphTargetInfluences,
                                c = void 0 === l ? 0 : l.length;
                            let h = e[o.id];
                            if (void 0 === h) {
                                h = [];
                                for (let t = 0; t < c; t++) h[t] = [t, 0];
                                e[o.id] = h
                            }
                            for (let t = 0; t < c; t++) {
                                const e = h[t];
                                e[0] = t, e[1] = l[t]
                            }
                            h.sort(os);
                            for (let t = 0; t < 8; t++) t < c && h[t][1] ? (i[t][0] = h[t][0], i[t][1] = h[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER, i[t][1] = 0);
                            i.sort(rs);
                            const u = s.morphTargets && o.morphAttributes.position,
                                d = s.morphNormals && o.morphAttributes.normal;
                            let p = 0;
                            for (let t = 0; t < 8; t++) {
                                const e = i[t],
                                    r = e[0],
                                    s = e[1];
                                r !== Number.MAX_SAFE_INTEGER && s ? (u && o.getAttribute("morphTarget" + t) !== u[r] && o.setAttribute("morphTarget" + t, u[r]), d && o.getAttribute("morphNormal" + t) !== d[r] && o.setAttribute("morphNormal" + t, d[r]), n[t] = s, p += s) : (u && !0 === o.hasAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t), d && !0 === o.hasAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t), n[t] = 0)
                            }
                            const f = o.morphTargetsRelative ? 1 : 1 - p;
                            a.getUniforms().setValue(t, "morphTargetBaseInfluence", f), a.getUniforms().setValue(t, "morphTargetInfluences", n)
                        }
                    }
                }

                function as(t, e, n, i) {
                    let r = new WeakMap;

                    function o(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", o), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
                    }
                    return {
                        update: function(t) {
                            const s = i.render.frame,
                                a = t.geometry,
                                l = e.get(t, a);
                            return r.get(l) !== s && (e.update(l), r.set(l, s)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", o) && t.addEventListener("dispose", o), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l
                        },
                        dispose: function() {
                            r = new WeakMap
                        }
                    }
                }
                Xo.physical = {
                    uniforms: Eo([Xo.standard.uniforms, {
                        clearcoat: {
                            value: 0
                        },
                        clearcoatMap: {
                            value: null
                        },
                        clearcoatRoughness: {
                            value: 0
                        },
                        clearcoatRoughnessMap: {
                            value: null
                        },
                        clearcoatNormalScale: {
                            value: new Qn(1, 1)
                        },
                        clearcoatNormalMap: {
                            value: null
                        },
                        sheen: {
                            value: new Fr(0)
                        },
                        transmission: {
                            value: 0
                        },
                        transmissionMap: {
                            value: null
                        },
                        transmissionSamplerSize: {
                            value: new Qn
                        },
                        transmissionSamplerMap: {
                            value: null
                        },
                        thickness: {
                            value: 0
                        },
                        thicknessMap: {
                            value: null
                        },
                        attenuationDistance: {
                            value: 0
                        },
                        attenuationColor: {
                            value: new Fr(0)
                        }
                    }]),
                    vertexShader: Wo.meshphysical_vert,
                    fragmentShader: Wo.meshphysical_frag
                };
                class ls extends ti {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        super(null), this.image = {
                            data: t,
                            width: e,
                            height: n,
                            depth: i
                        }, this.magFilter = ft, this.minFilter = ft, this.wrapR = dt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
                    }
                }
                ls.prototype.isDataTexture2DArray = !0;
                class cs extends ti {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        super(null), this.image = {
                            data: t,
                            width: e,
                            height: n,
                            depth: i
                        }, this.magFilter = ft, this.minFilter = ft, this.wrapR = dt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
                    }
                }
                cs.prototype.isDataTexture3D = !0;
                const hs = new ti,
                    us = new ls,
                    ds = new cs,
                    ps = new Do,
                    fs = [],
                    ms = [],
                    gs = new Float32Array(16),
                    vs = new Float32Array(9),
                    ys = new Float32Array(4);

                function xs(t, e, n) {
                    const i = t[0];
                    if (i <= 0 || i > 0) return t;
                    const r = e * n;
                    let o = fs[r];
                    if (void 0 === o && (o = new Float32Array(r), fs[r] = o), 0 !== e) {
                        i.toArray(o, 0);
                        for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(o, r)
                    }
                    return o
                }

                function bs(t, e) {
                    if (t.length !== e.length) return !1;
                    for (let n = 0, i = t.length; n < i; n++)
                        if (t[n] !== e[n]) return !1;
                    return !0
                }

                function ws(t, e) {
                    for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
                }

                function _s(t, e) {
                    let n = ms[e];
                    void 0 === n && (n = new Int32Array(e), ms[e] = n);
                    for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
                    return n
                }

                function Ss(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
                }

                function Ms(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                    else {
                        if (bs(n, e)) return;
                        t.uniform2fv(this.addr, e), ws(n, e)
                    }
                }

                function As(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                    else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                    else {
                        if (bs(n, e)) return;
                        t.uniform3fv(this.addr, e), ws(n, e)
                    }
                }

                function Ts(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                    else {
                        if (bs(n, e)) return;
                        t.uniform4fv(this.addr, e), ws(n, e)
                    }
                }

                function Es(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (bs(n, e)) return;
                        t.uniformMatrix2fv(this.addr, !1, e), ws(n, e)
                    } else {
                        if (bs(n, i)) return;
                        ys.set(i), t.uniformMatrix2fv(this.addr, !1, ys), ws(n, i)
                    }
                }

                function Cs(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (bs(n, e)) return;
                        t.uniformMatrix3fv(this.addr, !1, e), ws(n, e)
                    } else {
                        if (bs(n, i)) return;
                        vs.set(i), t.uniformMatrix3fv(this.addr, !1, vs), ws(n, i)
                    }
                }

                function Ps(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (bs(n, e)) return;
                        t.uniformMatrix4fv(this.addr, !1, e), ws(n, e)
                    } else {
                        if (bs(n, i)) return;
                        gs.set(i), t.uniformMatrix4fv(this.addr, !1, gs), ws(n, i)
                    }
                }

                function Ls(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
                }

                function Rs(t, e) {
                    const n = this.cache;
                    bs(n, e) || (t.uniform2iv(this.addr, e), ws(n, e))
                }

                function Is(t, e) {
                    const n = this.cache;
                    bs(n, e) || (t.uniform3iv(this.addr, e), ws(n, e))
                }

                function Fs(t, e) {
                    const n = this.cache;
                    bs(n, e) || (t.uniform4iv(this.addr, e), ws(n, e))
                }

                function Os(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
                }

                function Ns(t, e) {
                    const n = this.cache;
                    bs(n, e) || (t.uniform2uiv(this.addr, e), ws(n, e))
                }

                function Bs(t, e) {
                    const n = this.cache;
                    bs(n, e) || (t.uniform3uiv(this.addr, e), ws(n, e))
                }

                function Ds(t, e) {
                    const n = this.cache;
                    bs(n, e) || (t.uniform4uiv(this.addr, e), ws(n, e))
                }

                function Vs(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || hs, r)
                }

                function js(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || ds, r)
                }

                function ks(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || ps, r)
                }

                function Us(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || us, r)
                }

                function zs(t, e) {
                    t.uniform1fv(this.addr, e)
                }

                function Gs(t, e) {
                    const n = xs(e, this.size, 2);
                    t.uniform2fv(this.addr, n)
                }

                function Hs(t, e) {
                    const n = xs(e, this.size, 3);
                    t.uniform3fv(this.addr, n)
                }

                function Ws(t, e) {
                    const n = xs(e, this.size, 4);
                    t.uniform4fv(this.addr, n)
                }

                function Ys(t, e) {
                    const n = xs(e, this.size, 4);
                    t.uniformMatrix2fv(this.addr, !1, n)
                }

                function Xs(t, e) {
                    const n = xs(e, this.size, 9);
                    t.uniformMatrix3fv(this.addr, !1, n)
                }

                function qs(t, e) {
                    const n = xs(e, this.size, 16);
                    t.uniformMatrix4fv(this.addr, !1, n)
                }

                function Qs(t, e) {
                    t.uniform1iv(this.addr, e)
                }

                function Zs(t, e) {
                    t.uniform2iv(this.addr, e)
                }

                function Js(t, e) {
                    t.uniform3iv(this.addr, e)
                }

                function Ks(t, e) {
                    t.uniform4iv(this.addr, e)
                }

                function $s(t, e) {
                    t.uniform1uiv(this.addr, e)
                }

                function ta(t, e) {
                    t.uniform2uiv(this.addr, e)
                }

                function ea(t, e) {
                    t.uniform3uiv(this.addr, e)
                }

                function na(t, e) {
                    t.uniform4uiv(this.addr, e)
                }

                function ia(t, e, n) {
                    const i = e.length,
                        r = _s(n, i);
                    t.uniform1iv(this.addr, r);
                    for (let o = 0; o !== i; ++o) n.safeSetTexture2D(e[o] || hs, r[o])
                }

                function ra(t, e, n) {
                    const i = e.length,
                        r = _s(n, i);
                    t.uniform1iv(this.addr, r);
                    for (let o = 0; o !== i; ++o) n.safeSetTextureCube(e[o] || ps, r[o])
                }

                function oa(t, e, n) {
                    this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                        switch (t) {
                            case 5126:
                                return Ss;
                            case 35664:
                                return Ms;
                            case 35665:
                                return As;
                            case 35666:
                                return Ts;
                            case 35674:
                                return Es;
                            case 35675:
                                return Cs;
                            case 35676:
                                return Ps;
                            case 5124:
                            case 35670:
                                return Ls;
                            case 35667:
                            case 35671:
                                return Rs;
                            case 35668:
                            case 35672:
                                return Is;
                            case 35669:
                            case 35673:
                                return Fs;
                            case 5125:
                                return Os;
                            case 36294:
                                return Ns;
                            case 36295:
                                return Bs;
                            case 36296:
                                return Ds;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return Vs;
                            case 35679:
                            case 36299:
                            case 36307:
                                return js;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return ks;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return Us
                        }
                    }(e.type)
                }

                function sa(t, e, n) {
                    this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                        switch (t) {
                            case 5126:
                                return zs;
                            case 35664:
                                return Gs;
                            case 35665:
                                return Hs;
                            case 35666:
                                return Ws;
                            case 35674:
                                return Ys;
                            case 35675:
                                return Xs;
                            case 35676:
                                return qs;
                            case 5124:
                            case 35670:
                                return Qs;
                            case 35667:
                            case 35671:
                                return Zs;
                            case 35668:
                            case 35672:
                                return Js;
                            case 35669:
                            case 35673:
                                return Ks;
                            case 5125:
                                return $s;
                            case 36294:
                                return ta;
                            case 36295:
                                return ea;
                            case 36296:
                                return na;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return ia;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return ra
                        }
                    }(e.type)
                }

                function aa(t) {
                    this.id = t, this.seq = [], this.map = {}
                }
                sa.prototype.updateCache = function(t) {
                    const e = this.cache;
                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), ws(e, t)
                }, aa.prototype.setValue = function(t, e, n) {
                    const i = this.seq;
                    for (let r = 0, o = i.length; r !== o; ++r) {
                        const o = i[r];
                        o.setValue(t, e[o.id], n)
                    }
                };
                const la = /(\w+)(\])?(\[|\.)?/g;

                function ca(t, e) {
                    t.seq.push(e), t.map[e.id] = e
                }

                function ha(t, e, n) {
                    const i = t.name,
                        r = i.length;
                    for (la.lastIndex = 0;;) {
                        const o = la.exec(i),
                            s = la.lastIndex;
                        let a = o[1];
                        const l = "]" === o[2],
                            c = o[3];
                        if (l && (a |= 0), void 0 === c || "[" === c && s + 2 === r) {
                            ca(n, void 0 === c ? new oa(a, t, e) : new sa(a, t, e));
                            break
                        } {
                            let t = n.map[a];
                            void 0 === t && (t = new aa(a), ca(n, t)), n = t
                        }
                    }
                }

                function ua(t, e) {
                    this.seq = [], this.map = {};
                    const n = t.getProgramParameter(e, 35718);
                    for (let i = 0; i < n; ++i) {
                        const n = t.getActiveUniform(e, i);
                        ha(n, t.getUniformLocation(e, n.name), this)
                    }
                }

                function da(t, e, n) {
                    const i = t.createShader(e);
                    return t.shaderSource(i, n), t.compileShader(i), i
                }
                ua.prototype.setValue = function(t, e, n, i) {
                    const r = this.map[e];
                    void 0 !== r && r.setValue(t, n, i)
                }, ua.prototype.setOptional = function(t, e, n) {
                    const i = e[n];
                    void 0 !== i && this.setValue(t, n, i)
                }, ua.upload = function(t, e, n, i) {
                    for (let r = 0, o = e.length; r !== o; ++r) {
                        const o = e[r],
                            s = n[o.id];
                        !1 !== s.needsUpdate && o.setValue(t, s.value, i)
                    }
                }, ua.seqWithValue = function(t, e) {
                    const n = [];
                    for (let i = 0, r = t.length; i !== r; ++i) {
                        const r = t[i];
                        r.id in e && n.push(r)
                    }
                    return n
                };
                let pa = 0;

                function fa(t) {
                    switch (t) {
                        case Ze:
                            return ["Linear", "( value )"];
                        case Je:
                            return ["sRGB", "( value )"];
                        case $e:
                            return ["RGBE", "( value )"];
                        case en:
                            return ["RGBM", "( value, 7.0 )"];
                        case nn:
                            return ["RGBM", "( value, 16.0 )"];
                        case rn:
                            return ["RGBD", "( value, 256.0 )"];
                        case Ke:
                            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                        case tn:
                            return ["LogLuv", "( value )"];
                        default:
                            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                    }
                }

                function ma(t, e, n) {
                    const i = t.getShaderParameter(e, 35713),
                        r = t.getShaderInfoLog(e).trim();
                    return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function(t) {
                        const e = t.split("\n");
                        for (let n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
                        return e.join("\n")
                    }(t.getShaderSource(e))
                }

                function ga(t, e) {
                    const n = fa(e);
                    return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
                }

                function va(t, e) {
                    const n = fa(e);
                    return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
                }

                function ya(t, e) {
                    let n;
                    switch (e) {
                        case $:
                            n = "Linear";
                            break;
                        case tt:
                            n = "Reinhard";
                            break;
                        case et:
                            n = "OptimizedCineon";
                            break;
                        case nt:
                            n = "ACESFilmic";
                            break;
                        case it:
                            n = "Custom";
                            break;
                        default:
                            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                    }
                    return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }

                function xa(t) {
                    return "" !== t
                }

                function ba(t, e) {
                    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
                }

                function wa(t, e) {
                    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
                }
                const _a = /^[ \t]*#include +<([\w\d./]+)>/gm;

                function Sa(t) {
                    return t.replace(_a, Ma)
                }

                function Ma(t, e) {
                    const n = Wo[e];
                    if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
                    return Sa(n)
                }
                const Aa = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                    Ta = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

                function Ea(t) {
                    return t.replace(Ta, Pa).replace(Aa, Ca)
                }

                function Ca(t, e, n, i) {
                    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Pa(t, e, n, i)
                }

                function Pa(t, e, n, i) {
                    let r = "";
                    for (let o = parseInt(e); o < parseInt(n); o++) r += i.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
                    return r
                }

                function La(t) {
                    let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                    return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
                }

                function Ra(t, e, n, i) {
                    const r = t.getContext(),
                        o = n.defines;
                    let s = n.vertexShader,
                        a = n.fragmentShader;
                    const l = function(t) {
                            let e = "SHADOWMAP_TYPE_BASIC";
                            return t.shadowMapType === u ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === d ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === p && (e = "SHADOWMAP_TYPE_VSM"), e
                        }(n),
                        c = function(t) {
                            let e = "ENVMAP_TYPE_CUBE";
                            if (t.envMap) switch (t.envMapMode) {
                                case ot:
                                case st:
                                    e = "ENVMAP_TYPE_CUBE";
                                    break;
                                case ct:
                                case ht:
                                    e = "ENVMAP_TYPE_CUBE_UV"
                            }
                            return e
                        }(n),
                        h = function(t) {
                            let e = "ENVMAP_MODE_REFLECTION";
                            if (t.envMap) switch (t.envMapMode) {
                                case st:
                                case ht:
                                    e = "ENVMAP_MODE_REFRACTION"
                            }
                            return e
                        }(n),
                        f = function(t) {
                            let e = "ENVMAP_BLENDING_NONE";
                            if (t.envMap) switch (t.combine) {
                                case Q:
                                    e = "ENVMAP_BLENDING_MULTIPLY";
                                    break;
                                case Z:
                                    e = "ENVMAP_BLENDING_MIX";
                                    break;
                                case J:
                                    e = "ENVMAP_BLENDING_ADD"
                            }
                            return e
                        }(n),
                        m = t.gammaFactor > 0 ? t.gammaFactor : 1,
                        g = n.isWebGL2 ? "" : function(t) {
                            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission > 0) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(xa).join("\n")
                        }(n),
                        v = function(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                !1 !== i && e.push("#define " + n + " " + i)
                            }
                            return e.join("\n")
                        }(o),
                        y = r.createProgram();
                    let x, b, w = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                    n.isRawShaderMaterial ? (x = [v].filter(xa).join("\n"), x.length > 0 && (x += "\n"), b = [g, v].filter(xa).join("\n"), b.length > 0 && (b += "\n")) : (x = [La(n), "#define SHADER_NAME " + n.shaderName, v, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(xa).join("\n"), b = [g, La(n), "#define SHADER_NAME " + n.shaderName, v, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== K ? "#define TONE_MAPPING" : "", n.toneMapping !== K ? Wo.tonemapping_pars_fragment : "", n.toneMapping !== K ? ya("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", Wo.encodings_pars_fragment, n.map ? ga("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? ga("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? ga("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? ga("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? ga("lightMapTexelToLinear", n.lightMapEncoding) : "", va("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(xa).join("\n")), s = Sa(s), s = ba(s, n), s = wa(s, n), a = Sa(a), a = ba(a, n), a = wa(a, n), s = Ea(s), a = Ea(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (w = "#version 300 es\n", x = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x, b = ["#define varying in", n.glslVersion === Nn ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === Nn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b);
                    const _ = w + b + a,
                        S = da(r, 35633, w + x + s),
                        M = da(r, 35632, _);
                    if (r.attachShader(y, S), r.attachShader(y, M), void 0 !== n.index0AttributeName ? r.bindAttribLocation(y, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(y, 0, "position"), r.linkProgram(y), t.debug.checkShaderErrors) {
                        const t = r.getProgramInfoLog(y).trim(),
                            e = r.getShaderInfoLog(S).trim(),
                            n = r.getShaderInfoLog(M).trim();
                        let i = !0,
                            o = !0;
                        if (!1 === r.getProgramParameter(y, 35714)) {
                            i = !1;
                            const e = ma(r, S, "vertex"),
                                n = ma(r, M, "fragment");
                            console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(y, 35715), "gl.getProgramInfoLog", t, e, n)
                        } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (o = !1);
                        o && (this.diagnostics = {
                            runnable: i,
                            programLog: t,
                            vertexShader: {
                                log: e,
                                prefix: x
                            },
                            fragmentShader: {
                                log: n,
                                prefix: b
                            }
                        })
                    }
                    let A, T;
                    return r.deleteShader(S), r.deleteShader(M), this.getUniforms = function() {
                        return void 0 === A && (A = new ua(r, y)), A
                    }, this.getAttributes = function() {
                        return void 0 === T && (T = function(t, e) {
                            const n = {},
                                i = t.getProgramParameter(e, 35721);
                            for (let r = 0; r < i; r++) {
                                const i = t.getActiveAttrib(e, r).name;
                                n[i] = t.getAttribLocation(e, i)
                            }
                            return n
                        }(r, y)), T
                    }, this.destroy = function() {
                        i.releaseStatesOfProgram(this), r.deleteProgram(y), this.program = void 0
                    }, this.name = n.shaderName, this.id = pa++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = S, this.fragmentShader = M, this
                }

                function Ia(t, e, n, i, r, o) {
                    const s = [],
                        a = i.isWebGL2,
                        l = i.logarithmicDepthBuffer,
                        c = i.floatVertexTextures,
                        h = i.maxVertexUniforms,
                        u = i.vertexTextures;
                    let d = i.precision;
                    const p = {
                            MeshDepthMaterial: "depth",
                            MeshDistanceMaterial: "distanceRGBA",
                            MeshNormalMaterial: "normal",
                            MeshBasicMaterial: "basic",
                            MeshLambertMaterial: "lambert",
                            MeshPhongMaterial: "phong",
                            MeshToonMaterial: "toon",
                            MeshStandardMaterial: "physical",
                            MeshPhysicalMaterial: "physical",
                            MeshMatcapMaterial: "matcap",
                            LineBasicMaterial: "basic",
                            LineDashedMaterial: "dashed",
                            PointsMaterial: "points",
                            ShadowMaterial: "shadow",
                            SpriteMaterial: "sprite"
                        },
                        f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"];

                    function v(t) {
                        let e;
                        return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = Ze, e
                    }
                    return {
                        getParameters: function(r, s, f, y, x) {
                            const b = y.fog,
                                w = r.isMeshStandardMaterial ? y.environment : null,
                                _ = e.get(r.envMap || w),
                                S = p[r.type],
                                M = x.isSkinnedMesh ? function(t) {
                                    const e = t.skeleton.bones;
                                    if (c) return 1024; {
                                        const t = h,
                                            n = Math.floor((t - 20) / 4),
                                            i = Math.min(n, e.length);
                                        return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i
                                    }
                                }(x) : 0;
                            let A, T;
                            if (null !== r.precision && (d = i.getMaxPrecision(r.precision), d !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", d, "instead.")), S) {
                                const t = Xo[S];
                                A = t.vertexShader, T = t.fragmentShader
                            } else A = r.vertexShader, T = r.fragmentShader;
                            const E = t.getRenderTarget();
                            return {
                                isWebGL2: a,
                                shaderID: S,
                                shaderName: r.type,
                                vertexShader: A,
                                fragmentShader: T,
                                defines: r.defines,
                                isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                                glslVersion: r.glslVersion,
                                precision: d,
                                instancing: !0 === x.isInstancedMesh,
                                instancingColor: !0 === x.isInstancedMesh && null !== x.instanceColor,
                                supportsVertexTextures: u,
                                outputEncoding: null !== E ? v(E.texture) : t.outputEncoding,
                                map: !!r.map,
                                mapEncoding: v(r.map),
                                matcap: !!r.matcap,
                                matcapEncoding: v(r.matcap),
                                envMap: !!_,
                                envMapMode: _ && _.mapping,
                                envMapEncoding: v(_),
                                envMapCubeUV: !!_ && (_.mapping === ct || _.mapping === ht),
                                lightMap: !!r.lightMap,
                                lightMapEncoding: v(r.lightMap),
                                aoMap: !!r.aoMap,
                                emissiveMap: !!r.emissiveMap,
                                emissiveMapEncoding: v(r.emissiveMap),
                                bumpMap: !!r.bumpMap,
                                normalMap: !!r.normalMap,
                                objectSpaceNormalMap: r.normalMapType === ln,
                                tangentSpaceNormalMap: r.normalMapType === an,
                                clearcoatMap: !!r.clearcoatMap,
                                clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                                clearcoatNormalMap: !!r.clearcoatNormalMap,
                                displacementMap: !!r.displacementMap,
                                roughnessMap: !!r.roughnessMap,
                                metalnessMap: !!r.metalnessMap,
                                specularMap: !!r.specularMap,
                                alphaMap: !!r.alphaMap,
                                gradientMap: !!r.gradientMap,
                                sheen: !!r.sheen,
                                transmission: !!r.transmission,
                                transmissionMap: !!r.transmissionMap,
                                thicknessMap: !!r.thicknessMap,
                                combine: r.combine,
                                vertexTangents: r.normalMap && r.vertexTangents,
                                vertexColors: r.vertexColors,
                                vertexAlphas: !0 === r.vertexColors && x.geometry && x.geometry.attributes.color && 4 === x.geometry.attributes.color.itemSize,
                                vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmission || r.transmissionMap || r.thicknessMap),
                                uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmission || r.transmissionMap || r.thicknessMap || !r.displacementMap),
                                fog: !!b,
                                useFog: r.fog,
                                fogExp2: b && b.isFogExp2,
                                flatShading: !!r.flatShading,
                                sizeAttenuation: r.sizeAttenuation,
                                logarithmicDepthBuffer: l,
                                skinning: !0 === x.isSkinnedMesh && M > 0,
                                maxBones: M,
                                useVertexTexture: c,
                                morphTargets: r.morphTargets,
                                morphNormals: r.morphNormals,
                                numDirLights: s.directional.length,
                                numPointLights: s.point.length,
                                numSpotLights: s.spot.length,
                                numRectAreaLights: s.rectArea.length,
                                numHemiLights: s.hemi.length,
                                numDirLightShadows: s.directionalShadowMap.length,
                                numPointLightShadows: s.pointShadowMap.length,
                                numSpotLightShadows: s.spotShadowMap.length,
                                numClippingPlanes: o.numPlanes,
                                numClipIntersection: o.numIntersection,
                                dithering: r.dithering,
                                shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
                                shadowMapType: t.shadowMap.type,
                                toneMapping: r.toneMapped ? t.toneMapping : K,
                                physicallyCorrectLights: t.physicallyCorrectLights,
                                premultipliedAlpha: r.premultipliedAlpha,
                                alphaTest: r.alphaTest,
                                doubleSided: r.side === g,
                                flipSided: r.side === m,
                                depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                                index0AttributeName: r.index0AttributeName,
                                extensionDerivatives: r.extensions && r.extensions.derivatives,
                                extensionFragDepth: r.extensions && r.extensions.fragDepth,
                                extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                                extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
                                rendererExtensionFragDepth: a || n.has("EXT_frag_depth"),
                                rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"),
                                rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"),
                                customProgramCacheKey: r.customProgramCacheKey()
                            }
                        },
                        getProgramCacheKey: function(e) {
                            const n = [];
                            if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                            if (!1 === e.isRawShaderMaterial) {
                                for (let t = 0; t < f.length; t++) n.push(e[f[t]]);
                                n.push(t.outputEncoding), n.push(t.gammaFactor)
                            }
                            return n.push(e.customProgramCacheKey), n.join()
                        },
                        getUniforms: function(t) {
                            const e = p[t.type];
                            let n;
                            if (e) {
                                const t = Xo[e];
                                n = Co.clone(t.uniforms)
                            } else n = t.uniforms;
                            return n
                        },
                        acquireProgram: function(e, n) {
                            let i;
                            for (let t = 0, r = s.length; t < r; t++) {
                                const e = s[t];
                                if (e.cacheKey === n) {
                                    i = e, ++i.usedTimes;
                                    break
                                }
                            }
                            return void 0 === i && (i = new Ra(t, n, e, r), s.push(i)), i
                        },
                        releaseProgram: function(t) {
                            if (0 == --t.usedTimes) {
                                const e = s.indexOf(t);
                                s[e] = s[s.length - 1], s.pop(), t.destroy()
                            }
                        },
                        programs: s
                    }
                }

                function Fa() {
                    let t = new WeakMap;
                    return {
                        get: function(e) {
                            let n = t.get(e);
                            return void 0 === n && (n = {}, t.set(e, n)), n
                        },
                        remove: function(e) {
                            t.delete(e)
                        },
                        update: function(e, n, i) {
                            t.get(e)[n] = i
                        },
                        dispose: function() {
                            t = new WeakMap
                        }
                    }
                }

                function Oa(t, e) {
                    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
                }

                function Na(t, e) {
                    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
                }

                function Ba(t) {
                    const e = [];
                    let n = 0;
                    const i = [],
                        r = [],
                        o = [],
                        s = {
                            id: -1
                        };

                    function a(i, r, o, a, l, c) {
                        let h = e[n];
                        const u = t.get(o);
                        return void 0 === h ? (h = {
                            id: i.id,
                            object: i,
                            geometry: r,
                            material: o,
                            program: u.program || s,
                            groupOrder: a,
                            renderOrder: i.renderOrder,
                            z: l,
                            group: c
                        }, e[n] = h) : (h.id = i.id, h.object = i, h.geometry = r, h.material = o, h.program = u.program || s, h.groupOrder = a, h.renderOrder = i.renderOrder, h.z = l, h.group = c), n++, h
                    }
                    return {
                        opaque: i,
                        transmissive: r,
                        transparent: o,
                        init: function() {
                            n = 0, i.length = 0, r.length = 0, o.length = 0
                        },
                        push: function(t, e, n, s, l, c) {
                            const h = a(t, e, n, s, l, c);
                            n.transmission > 0 ? r.push(h) : !0 === n.transparent ? o.push(h) : i.push(h)
                        },
                        unshift: function(t, e, n, s, l, c) {
                            const h = a(t, e, n, s, l, c);
                            n.transmission > 0 ? r.unshift(h) : !0 === n.transparent ? o.unshift(h) : i.unshift(h)
                        },
                        finish: function() {
                            for (let t = n, i = e.length; t < i; t++) {
                                const n = e[t];
                                if (null === n.id) break;
                                n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                            }
                        },
                        sort: function(t, e) {
                            i.length > 1 && i.sort(t || Oa), r.length > 1 && r.sort(e || Na), o.length > 1 && o.sort(e || Na)
                        }
                    }
                }

                function Da(t) {
                    let e = new WeakMap;
                    return {
                        get: function(n, i) {
                            let r;
                            return !1 === e.has(n) ? (r = new Ba(t), e.set(n, [r])) : i >= e.get(n).length ? (r = new Ba(t), e.get(n).push(r)) : r = e.get(n)[i], r
                        },
                        dispose: function() {
                            e = new WeakMap
                        }
                    }
                }

                function Va() {
                    const t = {};
                    return {
                        get: function(e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                    n = {
                                        direction: new ai,
                                        color: new Fr
                                    };
                                    break;
                                case "SpotLight":
                                    n = {
                                        position: new ai,
                                        direction: new ai,
                                        color: new Fr,
                                        distance: 0,
                                        coneCos: 0,
                                        penumbraCos: 0,
                                        decay: 0
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        position: new ai,
                                        color: new Fr,
                                        distance: 0,
                                        decay: 0
                                    };
                                    break;
                                case "HemisphereLight":
                                    n = {
                                        direction: new ai,
                                        skyColor: new Fr,
                                        groundColor: new Fr
                                    };
                                    break;
                                case "RectAreaLight":
                                    n = {
                                        color: new Fr,
                                        position: new ai,
                                        halfWidth: new ai,
                                        halfHeight: new ai
                                    }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }
                let ja = 0;

                function ka(t, e) {
                    return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
                }

                function Ua(t, e) {
                    const n = new Va,
                        i = function() {
                            const t = {};
                            return {
                                get: function(e) {
                                    if (void 0 !== t[e.id]) return t[e.id];
                                    let n;
                                    switch (e.type) {
                                        case "DirectionalLight":
                                        case "SpotLight":
                                            n = {
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new Qn
                                            };
                                            break;
                                        case "PointLight":
                                            n = {
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new Qn,
                                                shadowCameraNear: 1,
                                                shadowCameraFar: 1e3
                                            }
                                    }
                                    return t[e.id] = n, n
                                }
                            }
                        }(),
                        r = {
                            version: 0,
                            hash: {
                                directionalLength: -1,
                                pointLength: -1,
                                spotLength: -1,
                                rectAreaLength: -1,
                                hemiLength: -1,
                                numDirectionalShadows: -1,
                                numPointShadows: -1,
                                numSpotShadows: -1
                            },
                            ambient: [0, 0, 0],
                            probe: [],
                            directional: [],
                            directionalShadow: [],
                            directionalShadowMap: [],
                            directionalShadowMatrix: [],
                            spot: [],
                            spotShadow: [],
                            spotShadowMap: [],
                            spotShadowMatrix: [],
                            rectArea: [],
                            rectAreaLTC1: null,
                            rectAreaLTC2: null,
                            point: [],
                            pointShadow: [],
                            pointShadowMap: [],
                            pointShadowMatrix: [],
                            hemi: []
                        };
                    for (let l = 0; l < 9; l++) r.probe.push(new ai);
                    const o = new ai,
                        s = new Vi,
                        a = new Vi;
                    return {
                        setup: function(o) {
                            let s = 0,
                                a = 0,
                                l = 0;
                            for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                            let c = 0,
                                h = 0,
                                u = 0,
                                d = 0,
                                p = 0,
                                f = 0,
                                m = 0,
                                g = 0;
                            o.sort(ka);
                            for (let t = 0, e = o.length; t < e; t++) {
                                const e = o[t],
                                    v = e.color,
                                    y = e.intensity,
                                    x = e.distance,
                                    b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                                if (e.isAmbientLight) s += v.r * y, a += v.g * y, l += v.b * y;
                                else if (e.isLightProbe)
                                    for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], y);
                                else if (e.isDirectionalLight) {
                                    const t = n.get(e);
                                    if (t.color.copy(e.color).multiplyScalar(e.intensity), e.castShadow) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[c] = n, r.directionalShadowMap[c] = b, r.directionalShadowMatrix[c] = e.shadow.matrix, f++
                                    }
                                    r.directional[c] = t, c++
                                } else if (e.isSpotLight) {
                                    const t = n.get(e);
                                    if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(v).multiplyScalar(y), t.distance = x, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.spotShadow[u] = n, r.spotShadowMap[u] = b, r.spotShadowMatrix[u] = e.shadow.matrix, g++
                                    }
                                    r.spot[u] = t, u++
                                } else if (e.isRectAreaLight) {
                                    const t = n.get(e);
                                    t.color.copy(v).multiplyScalar(y), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[d] = t, d++
                                } else if (e.isPointLight) {
                                    const t = n.get(e);
                                    if (t.color.copy(e.color).multiplyScalar(e.intensity), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[h] = n, r.pointShadowMap[h] = b, r.pointShadowMatrix[h] = e.shadow.matrix, m++
                                    }
                                    r.point[h] = t, h++
                                } else if (e.isHemisphereLight) {
                                    const t = n.get(e);
                                    t.skyColor.copy(e.color).multiplyScalar(y), t.groundColor.copy(e.groundColor).multiplyScalar(y), r.hemi[p] = t, p++
                                }
                            }
                            d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Yo.LTC_FLOAT_1, r.rectAreaLTC2 = Yo.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Yo.LTC_HALF_1, r.rectAreaLTC2 = Yo.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = s, r.ambient[1] = a, r.ambient[2] = l;
                            const v = r.hash;
                            v.directionalLength === c && v.pointLength === h && v.spotLength === u && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === f && v.numPointShadows === m && v.numSpotShadows === g || (r.directional.length = c, r.spot.length = u, r.rectArea.length = d, r.point.length = h, r.hemi.length = p, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = m, r.pointShadowMap.length = m, r.spotShadow.length = g, r.spotShadowMap.length = g, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = m, r.spotShadowMatrix.length = g, v.directionalLength = c, v.pointLength = h, v.spotLength = u, v.rectAreaLength = d, v.hemiLength = p, v.numDirectionalShadows = f, v.numPointShadows = m, v.numSpotShadows = g, r.version = ja++)
                        },
                        setupView: function(t, e) {
                            let n = 0,
                                i = 0,
                                l = 0,
                                c = 0,
                                h = 0;
                            const u = e.matrixWorldInverse;
                            for (let d = 0, p = t.length; d < p; d++) {
                                const e = t[d];
                                if (e.isDirectionalLight) {
                                    const t = r.directional[n];
                                    t.direction.setFromMatrixPosition(e.matrixWorld), o.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(u), n++
                                } else if (e.isSpotLight) {
                                    const t = r.spot[l];
                                    t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(e.matrixWorld), o.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(u), l++
                                } else if (e.isRectAreaLight) {
                                    const t = r.rectArea[c];
                                    t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(u), a.identity(), s.copy(e.matrixWorld), s.premultiply(u), a.extractRotation(s), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), c++
                                } else if (e.isPointLight) {
                                    const t = r.point[i];
                                    t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(u), i++
                                } else if (e.isHemisphereLight) {
                                    const t = r.hemi[h];
                                    t.direction.setFromMatrixPosition(e.matrixWorld), t.direction.transformDirection(u), t.direction.normalize(), h++
                                }
                            }
                        },
                        state: r
                    }
                }

                function za(t, e) {
                    const n = new Ua(t, e),
                        i = [],
                        r = [];
                    return {
                        init: function() {
                            i.length = 0, r.length = 0
                        },
                        state: {
                            lightsArray: i,
                            shadowsArray: r,
                            lights: n
                        },
                        setupLights: function() {
                            n.setup(i)
                        },
                        setupLightsView: function(t) {
                            n.setupView(i, t)
                        },
                        pushLight: function(t) {
                            i.push(t)
                        },
                        pushShadow: function(t) {
                            r.push(t)
                        }
                    }
                }

                function Ga(t, e) {
                    let n = new WeakMap;
                    return {
                        get: function(i) {
                            let r, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return !1 === n.has(i) ? (r = new za(t, e), n.set(i, [r])) : o >= n.get(i).length ? (r = new za(t, e), n.get(i).push(r)) : r = n.get(i)[o], r
                        },
                        dispose: function() {
                            n = new WeakMap
                        }
                    }
                }
                class Ha extends Tr {
                    constructor(t) {
                        super(), this.type = "MeshDepthMaterial", this.depthPacking = on, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.depthPacking = t.depthPacking, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
                    }
                }
                Ha.prototype.isMeshDepthMaterial = !0;
                class Wa extends Tr {
                    constructor(t) {
                        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new ai, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
                    }
                }
                Wa.prototype.isMeshDistanceMaterial = !0;
                var Ya = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
                    Xa = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

                function qa(t, e, n) {
                    let i = new Uo;
                    const r = new Qn,
                        o = new Qn,
                        s = new ni,
                        a = [],
                        l = [],
                        c = {},
                        h = n.maxTextureSize,
                        d = {
                            0: m,
                            1: f,
                            2: g
                        },
                        v = new Ro({
                            defines: {
                                SAMPLE_RATE: .25,
                                HALF_SAMPLE_RATE: 1 / 8
                            },
                            uniforms: {
                                shadow_pass: {
                                    value: null
                                },
                                resolution: {
                                    value: new Qn
                                },
                                radius: {
                                    value: 4
                                }
                            },
                            vertexShader: Xa,
                            fragmentShader: Ya
                        }),
                        y = v.clone();
                    y.defines.HORIZONTAL_PASS = 1;
                    const b = new ro;
                    b.setAttribute("position", new Dr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                    const w = new So(b, v),
                        _ = this;

                    function S(n, i) {
                        const r = e.update(w);
                        v.uniforms.shadow_pass.value = n.map.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, v, w, null), y.uniforms.shadow_pass.value = n.mapPass.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, y, w, null)
                    }

                    function M(t) {
                        const e = 0 | t;
                        let n = a[e];
                        return void 0 === n && (n = new Ha({
                            depthPacking: sn,
                            morphTargets: t
                        }), a[e] = n), n
                    }

                    function A(t) {
                        const e = 0 | t;
                        let n = l[e];
                        return void 0 === n && (n = new Wa({
                            morphTargets: t
                        }), l[e] = n), n
                    }

                    function T(e, n, i, r, o, s, a) {
                        let l = null,
                            h = M,
                            u = e.customDepthMaterial;
                        if (!0 === r.isPointLight && (h = A, u = e.customDistanceMaterial), void 0 === u) {
                            let t = !1;
                            !0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0), l = h(t)
                        } else l = u;
                        if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                            const t = l.uuid,
                                e = i.uuid;
                            let n = c[t];
                            void 0 === n && (n = {}, c[t] = n);
                            let r = n[e];
                            void 0 === r && (r = l.clone(), n[e] = r), l = r
                        }
                        return l.visible = i.visible, l.wireframe = i.wireframe, l.side = a === p ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : d[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = o, l.farDistance = s), l
                    }

                    function E(n, r, o, s, a) {
                        if (!1 === n.visible) return;
                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === p) && (!n.frustumCulled || i.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                            const i = e.update(n),
                                r = n.material;
                            if (Array.isArray(r)) {
                                const e = i.groups;
                                for (let l = 0, c = e.length; l < c; l++) {
                                    const c = e[l],
                                        h = r[c.materialIndex];
                                    if (h && h.visible) {
                                        const e = T(n, i, h, s, o.near, o.far, a);
                                        t.renderBufferDirect(o, null, i, e, n, c)
                                    }
                                }
                            } else if (r.visible) {
                                const e = T(n, i, r, s, o.near, o.far, a);
                                t.renderBufferDirect(o, null, i, e, n, null)
                            }
                        }
                        const l = n.children;
                        for (let t = 0, e = l.length; t < e; t++) E(l[t], r, o, s, a)
                    }
                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = u, this.render = function(e, n, a) {
                        if (!1 === _.enabled) return;
                        if (!1 === _.autoUpdate && !1 === _.needsUpdate) return;
                        if (0 === e.length) return;
                        const l = t.getRenderTarget(),
                            c = t.getActiveCubeFace(),
                            u = t.getActiveMipmapLevel(),
                            d = t.state;
                        d.setBlending(x), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                        for (let f = 0, m = e.length; f < m; f++) {
                            const l = e[f],
                                c = l.shadow;
                            if (void 0 === c) {
                                console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                                continue
                            }
                            if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
                            r.copy(c.mapSize);
                            const u = c.getFrameExtents();
                            if (r.multiply(u), o.copy(c.mapSize), (r.x > h || r.y > h) && (r.x > h && (o.x = Math.floor(h / u.x), r.x = o.x * u.x, c.mapSize.x = o.x), r.y > h && (o.y = Math.floor(h / u.y), r.y = o.y * u.y, c.mapSize.y = o.y)), null === c.map && !c.isPointLightShadow && this.type === p) {
                                const t = {
                                    minFilter: xt,
                                    magFilter: xt,
                                    format: Vt
                                };
                                c.map = new ii(r.x, r.y, t), c.map.texture.name = l.name + ".shadowMap", c.mapPass = new ii(r.x, r.y, t), c.camera.updateProjectionMatrix()
                            }
                            if (null === c.map) {
                                const t = {
                                    minFilter: ft,
                                    magFilter: ft,
                                    format: Vt
                                };
                                c.map = new ii(r.x, r.y, t), c.map.texture.name = l.name + ".shadowMap", c.camera.updateProjectionMatrix()
                            }
                            t.setRenderTarget(c.map), t.clear();
                            const m = c.getViewportCount();
                            for (let t = 0; t < m; t++) {
                                const e = c.getViewport(t);
                                s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w), d.viewport(s), c.updateMatrices(l, t), i = c.getFrustum(), E(n, a, c.camera, l, this.type)
                            }
                            c.isPointLightShadow || this.type !== p || S(c, a), c.needsUpdate = !1
                        }
                        _.needsUpdate = !1, t.setRenderTarget(l, c, u)
                    }
                }

                function Qa(t, e, n) {
                    const i = n.isWebGL2,
                        r = new function() {
                            let e = !1;
                            const n = new ni;
                            let i = null;
                            const r = new ni(0, 0, 0, 0);
                            return {
                                setMask: function(n) {
                                    i === n || e || (t.colorMask(n, n, n, n), i = n)
                                },
                                setLocked: function(t) {
                                    e = t
                                },
                                setClear: function(e, i, o, s, a) {
                                    !0 === a && (e *= s, i *= s, o *= s), n.set(e, i, o, s), !1 === r.equals(n) && (t.clearColor(e, i, o, s), r.copy(n))
                                },
                                reset: function() {
                                    e = !1, i = null, r.set(-1, 0, 0, 0)
                                }
                            }
                        },
                        o = new function() {
                            let e = !1,
                                n = null,
                                i = null,
                                r = null;
                            return {
                                setTest: function(t) {
                                    t ? yt(2929) : xt(2929)
                                },
                                setMask: function(i) {
                                    n === i || e || (t.depthMask(i), n = i)
                                },
                                setFunc: function(e) {
                                    if (i !== e) {
                                        if (e) switch (e) {
                                            case U:
                                                t.depthFunc(512);
                                                break;
                                            case z:
                                                t.depthFunc(519);
                                                break;
                                            case G:
                                                t.depthFunc(513);
                                                break;
                                            case H:
                                                t.depthFunc(515);
                                                break;
                                            case W:
                                                t.depthFunc(514);
                                                break;
                                            case Y:
                                                t.depthFunc(518);
                                                break;
                                            case X:
                                                t.depthFunc(516);
                                                break;
                                            case q:
                                                t.depthFunc(517);
                                                break;
                                            default:
                                                t.depthFunc(515)
                                        } else t.depthFunc(515);
                                        i = e
                                    }
                                },
                                setLocked: function(t) {
                                    e = t
                                },
                                setClear: function(e) {
                                    r !== e && (t.clearDepth(e), r = e)
                                },
                                reset: function() {
                                    e = !1, n = null, i = null, r = null
                                }
                            }
                        },
                        c = new function() {
                            let e = !1,
                                n = null,
                                i = null,
                                r = null,
                                o = null,
                                s = null,
                                a = null,
                                l = null,
                                c = null;
                            return {
                                setTest: function(t) {
                                    e || (t ? yt(2960) : xt(2960))
                                },
                                setMask: function(i) {
                                    n === i || e || (t.stencilMask(i), n = i)
                                },
                                setFunc: function(e, n, s) {
                                    i === e && r === n && o === s || (t.stencilFunc(e, n, s), i = e, r = n, o = s)
                                },
                                setOp: function(e, n, i) {
                                    s === e && a === n && l === i || (t.stencilOp(e, n, i), s = e, a = n, l = i)
                                },
                                setLocked: function(t) {
                                    e = t
                                },
                                setClear: function(e) {
                                    c !== e && (t.clearStencil(e), c = e)
                                },
                                reset: function() {
                                    e = !1, n = null, i = null, r = null, o = null, s = null, a = null, l = null, c = null
                                }
                            }
                        };
                    let h = {},
                        u = null,
                        d = {},
                        p = null,
                        f = !1,
                        v = null,
                        y = null,
                        Q = null,
                        Z = null,
                        J = null,
                        K = null,
                        $ = null,
                        tt = !1,
                        et = null,
                        nt = null,
                        it = null,
                        rt = null,
                        ot = null;
                    const st = t.getParameter(35661);
                    let at = !1,
                        lt = 0;
                    const ct = t.getParameter(7938); - 1 !== ct.indexOf("WebGL") ? (lt = parseFloat(/^WebGL (\d)/.exec(ct)[1]), at = lt >= 1) : -1 !== ct.indexOf("OpenGL ES") && (lt = parseFloat(/^OpenGL ES (\d)/.exec(ct)[1]), at = lt >= 2);
                    let ht = null,
                        ut = {};
                    const dt = t.getParameter(3088),
                        pt = t.getParameter(2978),
                        ft = (new ni).fromArray(dt),
                        mt = (new ni).fromArray(pt);

                    function gt(e, n, i) {
                        const r = new Uint8Array(4),
                            o = t.createTexture();
                        t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                        for (let s = 0; s < i; s++) t.texImage2D(n + s, 0, 6408, 1, 1, 0, 6408, 5121, r);
                        return o
                    }
                    const vt = {};

                    function yt(e) {
                        !0 !== h[e] && (t.enable(e), h[e] = !0)
                    }

                    function xt(e) {
                        !1 !== h[e] && (t.disable(e), h[e] = !1)
                    }
                    vt[3553] = gt(3553, 3553, 1), vt[34067] = gt(34067, 34069, 6), r.setClear(0, 0, 0, 1), o.setClear(1), c.setClear(0), yt(2929), o.setFunc(H), St(!1), Mt(a), yt(2884), _t(x);
                    const bt = {
                        [A]: 32774,
                        [T]: 32778,
                        [E]: 32779
                    };
                    if (i) bt[C] = 32775, bt[P] = 32776;
                    else {
                        const t = e.get("EXT_blend_minmax");
                        null !== t && (bt[C] = t.MIN_EXT, bt[P] = t.MAX_EXT)
                    }
                    const wt = {
                        [L]: 0,
                        [R]: 1,
                        [I]: 768,
                        [O]: 770,
                        [k]: 776,
                        [V]: 774,
                        [B]: 772,
                        [F]: 769,
                        [N]: 771,
                        [j]: 775,
                        [D]: 773
                    };

                    function _t(e, n, i, r, o, s, a, l) {
                        if (e !== x) {
                            if (!1 === f && (yt(3042), f = !0), e === M) o = o || n, s = s || i, a = a || r, n === y && o === J || (t.blendEquationSeparate(bt[n], bt[o]), y = n, J = o), i === Q && r === Z && s === K && a === $ || (t.blendFuncSeparate(wt[i], wt[r], wt[s], wt[a]), Q = i, Z = r, K = s, $ = a), v = e, tt = null;
                            else if (e !== v || l !== tt) {
                                if (y === A && J === A || (t.blendEquation(32774), y = A, J = A), l) switch (e) {
                                    case b:
                                        t.blendFuncSeparate(1, 771, 1, 771);
                                        break;
                                    case w:
                                        t.blendFunc(1, 1);
                                        break;
                                    case _:
                                        t.blendFuncSeparate(0, 0, 769, 771);
                                        break;
                                    case S:
                                        t.blendFuncSeparate(0, 768, 0, 770);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", e)
                                } else switch (e) {
                                    case b:
                                        t.blendFuncSeparate(770, 771, 1, 771);
                                        break;
                                    case w:
                                        t.blendFunc(770, 1);
                                        break;
                                    case _:
                                        t.blendFunc(0, 769);
                                        break;
                                    case S:
                                        t.blendFunc(0, 768);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", e)
                                }
                                Q = null, Z = null, K = null, $ = null, v = e, tt = l
                            }
                        } else !0 === f && (xt(3042), f = !1)
                    }

                    function St(e) {
                        et !== e && (e ? t.frontFace(2304) : t.frontFace(2305), et = e)
                    }

                    function Mt(e) {
                        e !== s ? (yt(2884), e !== nt && (e === a ? t.cullFace(1029) : e === l ? t.cullFace(1028) : t.cullFace(1032))) : xt(2884), nt = e
                    }

                    function At(e, n, i) {
                        e ? (yt(32823), rt === n && ot === i || (t.polygonOffset(n, i), rt = n, ot = i)) : xt(32823)
                    }

                    function Tt(e) {
                        void 0 === e && (e = 33984 + st - 1), ht !== e && (t.activeTexture(e), ht = e)
                    }
                    return {
                        buffers: {
                            color: r,
                            depth: o,
                            stencil: c
                        },
                        enable: yt,
                        disable: xt,
                        bindFramebuffer: function(e, n) {
                            return null === n && null !== u && (n = u), d[e] !== n && (t.bindFramebuffer(e, n), d[e] = n, i && (36009 === e && (d[36160] = n), 36160 === e && (d[36009] = n)), !0)
                        },
                        bindXRFramebuffer: function(e) {
                            e !== u && (t.bindFramebuffer(36160, e), u = e)
                        },
                        useProgram: function(e) {
                            return p !== e && (t.useProgram(e), p = e, !0)
                        },
                        setBlending: _t,
                        setMaterial: function(t, e) {
                            t.side === g ? xt(2884) : yt(2884);
                            let n = t.side === m;
                            e && (n = !n), St(n), t.blending === b && !1 === t.transparent ? _t(x) : _t(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), r.setMask(t.colorWrite);
                            const i = t.stencilWrite;
                            c.setTest(i), i && (c.setMask(t.stencilWriteMask), c.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), c.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), At(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? yt(32926) : xt(32926)
                        },
                        setFlipSided: St,
                        setCullFace: Mt,
                        setLineWidth: function(e) {
                            e !== it && (at && t.lineWidth(e), it = e)
                        },
                        setPolygonOffset: At,
                        setScissorTest: function(t) {
                            t ? yt(3089) : xt(3089)
                        },
                        activeTexture: Tt,
                        bindTexture: function(e, n) {
                            null === ht && Tt();
                            let i = ut[ht];
                            void 0 === i && (i = {
                                type: void 0,
                                texture: void 0
                            }, ut[ht] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || vt[e]), i.type = e, i.texture = n)
                        },
                        unbindTexture: function() {
                            const e = ut[ht];
                            void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                        },
                        compressedTexImage2D: function() {
                            try {
                                t.compressedTexImage2D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        texImage2D: function() {
                            try {
                                t.texImage2D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        texImage3D: function() {
                            try {
                                t.texImage3D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        scissor: function(e) {
                            !1 === ft.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), ft.copy(e))
                        },
                        viewport: function(e) {
                            !1 === mt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), mt.copy(e))
                        },
                        reset: function() {
                            t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), h = {}, ht = null, ut = {}, u = null, d = {}, p = null, f = !1, v = null, y = null, Q = null, Z = null, J = null, K = null, $ = null, tt = !1, et = null, nt = null, it = null, rt = null, ot = null, ft.set(0, 0, t.canvas.width, t.canvas.height), mt.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), o.reset(), c.reset()
                        }
                    }
                }

                function Za(t, e, n, i, r, o, s) {
                    const a = r.isWebGL2,
                        l = r.maxTextures,
                        c = r.maxCubemapSize,
                        h = r.maxTextureSize,
                        u = r.maxSamples,
                        d = new WeakMap;
                    let p, f = !1;
                    try {
                        f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                    } catch (t) {}

                    function m(t, e) {
                        return f ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                    }

                    function g(t, e, n, i) {
                        let r = 1;
                        if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                            if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                                const i = e ? Xn : Math.floor,
                                    o = i(r * t.width),
                                    s = i(r * t.height);
                                void 0 === p && (p = m(o, s));
                                const a = n ? m(o, s) : p;
                                return a.width = o, a.height = s, a.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), a
                            }
                            return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                        }
                        return t
                    }

                    function v(t) {
                        return Wn(t.width) && Wn(t.height)
                    }

                    function y(t, e) {
                        return t.generateMipmaps && e && t.minFilter !== ft && t.minFilter !== xt
                    }

                    function x(e, n, r, o) {
                        t.generateMipmap(e), i.get(n).__maxMipLevel = Math.log2(Math.max(r, o))
                    }

                    function b(n, i, r) {
                        if (!1 === a) return i;
                        if (null !== n) {
                            if (void 0 !== t[n]) return t[n];
                            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                        }
                        let o = i;
                        return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 6407 === i && (5126 === r && (o = 34837), 5131 === r && (o = 34843), 5121 === r && (o = 32849)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o
                    }

                    function w(t) {
                        return t === ft || t === mt || t === vt ? 9728 : 9729
                    }

                    function _(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", _),
                            function(e) {
                                const n = i.get(e);
                                void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), i.remove(e))
                            }(n), n.isVideoTexture && d.delete(n), s.memory.textures--
                    }

                    function S(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", S),
                            function(e) {
                                const n = e.texture,
                                    r = i.get(e),
                                    o = i.get(n);
                                if (e) {
                                    if (void 0 !== o.__webglTexture && (t.deleteTexture(o.__webglTexture), s.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                                        for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                                    else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                                    if (e.isWebGLMultipleRenderTargets)
                                        for (let e = 0, r = n.length; e < r; e++) {
                                            const r = i.get(n[e]);
                                            r.__webglTexture && (t.deleteTexture(r.__webglTexture), s.memory.textures--), i.remove(n[e])
                                        }
                                    i.remove(n), i.remove(e)
                                }
                            }(n)
                    }
                    let M = 0;

                    function A(t, e) {
                        const r = i.get(t);
                        if (t.isVideoTexture && function(t) {
                                const e = s.render.frame;
                                d.get(t) !== e && (d.set(t, e), t.update())
                            }(t), t.version > 0 && r.__version !== t.version) {
                            const n = t.image;
                            if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                            else {
                                if (!1 !== n.complete) return void R(r, t, e);
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                            }
                        }
                        n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
                    }

                    function T(e, r) {
                        const s = i.get(e);
                        e.version > 0 && s.__version !== e.version ? function(e, i, r) {
                            if (6 !== i.image.length) return;
                            L(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                            const s = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                                l = i.image[0] && i.image[0].isDataTexture,
                                h = [];
                            for (let t = 0; t < 6; t++) h[t] = s || l ? l ? i.image[t].image : i.image[t] : g(i.image[t], !1, !0, c);
                            const u = h[0],
                                d = v(u) || a,
                                p = o.convert(i.format),
                                f = o.convert(i.type),
                                m = b(i.internalFormat, p, f);
                            let w;
                            if (P(34067, i, d), s) {
                                for (let t = 0; t < 6; t++) {
                                    w = h[t].mipmaps;
                                    for (let e = 0; e < w.length; e++) {
                                        const r = w[e];
                                        i.format !== Vt && i.format !== Dt ? null !== p ? n.compressedTexImage2D(34069 + t, e, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, m, r.width, r.height, 0, p, f, r.data)
                                    }
                                }
                                e.__maxMipLevel = w.length - 1
                            } else {
                                w = i.mipmaps;
                                for (let t = 0; t < 6; t++)
                                    if (l) {
                                        n.texImage2D(34069 + t, 0, m, h[t].width, h[t].height, 0, p, f, h[t].data);
                                        for (let e = 0; e < w.length; e++) {
                                            const i = w[e].image[t].image;
                                            n.texImage2D(34069 + t, e + 1, m, i.width, i.height, 0, p, f, i.data)
                                        }
                                    } else {
                                        n.texImage2D(34069 + t, 0, m, p, f, h[t]);
                                        for (let e = 0; e < w.length; e++) {
                                            const i = w[e];
                                            n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t])
                                        }
                                    }
                                e.__maxMipLevel = w.length
                            }
                            y(i, d) && x(34067, i, u.width, u.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                        }(s, e, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture))
                    }
                    const E = {
                            [ut]: 10497,
                            [dt]: 33071,
                            [pt]: 33648
                        },
                        C = {
                            [ft]: 9728,
                            [mt]: 9984,
                            [vt]: 9986,
                            [xt]: 9729,
                            [bt]: 9985,
                            [_t]: 9987
                        };

                    function P(n, o, s) {
                        if (s ? (t.texParameteri(n, 10242, E[o.wrapS]), t.texParameteri(n, 10243, E[o.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, E[o.wrapR]), t.texParameteri(n, 10240, C[o.magFilter]), t.texParameteri(n, 10241, C[o.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), o.wrapS === dt && o.wrapT === dt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, w(o.magFilter)), t.texParameteri(n, 10241, w(o.minFilter)), o.minFilter !== ft && o.minFilter !== xt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                            const s = e.get("EXT_texture_filter_anisotropic");
                            if (o.type === Lt && !1 === e.has("OES_texture_float_linear")) return;
                            if (!1 === a && o.type === Rt && !1 === e.has("OES_texture_half_float_linear")) return;
                            (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy)
                        }
                    }

                    function L(e, n) {
                        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", _), e.__webglTexture = t.createTexture(), s.memory.textures++)
                    }

                    function R(e, i, r) {
                        let s = 3553;
                        i.isDataTexture2DArray && (s = 35866), i.isDataTexture3D && (s = 32879), L(e, i), n.activeTexture(33984 + r), n.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                        const l = function(t) {
                                return !a && (t.wrapS !== dt || t.wrapT !== dt || t.minFilter !== ft && t.minFilter !== xt)
                            }(i) && !1 === v(i.image),
                            c = g(i.image, l, !1, h),
                            u = v(c) || a,
                            d = o.convert(i.format);
                        let p, f = o.convert(i.type),
                            m = b(i.internalFormat, d, f);
                        P(s, i, u);
                        const w = i.mipmaps;
                        if (i.isDepthTexture) m = 6402, a ? m = i.type === Lt ? 36012 : i.type === Pt ? 33190 : i.type === Nt ? 35056 : 33189 : i.type === Lt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === zt && 6402 === m && i.type !== Et && i.type !== Pt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = Et, f = o.convert(i.type)), i.format === Gt && 6402 === m && (m = 34041, i.type !== Nt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Nt, f = o.convert(i.type))), n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
                        else if (i.isDataTexture)
                            if (w.length > 0 && u) {
                                for (let t = 0, e = w.length; t < e; t++) p = w[t], n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                                i.generateMipmaps = !1, e.__maxMipLevel = w.length - 1
                            } else n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data), e.__maxMipLevel = 0;
                        else if (i.isCompressedTexture) {
                            for (let t = 0, e = w.length; t < e; t++) p = w[t], i.format !== Vt && i.format !== Dt ? null !== d ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                            e.__maxMipLevel = w.length - 1
                        } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), e.__maxMipLevel = 0;
                        else if (i.isDataTexture3D) n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), e.__maxMipLevel = 0;
                        else if (w.length > 0 && u) {
                            for (let t = 0, e = w.length; t < e; t++) p = w[t], n.texImage2D(3553, t, m, d, f, p);
                            i.generateMipmaps = !1, e.__maxMipLevel = w.length - 1
                        } else n.texImage2D(3553, 0, m, d, f, c), e.__maxMipLevel = 0;
                        y(i, u) && x(s, i, c.width, c.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                    }

                    function I(e, r, s, a, l) {
                        const c = o.convert(s.format),
                            h = o.convert(s.type),
                            u = b(s.internalFormat, c, h);
                        32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null), n.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, l, i.get(s).__webglTexture, 0), n.bindFramebuffer(36160, null)
                    }

                    function F(e, n, i) {
                        if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                            let r = 33189;
                            if (i) {
                                const e = n.depthTexture;
                                e && e.isDepthTexture && (e.type === Lt ? r = 36012 : e.type === Pt && (r = 33190));
                                const i = N(n);
                                t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                            } else t.renderbufferStorage(36161, r, n.width, n.height);
                            t.framebufferRenderbuffer(36160, 36096, 36161, e)
                        } else if (n.depthBuffer && n.stencilBuffer) {
                            if (i) {
                                const e = N(n);
                                t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                            } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                            t.framebufferRenderbuffer(36160, 33306, 36161, e)
                        } else {
                            const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                                r = o.convert(e.format),
                                s = o.convert(e.type),
                                a = b(e.internalFormat, r, s);
                            if (i) {
                                const e = N(n);
                                t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
                            } else t.renderbufferStorage(36161, a, n.width, n.height)
                        }
                        t.bindRenderbuffer(36161, null)
                    }

                    function O(e) {
                        const r = i.get(e),
                            o = !0 === e.isWebGLCubeRenderTarget;
                        if (e.depthTexture) {
                            if (o) throw new Error("target.depthTexture not supported in Cube render targets");
                            ! function(e, r) {
                                if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                                if (n.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                                i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), A(r.depthTexture, 0);
                                const o = i.get(r.depthTexture).__webglTexture;
                                if (r.depthTexture.format === zt) t.framebufferTexture2D(36160, 36096, 3553, o, 0);
                                else {
                                    if (r.depthTexture.format !== Gt) throw new Error("Unknown depthTexture format");
                                    t.framebufferTexture2D(36160, 33306, 3553, o, 0)
                                }
                            }(r.__webglFramebuffer, e)
                        } else if (o) {
                            r.__webglDepthbuffer = [];
                            for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), F(r.__webglDepthbuffer[i], e, !1)
                        } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), F(r.__webglDepthbuffer, e, !1);
                        n.bindFramebuffer(36160, null)
                    }

                    function N(t) {
                        return a && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0
                    }
                    let B = !1,
                        D = !1;
                    this.allocateTextureUnit = function() {
                        const t = M;
                        return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), M += 1, t
                    }, this.resetTextureUnits = function() {
                        M = 0
                    }, this.setTexture2D = A, this.setTexture2DArray = function(t, e) {
                        const r = i.get(t);
                        t.version > 0 && r.__version !== t.version ? R(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
                    }, this.setTexture3D = function(t, e) {
                        const r = i.get(t);
                        t.version > 0 && r.__version !== t.version ? R(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
                    }, this.setTextureCube = T, this.setupRenderTarget = function(e) {
                        const l = e.texture,
                            c = i.get(e),
                            h = i.get(l);
                        e.addEventListener("dispose", S), !0 !== e.isWebGLMultipleRenderTargets && (h.__webglTexture = t.createTexture(), h.__version = l.version, s.memory.textures++);
                        const u = !0 === e.isWebGLCubeRenderTarget,
                            d = !0 === e.isWebGLMultipleRenderTargets,
                            p = !0 === e.isWebGLMultisampleRenderTarget,
                            f = l.isDataTexture3D || l.isDataTexture2DArray,
                            m = v(e) || a;
                        if (!a || l.format !== Dt || l.type !== Lt && l.type !== Rt || (l.format = Vt, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) {
                            c.__webglFramebuffer = [];
                            for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer()
                        } else if (c.__webglFramebuffer = t.createFramebuffer(), d)
                            if (r.drawBuffers) {
                                const n = e.texture;
                                for (let e = 0, r = n.length; e < r; e++) {
                                    const r = i.get(n[e]);
                                    void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), s.memory.textures++)
                                }
                            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                        else if (p)
                            if (a) {
                                c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                                const i = o.convert(l.format),
                                    r = o.convert(l.type),
                                    s = b(l.internalFormat, i, r),
                                    a = N(e);
                                t.renderbufferStorageMultisample(36161, a, s, e.width, e.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), F(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                        if (u) {
                            n.bindTexture(34067, h.__webglTexture), P(34067, l, m);
                            for (let t = 0; t < 6; t++) I(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                            y(l, m) && x(34067, l, e.width, e.height), n.bindTexture(34067, null)
                        } else if (d) {
                            const t = e.texture;
                            for (let r = 0, o = t.length; r < o; r++) {
                                const o = t[r],
                                    s = i.get(o);
                                n.bindTexture(3553, s.__webglTexture), P(3553, o, m), I(c.__webglFramebuffer, e, o, 36064 + r, 3553), y(o, m) && x(3553, o, e.width, e.height)
                            }
                            n.bindTexture(3553, null)
                        } else {
                            let t = 3553;
                            f && (a ? t = l.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(t, h.__webglTexture), P(t, l, m), I(c.__webglFramebuffer, e, l, 36064, t), y(l, m) && x(3553, l, e.width, e.height), n.bindTexture(3553, null)
                        }
                        e.depthBuffer && O(e)
                    }, this.updateRenderTargetMipmap = function(t) {
                        const e = v(t) || a,
                            r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                        for (let o = 0, s = r.length; o < s; o++) {
                            const s = r[o];
                            if (y(s, e)) {
                                const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                                    r = i.get(s).__webglTexture;
                                n.bindTexture(e, r), x(e, s, t.width, t.height), n.bindTexture(e, null)
                            }
                        }
                    }, this.updateMultisampleRenderTarget = function(e) {
                        if (e.isWebGLMultisampleRenderTarget)
                            if (a) {
                                const r = e.width,
                                    o = e.height;
                                let s = 16384;
                                e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024);
                                const a = i.get(e);
                                n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, a.__webglFramebuffer), t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                    }, this.safeSetTexture2D = function(t, e) {
                        t && t.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), A(t, e)
                    }, this.safeSetTextureCube = function(t, e) {
                        t && t.isWebGLCubeRenderTarget && (!1 === D && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), D = !0), t = t.texture), T(t, e)
                    }
                }

                function Ja(t, e, n) {
                    const i = n.isWebGL2;
                    return {
                        convert: function(t) {
                            let n;
                            if (t === Mt) return 5121;
                            if (t === It) return 32819;
                            if (t === Ft) return 32820;
                            if (t === Ot) return 33635;
                            if (t === At) return 5120;
                            if (t === Tt) return 5122;
                            if (t === Et) return 5123;
                            if (t === Ct) return 5124;
                            if (t === Pt) return 5125;
                            if (t === Lt) return 5126;
                            if (t === Rt) return i ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
                            if (t === Bt) return 6406;
                            if (t === Dt) return 6407;
                            if (t === Vt) return 6408;
                            if (t === jt) return 6409;
                            if (t === kt) return 6410;
                            if (t === zt) return 6402;
                            if (t === Gt) return 34041;
                            if (t === Ht) return 6403;
                            if (t === Wt) return 36244;
                            if (t === Yt) return 33319;
                            if (t === Xt) return 33320;
                            if (t === qt) return 36248;
                            if (t === Qt) return 36249;
                            if (t === Zt || t === Jt || t === Kt || t === $t) {
                                if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
                                if (t === Zt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (t === Jt) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (t === Kt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (t === $t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                            if (t === te || t === ee || t === ne || t === ie) {
                                if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
                                if (t === te) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (t === ee) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (t === ne) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (t === ie) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                            }
                            if (t === re) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                            if ((t === oe || t === se) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) {
                                if (t === oe) return n.COMPRESSED_RGB8_ETC2;
                                if (t === se) return n.COMPRESSED_RGBA8_ETC2_EAC
                            }
                            return t === ae || t === le || t === ce || t === he || t === ue || t === de || t === pe || t === fe || t === me || t === ge || t === ve || t === ye || t === xe || t === be || t === _e || t === Se || t === Me || t === Ae || t === Te || t === Ee || t === Ce || t === Pe || t === Le || t === Re || t === Ie || t === Fe || t === Oe || t === Ne ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : t === we ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : t === Nt ? i ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                        }
                    }
                }
                class Ka extends Fo {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        super(), this.cameras = t
                    }
                }
                Ka.prototype.isArrayCamera = !0;
                class $a extends cr {
                    constructor() {
                        super(), this.type = "Group"
                    }
                }
                $a.prototype.isGroup = !0;
                const tl = {
                    type: "move"
                };
                class el {
                    constructor() {
                        this._targetRay = null, this._grip = null, this._hand = null
                    }
                    getHandSpace() {
                        return null === this._hand && (this._hand = new $a, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                            pinching: !1
                        }), this._hand
                    }
                    getTargetRaySpace() {
                        return null === this._targetRay && (this._targetRay = new $a, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ai, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ai), this._targetRay
                    }
                    getGripSpace() {
                        return null === this._grip && (this._grip = new $a, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ai, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ai), this._grip
                    }
                    dispatchEvent(t) {
                        return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                    }
                    disconnect(t) {
                        return this.dispatchEvent({
                            type: "disconnected",
                            data: t
                        }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                    }
                    update(t, e, n) {
                        let i = null,
                            r = null,
                            o = null;
                        const s = this._targetRay,
                            a = this._grip,
                            l = this._hand;
                        if (t && "visible-blurred" !== e.session.visibilityState)
                            if (null !== s && (i = e.getPose(t.targetRaySpace, n), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(tl))), l && t.hand) {
                                o = !0;
                                for (const o of t.hand.values()) {
                                    const t = e.getJointPose(o, n);
                                    if (void 0 === l.joints[o.jointName]) {
                                        const t = new $a;
                                        t.matrixAutoUpdate = !1, t.visible = !1, l.joints[o.jointName] = t, l.add(t)
                                    }
                                    const i = l.joints[o.jointName];
                                    null !== t && (i.matrix.fromArray(t.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.jointRadius = t.radius), i.visible = null !== t
                                }
                                const i = l.joints["index-finger-tip"],
                                    r = l.joints["thumb-tip"],
                                    s = i.position.distanceTo(r.position),
                                    a = .02,
                                    c = .005;
                                l.inputState.pinching && s > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                                    type: "pinchend",
                                    handedness: t.handedness,
                                    target: this
                                })) : !l.inputState.pinching && s <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({
                                    type: "pinchstart",
                                    handedness: t.handedness,
                                    target: this
                                }))
                            } else null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
                        return null !== s && (s.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== o), this
                    }
                }
                class nl extends Bn {
                    constructor(t, e) {
                        super();
                        const n = this,
                            i = t.state;
                        let r = null,
                            o = 1,
                            s = null,
                            a = "local-floor",
                            l = null;
                        const c = [],
                            h = new Map,
                            u = new Fo;
                        u.layers.enable(1), u.viewport = new ni;
                        const d = new Fo;
                        d.layers.enable(2), d.viewport = new ni;
                        const p = [u, d],
                            f = new Ka;
                        f.layers.enable(1), f.layers.enable(2);
                        let m = null,
                            g = null;

                        function v(t) {
                            const e = h.get(t.inputSource);
                            e && e.dispatchEvent({
                                type: t.type,
                                data: t.inputSource
                            })
                        }

                        function y() {
                            h.forEach((function(t, e) {
                                t.disconnect(e)
                            })), h.clear(), m = null, g = null, i.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), M.stop(), n.isPresenting = !1, n.dispatchEvent({
                                type: "sessionend"
                            })
                        }

                        function x(t) {
                            const e = r.inputSources;
                            for (let n = 0; n < c.length; n++) h.set(e[n], c[n]);
                            for (let n = 0; n < t.removed.length; n++) {
                                const e = t.removed[n],
                                    i = h.get(e);
                                i && (i.dispatchEvent({
                                    type: "disconnected",
                                    data: e
                                }), h.delete(e))
                            }
                            for (let n = 0; n < t.added.length; n++) {
                                const e = t.added[n],
                                    i = h.get(e);
                                i && i.dispatchEvent({
                                    type: "connected",
                                    data: e
                                })
                            }
                        }
                        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                            let e = c[t];
                            return void 0 === e && (e = new el, c[t] = e), e.getTargetRaySpace()
                        }, this.getControllerGrip = function(t) {
                            let e = c[t];
                            return void 0 === e && (e = new el, c[t] = e), e.getGripSpace()
                        }, this.getHand = function(t) {
                            let e = c[t];
                            return void 0 === e && (e = new el, c[t] = e), e.getHandSpace()
                        }, this.setFramebufferScaleFactor = function(t) {
                            o = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                        }, this.setReferenceSpaceType = function(t) {
                            a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                        }, this.getReferenceSpace = function() {
                            return s
                        }, this.getSession = function() {
                            return r
                        }, this.setSession = async function(t) {
                            if (r = t, null !== r) {
                                r.addEventListener("select", v), r.addEventListener("selectstart", v), r.addEventListener("selectend", v), r.addEventListener("squeeze", v), r.addEventListener("squeezestart", v), r.addEventListener("squeezeend", v), r.addEventListener("end", y), r.addEventListener("inputsourceschange", x);
                                const t = e.getContextAttributes();
                                !0 !== t.xrCompatible && await e.makeXRCompatible();
                                const i = {
                                        antialias: t.antialias,
                                        alpha: t.alpha,
                                        depth: t.depth,
                                        stencil: t.stencil,
                                        framebufferScaleFactor: o
                                    },
                                    l = new XRWebGLLayer(r, e, i);
                                r.updateRenderState({
                                    baseLayer: l
                                }), s = await r.requestReferenceSpace(a), M.setContext(r), M.start(), n.isPresenting = !0, n.dispatchEvent({
                                    type: "sessionstart"
                                })
                            }
                        };
                        const b = new ai,
                            w = new ai;

                        function _(t, e) {
                            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                        }
                        this.updateCamera = function(t) {
                            if (null === r) return;
                            f.near = d.near = u.near = t.near, f.far = d.far = u.far = t.far, m === f.near && g === f.far || (r.updateRenderState({
                                depthNear: f.near,
                                depthFar: f.far
                            }), m = f.near, g = f.far);
                            const e = t.parent,
                                n = f.cameras;
                            _(f, e);
                            for (let r = 0; r < n.length; r++) _(n[r], e);
                            t.matrixWorld.copy(f.matrixWorld), t.matrix.copy(f.matrix), t.matrix.decompose(t.position, t.quaternion, t.scale);
                            const i = t.children;
                            for (let r = 0, o = i.length; r < o; r++) i[r].updateMatrixWorld(!0);
                            2 === n.length ? function(t, e, n) {
                                b.setFromMatrixPosition(e.matrixWorld), w.setFromMatrixPosition(n.matrixWorld);
                                const i = b.distanceTo(w),
                                    r = e.projectionMatrix.elements,
                                    o = n.projectionMatrix.elements,
                                    s = r[14] / (r[10] - 1),
                                    a = r[14] / (r[10] + 1),
                                    l = (r[9] + 1) / r[5],
                                    c = (r[9] - 1) / r[5],
                                    h = (r[8] - 1) / r[0],
                                    u = (o[8] + 1) / o[0],
                                    d = s * h,
                                    p = s * u,
                                    f = i / (-h + u),
                                    m = f * -h;
                                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                                const g = s + f,
                                    v = a + f,
                                    y = d - m,
                                    x = p + (i - m),
                                    _ = l * a / v * g,
                                    S = c * a / v * g;
                                t.projectionMatrix.makePerspective(y, x, _, S, g, v)
                            }(f, u, d) : f.projectionMatrix.copy(u.projectionMatrix)
                        }, this.getCamera = function() {
                            return f
                        };
                        let S = null;
                        const M = new zo;
                        M.setAnimationLoop((function(t, e) {
                            if (l = e.getViewerPose(s), null !== l) {
                                const t = l.views,
                                    e = r.renderState.baseLayer;
                                i.bindXRFramebuffer(e.framebuffer);
                                let n = !1;
                                t.length !== f.cameras.length && (f.cameras.length = 0, n = !0);
                                for (let i = 0; i < t.length; i++) {
                                    const r = t[i],
                                        o = e.getViewport(r),
                                        s = p[i];
                                    s.matrix.fromArray(r.transform.matrix), s.projectionMatrix.fromArray(r.projectionMatrix), s.viewport.set(o.x, o.y, o.width, o.height), 0 === i && f.matrix.copy(s.matrix), !0 === n && f.cameras.push(s)
                                }
                            }
                            const n = r.inputSources;
                            for (let i = 0; i < c.length; i++) {
                                const t = c[i],
                                    r = n[i];
                                t.update(r, e, s)
                            }
                            S && S(t, e)
                        })), this.setAnimationLoop = function(t) {
                            S = t
                        }, this.dispose = function() {}
                    }
                }

                function il(t) {
                    function e(e, n) {
                        e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
                        const i = t.get(n).envMap;
                        if (i) {
                            e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio;
                            const r = t.get(i).__maxMipLevel;
                            void 0 !== r && (e.maxMipLevel.value = r)
                        }
                        let r, o;
                        n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? o = n.aoMap : n.lightMap && (o = n.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), e.uv2Transform.value.copy(o.matrix))
                    }

                    function n(e, n) {
                        e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === m && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === m && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
                    }
                    return {
                        refreshFogUniforms: function(t, e) {
                            t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                        },
                        refreshMaterialUniforms: function(t, i, r, o, s) {
                            i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function(t, e) {
                                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                            }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function(t, e) {
                                e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                            }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function(t, e) {
                                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                            }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function(t, e, i) {
                                n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen), e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === m && t.clearcoatNormalScale.value.negate()), t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), e.transmission > 0 && (t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height)), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)
                            }(t, i, s) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function(t, e) {
                                e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                            }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function(t, e) {
                                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                            }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function(t, e) {
                                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                            }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function(t, e) {
                                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                            }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                            }(t, i), i.isLineDashedMaterial && function(t, e) {
                                t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                            }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                                let r;
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? r = e.map : e.alphaMap && (r = e.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                            }(t, i, r, o) : i.isSpriteMaterial ? function(t, e) {
                                let n;
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                            }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                        }
                    }
                }

                function rl(t) {
                    const e = void 0 !== (t = t || {}).canvas ? t.canvas : function() {
                            const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                            return t.style.display = "block", t
                        }(),
                        n = void 0 !== t.context ? t.context : null,
                        i = void 0 !== t.alpha && t.alpha,
                        r = void 0 === t.depth || t.depth,
                        o = void 0 === t.stencil || t.stencil,
                        s = void 0 !== t.antialias && t.antialias,
                        a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                        l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                        c = void 0 !== t.powerPreference ? t.powerPreference : "default",
                        h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                    let u = null,
                        d = null;
                    const p = [],
                        f = [];
                    this.domElement = e, this.debug = {
                        checkShaderErrors: !0
                    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Ze, this.physicallyCorrectLights = !1, this.toneMapping = K, this.toneMappingExposure = 1;
                    const m = this;
                    let g = !1,
                        v = 0,
                        y = 0,
                        x = null,
                        b = -1,
                        w = null;
                    const _ = new ni,
                        S = new ni;
                    let M = null,
                        A = e.width,
                        T = e.height,
                        E = 1,
                        C = null,
                        P = null;
                    const L = new ni(0, 0, A, T),
                        R = new ni(0, 0, A, T);
                    let I = !1;
                    const F = [],
                        O = new Uo;
                    let N = !1,
                        B = !1,
                        D = null;
                    const V = new Vi,
                        j = new ai,
                        k = {
                            background: null,
                            fog: null,
                            environment: null,
                            overrideMaterial: null,
                            isScene: !0
                        };

                    function U() {
                        return null === x ? E : 1
                    }
                    let z, G, H, W, Y, X, q, Q, Z, J, $, tt, et, nt, it, rt, ot, st, at, lt, ct, ht, ut = n;

                    function pt(t, n) {
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i],
                                o = e.getContext(r, n);
                            if (null !== o) return o
                        }
                        return null
                    }
                    try {
                        const t = {
                            alpha: i,
                            depth: r,
                            stencil: o,
                            antialias: s,
                            premultipliedAlpha: a,
                            preserveDrawingBuffer: l,
                            powerPreference: c,
                            failIfMajorPerformanceCaveat: h
                        };
                        if (e.addEventListener("webglcontextlost", vt, !1), e.addEventListener("webglcontextrestored", yt, !1), null === ut) {
                            const e = ["webgl2", "webgl", "experimental-webgl"];
                            if (!0 === m.isWebGL1Renderer && e.shift(), ut = pt(e, t), null === ut) throw pt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                        }
                        void 0 === ut.getShaderPrecisionFormat && (ut.getShaderPrecisionFormat = function() {
                            return {
                                rangeMin: 1,
                                rangeMax: 1,
                                precision: 1
                            }
                        })
                    } catch (t) {
                        throw console.error("THREE.WebGLRenderer: " + t.message), t
                    }

                    function mt() {
                        z = new ts(ut), G = new Jo(ut, z, t), z.init(G), ct = new Ja(ut, z, G), H = new Qa(ut, z, G), F[0] = 1029, W = new is(ut), Y = new Fa, X = new Za(ut, z, H, Y, G, ct, W), q = new $o(m), Q = new Go(ut, G), ht = new Qo(ut, z, Q, G), Z = new es(ut, Q, W, ht), J = new as(ut, Z, Q, W), st = new ss(ut), it = new Ko(Y), $ = new Ia(m, q, z, G, ht, it), tt = new il(Y), et = new Da(Y), nt = new Ga(z, G), ot = new qo(m, q, H, J, a), rt = new qa(m, J, G), at = new Zo(ut, z, W, G), lt = new ns(ut, z, W, G), W.programs = $.programs, m.capabilities = G, m.extensions = z, m.properties = Y, m.renderLists = et, m.shadowMap = rt, m.state = H, m.info = W
                    }
                    mt();
                    const gt = new nl(m, ut);

                    function vt(t) {
                        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0
                    }

                    function yt() {
                        console.log("THREE.WebGLRenderer: Context Restored."), g = !1;
                        const t = W.autoReset,
                            e = rt.enabled,
                            n = rt.autoUpdate,
                            i = rt.needsUpdate,
                            r = rt.type;
                        mt(), W.autoReset = t, rt.enabled = e, rt.autoUpdate = n, rt.needsUpdate = i, rt.type = r
                    }

                    function xt(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", xt),
                            function(t) {
                                (function(t) {
                                    const e = Y.get(t).programs;
                                    void 0 !== e && e.forEach((function(t) {
                                        $.releaseProgram(t)
                                    }))
                                })(t), Y.remove(t)
                            }(e)
                    }
                    this.xr = gt, this.getContext = function() {
                        return ut
                    }, this.getContextAttributes = function() {
                        return ut.getContextAttributes()
                    }, this.forceContextLoss = function() {
                        const t = z.get("WEBGL_lose_context");
                        t && t.loseContext()
                    }, this.forceContextRestore = function() {
                        const t = z.get("WEBGL_lose_context");
                        t && t.restoreContext()
                    }, this.getPixelRatio = function() {
                        return E
                    }, this.setPixelRatio = function(t) {
                        void 0 !== t && (E = t, this.setSize(A, T, !1))
                    }, this.getSize = function(t) {
                        return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new Qn), t.set(A, T)
                    }, this.setSize = function(t, n, i) {
                        gt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (A = t, T = n, e.width = Math.floor(t * E), e.height = Math.floor(n * E), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                    }, this.getDrawingBufferSize = function(t) {
                        return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new Qn), t.set(A * E, T * E).floor()
                    }, this.setDrawingBufferSize = function(t, n, i) {
                        A = t, T = n, E = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
                    }, this.getCurrentViewport = function(t) {
                        return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new ni), t.copy(_)
                    }, this.getViewport = function(t) {
                        return t.copy(L)
                    }, this.setViewport = function(t, e, n, i) {
                        t.isVector4 ? L.set(t.x, t.y, t.z, t.w) : L.set(t, e, n, i), H.viewport(_.copy(L).multiplyScalar(E).floor())
                    }, this.getScissor = function(t) {
                        return t.copy(R)
                    }, this.setScissor = function(t, e, n, i) {
                        t.isVector4 ? R.set(t.x, t.y, t.z, t.w) : R.set(t, e, n, i), H.scissor(S.copy(R).multiplyScalar(E).floor())
                    }, this.getScissorTest = function() {
                        return I
                    }, this.setScissorTest = function(t) {
                        H.setScissorTest(I = t)
                    }, this.setOpaqueSort = function(t) {
                        C = t
                    }, this.setTransparentSort = function(t) {
                        P = t
                    }, this.getClearColor = function(t) {
                        return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), t = new Fr), t.copy(ot.getClearColor())
                    }, this.setClearColor = function() {
                        ot.setClearColor.apply(ot, arguments)
                    }, this.getClearAlpha = function() {
                        return ot.getClearAlpha()
                    }, this.setClearAlpha = function() {
                        ot.setClearAlpha.apply(ot, arguments)
                    }, this.clear = function(t, e, n) {
                        let i = 0;
                        (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), ut.clear(i)
                    }, this.clearColor = function() {
                        this.clear(!0, !1, !1)
                    }, this.clearDepth = function() {
                        this.clear(!1, !0, !1)
                    }, this.clearStencil = function() {
                        this.clear(!1, !1, !0)
                    }, this.dispose = function() {
                        e.removeEventListener("webglcontextlost", vt, !1), e.removeEventListener("webglcontextrestored", yt, !1), et.dispose(), nt.dispose(), Y.dispose(), q.dispose(), J.dispose(), ht.dispose(), gt.dispose(), gt.removeEventListener("sessionstart", wt), gt.removeEventListener("sessionend", St), D && (D.dispose(), D = null), At.stop()
                    }, this.renderBufferImmediate = function(t, e) {
                        ht.initAttributes();
                        const n = Y.get(t);
                        t.hasPositions && !n.position && (n.position = ut.createBuffer()), t.hasNormals && !n.normal && (n.normal = ut.createBuffer()), t.hasUvs && !n.uv && (n.uv = ut.createBuffer()), t.hasColors && !n.color && (n.color = ut.createBuffer());
                        const i = e.getAttributes();
                        t.hasPositions && (ut.bindBuffer(34962, n.position), ut.bufferData(34962, t.positionArray, 35048), ht.enableAttribute(i.position), ut.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (ut.bindBuffer(34962, n.normal), ut.bufferData(34962, t.normalArray, 35048), ht.enableAttribute(i.normal), ut.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (ut.bindBuffer(34962, n.uv), ut.bufferData(34962, t.uvArray, 35048), ht.enableAttribute(i.uv), ut.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (ut.bindBuffer(34962, n.color), ut.bufferData(34962, t.colorArray, 35048), ht.enableAttribute(i.color), ut.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), ht.disableUnusedAttributes(), ut.drawArrays(4, 0, t.count), t.count = 0
                    }, this.renderBufferDirect = function(t, e, n, i, r, o) {
                        null === e && (e = k);
                        const s = r.isMesh && r.matrixWorld.determinant() < 0,
                            a = It(t, e, i, r);
                        H.setMaterial(i, s);
                        let l = n.index;
                        const c = n.attributes.position;
                        if (null === l) {
                            if (void 0 === c || 0 === c.count) return
                        } else if (0 === l.count) return;
                        let h, u = 1;
                        !0 === i.wireframe && (l = Z.getWireframeAttribute(n), u = 2), (i.morphTargets || i.morphNormals) && st.update(r, n, i, a), ht.setup(r, i, a, n, l);
                        let d = at;
                        null !== l && (h = Q.get(l), d = lt, d.setIndex(h));
                        const p = null !== l ? l.count : c.count,
                            f = n.drawRange.start * u,
                            m = n.drawRange.count * u,
                            g = null !== o ? o.start * u : 0,
                            v = null !== o ? o.count * u : 1 / 0,
                            y = Math.max(f, g),
                            x = Math.min(p, f + m, g + v) - 1,
                            b = Math.max(0, x - y + 1);
                        if (0 !== b) {
                            if (r.isMesh) !0 === i.wireframe ? (H.setLineWidth(i.wireframeLinewidth * U()), d.setMode(1)) : d.setMode(4);
                            else if (r.isLine) {
                                let t = i.linewidth;
                                void 0 === t && (t = 1), H.setLineWidth(t * U()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                            } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                            if (r.isInstancedMesh) d.renderInstances(y, b, r.count);
                            else if (n.isInstancedBufferGeometry) {
                                const t = Math.min(n.instanceCount, n._maxInstanceCount);
                                d.renderInstances(y, b, t)
                            } else d.render(y, b)
                        }
                    }, this.compile = function(t, e) {
                        d = nt.get(t), d.init(), t.traverseVisible((function(t) {
                            t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t))
                        })), d.setupLights(), t.traverse((function(e) {
                            const n = e.material;
                            if (n)
                                if (Array.isArray(n))
                                    for (let i = 0; i < n.length; i++) Ct(n[i], t, e);
                                else Ct(n, t, e)
                        }))
                    };
                    let bt = null;

                    function wt() {
                        At.stop()
                    }

                    function St() {
                        At.start()
                    }
                    const At = new zo;

                    function Tt(t, e, n) {
                        const i = !0 === e.isScene ? e.overrideMaterial : null;
                        for (let r = 0, o = t.length; r < o; r++) {
                            const o = t[r],
                                s = o.object,
                                a = o.geometry,
                                l = null === i ? o.material : i,
                                c = o.group;
                            if (n.isArrayCamera) {
                                const t = n.cameras;
                                for (let n = 0, i = t.length; n < i; n++) {
                                    const i = t[n];
                                    s.layers.test(i.layers) && (H.viewport(_.copy(i.viewport)), d.setupLightsView(i), Et(s, e, i, a, l, c))
                                }
                            } else Et(s, e, n, a, l, c)
                        }
                    }

                    function Et(t, e, n, i, r, o) {
                        if (t.onBeforeRender(m, e, n, i, r, o), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                            const i = It(n, e, r, t);
                            H.setMaterial(r), ht.reset(),
                                function(t, e) {
                                    t.render((function(t) {
                                        m.renderBufferImmediate(t, e)
                                    }))
                                }(t, i)
                        } else m.renderBufferDirect(n, e, i, r, t, o);
                        t.onAfterRender(m, e, n, i, r, o)
                    }

                    function Ct(t, e, n) {
                        !0 !== e.isScene && (e = k);
                        const i = Y.get(t),
                            r = d.state.lights,
                            o = d.state.shadowsArray,
                            s = r.state.version,
                            a = $.getParameters(t, r.state, o, e, n),
                            l = $.getProgramCacheKey(a);
                        let c = i.programs;
                        i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = q.get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", xt), c = new Map, i.programs = c);
                        let h = c.get(l);
                        if (void 0 !== h) {
                            if (i.currentProgram === h && i.lightsStateVersion === s) return Pt(t, a), h
                        } else a.uniforms = $.getUniforms(t), t.onBuild(a, m), t.onBeforeCompile(a, m), h = $.acquireProgram(a, l), c.set(l, h), i.uniforms = a.uniforms;
                        const u = i.uniforms;
                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = it.uniform), Pt(t, a), i.needsLights = function(t) {
                            return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                        }(t), i.lightsStateVersion = s, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                        const p = h.getUniforms(),
                            f = ua.seqWithValue(p.seq, u);
                        return i.currentProgram = h, i.uniformsList = f, h
                    }

                    function Pt(t, e) {
                        const n = Y.get(t);
                        n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas
                    }

                    function It(t, e, n, i) {
                        !0 !== e.isScene && (e = k), X.resetTextureUnits();
                        const r = e.fog,
                            o = n.isMeshStandardMaterial ? e.environment : null,
                            s = null === x ? m.outputEncoding : x.texture.encoding,
                            a = q.get(n.envMap || o),
                            l = !0 === n.vertexColors && i.geometry && i.geometry.attributes.color && 4 === i.geometry.attributes.color.itemSize,
                            c = Y.get(n),
                            h = d.state.lights;
                        if (!0 === N && (!0 === B || t !== w)) {
                            const e = t === w && n.id === b;
                            it.setState(n, t, e)
                        }
                        let u = !1;
                        n.version === c.__version ? c.needsLights && c.lightsStateVersion !== h.state.version || c.outputEncoding !== s || i.isInstancedMesh && !1 === c.instancing ? u = !0 : i.isInstancedMesh || !0 !== c.instancing ? i.isSkinnedMesh && !1 === c.skinning ? u = !0 : i.isSkinnedMesh || !0 !== c.skinning ? c.envMap !== a || n.fog && c.fog !== r ? u = !0 : void 0 === c.numClippingPlanes || c.numClippingPlanes === it.numPlanes && c.numIntersection === it.numIntersection ? c.vertexAlphas !== l && (u = !0) : u = !0 : u = !0 : u = !0 : (u = !0, c.__version = n.version);
                        let p = c.currentProgram;
                        !0 === u && (p = Ct(n, e, i));
                        let f = !1,
                            g = !1,
                            v = !1;
                        const y = p.getUniforms(),
                            _ = c.uniforms;
                        if (H.useProgram(p.program) && (f = !0, g = !0, v = !0), n.id !== b && (b = n.id, g = !0), f || w !== t) {
                            if (y.setValue(ut, "projectionMatrix", t.projectionMatrix), G.logarithmicDepthBuffer && y.setValue(ut, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), w !== t && (w = t, g = !0, v = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                                const e = y.map.cameraPosition;
                                void 0 !== e && e.setValue(ut, j.setFromMatrixPosition(t.matrixWorld))
                            }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && y.setValue(ut, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || i.isSkinnedMesh) && y.setValue(ut, "viewMatrix", t.matrixWorldInverse)
                        }
                        if (i.isSkinnedMesh) {
                            y.setOptional(ut, i, "bindMatrix"), y.setOptional(ut, i, "bindMatrixInverse");
                            const t = i.skeleton;
                            t && (G.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), y.setValue(ut, "boneTexture", t.boneTexture, X), y.setValue(ut, "boneTextureSize", t.boneTextureSize)) : y.setOptional(ut, t, "boneMatrices"))
                        }
                        var S, M;
                        return (g || c.receiveShadow !== i.receiveShadow) && (c.receiveShadow = i.receiveShadow, y.setValue(ut, "receiveShadow", i.receiveShadow)), g && (y.setValue(ut, "toneMappingExposure", m.toneMappingExposure), c.needsLights && (M = v, (S = _).ambientLightColor.needsUpdate = M, S.lightProbe.needsUpdate = M, S.directionalLights.needsUpdate = M, S.directionalLightShadows.needsUpdate = M, S.pointLights.needsUpdate = M, S.pointLightShadows.needsUpdate = M, S.spotLights.needsUpdate = M, S.spotLightShadows.needsUpdate = M, S.rectAreaLights.needsUpdate = M, S.hemisphereLights.needsUpdate = M), r && n.fog && tt.refreshFogUniforms(_, r), tt.refreshMaterialUniforms(_, n, E, T, D), ua.upload(ut, c.uniformsList, _, X)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (ua.upload(ut, c.uniformsList, _, X), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && y.setValue(ut, "center", i.center), y.setValue(ut, "modelViewMatrix", i.modelViewMatrix), y.setValue(ut, "normalMatrix", i.normalMatrix), y.setValue(ut, "modelMatrix", i.matrixWorld), p
                    }
                    At.setAnimationLoop((function(t) {
                        bt && bt(t)
                    })), "undefined" != typeof window && At.setContext(window), this.setAnimationLoop = function(t) {
                        bt = t, gt.setAnimationLoop(t), null === t ? At.stop() : At.start()
                    }, gt.addEventListener("sessionstart", wt), gt.addEventListener("sessionend", St), this.render = function(t, e) {
                        if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        if (!0 === g) return;
                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === gt.enabled && !0 === gt.isPresenting && (!0 === gt.cameraAutoUpdate && gt.updateCamera(e), e = gt.getCamera()), !0 === t.isScene && t.onBeforeRender(m, t, e, x), d = nt.get(t, f.length), d.init(), f.push(d), V.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), O.setFromProjectionMatrix(V), B = this.localClippingEnabled, N = it.init(this.clippingPlanes, B, e), u = et.get(t, p.length), u.init(), p.push(u),
                            function t(e, n, i, r) {
                                if (!1 === e.visible) return;
                                if (e.layers.test(n.layers))
                                    if (e.isGroup) i = e.renderOrder;
                                    else if (e.isLOD) !0 === e.autoUpdate && e.update(n);
                                else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
                                else if (e.isSprite) {
                                    if (!e.frustumCulled || O.intersectsSprite(e)) {
                                        r && j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);
                                        const t = J.update(e),
                                            n = e.material;
                                        n.visible && u.push(e, t, n, i, j.z, null)
                                    }
                                } else if (e.isImmediateRenderObject) r && j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V), u.push(e, null, e.material, i, j.z, null);
                                else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== W.render.frame && (e.skeleton.update(), e.skeleton.frame = W.render.frame), !e.frustumCulled || O.intersectsObject(e))) {
                                    r && j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);
                                    const t = J.update(e),
                                        n = e.material;
                                    if (Array.isArray(n)) {
                                        const r = t.groups;
                                        for (let o = 0, s = r.length; o < s; o++) {
                                            const s = r[o],
                                                a = n[s.materialIndex];
                                            a && a.visible && u.push(e, t, a, i, j.z, s)
                                        }
                                    } else n.visible && u.push(e, t, n, i, j.z, null)
                                }
                                const o = e.children;
                                for (let s = 0, a = o.length; s < a; s++) t(o[s], n, i, r)
                            }(t, e, 0, m.sortObjects), u.finish(), !0 === m.sortObjects && u.sort(C, P), !0 === N && it.beginShadows();
                        const n = d.state.shadowsArray;
                        rt.render(n, t, e), d.setupLights(), d.setupLightsView(e), !0 === N && it.endShadows(), !0 === this.info.autoReset && this.info.reset(), ot.render(u, t);
                        const i = u.opaque,
                            r = u.transmissive,
                            o = u.transparent;
                        i.length > 0 && Tt(i, t, e), r.length > 0 && function(t, e, n, i) {
                            null === D && (D = new ii(1024, 1024, {
                                generateMipmaps: !0,
                                minFilter: _t,
                                magFilter: ft,
                                wrapS: dt,
                                wrapT: dt
                            }));
                            const r = m.getRenderTarget();
                            m.setRenderTarget(D), m.clear(), Tt(t, n, i), X.updateRenderTargetMipmap(D), m.setRenderTarget(r), Tt(e, n, i)
                        }(i, r, t, e), o.length > 0 && Tt(o, t, e), null !== x && (X.updateRenderTargetMipmap(x), X.updateMultisampleRenderTarget(x)), !0 === t.isScene && t.onAfterRender(m, t, e), H.buffers.depth.setTest(!0), H.buffers.depth.setMask(!0), H.buffers.color.setMask(!0), H.setPolygonOffset(!1), ht.resetDefaultState(), b = -1, w = null, f.pop(), d = f.length > 0 ? f[f.length - 1] : null, p.pop(), u = p.length > 0 ? p[p.length - 1] : null
                    }, this.getActiveCubeFace = function() {
                        return v
                    }, this.getActiveMipmapLevel = function() {
                        return y
                    }, this.getRenderTarget = function() {
                        return x
                    }, this.setRenderTarget = function(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        x = t, v = e, y = n, t && void 0 === Y.get(t).__webglFramebuffer && X.setupRenderTarget(t);
                        let i = null,
                            r = !1,
                            o = !1;
                        if (t) {
                            const n = t.texture;
                            (n.isDataTexture3D || n.isDataTexture2DArray) && (o = !0);
                            const s = Y.get(t).__webglFramebuffer;
                            t.isWebGLCubeRenderTarget ? (i = s[e], r = !0) : i = t.isWebGLMultisampleRenderTarget ? Y.get(t).__webglMultisampledFramebuffer : s, _.copy(t.viewport), S.copy(t.scissor), M = t.scissorTest
                        } else _.copy(L).multiplyScalar(E).floor(), S.copy(R).multiplyScalar(E).floor(), M = I;
                        if (H.bindFramebuffer(36160, i) && G.drawBuffers) {
                            let e = !1;
                            if (t)
                                if (t.isWebGLMultipleRenderTargets) {
                                    const n = t.texture;
                                    if (F.length !== n.length || 36064 !== F[0]) {
                                        for (let t = 0, e = n.length; t < e; t++) F[t] = 36064 + t;
                                        F.length = n.length, e = !0
                                    }
                                } else 1 === F.length && 36064 === F[0] || (F[0] = 36064, F.length = 1, e = !0);
                            else 1 === F.length && 1029 === F[0] || (F[0] = 1029, F.length = 1, e = !0);
                            e && (G.isWebGL2 ? ut.drawBuffers(F) : z.get("WEBGL_draw_buffers").drawBuffersWEBGL(F))
                        }
                        if (H.viewport(_), H.scissor(S), H.setScissorTest(M), r) {
                            const i = Y.get(t.texture);
                            ut.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                        } else if (o) {
                            const i = Y.get(t.texture),
                                r = e || 0;
                            ut.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                        }
                    }, this.readRenderTargetPixels = function(t, e, n, i, r, o, s) {
                        if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        let a = Y.get(t).__webglFramebuffer;
                        if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) {
                            H.bindFramebuffer(36160, a);
                            try {
                                const s = t.texture,
                                    a = s.format,
                                    l = s.type;
                                if (a !== Vt && ct.convert(a) !== ut.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                const c = l === Rt && (z.has("EXT_color_buffer_half_float") || G.isWebGL2 && z.has("EXT_color_buffer_float"));
                                if (!(l === Mt || ct.convert(l) === ut.getParameter(35738) || l === Lt && (G.isWebGL2 || z.has("OES_texture_float") || z.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === ut.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && ut.readPixels(e, n, i, r, ct.convert(a), ct.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                const t = null !== x ? Y.get(x).__webglFramebuffer : null;
                                H.bindFramebuffer(36160, t)
                            }
                        }
                    }, this.copyFramebufferToTexture = function(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        const i = Math.pow(2, -n),
                            r = Math.floor(e.image.width * i),
                            o = Math.floor(e.image.height * i);
                        let s = ct.convert(e.format);
                        G.isWebGL2 && (6407 === s && (s = 32849), 6408 === s && (s = 32856)), X.setTexture2D(e, 0), ut.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0), H.unbindTexture()
                    }, this.copyTextureToTexture = function(t, e, n) {
                        let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                        const r = e.image.width,
                            o = e.image.height,
                            s = ct.convert(n.format),
                            a = ct.convert(n.type);
                        X.setTexture2D(n, 0), ut.pixelStorei(37440, n.flipY), ut.pixelStorei(37441, n.premultiplyAlpha), ut.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? ut.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data) : e.isCompressedTexture ? ut.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : ut.texSubImage2D(3553, i, t.x, t.y, s, a, e.image), 0 === i && n.generateMipmaps && ut.generateMipmap(3553), H.unbindTexture()
                    }, this.copyTextureToTexture3D = function(t, e, n, i) {
                        let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                        if (m.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                        const {
                            width: o,
                            height: s,
                            data: a
                        } = n.image, l = ct.convert(i.format), c = ct.convert(i.type);
                        let h;
                        if (i.isDataTexture3D) X.setTexture3D(i, 0), h = 32879;
                        else {
                            if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                            X.setTexture2DArray(i, 0), h = 35866
                        }
                        ut.pixelStorei(37440, i.flipY), ut.pixelStorei(37441, i.premultiplyAlpha), ut.pixelStorei(3317, i.unpackAlignment);
                        const u = ut.getParameter(3314),
                            d = ut.getParameter(32878),
                            p = ut.getParameter(3316),
                            f = ut.getParameter(3315),
                            g = ut.getParameter(32877);
                        ut.pixelStorei(3314, o), ut.pixelStorei(32878, s), ut.pixelStorei(3316, t.min.x), ut.pixelStorei(3315, t.min.y), ut.pixelStorei(32877, t.min.z), ut.texSubImage3D(h, r, e.x, e.y, e.z, t.max.x - t.min.x + 1, t.max.y - t.min.y + 1, t.max.z - t.min.z + 1, l, c, a), ut.pixelStorei(3314, u), ut.pixelStorei(32878, d), ut.pixelStorei(3316, p), ut.pixelStorei(3315, f), ut.pixelStorei(32877, g), 0 === r && i.generateMipmaps && ut.generateMipmap(h), H.unbindTexture()
                    }, this.initTexture = function(t) {
                        X.setTexture2D(t, 0), H.unbindTexture()
                    }, this.resetState = function() {
                        v = 0, y = 0, x = null, H.reset(), ht.reset()
                    }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                class ol extends rl {}
                ol.prototype.isWebGL1Renderer = !0;
                class sl {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 25e-5;
                        this.name = "", this.color = new Fr(t), this.density = e
                    }
                    clone() {
                        return new sl(this.color, this.density)
                    }
                    toJSON() {
                        return {
                            type: "FogExp2",
                            color: this.color.getHex(),
                            density: this.density
                        }
                    }
                }
                sl.prototype.isFogExp2 = !0;
                class al {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e3;
                        this.name = "", this.color = new Fr(t), this.near = e, this.far = n
                    }
                    clone() {
                        return new al(this.color, this.near, this.far)
                    }
                    toJSON() {
                        return {
                            type: "Fog",
                            color: this.color.getHex(),
                            near: this.near,
                            far: this.far
                        }
                    }
                }
                al.prototype.isFog = !0;
                class ll extends cr {
                    constructor() {
                        super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                            detail: this
                        }))
                    }
                    copy(t, e) {
                        return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                    }
                }
                ll.prototype.isScene = !0;
                class cl {
                    constructor(t, e) {
                        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = An, this.updateRange = {
                            offset: 0,
                            count: -1
                        }, this.version = 0, this.uuid = Un()
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                    setUsage(t) {
                        return this.usage = t, this
                    }
                    copy(t) {
                        return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
                    }
                    copyAt(t, e, n) {
                        t *= this.stride, n *= e.stride;
                        for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                        return this
                    }
                    set(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this.array.set(t, e), this
                    }
                    clone(t) {
                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Un()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                            n = new this.constructor(e, this.stride);
                        return n.setUsage(this.usage), n
                    }
                    onUpload(t) {
                        return this.onUploadCallback = t, this
                    }
                    toJSON(t) {
                        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Un()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        }
                    }
                }
                cl.prototype.isInterleavedBuffer = !0;
                const hl = new ai;
                class ul {
                    constructor(t, e, n, i) {
                        this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
                    }
                    get count() {
                        return this.data.count
                    }
                    get array() {
                        return this.data.array
                    }
                    set needsUpdate(t) {
                        this.data.needsUpdate = t
                    }
                    applyMatrix4(t) {
                        for (let e = 0, n = this.data.count; e < n; e++) hl.x = this.getX(e), hl.y = this.getY(e), hl.z = this.getZ(e), hl.applyMatrix4(t), this.setXYZ(e, hl.x, hl.y, hl.z);
                        return this
                    }
                    applyNormalMatrix(t) {
                        for (let e = 0, n = this.count; e < n; e++) hl.x = this.getX(e), hl.y = this.getY(e), hl.z = this.getZ(e), hl.applyNormalMatrix(t), this.setXYZ(e, hl.x, hl.y, hl.z);
                        return this
                    }
                    transformDirection(t) {
                        for (let e = 0, n = this.count; e < n; e++) hl.x = this.getX(e), hl.y = this.getY(e), hl.z = this.getZ(e), hl.transformDirection(t), this.setXYZ(e, hl.x, hl.y, hl.z);
                        return this
                    }
                    setX(t, e) {
                        return this.data.array[t * this.data.stride + this.offset] = e, this
                    }
                    setY(t, e) {
                        return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                    }
                    setZ(t, e) {
                        return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                    }
                    setW(t, e) {
                        return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                    }
                    getX(t) {
                        return this.data.array[t * this.data.stride + this.offset]
                    }
                    getY(t) {
                        return this.data.array[t * this.data.stride + this.offset + 1]
                    }
                    getZ(t) {
                        return this.data.array[t * this.data.stride + this.offset + 2]
                    }
                    getW(t) {
                        return this.data.array[t * this.data.stride + this.offset + 3]
                    }
                    setXY(t, e, n) {
                        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
                    }
                    setXYZ(t, e, n, i) {
                        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
                    }
                    setXYZW(t, e, n, i, r) {
                        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
                    }
                    clone(t) {
                        if (void 0 === t) {
                            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                            const t = [];
                            for (let e = 0; e < this.count; e++) {
                                const n = e * this.data.stride + this.offset;
                                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                            }
                            return new Dr(new this.array.constructor(t), this.itemSize, this.normalized)
                        }
                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new ul(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                    }
                    toJSON(t) {
                        if (void 0 === t) {
                            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                            const t = [];
                            for (let e = 0; e < this.count; e++) {
                                const n = e * this.data.stride + this.offset;
                                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                            }
                            return {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: t,
                                normalized: this.normalized
                            }
                        }
                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                            isInterleavedBufferAttribute: !0,
                            itemSize: this.itemSize,
                            data: this.data.uuid,
                            offset: this.offset,
                            normalized: this.normalized
                        }
                    }
                }
                ul.prototype.isInterleavedBufferAttribute = !0;
                class dl extends Tr {
                    constructor(t) {
                        super(), this.type = "SpriteMaterial", this.color = new Fr(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
                    }
                }
                let pl;
                dl.prototype.isSpriteMaterial = !0;
                const fl = new ai,
                    ml = new ai,
                    gl = new ai,
                    vl = new Qn,
                    yl = new Qn,
                    xl = new Vi,
                    bl = new ai,
                    wl = new ai,
                    _l = new ai,
                    Sl = new Qn,
                    Ml = new Qn,
                    Al = new Qn;
                class Tl extends cr {
                    constructor(t) {
                        if (super(), this.type = "Sprite", void 0 === pl) {
                            pl = new ro;
                            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                                e = new cl(t, 5);
                            pl.setIndex([0, 1, 2, 0, 2, 3]), pl.setAttribute("position", new ul(e, 3, 0, !1)), pl.setAttribute("uv", new ul(e, 2, 3, !1))
                        }
                        this.geometry = pl, this.material = void 0 !== t ? t : new dl, this.center = new Qn(.5, .5)
                    }
                    raycast(t, e) {
                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ml.setFromMatrixScale(this.matrixWorld), xl.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), gl.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && ml.multiplyScalar(-gl.z);
                        const n = this.material.rotation;
                        let i, r;
                        0 !== n && (r = Math.cos(n), i = Math.sin(n));
                        const o = this.center;
                        El(bl.set(-.5, -.5, 0), gl, o, ml, i, r), El(wl.set(.5, -.5, 0), gl, o, ml, i, r), El(_l.set(.5, .5, 0), gl, o, ml, i, r), Sl.set(0, 0), Ml.set(1, 0), Al.set(1, 1);
                        let s = t.ray.intersectTriangle(bl, wl, _l, !1, fl);
                        if (null === s && (El(wl.set(-.5, .5, 0), gl, o, ml, i, r), Ml.set(0, 1), s = t.ray.intersectTriangle(bl, _l, wl, !1, fl), null === s)) return;
                        const a = t.ray.origin.distanceTo(fl);
                        a < t.near || a > t.far || e.push({
                            distance: a,
                            point: fl.clone(),
                            uv: Mr.getUV(fl, bl, wl, _l, Sl, Ml, Al, new Qn),
                            face: null,
                            object: this
                        })
                    }
                    copy(t) {
                        return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                    }
                }

                function El(t, e, n, i, r, o) {
                    vl.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (yl.x = o * vl.x - r * vl.y, yl.y = r * vl.x + o * vl.y) : yl.copy(vl), t.copy(e), t.x += yl.x, t.y += yl.y, t.applyMatrix4(xl)
                }
                Tl.prototype.isSprite = !0;
                const Cl = new ai,
                    Pl = new ai;
                class Ll extends cr {
                    constructor() {
                        super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                            levels: {
                                enumerable: !0,
                                value: []
                            },
                            isLOD: {
                                value: !0
                            }
                        }), this.autoUpdate = !0
                    }
                    copy(t) {
                        super.copy(t, !1);
                        const e = t.levels;
                        for (let n = 0, i = e.length; n < i; n++) {
                            const t = e[n];
                            this.addLevel(t.object.clone(), t.distance)
                        }
                        return this.autoUpdate = t.autoUpdate, this
                    }
                    addLevel(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        e = Math.abs(e);
                        const n = this.levels;
                        let i;
                        for (i = 0; i < n.length && !(e < n[i].distance); i++);
                        return n.splice(i, 0, {
                            distance: e,
                            object: t
                        }), this.add(t), this
                    }
                    getCurrentLevel() {
                        return this._currentLevel
                    }
                    getObjectForDistance(t) {
                        const e = this.levels;
                        if (e.length > 0) {
                            let n, i;
                            for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                            return e[n - 1].object
                        }
                        return null
                    }
                    raycast(t, e) {
                        if (this.levels.length > 0) {
                            Cl.setFromMatrixPosition(this.matrixWorld);
                            const n = t.ray.origin.distanceTo(Cl);
                            this.getObjectForDistance(n).raycast(t, e)
                        }
                    }
                    update(t) {
                        const e = this.levels;
                        if (e.length > 1) {
                            Cl.setFromMatrixPosition(t.matrixWorld), Pl.setFromMatrixPosition(this.matrixWorld);
                            const n = Cl.distanceTo(Pl) / t.zoom;
                            let i, r;
                            for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                            for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1
                        }
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
                        const n = this.levels;
                        for (let i = 0, r = n.length; i < r; i++) {
                            const t = n[i];
                            e.object.levels.push({
                                object: t.object.uuid,
                                distance: t.distance
                            })
                        }
                        return e
                    }
                }
                const Rl = new ai,
                    Il = new ni,
                    Fl = new ni,
                    Ol = new ai,
                    Nl = new Vi;
                class Bl extends So {
                    constructor(t, e) {
                        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Vi, this.bindMatrixInverse = new Vi
                    }
                    copy(t) {
                        return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
                    }
                    bind(t, e) {
                        this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                    }
                    pose() {
                        this.skeleton.pose()
                    }
                    normalizeSkinWeights() {
                        const t = new ni,
                            e = this.geometry.attributes.skinWeight;
                        for (let n = 0, i = e.count; n < i; n++) {
                            t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                            const i = 1 / t.manhattanLength();
                            i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                        }
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                    }
                    boneTransform(t, e) {
                        const n = this.skeleton,
                            i = this.geometry;
                        Il.fromBufferAttribute(i.attributes.skinIndex, t), Fl.fromBufferAttribute(i.attributes.skinWeight, t), Rl.fromBufferAttribute(i.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                        for (let r = 0; r < 4; r++) {
                            const t = Fl.getComponent(r);
                            if (0 !== t) {
                                const i = Il.getComponent(r);
                                Nl.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), e.addScaledVector(Ol.copy(Rl).applyMatrix4(Nl), t)
                            }
                        }
                        return e.applyMatrix4(this.bindMatrixInverse)
                    }
                }
                Bl.prototype.isSkinnedMesh = !0;
                class Dl extends cr {
                    constructor() {
                        super(), this.type = "Bone"
                    }
                }
                Dl.prototype.isBone = !0;
                class Vl extends ti {
                    constructor(t, e, n, i, r, o, s, a, l, c, h, u) {
                        super(null, o, s, a, l, c, i, r, h, u), this.image = {
                            data: t || null,
                            width: e || 1,
                            height: n || 1
                        }, this.magFilter = void 0 !== l ? l : ft, this.minFilter = void 0 !== c ? c : ft, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
                    }
                }
                Vl.prototype.isDataTexture = !0;
                const jl = new Vi,
                    kl = new Vi;
                class Ul {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                        this.uuid = Un(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
                    }
                    init() {
                        const t = this.bones,
                            e = this.boneInverses;
                        if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                        else if (t.length !== e.length) {
                            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                            for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Vi)
                        }
                    }
                    calculateInverses() {
                        this.boneInverses.length = 0;
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = new Vi;
                            this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                        }
                    }
                    pose() {
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = this.bones[t];
                            e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                        }
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = this.bones[t];
                            e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                        }
                    }
                    update() {
                        const t = this.bones,
                            e = this.boneInverses,
                            n = this.boneMatrices,
                            i = this.boneTexture;
                        for (let r = 0, o = t.length; r < o; r++) {
                            const i = t[r] ? t[r].matrixWorld : kl;
                            jl.multiplyMatrices(i, e[r]), jl.toArray(n, 16 * r)
                        }
                        null !== i && (i.needsUpdate = !0)
                    }
                    clone() {
                        return new Ul(this.bones, this.boneInverses)
                    }
                    computeBoneTexture() {
                        let t = Math.sqrt(4 * this.bones.length);
                        t = Yn(t), t = Math.max(t, 4);
                        const e = new Float32Array(t * t * 4);
                        e.set(this.boneMatrices);
                        const n = new Vl(e, t, t, Vt, Lt);
                        return this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this
                    }
                    getBoneByName(t) {
                        for (let e = 0, n = this.bones.length; e < n; e++) {
                            const n = this.bones[e];
                            if (n.name === t) return n
                        }
                    }
                    dispose() {
                        null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                    }
                    fromJSON(t, e) {
                        this.uuid = t.uuid;
                        for (let n = 0, i = t.bones.length; n < i; n++) {
                            const i = t.bones[n];
                            let r = e[i];
                            void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Dl), this.bones.push(r), this.boneInverses.push((new Vi).fromArray(t.boneInverses[n]))
                        }
                        return this.init(), this
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.5,
                                type: "Skeleton",
                                generator: "Skeleton.toJSON"
                            },
                            bones: [],
                            boneInverses: []
                        };
                        t.uuid = this.uuid;
                        const e = this.bones,
                            n = this.boneInverses;
                        for (let i = 0, r = e.length; i < r; i++) {
                            const r = e[i];
                            t.bones.push(r.uuid);
                            const o = n[i];
                            t.boneInverses.push(o.toArray())
                        }
                        return t
                    }
                }
                const zl = new Vi,
                    Gl = new Vi,
                    Hl = [],
                    Wl = new So;
                class Yl extends So {
                    constructor(t, e, n) {
                        super(t, e), this.instanceMatrix = new Dr(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
                    }
                    copy(t) {
                        return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
                    }
                    getColorAt(t, e) {
                        e.fromArray(this.instanceColor.array, 3 * t)
                    }
                    getMatrixAt(t, e) {
                        e.fromArray(this.instanceMatrix.array, 16 * t)
                    }
                    raycast(t, e) {
                        const n = this.matrixWorld,
                            i = this.count;
                        if (Wl.geometry = this.geometry, Wl.material = this.material, void 0 !== Wl.material)
                            for (let r = 0; r < i; r++) {
                                this.getMatrixAt(r, zl), Gl.multiplyMatrices(n, zl), Wl.matrixWorld = Gl, Wl.raycast(t, Hl);
                                for (let t = 0, n = Hl.length; t < n; t++) {
                                    const n = Hl[t];
                                    n.instanceId = r, n.object = this, e.push(n)
                                }
                                Hl.length = 0
                            }
                    }
                    setColorAt(t, e) {
                        null === this.instanceColor && (this.instanceColor = new Dr(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                    }
                    setMatrixAt(t, e) {
                        e.toArray(this.instanceMatrix.array, 16 * t)
                    }
                    updateMorphTargets() {}
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                Yl.prototype.isInstancedMesh = !0;
                class Xl extends Tr {
                    constructor(t) {
                        super(), this.type = "LineBasicMaterial", this.color = new Fr(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this
                    }
                }
                Xl.prototype.isLineBasicMaterial = !0;
                const ql = new ai,
                    Ql = new ai,
                    Zl = new Vi,
                    Jl = new Di,
                    Kl = new Pi;
                class $l extends cr {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ro,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Xl;
                        super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
                    }
                    copy(t) {
                        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                    }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (t.isBufferGeometry)
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    n = [0];
                                for (let t = 1, i = e.count; t < i; t++) ql.fromBufferAttribute(e, t - 1), Ql.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += ql.distanceTo(Ql);
                                t.setAttribute("lineDistance", new Yr(n, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        return this
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.matrixWorld,
                            r = t.params.Line.threshold,
                            o = n.drawRange;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), Kl.copy(n.boundingSphere), Kl.applyMatrix4(i), Kl.radius += r, !1 === t.ray.intersectsSphere(Kl)) return;
                        Zl.copy(i).invert(), Jl.copy(t.ray).applyMatrix4(Zl);
                        const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = s * s,
                            l = new ai,
                            c = new ai,
                            h = new ai,
                            u = new ai,
                            d = this.isLineSegments ? 2 : 1;
                        if (n.isBufferGeometry) {
                            const i = n.index,
                                r = n.attributes.position;
                            if (null !== i)
                                for (let n = Math.max(0, o.start), s = Math.min(i.count, o.start + o.count) - 1; n < s; n += d) {
                                    const o = i.getX(n),
                                        s = i.getX(n + 1);
                                    if (l.fromBufferAttribute(r, o), c.fromBufferAttribute(r, s), Jl.distanceSqToSegment(l, c, u, h) > a) continue;
                                    u.applyMatrix4(this.matrixWorld);
                                    const d = t.ray.origin.distanceTo(u);
                                    d < t.near || d > t.far || e.push({
                                        distance: d,
                                        point: h.clone().applyMatrix4(this.matrixWorld),
                                        index: n,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                } else
                                    for (let n = Math.max(0, o.start), s = Math.min(r.count, o.start + o.count) - 1; n < s; n += d) {
                                        if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), Jl.distanceSqToSegment(l, c, u, h) > a) continue;
                                        u.applyMatrix4(this.matrixWorld);
                                        const i = t.ray.origin.distanceTo(u);
                                        i < t.near || i > t.far || e.push({
                                            distance: i,
                                            point: h.clone().applyMatrix4(this.matrixWorld),
                                            index: n,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                        } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                }
                $l.prototype.isLine = !0;
                const tc = new ai,
                    ec = new ai;
                class nc extends $l {
                    constructor(t, e) {
                        super(t, e), this.type = "LineSegments"
                    }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (t.isBufferGeometry)
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    n = [];
                                for (let t = 0, i = e.count; t < i; t += 2) tc.fromBufferAttribute(e, t), ec.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + tc.distanceTo(ec);
                                t.setAttribute("lineDistance", new Yr(n, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        return this
                    }
                }
                nc.prototype.isLineSegments = !0;
                class ic extends $l {
                    constructor(t, e) {
                        super(t, e), this.type = "LineLoop"
                    }
                }
                ic.prototype.isLineLoop = !0;
                class rc extends Tr {
                    constructor(t) {
                        super(), this.type = "PointsMaterial", this.color = new Fr(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
                    }
                }
                rc.prototype.isPointsMaterial = !0;
                const oc = new Vi,
                    sc = new Di,
                    ac = new Pi,
                    lc = new ai;
                class cc extends cr {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ro,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new rc;
                        super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
                    }
                    copy(t) {
                        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.matrixWorld,
                            r = t.params.Points.threshold,
                            o = n.drawRange;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), ac.copy(n.boundingSphere), ac.applyMatrix4(i), ac.radius += r, !1 === t.ray.intersectsSphere(ac)) return;
                        oc.copy(i).invert(), sc.copy(t.ray).applyMatrix4(oc);
                        const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = s * s;
                        if (n.isBufferGeometry) {
                            const r = n.index,
                                s = n.attributes.position;
                            if (null !== r)
                                for (let n = Math.max(0, o.start), l = Math.min(r.count, o.start + o.count); n < l; n++) {
                                    const o = r.getX(n);
                                    lc.fromBufferAttribute(s, o), hc(lc, o, a, i, t, e, this)
                                } else
                                    for (let n = Math.max(0, o.start), l = Math.min(s.count, o.start + o.count); n < l; n++) lc.fromBufferAttribute(s, n), hc(lc, n, a, i, t, e, this)
                        } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                }

                function hc(t, e, n, i, r, o, s) {
                    const a = sc.distanceSqToPoint(t);
                    if (a < n) {
                        const n = new ai;
                        sc.closestPointToPoint(t, n), n.applyMatrix4(i);
                        const l = r.ray.origin.distanceTo(n);
                        if (l < r.near || l > r.far) return;
                        o.push({
                            distance: l,
                            distanceToRay: Math.sqrt(a),
                            point: n,
                            index: e,
                            face: null,
                            object: s
                        })
                    }
                }
                cc.prototype.isPoints = !0;
                class uc extends ti {
                    constructor(t, e, n, i, r, o, s, a, l) {
                        super(t, e, n, i, r, o, s, a, l), this.format = void 0 !== s ? s : Dt, this.minFilter = void 0 !== o ? o : xt, this.magFilter = void 0 !== r ? r : xt, this.generateMipmaps = !1;
                        const c = this;
                        "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                            c.needsUpdate = !0, t.requestVideoFrameCallback(e)
                        }))
                    }
                    clone() {
                        return new this.constructor(this.image).copy(this)
                    }
                    update() {
                        const t = this.image;
                        !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                    }
                }
                uc.prototype.isVideoTexture = !0;
                class dc extends ti {
                    constructor(t, e, n, i, r, o, s, a, l, c, h, u) {
                        super(null, o, s, a, l, c, i, r, h, u), this.image = {
                            width: e,
                            height: n
                        }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
                    }
                }
                dc.prototype.isCompressedTexture = !0;
                class pc extends ti {
                    constructor(t, e, n, i, r, o, s, a, l) {
                        super(t, e, n, i, r, o, s, a, l), this.needsUpdate = !0
                    }
                }
                pc.prototype.isCanvasTexture = !0;
                class fc extends ti {
                    constructor(t, e, n, i, r, o, s, a, l, c) {
                        if ((c = void 0 !== c ? c : zt) !== zt && c !== Gt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        void 0 === n && c === zt && (n = Et), void 0 === n && c === Gt && (n = Nt), super(null, i, r, o, s, a, c, n, l), this.image = {
                            width: t,
                            height: e
                        }, this.magFilter = void 0 !== s ? s : ft, this.minFilter = void 0 !== a ? a : ft, this.flipY = !1, this.generateMipmaps = !1
                    }
                }
                fc.prototype.isDepthTexture = !0;
                class mc extends ro {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 8,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2 * Math.PI;
                        super(), this.type = "CircleGeometry", this.parameters = {
                            radius: t,
                            segments: e,
                            thetaStart: n,
                            thetaLength: i
                        }, e = Math.max(3, e);
                        const r = [],
                            o = [],
                            s = [],
                            a = [],
                            l = new ai,
                            c = new Qn;
                        o.push(0, 0, 0), s.push(0, 0, 1), a.push(.5, .5);
                        for (let h = 0, u = 3; h <= e; h++, u += 3) {
                            const r = n + h / e * i;
                            l.x = t * Math.cos(r), l.y = t * Math.sin(r), o.push(l.x, l.y, l.z), s.push(0, 0, 1), c.x = (o[u] / t + 1) / 2, c.y = (o[u + 1] / t + 1) / 2, a.push(c.x, c.y)
                        }
                        for (let h = 1; h <= e; h++) r.push(h, h + 1, 0);
                        this.setIndex(r), this.setAttribute("position", new Yr(o, 3)), this.setAttribute("normal", new Yr(s, 3)), this.setAttribute("uv", new Yr(a, 2))
                    }
                }
                class gc extends ro {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1,
                            o = arguments.length > 5 && void 0 !== arguments[5] && arguments[5],
                            s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0,
                            a = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 2 * Math.PI;
                        super(), this.type = "CylinderGeometry", this.parameters = {
                            radiusTop: t,
                            radiusBottom: e,
                            height: n,
                            radialSegments: i,
                            heightSegments: r,
                            openEnded: o,
                            thetaStart: s,
                            thetaLength: a
                        };
                        const l = this;
                        i = Math.floor(i), r = Math.floor(r);
                        const c = [],
                            h = [],
                            u = [],
                            d = [];
                        let p = 0;
                        const f = [],
                            m = n / 2;
                        let g = 0;

                        function v(n) {
                            const r = p,
                                o = new Qn,
                                f = new ai;
                            let v = 0;
                            const y = !0 === n ? t : e,
                                x = !0 === n ? 1 : -1;
                            for (let t = 1; t <= i; t++) h.push(0, m * x, 0), u.push(0, x, 0), d.push(.5, .5), p++;
                            const b = p;
                            for (let t = 0; t <= i; t++) {
                                const e = t / i * a + s,
                                    n = Math.cos(e),
                                    r = Math.sin(e);
                                f.x = y * r, f.y = m * x, f.z = y * n, h.push(f.x, f.y, f.z), u.push(0, x, 0), o.x = .5 * n + .5, o.y = .5 * r * x + .5, d.push(o.x, o.y), p++
                            }
                            for (let t = 0; t < i; t++) {
                                const e = r + t,
                                    i = b + t;
                                !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), v += 3
                            }
                            l.addGroup(g, v, !0 === n ? 1 : 2), g += v
                        }! function() {
                            const o = new ai,
                                v = new ai;
                            let y = 0;
                            const x = (e - t) / n;
                            for (let l = 0; l <= r; l++) {
                                const c = [],
                                    g = l / r,
                                    y = g * (e - t) + t;
                                for (let t = 0; t <= i; t++) {
                                    const e = t / i,
                                        r = e * a + s,
                                        l = Math.sin(r),
                                        f = Math.cos(r);
                                    v.x = y * l, v.y = -g * n + m, v.z = y * f, h.push(v.x, v.y, v.z), o.set(l, x, f).normalize(), u.push(o.x, o.y, o.z), d.push(e, 1 - g), c.push(p++)
                                }
                                f.push(c)
                            }
                            for (let t = 0; t < i; t++)
                                for (let e = 0; e < r; e++) {
                                    const n = f[e][t],
                                        i = f[e + 1][t],
                                        r = f[e + 1][t + 1],
                                        o = f[e][t + 1];
                                    c.push(n, i, o), c.push(i, r, o), y += 6
                                }
                            l.addGroup(g, y, 0), g += y
                        }(), !1 === o && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new Yr(h, 3)), this.setAttribute("normal", new Yr(u, 3)), this.setAttribute("uv", new Yr(d, 2))
                    }
                }
                class vc extends gc {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                            r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                            s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 2 * Math.PI;
                        super(0, t, e, n, i, r, o, s), this.type = "ConeGeometry", this.parameters = {
                            radius: t,
                            height: e,
                            radialSegments: n,
                            heightSegments: i,
                            openEnded: r,
                            thetaStart: o,
                            thetaLength: s
                        }
                    }
                }
                class yc extends ro {
                    constructor(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                        super(), this.type = "PolyhedronGeometry", this.parameters = {
                            vertices: t,
                            indices: e,
                            radius: n,
                            detail: i
                        };
                        const r = [],
                            o = [];

                        function s(t, e, n, i) {
                            const r = i + 1,
                                o = [];
                            for (let s = 0; s <= r; s++) {
                                o[s] = [];
                                const i = t.clone().lerp(n, s / r),
                                    a = e.clone().lerp(n, s / r),
                                    l = r - s;
                                for (let t = 0; t <= l; t++) o[s][t] = 0 === t && s === r ? i : i.clone().lerp(a, t / l)
                            }
                            for (let s = 0; s < r; s++)
                                for (let t = 0; t < 2 * (r - s) - 1; t++) {
                                    const e = Math.floor(t / 2);
                                    t % 2 == 0 ? (a(o[s][e + 1]), a(o[s + 1][e]), a(o[s][e])) : (a(o[s][e + 1]), a(o[s + 1][e + 1]), a(o[s + 1][e]))
                                }
                        }

                        function a(t) {
                            r.push(t.x, t.y, t.z)
                        }

                        function l(e, n) {
                            const i = 3 * e;
                            n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2]
                        }

                        function c(t, e, n, i) {
                            i < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + .5)
                        }

                        function h(t) {
                            return Math.atan2(t.z, -t.x)
                        }! function(t) {
                            const n = new ai,
                                i = new ai,
                                r = new ai;
                            for (let o = 0; o < e.length; o += 3) l(e[o + 0], n), l(e[o + 1], i), l(e[o + 2], r), s(n, i, r, t)
                        }(i),
                        function(t) {
                            const e = new ai;
                            for (let n = 0; n < r.length; n += 3) e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z
                        }(n),
                        function() {
                            const t = new ai;
                            for (let n = 0; n < r.length; n += 3) {
                                t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2];
                                const i = h(t) / 2 / Math.PI + .5,
                                    s = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
                                o.push(i, 1 - s)
                            }
                            var e;
                            (function() {
                                const t = new ai,
                                    e = new ai,
                                    n = new ai,
                                    i = new ai,
                                    s = new Qn,
                                    a = new Qn,
                                    l = new Qn;
                                for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
                                    t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), n.set(r[u + 6], r[u + 7], r[u + 8]), s.set(o[d + 0], o[d + 1]), a.set(o[d + 2], o[d + 3]), l.set(o[d + 4], o[d + 5]), i.copy(t).add(e).add(n).divideScalar(3);
                                    const p = h(i);
                                    c(s, d + 0, t, p), c(a, d + 2, e, p), c(l, d + 4, n, p)
                                }
                            })(),
                            function() {
                                for (let t = 0; t < o.length; t += 6) {
                                    const e = o[t + 0],
                                        n = o[t + 2],
                                        i = o[t + 4],
                                        r = Math.max(e, n, i),
                                        s = Math.min(e, n, i);
                                    r > .9 && s < .1 && (e < .2 && (o[t + 0] += 1), n < .2 && (o[t + 2] += 1), i < .2 && (o[t + 4] += 1))
                                }
                            }()
                        }(), this.setAttribute("position", new Yr(r, 3)), this.setAttribute("normal", new Yr(r.slice(), 3)), this.setAttribute("uv", new Yr(o, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
                    }
                }
                class xc extends yc {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = (1 + Math.sqrt(5)) / 2,
                            i = 1 / n;
                        super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronGeometry", this.parameters = {
                            radius: t,
                            detail: e
                        }
                    }
                }
                const bc = new ai,
                    wc = new ai,
                    _c = new ai,
                    Sc = new Mr;
                class Mc extends ro {
                    constructor(t, e) {
                        if (super(), this.type = "EdgesGeometry", this.parameters = {
                                thresholdAngle: e
                            }, e = void 0 !== e ? e : 1, !0 === t.isGeometry) return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        const n = Math.pow(10, 4),
                            i = Math.cos(jn * e),
                            r = t.getIndex(),
                            o = t.getAttribute("position"),
                            s = r ? r.count : o.count,
                            a = [0, 0, 0],
                            l = ["a", "b", "c"],
                            c = new Array(3),
                            h = {},
                            u = [];
                        for (let d = 0; d < s; d += 3) {
                            r ? (a[0] = r.getX(d), a[1] = r.getX(d + 1), a[2] = r.getX(d + 2)) : (a[0] = d, a[1] = d + 1, a[2] = d + 2);
                            const {
                                a: t,
                                b: e,
                                c: s
                            } = Sc;
                            if (t.fromBufferAttribute(o, a[0]), e.fromBufferAttribute(o, a[1]), s.fromBufferAttribute(o, a[2]), Sc.getNormal(_c), c[0] = "".concat(Math.round(t.x * n), ",").concat(Math.round(t.y * n), ",").concat(Math.round(t.z * n)), c[1] = "".concat(Math.round(e.x * n), ",").concat(Math.round(e.y * n), ",").concat(Math.round(e.z * n)), c[2] = "".concat(Math.round(s.x * n), ",").concat(Math.round(s.y * n), ",").concat(Math.round(s.z * n)), c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
                                for (let n = 0; n < 3; n++) {
                                    const t = (n + 1) % 3,
                                        e = c[n],
                                        r = c[t],
                                        o = Sc[l[n]],
                                        s = Sc[l[t]],
                                        d = "".concat(e, "_").concat(r),
                                        p = "".concat(r, "_").concat(e);
                                    p in h && h[p] ? (_c.dot(h[p].normal) <= i && (u.push(o.x, o.y, o.z), u.push(s.x, s.y, s.z)), h[p] = null) : d in h || (h[d] = {
                                        index0: a[n],
                                        index1: a[t],
                                        normal: _c.clone()
                                    })
                                }
                        }
                        for (const d in h)
                            if (h[d]) {
                                const {
                                    index0: t,
                                    index1: e
                                } = h[d];
                                bc.fromBufferAttribute(o, t), wc.fromBufferAttribute(o, e), u.push(bc.x, bc.y, bc.z), u.push(wc.x, wc.y, wc.z)
                            }
                        this.setAttribute("position", new Yr(u, 3))
                    }
                }
                const Ac = {
                    triangulate: function(t, e, n) {
                        n = n || 2;
                        const i = e && e.length,
                            r = i ? e[0] * n : t.length;
                        let o = Tc(t, 0, r, n, !0);
                        const s = [];
                        if (!o || o.next === o.prev) return s;
                        let a, l, c, h, u, d, p;
                        if (i && (o = function(t, e, n, i) {
                                const r = [];
                                let o, s, a, l, c;
                                for (o = 0, s = e.length; o < s; o++) a = e[o] * i, l = o < s - 1 ? e[o + 1] * i : t.length, c = Tc(t, a, l, i, !1), c === c.next && (c.steiner = !0), r.push(Dc(c));
                                for (r.sort(Fc), o = 0; o < r.length; o++) Oc(r[o], n), n = Ec(n, n.next);
                                return n
                            }(t, e, o, n)), t.length > 80 * n) {
                            a = c = t[0], l = h = t[1];
                            for (let e = n; e < r; e += n) u = t[e], d = t[e + 1], u < a && (a = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
                            p = Math.max(c - a, h - l), p = 0 !== p ? 1 / p : 0
                        }
                        return Cc(o, s, n, a, l, p), s
                    }
                };

                function Tc(t, e, n, i, r) {
                    let o, s;
                    if (r === function(t, e, n, i) {
                            let r = 0;
                            for (let o = e, s = n - i; o < n; o += i) r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;
                            return r
                        }(t, e, n, i) > 0)
                        for (o = e; o < n; o += i) s = Xc(o, t[o], t[o + 1], s);
                    else
                        for (o = n - i; o >= e; o -= i) s = Xc(o, t[o], t[o + 1], s);
                    return s && Uc(s, s.next) && (qc(s), s = s.next), s
                }

                function Ec(t, e) {
                    if (!t) return t;
                    e || (e = t);
                    let n, i = t;
                    do {
                        if (n = !1, i.steiner || !Uc(i, i.next) && 0 !== kc(i.prev, i, i.next)) i = i.next;
                        else {
                            if (qc(i), i = e = i.prev, i === i.next) break;
                            n = !0
                        }
                    } while (n || i !== e);
                    return e
                }

                function Cc(t, e, n, i, r, o, s) {
                    if (!t) return;
                    !s && o && function(t, e, n, i) {
                        let r = t;
                        do {
                            null === r.z && (r.z = Bc(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                        } while (r !== t);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(t) {
                                let e, n, i, r, o, s, a, l, c = 1;
                                do {
                                    for (n = t, t = null, o = null, s = 0; n;) {
                                        for (s++, i = n, a = 0, e = 0; e < c && (a++, i = i.nextZ, i); e++);
                                        for (l = c; a > 0 || l > 0 && i;) 0 !== a && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, l--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
                                        n = i
                                    }
                                    o.nextZ = null, c *= 2
                                } while (s > 1)
                            }(r)
                    }(t, i, r, o);
                    let a, l, c = t;
                    for (; t.prev !== t.next;)
                        if (a = t.prev, l = t.next, o ? Lc(t, i, r, o) : Pc(t)) e.push(a.i / n), e.push(t.i / n), e.push(l.i / n), qc(t), t = l.next, c = l.next;
                        else if ((t = l) === c) {
                        s ? 1 === s ? Cc(t = Rc(Ec(t), e, n), e, n, i, r, o, 2) : 2 === s && Ic(t, e, n, i, r, o) : Cc(Ec(t), e, n, i, r, o, 1);
                        break
                    }
                }

                function Pc(t) {
                    const e = t.prev,
                        n = t,
                        i = t.next;
                    if (kc(e, n, i) >= 0) return !1;
                    let r = t.next.next;
                    for (; r !== t.prev;) {
                        if (Vc(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && kc(r.prev, r, r.next) >= 0) return !1;
                        r = r.next
                    }
                    return !0
                }

                function Lc(t, e, n, i) {
                    const r = t.prev,
                        o = t,
                        s = t.next;
                    if (kc(r, o, s) >= 0) return !1;
                    const a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x,
                        l = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y,
                        c = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x,
                        h = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y,
                        u = Bc(a, l, e, n, i),
                        d = Bc(c, h, e, n, i);
                    let p = t.prevZ,
                        f = t.nextZ;
                    for (; p && p.z >= u && f && f.z <= d;) {
                        if (p !== t.prev && p !== t.next && Vc(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && kc(p.prev, p, p.next) >= 0) return !1;
                        if (p = p.prevZ, f !== t.prev && f !== t.next && Vc(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && kc(f.prev, f, f.next) >= 0) return !1;
                        f = f.nextZ
                    }
                    for (; p && p.z >= u;) {
                        if (p !== t.prev && p !== t.next && Vc(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && kc(p.prev, p, p.next) >= 0) return !1;
                        p = p.prevZ
                    }
                    for (; f && f.z <= d;) {
                        if (f !== t.prev && f !== t.next && Vc(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && kc(f.prev, f, f.next) >= 0) return !1;
                        f = f.nextZ
                    }
                    return !0
                }

                function Rc(t, e, n) {
                    let i = t;
                    do {
                        const r = i.prev,
                            o = i.next.next;
                        !Uc(r, o) && zc(r, i, i.next, o) && Wc(r, o) && Wc(o, r) && (e.push(r.i / n), e.push(i.i / n), e.push(o.i / n), qc(i), qc(i.next), i = t = o), i = i.next
                    } while (i !== t);
                    return Ec(i)
                }

                function Ic(t, e, n, i, r, o) {
                    let s = t;
                    do {
                        let t = s.next.next;
                        for (; t !== s.prev;) {
                            if (s.i !== t.i && jc(s, t)) {
                                let a = Yc(s, t);
                                return s = Ec(s, s.next), a = Ec(a, a.next), Cc(s, e, n, i, r, o), void Cc(a, e, n, i, r, o)
                            }
                            t = t.next
                        }
                        s = s.next
                    } while (s !== t)
                }

                function Fc(t, e) {
                    return t.x - e.x
                }

                function Oc(t, e) {
                    if (e = function(t, e) {
                            let n = e;
                            const i = t.x,
                                r = t.y;
                            let o, s = -1 / 0;
                            do {
                                if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                                    const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                    if (t <= i && t > s) {
                                        if (s = t, t === i) {
                                            if (r === n.y) return n;
                                            if (r === n.next.y) return n.next
                                        }
                                        o = n.x < n.next.x ? n : n.next
                                    }
                                }
                                n = n.next
                            } while (n !== e);
                            if (!o) return null;
                            if (i === s) return o;
                            const a = o,
                                l = o.x,
                                c = o.y;
                            let h, u = 1 / 0;
                            n = o;
                            do {
                                i >= n.x && n.x >= l && i !== n.x && Vc(r < c ? i : s, r, l, c, r < c ? s : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), Wc(n, t) && (h < u || h === u && (n.x > o.x || n.x === o.x && Nc(o, n))) && (o = n, u = h)), n = n.next
                            } while (n !== a);
                            return o
                        }(t, e)) {
                        const n = Yc(e, t);
                        Ec(e, e.next), Ec(n, n.next)
                    }
                }

                function Nc(t, e) {
                    return kc(t.prev, t, e.prev) < 0 && kc(e.next, t, t.next) < 0
                }

                function Bc(t, e, n, i, r) {
                    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                }

                function Dc(t) {
                    let e = t,
                        n = t;
                    do {
                        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                    } while (e !== t);
                    return n
                }

                function Vc(t, e, n, i, r, o, s, a) {
                    return (r - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (i - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (r - s) * (i - a) >= 0
                }

                function jc(t, e) {
                    return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                        let n = t;
                        do {
                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && zc(n, n.next, t, e)) return !0;
                            n = n.next
                        } while (n !== t);
                        return !1
                    }(t, e) && (Wc(t, e) && Wc(e, t) && function(t, e) {
                        let n = t,
                            i = !1;
                        const r = (t.x + e.x) / 2,
                            o = (t.y + e.y) / 2;
                        do {
                            n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                        } while (n !== t);
                        return i
                    }(t, e) && (kc(t.prev, t, e.prev) || kc(t, e.prev, e)) || Uc(t, e) && kc(t.prev, t, t.next) > 0 && kc(e.prev, e, e.next) > 0)
                }

                function kc(t, e, n) {
                    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
                }

                function Uc(t, e) {
                    return t.x === e.x && t.y === e.y
                }

                function zc(t, e, n, i) {
                    const r = Hc(kc(t, e, n)),
                        o = Hc(kc(t, e, i)),
                        s = Hc(kc(n, i, t)),
                        a = Hc(kc(n, i, e));
                    return r !== o && s !== a || !(0 !== r || !Gc(t, n, e)) || !(0 !== o || !Gc(t, i, e)) || !(0 !== s || !Gc(n, t, i)) || !(0 !== a || !Gc(n, e, i))
                }

                function Gc(t, e, n) {
                    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
                }

                function Hc(t) {
                    return t > 0 ? 1 : t < 0 ? -1 : 0
                }

                function Wc(t, e) {
                    return kc(t.prev, t, t.next) < 0 ? kc(t, e, t.next) >= 0 && kc(t, t.prev, e) >= 0 : kc(t, e, t.prev) < 0 || kc(t, t.next, e) < 0
                }

                function Yc(t, e) {
                    const n = new Qc(t.i, t.x, t.y),
                        i = new Qc(e.i, e.x, e.y),
                        r = t.next,
                        o = e.prev;
                    return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i
                }

                function Xc(t, e, n, i) {
                    const r = new Qc(t, e, n);
                    return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
                }

                function qc(t) {
                    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                }

                function Qc(t, e, n) {
                    this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
                }
                class Zc {
                    static area(t) {
                        const e = t.length;
                        let n = 0;
                        for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                        return .5 * n
                    }
                    static isClockWise(t) {
                        return Zc.area(t) < 0
                    }
                    static triangulateShape(t, e) {
                        const n = [],
                            i = [],
                            r = [];
                        Jc(t), Kc(n, t);
                        let o = t.length;
                        e.forEach(Jc);
                        for (let a = 0; a < e.length; a++) i.push(o), o += e[a].length, Kc(n, e[a]);
                        const s = Ac.triangulate(n, i);
                        for (let a = 0; a < s.length; a += 3) r.push(s.slice(a, a + 3));
                        return r
                    }
                }

                function Jc(t) {
                    const e = t.length;
                    e > 2 && t[e - 1].equals(t[0]) && t.pop()
                }

                function Kc(t, e) {
                    for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
                }
                class $c extends ro {
                    constructor(t, e) {
                        super(), this.type = "ExtrudeGeometry", this.parameters = {
                            shapes: t,
                            options: e
                        }, t = Array.isArray(t) ? t : [t];
                        const n = this,
                            i = [],
                            r = [];
                        for (let s = 0, a = t.length; s < a; s++) o(t[s]);

                        function o(t) {
                            const o = [],
                                s = void 0 !== e.curveSegments ? e.curveSegments : 12,
                                a = void 0 !== e.steps ? e.steps : 1;
                            let l = void 0 !== e.depth ? e.depth : 100,
                                c = void 0 === e.bevelEnabled || e.bevelEnabled,
                                h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                                u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                                d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                                p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                            const f = e.extrudePath,
                                m = void 0 !== e.UVGenerator ? e.UVGenerator : th;
                            void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                            let g, v, y, x, b, w = !1;
                            f && (g = f.getSpacedPoints(a), w = !0, c = !1, v = f.computeFrenetFrames(a, !1), y = new ai, x = new ai, b = new ai), c || (p = 0, h = 0, u = 0, d = 0);
                            const _ = t.extractPoints(s);
                            let S = _.shape;
                            const M = _.holes;
                            if (!Zc.isClockWise(S)) {
                                S = S.reverse();
                                for (let t = 0, e = M.length; t < e; t++) {
                                    const e = M[t];
                                    Zc.isClockWise(e) && (M[t] = e.reverse())
                                }
                            }
                            const A = Zc.triangulateShape(S, M),
                                T = S;
                            for (let e = 0, n = M.length; e < n; e++) {
                                const t = M[e];
                                S = S.concat(t)
                            }

                            function E(t, e, n) {
                                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                            }
                            const C = S.length,
                                P = A.length;

                            function L(t, e, n) {
                                let i, r, o;
                                const s = t.x - e.x,
                                    a = t.y - e.y,
                                    l = n.x - t.x,
                                    c = n.y - t.y,
                                    h = s * s + a * a,
                                    u = s * c - a * l;
                                if (Math.abs(u) > Number.EPSILON) {
                                    const u = Math.sqrt(h),
                                        d = Math.sqrt(l * l + c * c),
                                        p = e.x - a / u,
                                        f = e.y + s / u,
                                        m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (s * c - a * l);
                                    i = p + s * m - t.x, r = f + a * m - t.y;
                                    const g = i * i + r * r;
                                    if (g <= 2) return new Qn(i, r);
                                    o = Math.sqrt(g / 2)
                                } else {
                                    let t = !1;
                                    s > Number.EPSILON ? l > Number.EPSILON && (t = !0) : s < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0), t ? (i = -a, r = s, o = Math.sqrt(h)) : (i = s, r = a, o = Math.sqrt(h / 2))
                                }
                                return new Qn(i / o, r / o)
                            }
                            const R = [];
                            for (let e = 0, n = T.length, i = n - 1, r = e + 1; e < n; e++, i++, r++) i === n && (i = 0), r === n && (r = 0), R[e] = L(T[e], T[i], T[r]);
                            const I = [];
                            let F, O = R.concat();
                            for (let e = 0, n = M.length; e < n; e++) {
                                const t = M[e];
                                F = [];
                                for (let e = 0, n = t.length, i = n - 1, r = e + 1; e < n; e++, i++, r++) i === n && (i = 0), r === n && (r = 0), F[e] = L(t[e], t[i], t[r]);
                                I.push(F), O = O.concat(F)
                            }
                            for (let e = 0; e < p; e++) {
                                const t = e / p,
                                    n = h * Math.cos(t * Math.PI / 2),
                                    i = u * Math.sin(t * Math.PI / 2) + d;
                                for (let e = 0, r = T.length; e < r; e++) {
                                    const t = E(T[e], R[e], i);
                                    D(t.x, t.y, -n)
                                }
                                for (let e = 0, r = M.length; e < r; e++) {
                                    const t = M[e];
                                    F = I[e];
                                    for (let e = 0, r = t.length; e < r; e++) {
                                        const r = E(t[e], F[e], i);
                                        D(r.x, r.y, -n)
                                    }
                                }
                            }
                            const N = u + d;
                            for (let e = 0; e < C; e++) {
                                const t = c ? E(S[e], O[e], N) : S[e];
                                w ? (x.copy(v.normals[0]).multiplyScalar(t.x), y.copy(v.binormals[0]).multiplyScalar(t.y), b.copy(g[0]).add(x).add(y), D(b.x, b.y, b.z)) : D(t.x, t.y, 0)
                            }
                            for (let e = 1; e <= a; e++)
                                for (let t = 0; t < C; t++) {
                                    const n = c ? E(S[t], O[t], N) : S[t];
                                    w ? (x.copy(v.normals[e]).multiplyScalar(n.x), y.copy(v.binormals[e]).multiplyScalar(n.y), b.copy(g[e]).add(x).add(y), D(b.x, b.y, b.z)) : D(n.x, n.y, l / a * e)
                                }
                            for (let e = p - 1; e >= 0; e--) {
                                const t = e / p,
                                    n = h * Math.cos(t * Math.PI / 2),
                                    i = u * Math.sin(t * Math.PI / 2) + d;
                                for (let e = 0, r = T.length; e < r; e++) {
                                    const t = E(T[e], R[e], i);
                                    D(t.x, t.y, l + n)
                                }
                                for (let e = 0, r = M.length; e < r; e++) {
                                    const t = M[e];
                                    F = I[e];
                                    for (let e = 0, r = t.length; e < r; e++) {
                                        const r = E(t[e], F[e], i);
                                        w ? D(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : D(r.x, r.y, l + n)
                                    }
                                }
                            }

                            function B(t, e) {
                                let n = t.length;
                                for (; --n >= 0;) {
                                    const i = n;
                                    let r = n - 1;
                                    r < 0 && (r = t.length - 1);
                                    for (let t = 0, n = a + 2 * p; t < n; t++) {
                                        const n = C * t,
                                            o = C * (t + 1);
                                        j(e + i + n, e + r + n, e + r + o, e + i + o)
                                    }
                                }
                            }

                            function D(t, e, n) {
                                o.push(t), o.push(e), o.push(n)
                            }

                            function V(t, e, r) {
                                k(t), k(e), k(r);
                                const o = i.length / 3,
                                    s = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
                                U(s[0]), U(s[1]), U(s[2])
                            }

                            function j(t, e, r, o) {
                                k(t), k(e), k(o), k(e), k(r), k(o);
                                const s = i.length / 3,
                                    a = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
                                U(a[0]), U(a[1]), U(a[3]), U(a[1]), U(a[2]), U(a[3])
                            }

                            function k(t) {
                                i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2])
                            }

                            function U(t) {
                                r.push(t.x), r.push(t.y)
                            }! function() {
                                const t = i.length / 3;
                                if (c) {
                                    let t = 0,
                                        e = C * t;
                                    for (let n = 0; n < P; n++) {
                                        const t = A[n];
                                        V(t[2] + e, t[1] + e, t[0] + e)
                                    }
                                    t = a + 2 * p, e = C * t;
                                    for (let n = 0; n < P; n++) {
                                        const t = A[n];
                                        V(t[0] + e, t[1] + e, t[2] + e)
                                    }
                                } else {
                                    for (let t = 0; t < P; t++) {
                                        const e = A[t];
                                        V(e[2], e[1], e[0])
                                    }
                                    for (let t = 0; t < P; t++) {
                                        const e = A[t];
                                        V(e[0] + C * a, e[1] + C * a, e[2] + C * a)
                                    }
                                }
                                n.addGroup(t, i.length / 3 - t, 0)
                            }(),
                            function() {
                                const t = i.length / 3;
                                let e = 0;
                                B(T, e), e += T.length;
                                for (let n = 0, i = M.length; n < i; n++) {
                                    const t = M[n];
                                    B(t, e), e += t.length
                                }
                                n.addGroup(t, i.length / 3 - t, 1)
                            }()
                        }
                        this.setAttribute("position", new Yr(i, 3)), this.setAttribute("uv", new Yr(r, 2)), this.computeVertexNormals()
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return function(t, e, n) {
                            if (n.shapes = [], Array.isArray(t))
                                for (let i = 0, r = t.length; i < r; i++) {
                                    const e = t[i];
                                    n.shapes.push(e.uuid)
                                } else n.shapes.push(t.uuid);
                            return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
                        }(this.parameters.shapes, this.parameters.options, t)
                    }
                }
                const th = {
                    generateTopUV: function(t, e, n, i, r) {
                        const o = e[3 * n],
                            s = e[3 * n + 1],
                            a = e[3 * i],
                            l = e[3 * i + 1],
                            c = e[3 * r],
                            h = e[3 * r + 1];
                        return [new Qn(o, s), new Qn(a, l), new Qn(c, h)]
                    },
                    generateSideWallUV: function(t, e, n, i, r, o) {
                        const s = e[3 * n],
                            a = e[3 * n + 1],
                            l = e[3 * n + 2],
                            c = e[3 * i],
                            h = e[3 * i + 1],
                            u = e[3 * i + 2],
                            d = e[3 * r],
                            p = e[3 * r + 1],
                            f = e[3 * r + 2],
                            m = e[3 * o],
                            g = e[3 * o + 1],
                            v = e[3 * o + 2];
                        return Math.abs(a - h) < Math.abs(s - c) ? [new Qn(s, 1 - l), new Qn(c, 1 - u), new Qn(d, 1 - f), new Qn(m, 1 - v)] : [new Qn(a, 1 - l), new Qn(h, 1 - u), new Qn(p, 1 - f), new Qn(g, 1 - v)]
                    }
                };
                class eh extends yc {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = (1 + Math.sqrt(5)) / 2;
                        super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = {
                            radius: t,
                            detail: e
                        }
                    }
                }
                class nh extends ro {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 12,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2 * Math.PI;
                        super(), this.type = "LatheGeometry", this.parameters = {
                            points: t,
                            segments: e,
                            phiStart: n,
                            phiLength: i
                        }, e = Math.floor(e), i = zn(i, 0, 2 * Math.PI);
                        const r = [],
                            o = [],
                            s = [],
                            a = 1 / e,
                            l = new ai,
                            c = new Qn;
                        for (let h = 0; h <= e; h++) {
                            const r = n + h * a * i,
                                u = Math.sin(r),
                                d = Math.cos(r);
                            for (let n = 0; n <= t.length - 1; n++) l.x = t[n].x * u, l.y = t[n].y, l.z = t[n].x * d, o.push(l.x, l.y, l.z), c.x = h / e, c.y = n / (t.length - 1), s.push(c.x, c.y)
                        }
                        for (let h = 0; h < e; h++)
                            for (let e = 0; e < t.length - 1; e++) {
                                const n = e + h * t.length,
                                    i = n,
                                    o = n + t.length,
                                    s = n + t.length + 1,
                                    a = n + 1;
                                r.push(i, o, a), r.push(o, s, a)
                            }
                        if (this.setIndex(r), this.setAttribute("position", new Yr(o, 3)), this.setAttribute("uv", new Yr(s, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
                            const n = this.attributes.normal.array,
                                i = new ai,
                                r = new ai,
                                o = new ai,
                                s = e * t.length * 3;
                            for (let e = 0, a = 0; e < t.length; e++, a += 3) i.x = n[a + 0], i.y = n[a + 1], i.z = n[a + 2], r.x = n[s + a + 0], r.y = n[s + a + 1], r.z = n[s + a + 2], o.addVectors(i, r).normalize(), n[a + 0] = n[s + a + 0] = o.x, n[a + 1] = n[s + a + 1] = o.y, n[a + 2] = n[s + a + 2] = o.z
                        }
                    }
                }
                class ih extends yc {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = {
                            radius: t,
                            detail: e
                        }
                    }
                }
                class rh extends ro {
                    constructor(t, e, n) {
                        super(), this.type = "ParametricGeometry", this.parameters = {
                            func: t,
                            slices: e,
                            stacks: n
                        };
                        const i = [],
                            r = [],
                            o = [],
                            s = [],
                            a = new ai,
                            l = new ai,
                            c = new ai,
                            h = new ai,
                            u = new ai;
                        t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                        const d = e + 1;
                        for (let p = 0; p <= n; p++) {
                            const i = p / n;
                            for (let n = 0; n <= e; n++) {
                                const d = n / e;
                                t(d, i, l), r.push(l.x, l.y, l.z), d - 1e-5 >= 0 ? (t(d - 1e-5, i, c), h.subVectors(l, c)) : (t(d + 1e-5, i, c), h.subVectors(c, l)), i - 1e-5 >= 0 ? (t(d, i - 1e-5, c), u.subVectors(l, c)) : (t(d, i + 1e-5, c), u.subVectors(c, l)), a.crossVectors(h, u).normalize(), o.push(a.x, a.y, a.z), s.push(d, i)
                            }
                        }
                        for (let p = 0; p < n; p++)
                            for (let t = 0; t < e; t++) {
                                const e = p * d + t,
                                    n = p * d + t + 1,
                                    r = (p + 1) * d + t + 1,
                                    o = (p + 1) * d + t;
                                i.push(e, n, o), i.push(n, r, o)
                            }
                        this.setIndex(i), this.setAttribute("position", new Yr(r, 3)), this.setAttribute("normal", new Yr(o, 3)), this.setAttribute("uv", new Yr(s, 2))
                    }
                }
                class oh extends ro {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2 * Math.PI;
                        super(), this.type = "RingGeometry", this.parameters = {
                            innerRadius: t,
                            outerRadius: e,
                            thetaSegments: n,
                            phiSegments: i,
                            thetaStart: r,
                            thetaLength: o
                        }, n = Math.max(3, n);
                        const s = [],
                            a = [],
                            l = [],
                            c = [];
                        let h = t;
                        const u = (e - t) / (i = Math.max(1, i)),
                            d = new ai,
                            p = new Qn;
                        for (let f = 0; f <= i; f++) {
                            for (let t = 0; t <= n; t++) {
                                const i = r + t / n * o;
                                d.x = h * Math.cos(i), d.y = h * Math.sin(i), a.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / e + 1) / 2, p.y = (d.y / e + 1) / 2, c.push(p.x, p.y)
                            }
                            h += u
                        }
                        for (let f = 0; f < i; f++) {
                            const t = f * (n + 1);
                            for (let e = 0; e < n; e++) {
                                const i = e + t,
                                    r = i,
                                    o = i + n + 1,
                                    a = i + n + 2,
                                    l = i + 1;
                                s.push(r, o, l), s.push(o, a, l)
                            }
                        }
                        this.setIndex(s), this.setAttribute("position", new Yr(a, 3)), this.setAttribute("normal", new Yr(l, 3)), this.setAttribute("uv", new Yr(c, 2))
                    }
                }
                class sh extends ro {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 12;
                        super(), this.type = "ShapeGeometry", this.parameters = {
                            shapes: t,
                            curveSegments: e
                        };
                        const n = [],
                            i = [],
                            r = [],
                            o = [];
                        let s = 0,
                            a = 0;
                        if (!1 === Array.isArray(t)) l(t);
                        else
                            for (let c = 0; c < t.length; c++) l(t[c]), this.addGroup(s, a, c), s += a, a = 0;

                        function l(t) {
                            const s = i.length / 3,
                                l = t.extractPoints(e);
                            let c = l.shape;
                            const h = l.holes;
                            !1 === Zc.isClockWise(c) && (c = c.reverse());
                            for (let e = 0, n = h.length; e < n; e++) {
                                const t = h[e];
                                !0 === Zc.isClockWise(t) && (h[e] = t.reverse())
                            }
                            const u = Zc.triangulateShape(c, h);
                            for (let e = 0, n = h.length; e < n; e++) {
                                const t = h[e];
                                c = c.concat(t)
                            }
                            for (let e = 0, n = c.length; e < n; e++) {
                                const t = c[e];
                                i.push(t.x, t.y, 0), r.push(0, 0, 1), o.push(t.x, t.y)
                            }
                            for (let e = 0, i = u.length; e < i; e++) {
                                const t = u[e],
                                    i = t[0] + s,
                                    r = t[1] + s,
                                    o = t[2] + s;
                                n.push(i, r, o), a += 3
                            }
                        }
                        this.setIndex(n), this.setAttribute("position", new Yr(i, 3)), this.setAttribute("normal", new Yr(r, 3)), this.setAttribute("uv", new Yr(o, 2))
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return function(t, e) {
                            if (e.shapes = [], Array.isArray(t))
                                for (let n = 0, i = t.length; n < i; n++) {
                                    const i = t[n];
                                    e.shapes.push(i.uuid)
                                } else e.shapes.push(t.uuid);
                            return e
                        }(this.parameters.shapes, t)
                    }
                }
                class ah extends ro {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 8,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 6,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2 * Math.PI,
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                            s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : Math.PI;
                        super(), this.type = "SphereGeometry", this.parameters = {
                            radius: t,
                            widthSegments: e,
                            heightSegments: n,
                            phiStart: i,
                            phiLength: r,
                            thetaStart: o,
                            thetaLength: s
                        }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
                        const a = Math.min(o + s, Math.PI);
                        let l = 0;
                        const c = [],
                            h = new ai,
                            u = new ai,
                            d = [],
                            p = [],
                            f = [],
                            m = [];
                        for (let g = 0; g <= n; g++) {
                            const d = [],
                                v = g / n;
                            let y = 0;
                            0 == g && 0 == o ? y = .5 / e : g == n && a == Math.PI && (y = -.5 / e);
                            for (let n = 0; n <= e; n++) {
                                const a = n / e;
                                h.x = -t * Math.cos(i + a * r) * Math.sin(o + v * s), h.y = t * Math.cos(o + v * s), h.z = t * Math.sin(i + a * r) * Math.sin(o + v * s), p.push(h.x, h.y, h.z), u.copy(h).normalize(), f.push(u.x, u.y, u.z), m.push(a + y, 1 - v), d.push(l++)
                            }
                            c.push(d)
                        }
                        for (let g = 0; g < n; g++)
                            for (let t = 0; t < e; t++) {
                                const e = c[g][t + 1],
                                    i = c[g][t],
                                    r = c[g + 1][t],
                                    s = c[g + 1][t + 1];
                                (0 !== g || o > 0) && d.push(e, i, s), (g !== n - 1 || a < Math.PI) && d.push(i, r, s)
                            }
                        this.setIndex(d), this.setAttribute("position", new Yr(p, 3)), this.setAttribute("normal", new Yr(f, 3)), this.setAttribute("uv", new Yr(m, 2))
                    }
                }
                class lh extends yc {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = {
                            radius: t,
                            detail: e
                        }
                    }
                }
                class ch extends $c {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        const n = e.font;
                        if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new ro;
                        const i = n.generateShapes(t, e.size);
                        e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), super(i, e), this.type = "TextGeometry"
                    }
                }
                class hh extends ro {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .4,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 6,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2 * Math.PI;
                        super(), this.type = "TorusGeometry", this.parameters = {
                            radius: t,
                            tube: e,
                            radialSegments: n,
                            tubularSegments: i,
                            arc: r
                        }, n = Math.floor(n), i = Math.floor(i);
                        const o = [],
                            s = [],
                            a = [],
                            l = [],
                            c = new ai,
                            h = new ai,
                            u = new ai;
                        for (let d = 0; d <= n; d++)
                            for (let o = 0; o <= i; o++) {
                                const p = o / i * r,
                                    f = d / n * Math.PI * 2;
                                h.x = (t + e * Math.cos(f)) * Math.cos(p), h.y = (t + e * Math.cos(f)) * Math.sin(p), h.z = e * Math.sin(f), s.push(h.x, h.y, h.z), c.x = t * Math.cos(p), c.y = t * Math.sin(p), u.subVectors(h, c).normalize(), a.push(u.x, u.y, u.z), l.push(o / i), l.push(d / n)
                            }
                        for (let d = 1; d <= n; d++)
                            for (let t = 1; t <= i; t++) {
                                const e = (i + 1) * d + t - 1,
                                    n = (i + 1) * (d - 1) + t - 1,
                                    r = (i + 1) * (d - 1) + t,
                                    s = (i + 1) * d + t;
                                o.push(e, n, s), o.push(n, r, s)
                            }
                        this.setIndex(o), this.setAttribute("position", new Yr(s, 3)), this.setAttribute("normal", new Yr(a, 3)), this.setAttribute("uv", new Yr(l, 2))
                    }
                }
                class uh extends ro {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .4,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 64,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2,
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 3;
                        super(), this.type = "TorusKnotGeometry", this.parameters = {
                            radius: t,
                            tube: e,
                            tubularSegments: n,
                            radialSegments: i,
                            p: r,
                            q: o
                        }, n = Math.floor(n), i = Math.floor(i);
                        const s = [],
                            a = [],
                            l = [],
                            c = [],
                            h = new ai,
                            u = new ai,
                            d = new ai,
                            p = new ai,
                            f = new ai,
                            m = new ai,
                            g = new ai;
                        for (let y = 0; y <= n; ++y) {
                            const s = y / n * r * Math.PI * 2;
                            v(s, r, o, t, d), v(s + .01, r, o, t, p), m.subVectors(p, d), g.addVectors(p, d), f.crossVectors(m, g), g.crossVectors(f, m), f.normalize(), g.normalize();
                            for (let t = 0; t <= i; ++t) {
                                const r = t / i * Math.PI * 2,
                                    o = -e * Math.cos(r),
                                    s = e * Math.sin(r);
                                h.x = d.x + (o * g.x + s * f.x), h.y = d.y + (o * g.y + s * f.y), h.z = d.z + (o * g.z + s * f.z), a.push(h.x, h.y, h.z), u.subVectors(h, d).normalize(), l.push(u.x, u.y, u.z), c.push(y / n), c.push(t / i)
                            }
                        }
                        for (let y = 1; y <= n; y++)
                            for (let t = 1; t <= i; t++) {
                                const e = (i + 1) * (y - 1) + (t - 1),
                                    n = (i + 1) * y + (t - 1),
                                    r = (i + 1) * y + t,
                                    o = (i + 1) * (y - 1) + t;
                                s.push(e, n, o), s.push(n, r, o)
                            }

                        function v(t, e, n, i, r) {
                            const o = Math.cos(t),
                                s = Math.sin(t),
                                a = n / e * t,
                                l = Math.cos(a);
                            r.x = i * (2 + l) * .5 * o, r.y = i * (2 + l) * s * .5, r.z = i * Math.sin(a) * .5
                        }
                        this.setIndex(s), this.setAttribute("position", new Yr(a, 3)), this.setAttribute("normal", new Yr(l, 3)), this.setAttribute("uv", new Yr(c, 2))
                    }
                }
                class dh extends ro {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8,
                            r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                        super(), this.type = "TubeGeometry", this.parameters = {
                            path: t,
                            tubularSegments: e,
                            radius: n,
                            radialSegments: i,
                            closed: r
                        };
                        const o = t.computeFrenetFrames(e, r);
                        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
                        const s = new ai,
                            a = new ai,
                            l = new Qn;
                        let c = new ai;
                        const h = [],
                            u = [],
                            d = [],
                            p = [];

                        function f(r) {
                            c = t.getPointAt(r / e, c);
                            const l = o.normals[r],
                                d = o.binormals[r];
                            for (let t = 0; t <= i; t++) {
                                const e = t / i * Math.PI * 2,
                                    r = Math.sin(e),
                                    o = -Math.cos(e);
                                a.x = o * l.x + r * d.x, a.y = o * l.y + r * d.y, a.z = o * l.z + r * d.z, a.normalize(), u.push(a.x, a.y, a.z), s.x = c.x + n * a.x, s.y = c.y + n * a.y, s.z = c.z + n * a.z, h.push(s.x, s.y, s.z)
                            }
                        }! function() {
                            for (let t = 0; t < e; t++) f(t);
                            f(!1 === r ? e : 0),
                                function() {
                                    for (let t = 0; t <= e; t++)
                                        for (let n = 0; n <= i; n++) l.x = t / e, l.y = n / i, d.push(l.x, l.y)
                                }(),
                                function() {
                                    for (let t = 1; t <= e; t++)
                                        for (let e = 1; e <= i; e++) {
                                            const n = (i + 1) * (t - 1) + (e - 1),
                                                r = (i + 1) * t + (e - 1),
                                                o = (i + 1) * t + e,
                                                s = (i + 1) * (t - 1) + e;
                                            p.push(n, r, s), p.push(r, o, s)
                                        }
                                }()
                        }(), this.setIndex(p), this.setAttribute("position", new Yr(h, 3)), this.setAttribute("normal", new Yr(u, 3)), this.setAttribute("uv", new Yr(d, 2))
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.path = this.parameters.path.toJSON(), t
                    }
                }
                class ph extends ro {
                    constructor(t) {
                        if (super(), this.type = "WireframeGeometry", !0 === t.isGeometry) return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        const e = [],
                            n = [0, 0],
                            i = {},
                            r = new ai;
                        if (null !== t.index) {
                            const o = t.attributes.position,
                                s = t.index;
                            let a = t.groups;
                            0 === a.length && (a = [{
                                start: 0,
                                count: s.count,
                                materialIndex: 0
                            }]);
                            for (let t = 0, e = a.length; t < e; ++t) {
                                const e = a[t],
                                    r = e.start;
                                for (let t = r, o = r + e.count; t < o; t += 3)
                                    for (let e = 0; e < 3; e++) {
                                        const r = s.getX(t + e),
                                            o = s.getX(t + (e + 1) % 3);
                                        n[0] = Math.min(r, o), n[1] = Math.max(r, o);
                                        const a = n[0] + "," + n[1];
                                        void 0 === i[a] && (i[a] = {
                                            index1: n[0],
                                            index2: n[1]
                                        })
                                    }
                            }
                            for (const t in i) {
                                const n = i[t];
                                r.fromBufferAttribute(o, n.index1), e.push(r.x, r.y, r.z), r.fromBufferAttribute(o, n.index2), e.push(r.x, r.y, r.z)
                            }
                        } else {
                            const n = t.attributes.position;
                            for (let t = 0, i = n.count / 3; t < i; t++)
                                for (let o = 0; o < 3; o++) {
                                    const i = 3 * t + o;
                                    r.fromBufferAttribute(n, i), e.push(r.x, r.y, r.z);
                                    const s = 3 * t + (o + 1) % 3;
                                    r.fromBufferAttribute(n, s), e.push(r.x, r.y, r.z)
                                }
                        }
                        this.setAttribute("position", new Yr(e, 3))
                    }
                }
                var fh = Object.freeze({
                    __proto__: null,
                    BoxGeometry: Ao,
                    BoxBufferGeometry: Ao,
                    CircleGeometry: mc,
                    CircleBufferGeometry: mc,
                    ConeGeometry: vc,
                    ConeBufferGeometry: vc,
                    CylinderGeometry: gc,
                    CylinderBufferGeometry: gc,
                    DodecahedronGeometry: xc,
                    DodecahedronBufferGeometry: xc,
                    EdgesGeometry: Mc,
                    ExtrudeGeometry: $c,
                    ExtrudeBufferGeometry: $c,
                    IcosahedronGeometry: eh,
                    IcosahedronBufferGeometry: eh,
                    LatheGeometry: nh,
                    LatheBufferGeometry: nh,
                    OctahedronGeometry: ih,
                    OctahedronBufferGeometry: ih,
                    ParametricGeometry: rh,
                    ParametricBufferGeometry: rh,
                    PlaneGeometry: Ho,
                    PlaneBufferGeometry: Ho,
                    PolyhedronGeometry: yc,
                    PolyhedronBufferGeometry: yc,
                    RingGeometry: oh,
                    RingBufferGeometry: oh,
                    ShapeGeometry: sh,
                    ShapeBufferGeometry: sh,
                    SphereGeometry: ah,
                    SphereBufferGeometry: ah,
                    TetrahedronGeometry: lh,
                    TetrahedronBufferGeometry: lh,
                    TextGeometry: ch,
                    TextBufferGeometry: ch,
                    TorusGeometry: hh,
                    TorusBufferGeometry: hh,
                    TorusKnotGeometry: uh,
                    TorusKnotBufferGeometry: uh,
                    TubeGeometry: dh,
                    TubeBufferGeometry: dh,
                    WireframeGeometry: ph
                });
                class mh extends Tr {
                    constructor(t) {
                        super(), this.type = "ShadowMaterial", this.color = new Fr(0), this.transparent = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this
                    }
                }
                mh.prototype.isShadowMaterial = !0;
                class gh extends Ro {
                    constructor(t) {
                        super(t), this.type = "RawShaderMaterial"
                    }
                }
                gh.prototype.isRawShaderMaterial = !0;
                class vh extends Tr {
                    constructor(t) {
                        super(), this.defines = {
                            STANDARD: ""
                        }, this.type = "MeshStandardMaterial", this.color = new Fr(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Fr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new Qn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.defines = {
                            STANDARD: ""
                        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this.vertexTangents = t.vertexTangents, this
                    }
                }
                vh.prototype.isMeshStandardMaterial = !0;
                class yh extends vh {
                    constructor(t) {
                        super(), this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Qn(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
                            get: function() {
                                return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                            },
                            set: function(t) {
                                this.reflectivity = zn(2.5 * (t - 1) / (t + 1), 0, 1)
                            }
                        }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Fr(1, 1, 1), this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Fr).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this
                    }
                }
                yh.prototype.isMeshPhysicalMaterial = !0;
                class xh extends Tr {
                    constructor(t) {
                        super(), this.type = "MeshPhongMaterial", this.color = new Fr(16777215), this.specular = new Fr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Fr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new Qn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
                    }
                }
                xh.prototype.isMeshPhongMaterial = !0;
                class bh extends Tr {
                    constructor(t) {
                        super(), this.defines = {
                            TOON: ""
                        }, this.type = "MeshToonMaterial", this.color = new Fr(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Fr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new Qn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
                    }
                }
                bh.prototype.isMeshToonMaterial = !0;
                class wh extends Tr {
                    constructor(t) {
                        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new Qn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
                    }
                }
                wh.prototype.isMeshNormalMaterial = !0;
                class _h extends Tr {
                    constructor(t) {
                        super(), this.type = "MeshLambertMaterial", this.color = new Fr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Fr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
                    }
                }
                _h.prototype.isMeshLambertMaterial = !0;
                class Sh extends Tr {
                    constructor(t) {
                        super(), this.defines = {
                            MATCAP: ""
                        }, this.type = "MeshMatcapMaterial", this.color = new Fr(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new Qn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.defines = {
                            MATCAP: ""
                        }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
                    }
                }
                Sh.prototype.isMeshMatcapMaterial = !0;
                class Mh extends Xl {
                    constructor(t) {
                        super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
                    }
                }
                Mh.prototype.isLineDashedMaterial = !0;
                var Ah = Object.freeze({
                    __proto__: null,
                    ShadowMaterial: mh,
                    SpriteMaterial: dl,
                    RawShaderMaterial: gh,
                    ShaderMaterial: Ro,
                    PointsMaterial: rc,
                    MeshPhysicalMaterial: yh,
                    MeshStandardMaterial: vh,
                    MeshPhongMaterial: xh,
                    MeshToonMaterial: bh,
                    MeshNormalMaterial: wh,
                    MeshLambertMaterial: _h,
                    MeshDepthMaterial: Ha,
                    MeshDistanceMaterial: Wa,
                    MeshBasicMaterial: Or,
                    MeshMatcapMaterial: Sh,
                    LineDashedMaterial: Mh,
                    LineBasicMaterial: Xl,
                    Material: Tr
                });
                const Th = {
                    arraySlice: function(t, e, n) {
                        return Th.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                    },
                    convertArray: function(t, e, n) {
                        return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                    },
                    isTypedArray: function(t) {
                        return ArrayBuffer.isView(t) && !(t instanceof DataView)
                    },
                    getKeyframeOrder: function(t) {
                        const e = t.length,
                            n = new Array(e);
                        for (let i = 0; i !== e; ++i) n[i] = i;
                        return n.sort((function(e, n) {
                            return t[e] - t[n]
                        })), n
                    },
                    sortedArray: function(t, e, n) {
                        const i = t.length,
                            r = new t.constructor(i);
                        for (let o = 0, s = 0; s !== i; ++o) {
                            const i = n[o] * e;
                            for (let n = 0; n !== e; ++n) r[s++] = t[i + n]
                        }
                        return r
                    },
                    flattenJSON: function(t, e, n, i) {
                        let r = 1,
                            o = t[0];
                        for (; void 0 !== o && void 0 === o[i];) o = t[r++];
                        if (void 0 === o) return;
                        let s = o[i];
                        if (void 0 !== s)
                            if (Array.isArray(s))
                                do {
                                    s = o[i], void 0 !== s && (e.push(o.time), n.push.apply(n, s)), o = t[r++]
                                } while (void 0 !== o);
                            else if (void 0 !== s.toArray)
                            do {
                                s = o[i], void 0 !== s && (e.push(o.time), s.toArray(n, n.length)), o = t[r++]
                            } while (void 0 !== o);
                        else
                            do {
                                s = o[i], void 0 !== s && (e.push(o.time), n.push(s)), o = t[r++]
                            } while (void 0 !== o)
                    },
                    subclip: function(t, e, n, i) {
                        let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 30;
                        const o = t.clone();
                        o.name = e;
                        const s = [];
                        for (let l = 0; l < o.tracks.length; ++l) {
                            const t = o.tracks[l],
                                e = t.getValueSize(),
                                a = [],
                                c = [];
                            for (let o = 0; o < t.times.length; ++o) {
                                const s = t.times[o] * r;
                                if (!(s < n || s >= i)) {
                                    a.push(t.times[o]);
                                    for (let n = 0; n < e; ++n) c.push(t.values[o * e + n])
                                }
                            }
                            0 !== a.length && (t.times = Th.convertArray(a, t.times.constructor), t.values = Th.convertArray(c, t.values.constructor), s.push(t))
                        }
                        o.tracks = s;
                        let a = 1 / 0;
                        for (let l = 0; l < o.tracks.length; ++l) a > o.tracks[l].times[0] && (a = o.tracks[l].times[0]);
                        for (let l = 0; l < o.tracks.length; ++l) o.tracks[l].shift(-1 * a);
                        return o.resetDuration(), o
                    },
                    makeClipAdditive: function(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 30;
                        i <= 0 && (i = 30);
                        const r = n.tracks.length,
                            o = e / i;
                        for (let s = 0; s < r; ++s) {
                            const e = n.tracks[s],
                                i = e.ValueTypeName;
                            if ("bool" === i || "string" === i) continue;
                            const r = t.tracks.find((function(t) {
                                return t.name === e.name && t.ValueTypeName === i
                            }));
                            if (void 0 === r) continue;
                            let a = 0;
                            const l = e.getValueSize();
                            e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
                            let c = 0;
                            const h = r.getValueSize();
                            r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                            const u = e.times.length - 1;
                            let d;
                            if (o <= e.times[0]) {
                                const t = a,
                                    n = l - a;
                                d = Th.arraySlice(e.values, t, n)
                            } else if (o >= e.times[u]) {
                                const t = u * l + a,
                                    n = t + l - a;
                                d = Th.arraySlice(e.values, t, n)
                            } else {
                                const t = e.createInterpolant(),
                                    n = a,
                                    i = l - a;
                                t.evaluate(o), d = Th.arraySlice(t.resultBuffer, n, i)
                            }
                            "quaternion" === i && (new si).fromArray(d).normalize().conjugate().toArray(d);
                            const p = r.times.length;
                            for (let t = 0; t < p; ++t) {
                                const e = t * h + c;
                                if ("quaternion" === i) si.multiplyQuaternionsFlat(r.values, e, d, 0, r.values, e);
                                else {
                                    const t = h - 2 * c;
                                    for (let n = 0; n < t; ++n) r.values[e + n] -= d[n]
                                }
                            }
                        }
                        return t.blendMode = Ye, t
                    }
                };
                class Eh {
                    constructor(t, e, n, i) {
                        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
                    }
                    evaluate(t) {
                        const e = this.parameterPositions;
                        let n = this._cachedIndex,
                            i = e[n],
                            r = e[n - 1];
                        t: {
                            e: {
                                let o;n: {
                                    i: if (!(t < i)) {
                                        for (let o = n + 2;;) {
                                            if (void 0 === i) {
                                                if (t < r) break i;
                                                return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r)
                                            }
                                            if (n === o) break;
                                            if (r = i, i = e[++n], t < i) break e
                                        }
                                        o = e.length;
                                        break n
                                    }if (t >= r) break t; {
                                        const s = e[1];
                                        t < s && (n = 2, r = s);
                                        for (let o = n - 2;;) {
                                            if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                            if (n === o) break;
                                            if (i = r, r = e[--n - 1], t >= r) break e
                                        }
                                        o = n, n = 0
                                    }
                                }
                                for (; n < o;) {
                                    const i = n + o >>> 1;
                                    t < e[i] ? o = i : n = i + 1
                                }
                                if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, r, i)
                        }
                        return this.interpolate_(n, r, t, i)
                    }
                    getSettings_() {
                        return this.settings || this.DefaultSettings_
                    }
                    copySampleValue_(t) {
                        const e = this.resultBuffer,
                            n = this.sampleValues,
                            i = this.valueSize,
                            r = t * i;
                        for (let o = 0; o !== i; ++o) e[o] = n[r + o];
                        return e
                    }
                    interpolate_() {
                        throw new Error("call to abstract method")
                    }
                    intervalChanged_() {}
                }
                Eh.prototype.beforeStart_ = Eh.prototype.copySampleValue_, Eh.prototype.afterEnd_ = Eh.prototype.copySampleValue_;
                class Ch extends Eh {
                    constructor(t, e, n, i) {
                        super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                            endingStart: ze,
                            endingEnd: ze
                        }
                    }
                    intervalChanged_(t, e, n) {
                        const i = this.parameterPositions;
                        let r = t - 2,
                            o = t + 1,
                            s = i[r],
                            a = i[o];
                        if (void 0 === s) switch (this.getSettings_().endingStart) {
                            case Ge:
                                r = t, s = 2 * e - n;
                                break;
                            case He:
                                r = i.length - 2, s = e + i[r] - i[r + 1];
                                break;
                            default:
                                r = t, s = n
                        }
                        if (void 0 === a) switch (this.getSettings_().endingEnd) {
                            case Ge:
                                o = t, a = 2 * n - e;
                                break;
                            case He:
                                o = 1, a = n + i[1] - i[0];
                                break;
                            default:
                                o = t - 1, a = e
                        }
                        const l = .5 * (n - e),
                            c = this.valueSize;
                        this._weightPrev = l / (e - s), this._weightNext = l / (a - n), this._offsetPrev = r * c, this._offsetNext = o * c
                    }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            o = this.sampleValues,
                            s = this.valueSize,
                            a = t * s,
                            l = a - s,
                            c = this._offsetPrev,
                            h = this._offsetNext,
                            u = this._weightPrev,
                            d = this._weightNext,
                            p = (n - e) / (i - e),
                            f = p * p,
                            m = f * p,
                            g = -u * m + 2 * u * f - u * p,
                            v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1,
                            y = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                            x = d * m - d * f;
                        for (let b = 0; b !== s; ++b) r[b] = g * o[c + b] + v * o[l + b] + y * o[a + b] + x * o[h + b];
                        return r
                    }
                }
                class Ph extends Eh {
                    constructor(t, e, n, i) {
                        super(t, e, n, i)
                    }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            o = this.sampleValues,
                            s = this.valueSize,
                            a = t * s,
                            l = a - s,
                            c = (n - e) / (i - e),
                            h = 1 - c;
                        for (let u = 0; u !== s; ++u) r[u] = o[l + u] * h + o[a + u] * c;
                        return r
                    }
                }
                class Lh extends Eh {
                    constructor(t, e, n, i) {
                        super(t, e, n, i)
                    }
                    interpolate_(t) {
                        return this.copySampleValue_(t - 1)
                    }
                }
                class Rh {
                    constructor(t, e, n, i) {
                        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                        this.name = t, this.times = Th.convertArray(e, this.TimeBufferType), this.values = Th.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
                    }
                    static toJSON(t) {
                        const e = t.constructor;
                        let n;
                        if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                        else {
                            n = {
                                name: t.name,
                                times: Th.convertArray(t.times, Array),
                                values: Th.convertArray(t.values, Array)
                            };
                            const e = t.getInterpolation();
                            e !== t.DefaultInterpolation && (n.interpolation = e)
                        }
                        return n.type = t.ValueTypeName, n
                    }
                    InterpolantFactoryMethodDiscrete(t) {
                        return new Lh(this.times, this.values, this.getValueSize(), t)
                    }
                    InterpolantFactoryMethodLinear(t) {
                        return new Ph(this.times, this.values, this.getValueSize(), t)
                    }
                    InterpolantFactoryMethodSmooth(t) {
                        return new Ch(this.times, this.values, this.getValueSize(), t)
                    }
                    setInterpolation(t) {
                        let e;
                        switch (t) {
                            case je:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case ke:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case Ue:
                                e = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === e) {
                            const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation) throw new Error(e);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", e), this
                        }
                        return this.createInterpolant = e, this
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return je;
                            case this.InterpolantFactoryMethodLinear:
                                return ke;
                            case this.InterpolantFactoryMethodSmooth:
                                return Ue
                        }
                    }
                    getValueSize() {
                        return this.values.length / this.times.length
                    }
                    shift(t) {
                        if (0 !== t) {
                            const e = this.times;
                            for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
                        }
                        return this
                    }
                    scale(t) {
                        if (1 !== t) {
                            const e = this.times;
                            for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
                        }
                        return this
                    }
                    trim(t, e) {
                        const n = this.times,
                            i = n.length;
                        let r = 0,
                            o = i - 1;
                        for (; r !== i && n[r] < t;) ++r;
                        for (; - 1 !== o && n[o] > e;) --o;
                        if (++o, 0 !== r || o !== i) {
                            r >= o && (o = Math.max(o, 1), r = o - 1);
                            const t = this.getValueSize();
                            this.times = Th.arraySlice(n, r, o), this.values = Th.arraySlice(this.values, r * t, o * t)
                        }
                        return this
                    }
                    validate() {
                        let t = !0;
                        const e = this.getValueSize();
                        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                        const n = this.times,
                            i = this.values,
                            r = n.length;
                        0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                        let o = null;
                        for (let s = 0; s !== r; s++) {
                            const e = n[s];
                            if ("number" == typeof e && isNaN(e)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, e), t = !1;
                                break
                            }
                            if (null !== o && o > e) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, s, e, o), t = !1;
                                break
                            }
                            o = e
                        }
                        if (void 0 !== i && Th.isTypedArray(i))
                            for (let s = 0, a = i.length; s !== a; ++s) {
                                const e = i[s];
                                if (isNaN(e)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, s, e), t = !1;
                                    break
                                }
                            }
                        return t
                    }
                    optimize() {
                        const t = Th.arraySlice(this.times),
                            e = Th.arraySlice(this.values),
                            n = this.getValueSize(),
                            i = this.getInterpolation() === Ue,
                            r = t.length - 1;
                        let o = 1;
                        for (let s = 1; s < r; ++s) {
                            let r = !1;
                            const a = t[s];
                            if (a !== t[s + 1] && (1 !== s || a !== t[0]))
                                if (i) r = !0;
                                else {
                                    const t = s * n,
                                        i = t - n,
                                        o = t + n;
                                    for (let s = 0; s !== n; ++s) {
                                        const n = e[t + s];
                                        if (n !== e[i + s] || n !== e[o + s]) {
                                            r = !0;
                                            break
                                        }
                                    }
                                }
                            if (r) {
                                if (s !== o) {
                                    t[o] = t[s];
                                    const i = s * n,
                                        r = o * n;
                                    for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                                }++o
                            }
                        }
                        if (r > 0) {
                            t[o] = t[r];
                            for (let t = r * n, i = o * n, s = 0; s !== n; ++s) e[i + s] = e[t + s];
                            ++o
                        }
                        return o !== t.length ? (this.times = Th.arraySlice(t, 0, o), this.values = Th.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this
                    }
                    clone() {
                        const t = Th.arraySlice(this.times, 0),
                            e = Th.arraySlice(this.values, 0),
                            n = new(0, this.constructor)(this.name, t, e);
                        return n.createInterpolant = this.createInterpolant, n
                    }
                }
                Rh.prototype.TimeBufferType = Float32Array, Rh.prototype.ValueBufferType = Float32Array, Rh.prototype.DefaultInterpolation = ke;
                class Ih extends Rh {}
                Ih.prototype.ValueTypeName = "bool", Ih.prototype.ValueBufferType = Array, Ih.prototype.DefaultInterpolation = je, Ih.prototype.InterpolantFactoryMethodLinear = void 0, Ih.prototype.InterpolantFactoryMethodSmooth = void 0;
                class Fh extends Rh {}
                Fh.prototype.ValueTypeName = "color";
                class Oh extends Rh {}
                Oh.prototype.ValueTypeName = "number";
                class Nh extends Eh {
                    constructor(t, e, n, i) {
                        super(t, e, n, i)
                    }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            o = this.sampleValues,
                            s = this.valueSize,
                            a = (n - e) / (i - e);
                        let l = t * s;
                        for (let c = l + s; l !== c; l += 4) si.slerpFlat(r, 0, o, l - s, o, l, a);
                        return r
                    }
                }
                class Bh extends Rh {
                    InterpolantFactoryMethodLinear(t) {
                        return new Nh(this.times, this.values, this.getValueSize(), t)
                    }
                }
                Bh.prototype.ValueTypeName = "quaternion", Bh.prototype.DefaultInterpolation = ke, Bh.prototype.InterpolantFactoryMethodSmooth = void 0;
                class Dh extends Rh {}
                Dh.prototype.ValueTypeName = "string", Dh.prototype.ValueBufferType = Array, Dh.prototype.DefaultInterpolation = je, Dh.prototype.InterpolantFactoryMethodLinear = void 0, Dh.prototype.InterpolantFactoryMethodSmooth = void 0;
                class Vh extends Rh {}
                Vh.prototype.ValueTypeName = "vector";
                class jh {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1,
                            n = arguments.length > 2 ? arguments[2] : void 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : We;
                        this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = Un(), this.duration < 0 && this.resetDuration()
                    }
                    static parse(t) {
                        const e = [],
                            n = t.tracks,
                            i = 1 / (t.fps || 1);
                        for (let o = 0, s = n.length; o !== s; ++o) e.push(kh(n[o]).scale(i));
                        const r = new this(t.name, t.duration, e, t.blendMode);
                        return r.uuid = t.uuid, r
                    }
                    static toJSON(t) {
                        const e = [],
                            n = t.tracks,
                            i = {
                                name: t.name,
                                duration: t.duration,
                                tracks: e,
                                uuid: t.uuid,
                                blendMode: t.blendMode
                            };
                        for (let r = 0, o = n.length; r !== o; ++r) e.push(Rh.toJSON(n[r]));
                        return i
                    }
                    static CreateFromMorphTargetSequence(t, e, n, i) {
                        const r = e.length,
                            o = [];
                        for (let s = 0; s < r; s++) {
                            let t = [],
                                a = [];
                            t.push((s + r - 1) % r, s, (s + 1) % r), a.push(0, 1, 0);
                            const l = Th.getKeyframeOrder(t);
                            t = Th.sortedArray(t, 1, l), a = Th.sortedArray(a, 1, l), i || 0 !== t[0] || (t.push(r), a.push(a[0])), o.push(new Oh(".morphTargetInfluences[" + e[s].name + "]", t, a).scale(1 / n))
                        }
                        return new this(t, -1, o)
                    }
                    static findByName(t, e) {
                        let n = t;
                        if (!Array.isArray(t)) {
                            const e = t;
                            n = e.geometry && e.geometry.animations || e.animations
                        }
                        for (let i = 0; i < n.length; i++)
                            if (n[i].name === e) return n[i];
                        return null
                    }
                    static CreateClipsFromMorphTargetSequences(t, e, n) {
                        const i = {},
                            r = /^([\w-]*?)([\d]+)$/;
                        for (let s = 0, a = t.length; s < a; s++) {
                            const e = t[s],
                                n = e.name.match(r);
                            if (n && n.length > 1) {
                                const t = n[1];
                                let r = i[t];
                                r || (i[t] = r = []), r.push(e)
                            }
                        }
                        const o = [];
                        for (const s in i) o.push(this.CreateFromMorphTargetSequence(s, i[s], e, n));
                        return o
                    }
                    static parseAnimation(t, e) {
                        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        const n = function(t, e, n, i, r) {
                                if (0 !== n.length) {
                                    const o = [],
                                        s = [];
                                    Th.flattenJSON(n, o, s, i), 0 !== o.length && r.push(new t(e, o, s))
                                }
                            },
                            i = [],
                            r = t.name || "default",
                            o = t.fps || 30,
                            s = t.blendMode;
                        let a = t.length || -1;
                        const l = t.hierarchy || [];
                        for (let c = 0; c < l.length; c++) {
                            const t = l[c].keys;
                            if (t && 0 !== t.length)
                                if (t[0].morphTargets) {
                                    const e = {};
                                    let n;
                                    for (n = 0; n < t.length; n++)
                                        if (t[n].morphTargets)
                                            for (let i = 0; i < t[n].morphTargets.length; i++) e[t[n].morphTargets[i]] = -1;
                                    for (const r in e) {
                                        const e = [],
                                            o = [];
                                        for (let i = 0; i !== t[n].morphTargets.length; ++i) {
                                            const i = t[n];
                                            e.push(i.time), o.push(i.morphTarget === r ? 1 : 0)
                                        }
                                        i.push(new Oh(".morphTargetInfluence[" + r + "]", e, o))
                                    }
                                    a = e.length * (o || 1)
                                } else {
                                    const r = ".bones[" + e[c].name + "]";
                                    n(Vh, r + ".position", t, "pos", i), n(Bh, r + ".quaternion", t, "rot", i), n(Vh, r + ".scale", t, "scl", i)
                                }
                        }
                        return 0 === i.length ? null : new this(r, a, i, s)
                    }
                    resetDuration() {
                        let t = 0;
                        for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                            const n = this.tracks[e];
                            t = Math.max(t, n.times[n.times.length - 1])
                        }
                        return this.duration = t, this
                    }
                    trim() {
                        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                        return this
                    }
                    validate() {
                        let t = !0;
                        for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                        return t
                    }
                    optimize() {
                        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                        return this
                    }
                    clone() {
                        const t = [];
                        for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                        return new this.constructor(this.name, this.duration, t, this.blendMode)
                    }
                    toJSON() {
                        return this.constructor.toJSON(this)
                    }
                }

                function kh(t) {
                    if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    const e = function(t) {
                        switch (t.toLowerCase()) {
                            case "scalar":
                            case "double":
                            case "float":
                            case "number":
                            case "integer":
                                return Oh;
                            case "vector":
                            case "vector2":
                            case "vector3":
                            case "vector4":
                                return Vh;
                            case "color":
                                return Fh;
                            case "quaternion":
                                return Bh;
                            case "bool":
                            case "boolean":
                                return Ih;
                            case "string":
                                return Dh
                        }
                        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                    }(t.type);
                    if (void 0 === t.times) {
                        const e = [],
                            n = [];
                        Th.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
                    }
                    return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                }
                const Uh = {
                    enabled: !1,
                    files: {},
                    add: function(t, e) {
                        !1 !== this.enabled && (this.files[t] = e)
                    },
                    get: function(t) {
                        if (!1 !== this.enabled) return this.files[t]
                    },
                    remove: function(t) {
                        delete this.files[t]
                    },
                    clear: function() {
                        this.files = {}
                    }
                };
                class zh {
                    constructor(t, e, n) {
                        const i = this;
                        let r, o = !1,
                            s = 0,
                            a = 0;
                        const l = [];
                        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                            a++, !1 === o && void 0 !== i.onStart && i.onStart(t, s, a), o = !0
                        }, this.itemEnd = function(t) {
                            s++, void 0 !== i.onProgress && i.onProgress(t, s, a), s === a && (o = !1, void 0 !== i.onLoad && i.onLoad())
                        }, this.itemError = function(t) {
                            void 0 !== i.onError && i.onError(t)
                        }, this.resolveURL = function(t) {
                            return r ? r(t) : t
                        }, this.setURLModifier = function(t) {
                            return r = t, this
                        }, this.addHandler = function(t, e) {
                            return l.push(t, e), this
                        }, this.removeHandler = function(t) {
                            const e = l.indexOf(t);
                            return -1 !== e && l.splice(e, 2), this
                        }, this.getHandler = function(t) {
                            for (let e = 0, n = l.length; e < n; e += 2) {
                                const n = l[e],
                                    i = l[e + 1];
                                if (n.global && (n.lastIndex = 0), n.test(t)) return i
                            }
                            return null
                        }
                    }
                }
                const Gh = new zh;
                class Hh {
                    constructor(t) {
                        this.manager = void 0 !== t ? t : Gh, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                    }
                    load() {}
                    loadAsync(t, e) {
                        const n = this;
                        return new Promise((function(i, r) {
                            n.load(t, i, e, r)
                        }))
                    }
                    parse() {}
                    setCrossOrigin(t) {
                        return this.crossOrigin = t, this
                    }
                    setWithCredentials(t) {
                        return this.withCredentials = t, this
                    }
                    setPath(t) {
                        return this.path = t, this
                    }
                    setResourcePath(t) {
                        return this.resourcePath = t, this
                    }
                    setRequestHeader(t) {
                        return this.requestHeader = t, this
                    }
                }
                const Wh = {};
                class Yh extends Hh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const r = this,
                            o = Uh.get(t);
                        if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function() {
                            e && e(o), r.manager.itemEnd(t)
                        }), 0), o;
                        if (void 0 !== Wh[t]) return void Wh[t].push({
                            onLoad: e,
                            onProgress: n,
                            onError: i
                        });
                        const s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                        let a;
                        if (s) {
                            const n = s[1],
                                o = !!s[2];
                            let a = s[3];
                            a = decodeURIComponent(a), o && (a = atob(a));
                            try {
                                let i;
                                const o = (this.responseType || "").toLowerCase();
                                switch (o) {
                                    case "arraybuffer":
                                    case "blob":
                                        const t = new Uint8Array(a.length);
                                        for (let n = 0; n < a.length; n++) t[n] = a.charCodeAt(n);
                                        i = "blob" === o ? new Blob([t.buffer], {
                                            type: n
                                        }) : t.buffer;
                                        break;
                                    case "document":
                                        const e = new DOMParser;
                                        i = e.parseFromString(a, n);
                                        break;
                                    case "json":
                                        i = JSON.parse(a);
                                        break;
                                    default:
                                        i = a
                                }
                                setTimeout((function() {
                                    e && e(i), r.manager.itemEnd(t)
                                }), 0)
                            } catch (e) {
                                setTimeout((function() {
                                    i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                                }), 0)
                            }
                        } else {
                            Wh[t] = [], Wh[t].push({
                                onLoad: e,
                                onProgress: n,
                                onError: i
                            }), a = new XMLHttpRequest, a.open("GET", t, !0), a.addEventListener("load", (function(e) {
                                const n = this.response,
                                    i = Wh[t];
                                if (delete Wh[t], 200 === this.status || 0 === this.status) {
                                    0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Uh.add(t, n);
                                    for (let t = 0, e = i.length; t < e; t++) {
                                        const e = i[t];
                                        e.onLoad && e.onLoad(n)
                                    }
                                    r.manager.itemEnd(t)
                                } else {
                                    for (let t = 0, n = i.length; t < n; t++) {
                                        const n = i[t];
                                        n.onError && n.onError(e)
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t)
                                }
                            }), !1), a.addEventListener("progress", (function(e) {
                                const n = Wh[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onProgress && i.onProgress(e)
                                }
                            }), !1), a.addEventListener("error", (function(e) {
                                const n = Wh[t];
                                delete Wh[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onError && i.onError(e)
                                }
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            }), !1), a.addEventListener("abort", (function(e) {
                                const n = Wh[t];
                                delete Wh[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onError && i.onError(e)
                                }
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            }), !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                            for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);
                            a.send(null)
                        }
                        return r.manager.itemStart(t), a
                    }
                    setResponseType(t) {
                        return this.responseType = t, this
                    }
                    setMimeType(t) {
                        return this.mimeType = t, this
                    }
                }
                class Xh extends Hh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const r = this,
                            o = new Yh(this.manager);
                        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, (function(n) {
                            try {
                                e(r.parse(JSON.parse(n)))
                            } catch (e) {
                                i ? i(e) : console.error(e), r.manager.itemError(t)
                            }
                        }), n, i)
                    }
                    parse(t) {
                        const e = [];
                        for (let n = 0; n < t.length; n++) {
                            const i = jh.parse(t[n]);
                            e.push(i)
                        }
                        return e
                    }
                }
                class qh extends Hh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const r = this,
                            o = [],
                            s = new dc,
                            a = new Yh(this.manager);
                        a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(r.withCredentials);
                        let l = 0;

                        function c(c) {
                            a.load(t[c], (function(t) {
                                const n = r.parse(t, !0);
                                o[c] = {
                                    width: n.width,
                                    height: n.height,
                                    format: n.format,
                                    mipmaps: n.mipmaps
                                }, l += 1, 6 === l && (1 === n.mipmapCount && (s.minFilter = xt), s.image = o, s.format = n.format, s.needsUpdate = !0, e && e(s))
                            }), n, i)
                        }
                        if (Array.isArray(t))
                            for (let h = 0, u = t.length; h < u; ++h) c(h);
                        else a.load(t, (function(t) {
                            const n = r.parse(t, !0);
                            if (n.isCubemap) {
                                const t = n.mipmaps.length / n.mipmapCount;
                                for (let e = 0; e < t; e++) {
                                    o[e] = {
                                        mipmaps: []
                                    };
                                    for (let t = 0; t < n.mipmapCount; t++) o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), o[e].format = n.format, o[e].width = n.width, o[e].height = n.height
                                }
                                s.image = o
                            } else s.image.width = n.width, s.image.height = n.height, s.mipmaps = n.mipmaps;
                            1 === n.mipmapCount && (s.minFilter = xt), s.format = n.format, s.needsUpdate = !0, e && e(s)
                        }), n, i);
                        return s
                    }
                }
                class Qh extends Hh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const r = this,
                            o = Uh.get(t);
                        if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function() {
                            e && e(o), r.manager.itemEnd(t)
                        }), 0), o;
                        const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                        function a() {
                            s.removeEventListener("load", a, !1), s.removeEventListener("error", l, !1), Uh.add(t, this), e && e(this), r.manager.itemEnd(t)
                        }

                        function l(e) {
                            s.removeEventListener("load", a, !1), s.removeEventListener("error", l, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                        }
                        return s.addEventListener("load", a, !1), s.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(t), s.src = t, s
                    }
                }
                class Zh extends Hh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const r = new Do,
                            o = new Qh(this.manager);
                        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                        let s = 0;

                        function a(n) {
                            o.load(t[n], (function(t) {
                                r.images[n] = t, s++, 6 === s && (r.needsUpdate = !0, e && e(r))
                            }), void 0, i)
                        }
                        for (let l = 0; l < t.length; ++l) a(l);
                        return r
                    }
                }
                class Jh extends Hh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const r = this,
                            o = new Vl,
                            s = new Yh(this.manager);
                        return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.setWithCredentials(r.withCredentials), s.load(t, (function(t) {
                            const n = r.parse(t);
                            n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : dt, o.wrapT = void 0 !== n.wrapT ? n.wrapT : dt, o.magFilter = void 0 !== n.magFilter ? n.magFilter : xt, o.minFilter = void 0 !== n.minFilter ? n.minFilter : xt, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (o.encoding = n.encoding), void 0 !== n.flipY && (o.flipY = n.flipY), void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = _t), 1 === n.mipmapCount && (o.minFilter = xt), void 0 !== n.generateMipmaps && (o.generateMipmaps = n.generateMipmaps), o.needsUpdate = !0, e && e(o, n))
                        }), n, i), o
                    }
                }
                class Kh extends Hh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const r = new ti,
                            o = new Qh(this.manager);
                        return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function(n) {
                            r.image = n;
                            const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                            r.format = i ? Dt : Vt, r.needsUpdate = !0, void 0 !== e && e(r)
                        }), n, i), r
                    }
                }
                class $h {
                    constructor() {
                        this.type = "Curve", this.arcLengthDivisions = 200
                    }
                    getPoint() {
                        return console.warn("THREE.Curve: .getPoint() not implemented."), null
                    }
                    getPointAt(t, e) {
                        const n = this.getUtoTmapping(t);
                        return this.getPoint(n, e)
                    }
                    getPoints() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5;
                        const e = [];
                        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                        return e
                    }
                    getSpacedPoints() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5;
                        const e = [];
                        for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                        return e
                    }
                    getLength() {
                        const t = this.getLengths();
                        return t[t.length - 1]
                    }
                    getLengths() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.arcLengthDivisions;
                        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        const e = [];
                        let n, i = this.getPoint(0),
                            r = 0;
                        e.push(0);
                        for (let o = 1; o <= t; o++) n = this.getPoint(o / t), r += n.distanceTo(i), e.push(r), i = n;
                        return this.cacheArcLengths = e, e
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0, this.getLengths()
                    }
                    getUtoTmapping(t, e) {
                        const n = this.getLengths();
                        let i = 0;
                        const r = n.length;
                        let o;
                        o = e || t * n[r - 1];
                        let s, a = 0,
                            l = r - 1;
                        for (; a <= l;)
                            if (i = Math.floor(a + (l - a) / 2), s = n[i] - o, s < 0) a = i + 1;
                            else {
                                if (!(s > 0)) {
                                    l = i;
                                    break
                                }
                                l = i - 1
                            }
                        if (i = l, n[i] === o) return i / (r - 1);
                        const c = n[i];
                        return (i + (o - c) / (n[i + 1] - c)) / (r - 1)
                    }
                    getTangent(t, e) {
                        let n = t - 1e-4,
                            i = t + 1e-4;
                        n < 0 && (n = 0), i > 1 && (i = 1);
                        const r = this.getPoint(n),
                            o = this.getPoint(i),
                            s = e || (r.isVector2 ? new Qn : new ai);
                        return s.copy(o).sub(r).normalize(), s
                    }
                    getTangentAt(t, e) {
                        const n = this.getUtoTmapping(t);
                        return this.getTangent(n, e)
                    }
                    computeFrenetFrames(t, e) {
                        const n = new ai,
                            i = [],
                            r = [],
                            o = [],
                            s = new ai,
                            a = new Vi;
                        for (let d = 0; d <= t; d++) {
                            const e = d / t;
                            i[d] = this.getTangentAt(e, new ai), i[d].normalize()
                        }
                        r[0] = new ai, o[0] = new ai;
                        let l = Number.MAX_VALUE;
                        const c = Math.abs(i[0].x),
                            h = Math.abs(i[0].y),
                            u = Math.abs(i[0].z);
                        c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), s.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], s), o[0].crossVectors(i[0], r[0]);
                        for (let d = 1; d <= t; d++) {
                            if (r[d] = r[d - 1].clone(), o[d] = o[d - 1].clone(), s.crossVectors(i[d - 1], i[d]), s.length() > Number.EPSILON) {
                                s.normalize();
                                const t = Math.acos(zn(i[d - 1].dot(i[d]), -1, 1));
                                r[d].applyMatrix4(a.makeRotationAxis(s, t))
                            }
                            o[d].crossVectors(i[d], r[d])
                        }
                        if (!0 === e) {
                            let e = Math.acos(zn(r[0].dot(r[t]), -1, 1));
                            e /= t, i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e);
                            for (let n = 1; n <= t; n++) r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), o[n].crossVectors(i[n], r[n])
                        }
                        return {
                            tangents: i,
                            normals: r,
                            binormals: o
                        }
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.arcLengthDivisions = t.arcLengthDivisions, this
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.5,
                                type: "Curve",
                                generator: "Curve.toJSON"
                            }
                        };
                        return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                    }
                    fromJSON(t) {
                        return this.arcLengthDivisions = t.arcLengthDivisions, this
                    }
                }
                class tu extends $h {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2 * Math.PI,
                            s = arguments.length > 6 && void 0 !== arguments[6] && arguments[6],
                            a = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0;
                        super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = s, this.aRotation = a
                    }
                    getPoint(t, e) {
                        const n = e || new Qn,
                            i = 2 * Math.PI;
                        let r = this.aEndAngle - this.aStartAngle;
                        const o = Math.abs(r) < Number.EPSILON;
                        for (; r < 0;) r += i;
                        for (; r > i;) r -= i;
                        r < Number.EPSILON && (r = o ? 0 : i), !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i);
                        const s = this.aStartAngle + t * r;
                        let a = this.aX + this.xRadius * Math.cos(s),
                            l = this.aY + this.yRadius * Math.sin(s);
                        if (0 !== this.aRotation) {
                            const t = Math.cos(this.aRotation),
                                e = Math.sin(this.aRotation),
                                n = a - this.aX,
                                i = l - this.aY;
                            a = n * t - i * e + this.aX, l = n * e + i * t + this.aY
                        }
                        return n.set(a, l)
                    }
                    copy(t) {
                        return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                    }
                }
                tu.prototype.isEllipseCurve = !0;
                class eu extends tu {
                    constructor(t, e, n, i, r, o) {
                        super(t, e, n, n, i, r, o), this.type = "ArcCurve"
                    }
                }

                function nu() {
                    let t = 0,
                        e = 0,
                        n = 0,
                        i = 0;

                    function r(r, o, s, a) {
                        t = r, e = s, n = -3 * r + 3 * o - 2 * s - a, i = 2 * r - 2 * o + s + a
                    }
                    return {
                        initCatmullRom: function(t, e, n, i, o) {
                            r(e, n, o * (n - t), o * (i - e))
                        },
                        initNonuniformCatmullRom: function(t, e, n, i, o, s, a) {
                            let l = (e - t) / o - (n - t) / (o + s) + (n - e) / s,
                                c = (n - e) / s - (i - e) / (s + a) + (i - n) / a;
                            l *= s, c *= s, r(e, n, l, c)
                        },
                        calc: function(r) {
                            const o = r * r;
                            return t + e * r + n * o + i * (o * r)
                        }
                    }
                }
                eu.prototype.isArcCurve = !0;
                const iu = new ai,
                    ru = new nu,
                    ou = new nu,
                    su = new nu;
                class au extends $h {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "centripetal",
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                        super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i
                    }
                    getPoint(t) {
                        const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ai,
                            n = this.points,
                            i = n.length,
                            r = (i - (this.closed ? 0 : 1)) * t;
                        let o, s, a = Math.floor(r),
                            l = r - a;
                        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / i) + 1) * i : 0 === l && a === i - 1 && (a = i - 2, l = 1), this.closed || a > 0 ? o = n[(a - 1) % i] : (iu.subVectors(n[0], n[1]).add(n[0]), o = iu);
                        const c = n[a % i],
                            h = n[(a + 1) % i];
                        if (this.closed || a + 2 < i ? s = n[(a + 2) % i] : (iu.subVectors(n[i - 1], n[i - 2]).add(n[i - 1]), s = iu), "centripetal" === this.curveType || "chordal" === this.curveType) {
                            const t = "chordal" === this.curveType ? .5 : .25;
                            let e = Math.pow(o.distanceToSquared(c), t),
                                n = Math.pow(c.distanceToSquared(h), t),
                                i = Math.pow(h.distanceToSquared(s), t);
                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), ru.initNonuniformCatmullRom(o.x, c.x, h.x, s.x, e, n, i), ou.initNonuniformCatmullRom(o.y, c.y, h.y, s.y, e, n, i), su.initNonuniformCatmullRom(o.z, c.z, h.z, s.z, e, n, i)
                        } else "catmullrom" === this.curveType && (ru.initCatmullRom(o.x, c.x, h.x, s.x, this.tension), ou.initCatmullRom(o.y, c.y, h.y, s.y, this.tension), su.initCatmullRom(o.z, c.z, h.z, s.z, this.tension));
                        return e.set(ru.calc(l), ou.calc(l), su.calc(l)), e
                    }
                    copy(t) {
                        super.copy(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push(n.clone())
                        }
                        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const n = this.points[e];
                            t.points.push(n.toArray())
                        }
                        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push((new ai).fromArray(n))
                        }
                        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                    }
                }

                function lu(t, e, n, i, r) {
                    const o = .5 * (i - e),
                        s = .5 * (r - n),
                        a = t * t;
                    return (2 * n - 2 * i + o + s) * (t * a) + (-3 * n + 3 * i - 2 * o - s) * a + o * t + n
                }

                function cu(t, e, n, i) {
                    return function(t, e) {
                        const n = 1 - t;
                        return n * n * e
                    }(t, e) + function(t, e) {
                        return 2 * (1 - t) * t * e
                    }(t, n) + function(t, e) {
                        return t * t * e
                    }(t, i)
                }

                function hu(t, e, n, i, r) {
                    return function(t, e) {
                        const n = 1 - t;
                        return n * n * n * e
                    }(t, e) + function(t, e) {
                        const n = 1 - t;
                        return 3 * n * n * t * e
                    }(t, n) + function(t, e) {
                        return 3 * (1 - t) * t * t * e
                    }(t, i) + function(t, e) {
                        return t * t * t * e
                    }(t, r)
                }
                au.prototype.isCatmullRomCurve3 = !0;
                class uu extends $h {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Qn,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Qn,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Qn,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Qn;
                        super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
                    }
                    getPoint(t) {
                        const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Qn,
                            n = this.v0,
                            i = this.v1,
                            r = this.v2,
                            o = this.v3;
                        return e.set(hu(t, n.x, i.x, r.x, o.x), hu(t, n.y, i.y, r.y, o.y)), e
                    }
                    copy(t) {
                        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                    }
                }
                uu.prototype.isCubicBezierCurve = !0;
                class du extends $h {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ai,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ai,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new ai,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new ai;
                        super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
                    }
                    getPoint(t) {
                        const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ai,
                            n = this.v0,
                            i = this.v1,
                            r = this.v2,
                            o = this.v3;
                        return e.set(hu(t, n.x, i.x, r.x, o.x), hu(t, n.y, i.y, r.y, o.y), hu(t, n.z, i.z, r.z, o.z)), e
                    }
                    copy(t) {
                        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                    }
                }
                du.prototype.isCubicBezierCurve3 = !0;
                class pu extends $h {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Qn,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Qn;
                        super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
                    }
                    getPoint(t) {
                        const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Qn;
                        return 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e
                    }
                    getPointAt(t, e) {
                        return this.getPoint(t, e)
                    }
                    getTangent(t, e) {
                        const n = e || new Qn;
                        return n.copy(this.v2).sub(this.v1).normalize(), n
                    }
                    copy(t) {
                        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                }
                pu.prototype.isLineCurve = !0;
                class fu extends $h {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ai,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ai;
                        super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
                    }
                    getPoint(t) {
                        const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ai;
                        return 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e
                    }
                    getPointAt(t, e) {
                        return this.getPoint(t, e)
                    }
                    copy(t) {
                        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                }
                class mu extends $h {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Qn,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Qn,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Qn;
                        super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
                    }
                    getPoint(t) {
                        const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Qn,
                            n = this.v0,
                            i = this.v1,
                            r = this.v2;
                        return e.set(cu(t, n.x, i.x, r.x), cu(t, n.y, i.y, r.y)), e
                    }
                    copy(t) {
                        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                }
                mu.prototype.isQuadraticBezierCurve = !0;
                class gu extends $h {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ai,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ai,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new ai;
                        super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
                    }
                    getPoint(t) {
                        const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ai,
                            n = this.v0,
                            i = this.v1,
                            r = this.v2;
                        return e.set(cu(t, n.x, i.x, r.x), cu(t, n.y, i.y, r.y), cu(t, n.z, i.z, r.z)), e
                    }
                    copy(t) {
                        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                }
                gu.prototype.isQuadraticBezierCurve3 = !0;
                class vu extends $h {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        super(), this.type = "SplineCurve", this.points = t
                    }
                    getPoint(t) {
                        const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Qn,
                            n = this.points,
                            i = (n.length - 1) * t,
                            r = Math.floor(i),
                            o = i - r,
                            s = n[0 === r ? r : r - 1],
                            a = n[r],
                            l = n[r > n.length - 2 ? n.length - 1 : r + 1],
                            c = n[r > n.length - 3 ? n.length - 1 : r + 2];
                        return e.set(lu(o, s.x, a.x, l.x, c.x), lu(o, s.y, a.y, l.y, c.y)), e
                    }
                    copy(t) {
                        super.copy(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push(n.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const n = this.points[e];
                            t.points.push(n.toArray())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push((new Qn).fromArray(n))
                        }
                        return this
                    }
                }
                vu.prototype.isSplineCurve = !0;
                var yu = Object.freeze({
                    __proto__: null,
                    ArcCurve: eu,
                    CatmullRomCurve3: au,
                    CubicBezierCurve: uu,
                    CubicBezierCurve3: du,
                    EllipseCurve: tu,
                    LineCurve: pu,
                    LineCurve3: fu,
                    QuadraticBezierCurve: mu,
                    QuadraticBezierCurve3: gu,
                    SplineCurve: vu
                });
                class xu extends $h {
                    constructor() {
                        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                    }
                    add(t) {
                        this.curves.push(t)
                    }
                    closePath() {
                        const t = this.curves[0].getPoint(0),
                            e = this.curves[this.curves.length - 1].getPoint(1);
                        t.equals(e) || this.curves.push(new pu(e, t))
                    }
                    getPoint(t) {
                        const e = t * this.getLength(),
                            n = this.getCurveLengths();
                        let i = 0;
                        for (; i < n.length;) {
                            if (n[i] >= e) {
                                const t = n[i] - e,
                                    r = this.curves[i],
                                    o = r.getLength(),
                                    s = 0 === o ? 0 : 1 - t / o;
                                return r.getPointAt(s)
                            }
                            i++
                        }
                        return null
                    }
                    getLength() {
                        const t = this.getCurveLengths();
                        return t[t.length - 1]
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                    }
                    getCurveLengths() {
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                        const t = [];
                        let e = 0;
                        for (let n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);
                        return this.cacheLengths = t, t
                    }
                    getSpacedPoints() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 40;
                        const e = [];
                        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                        return this.autoClose && e.push(e[0]), e
                    }
                    getPoints() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 12;
                        const e = [];
                        let n;
                        for (let i = 0, r = this.curves; i < r.length; i++) {
                            const o = r[i],
                                s = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t,
                                a = o.getPoints(s);
                            for (let t = 0; t < a.length; t++) {
                                const i = a[t];
                                n && n.equals(i) || (e.push(i), n = i)
                            }
                        }
                        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                    }
                    copy(t) {
                        super.copy(t), this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const n = t.curves[e];
                            this.curves.push(n.clone())
                        }
                        return this.autoClose = t.autoClose, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.autoClose = this.autoClose, t.curves = [];
                        for (let e = 0, n = this.curves.length; e < n; e++) {
                            const n = this.curves[e];
                            t.curves.push(n.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const n = t.curves[e];
                            this.curves.push((new yu[n.type]).fromJSON(n))
                        }
                        return this
                    }
                }
                class bu extends xu {
                    constructor(t) {
                        super(), this.type = "Path", this.currentPoint = new Qn, t && this.setFromPoints(t)
                    }
                    setFromPoints(t) {
                        this.moveTo(t[0].x, t[0].y);
                        for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                        return this
                    }
                    moveTo(t, e) {
                        return this.currentPoint.set(t, e), this
                    }
                    lineTo(t, e) {
                        const n = new pu(this.currentPoint.clone(), new Qn(t, e));
                        return this.curves.push(n), this.currentPoint.set(t, e), this
                    }
                    quadraticCurveTo(t, e, n, i) {
                        const r = new mu(this.currentPoint.clone(), new Qn(t, e), new Qn(n, i));
                        return this.curves.push(r), this.currentPoint.set(n, i), this
                    }
                    bezierCurveTo(t, e, n, i, r, o) {
                        const s = new uu(this.currentPoint.clone(), new Qn(t, e), new Qn(n, i), new Qn(r, o));
                        return this.curves.push(s), this.currentPoint.set(r, o), this
                    }
                    splineThru(t) {
                        const e = [this.currentPoint.clone()].concat(t),
                            n = new vu(e);
                        return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
                    }
                    arc(t, e, n, i, r, o) {
                        const s = this.currentPoint.x,
                            a = this.currentPoint.y;
                        return this.absarc(t + s, e + a, n, i, r, o), this
                    }
                    absarc(t, e, n, i, r, o) {
                        return this.absellipse(t, e, n, n, i, r, o), this
                    }
                    ellipse(t, e, n, i, r, o, s, a) {
                        const l = this.currentPoint.x,
                            c = this.currentPoint.y;
                        return this.absellipse(t + l, e + c, n, i, r, o, s, a), this
                    }
                    absellipse(t, e, n, i, r, o, s, a) {
                        const l = new tu(t, e, n, i, r, o, s, a);
                        if (this.curves.length > 0) {
                            const t = l.getPoint(0);
                            t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                        }
                        this.curves.push(l);
                        const c = l.getPoint(1);
                        return this.currentPoint.copy(c), this
                    }
                    copy(t) {
                        return super.copy(t), this.currentPoint.copy(t.currentPoint), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.currentPoint = this.currentPoint.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                    }
                }
                class wu extends bu {
                    constructor(t) {
                        super(t), this.uuid = Un(), this.type = "Shape", this.holes = []
                    }
                    getPointsHoles(t) {
                        const e = [];
                        for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                        return e
                    }
                    extractPoints(t) {
                        return {
                            shape: this.getPoints(t),
                            holes: this.getPointsHoles(t)
                        }
                    }
                    copy(t) {
                        super.copy(t), this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const n = t.holes[e];
                            this.holes.push(n.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.uuid = this.uuid, t.holes = [];
                        for (let e = 0, n = this.holes.length; e < n; e++) {
                            const n = this.holes[e];
                            t.holes.push(n.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const n = t.holes[e];
                            this.holes.push((new bu).fromJSON(n))
                        }
                        return this
                    }
                }
                class _u extends cr {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        super(), this.type = "Light", this.color = new Fr(t), this.intensity = e
                    }
                    dispose() {}
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                    }
                }
                _u.prototype.isLight = !0;
                class Su extends _u {
                    constructor(t, e, n) {
                        super(t, n), this.type = "HemisphereLight", this.position.copy(cr.DefaultUp), this.updateMatrix(), this.groundColor = new Fr(e)
                    }
                    copy(t) {
                        return _u.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                    }
                }
                Su.prototype.isHemisphereLight = !0;
                const Mu = new Vi,
                    Au = new ai,
                    Tu = new ai;
                class Eu {
                    constructor(t) {
                        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Qn(512, 512), this.map = null, this.mapPass = null, this.matrix = new Vi, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Uo, this._frameExtents = new Qn(1, 1), this._viewportCount = 1, this._viewports = [new ni(0, 0, 1, 1)]
                    }
                    getViewportCount() {
                        return this._viewportCount
                    }
                    getFrustum() {
                        return this._frustum
                    }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = this.matrix;
                        Au.setFromMatrixPosition(t.matrixWorld), e.position.copy(Au), Tu.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Tu), e.updateMatrixWorld(), Mu.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Mu), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                    }
                    getViewport(t) {
                        return this._viewports[t]
                    }
                    getFrameExtents() {
                        return this._frameExtents
                    }
                    dispose() {
                        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                    }
                    copy(t) {
                        return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    toJSON() {
                        const t = {};
                        return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                    }
                }
                class Cu extends Eu {
                    constructor() {
                        super(new Fo(50, 1, .5, 500)), this.focus = 1
                    }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = 2 * kn * t.angle * this.focus,
                            i = this.mapSize.width / this.mapSize.height,
                            r = t.distance || e.far;
                        n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
                    }
                    copy(t) {
                        return super.copy(t), this.focus = t.focus, this
                    }
                }
                Cu.prototype.isSpotLightShadow = !0;
                class Pu extends _u {
                    constructor(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Math.PI / 3,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
                        super(t, e), this.type = "SpotLight", this.position.copy(cr.DefaultUp), this.updateMatrix(), this.target = new cr, this.distance = n, this.angle = i, this.penumbra = r, this.decay = o, this.shadow = new Cu
                    }
                    get power() {
                        return this.intensity * Math.PI
                    }
                    set power(t) {
                        this.intensity = t / Math.PI
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(t) {
                        return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                    }
                }
                Pu.prototype.isSpotLight = !0;
                const Lu = new Vi,
                    Ru = new ai,
                    Iu = new ai;
                class Fu extends Eu {
                    constructor() {
                        super(new Fo(90, 1, .5, 500)), this._frameExtents = new Qn(4, 2), this._viewportCount = 6, this._viewports = [new ni(2, 1, 1, 1), new ni(0, 1, 1, 1), new ni(3, 1, 1, 1), new ni(1, 1, 1, 1), new ni(3, 0, 1, 1), new ni(1, 0, 1, 1)], this._cubeDirections = [new ai(1, 0, 0), new ai(-1, 0, 0), new ai(0, 0, 1), new ai(0, 0, -1), new ai(0, 1, 0), new ai(0, -1, 0)], this._cubeUps = [new ai(0, 1, 0), new ai(0, 1, 0), new ai(0, 1, 0), new ai(0, 1, 0), new ai(0, 0, 1), new ai(0, 0, -1)]
                    }
                    updateMatrices(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = this.camera,
                            i = this.matrix,
                            r = t.distance || n.far;
                        r !== n.far && (n.far = r, n.updateProjectionMatrix()), Ru.setFromMatrixPosition(t.matrixWorld), n.position.copy(Ru), Iu.copy(n.position), Iu.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Iu), n.updateMatrixWorld(), i.makeTranslation(-Ru.x, -Ru.y, -Ru.z), Lu.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Lu)
                    }
                }
                Fu.prototype.isPointLightShadow = !0;
                class Ou extends _u {
                    constructor(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Fu
                    }
                    get power() {
                        return 4 * this.intensity * Math.PI
                    }
                    set power(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(t) {
                        return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                    }
                }
                Ou.prototype.isPointLight = !0;
                class Nu extends Io {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .1,
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2e3;
                        super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = o, this.updateProjectionMatrix()
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                    }
                    setViewOffset(t, e, n, i, r, o) {
                        null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const t = (this.right - this.left) / (2 * this.zoom),
                            e = (this.top - this.bottom) / (2 * this.zoom),
                            n = (this.right + this.left) / 2,
                            i = (this.top + this.bottom) / 2;
                        let r = n - t,
                            o = n + t,
                            s = i + e,
                            a = i - e;
                        if (null !== this.view && this.view.enabled) {
                            const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            r += t * this.view.offsetX, o = r + t * this.view.width, s -= e * this.view.offsetY, a = s - e * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                    }
                }
                Nu.prototype.isOrthographicCamera = !0;
                class Bu extends Eu {
                    constructor() {
                        super(new Nu(-5, 5, 5, -5, .5, 500))
                    }
                }
                Bu.prototype.isDirectionalLightShadow = !0;
                class Du extends _u {
                    constructor(t, e) {
                        super(t, e), this.type = "DirectionalLight", this.position.copy(cr.DefaultUp), this.updateMatrix(), this.target = new cr, this.shadow = new Bu
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(t) {
                        return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                    }
                }
                Du.prototype.isDirectionalLight = !0;
                class Vu extends _u {
                    constructor(t, e) {
                        super(t, e), this.type = "AmbientLight"
                    }
                }
                Vu.prototype.isAmbientLight = !0;
                class ju extends _u {
                    constructor(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 10;
                        super(t, e), this.type = "RectAreaLight", this.width = n, this.height = i
                    }
                    copy(t) {
                        return super.copy(t), this.width = t.width, this.height = t.height, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.width = this.width, e.object.height = this.height, e
                    }
                }
                ju.prototype.isRectAreaLight = !0;
                class ku {
                    constructor() {
                        this.coefficients = [];
                        for (let t = 0; t < 9; t++) this.coefficients.push(new ai)
                    }
                    set(t) {
                        for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                        return this
                    }
                    zero() {
                        for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                        return this
                    }
                    getAt(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            o = this.coefficients;
                        return e.copy(o[0]).multiplyScalar(.282095), e.addScaledVector(o[1], .488603 * i), e.addScaledVector(o[2], .488603 * r), e.addScaledVector(o[3], .488603 * n), e.addScaledVector(o[4], n * i * 1.092548), e.addScaledVector(o[5], i * r * 1.092548), e.addScaledVector(o[6], .315392 * (3 * r * r - 1)), e.addScaledVector(o[7], n * r * 1.092548), e.addScaledVector(o[8], .546274 * (n * n - i * i)), e
                    }
                    getIrradianceAt(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            o = this.coefficients;
                        return e.copy(o[0]).multiplyScalar(.886227), e.addScaledVector(o[1], 1.023328 * i), e.addScaledVector(o[2], 1.023328 * r), e.addScaledVector(o[3], 1.023328 * n), e.addScaledVector(o[4], .858086 * n * i), e.addScaledVector(o[5], .858086 * i * r), e.addScaledVector(o[6], .743125 * r * r - .247708), e.addScaledVector(o[7], .858086 * n * r), e.addScaledVector(o[8], .429043 * (n * n - i * i)), e
                    }
                    add(t) {
                        for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                        return this
                    }
                    addScaledSH(t, e) {
                        for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
                        return this
                    }
                    scale(t) {
                        for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                        return this
                    }
                    lerp(t, e) {
                        for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
                        return this
                    }
                    equals(t) {
                        for (let e = 0; e < 9; e++)
                            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                        return !0
                    }
                    copy(t) {
                        return this.set(t.coefficients)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    fromArray(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = this.coefficients;
                        for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
                        return this
                    }
                    toArray() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = this.coefficients;
                        for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
                        return t
                    }
                    static getBasisAt(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z;
                        e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
                    }
                }
                ku.prototype.isSphericalHarmonics3 = !0;
                class Uu extends _u {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ku;
                        super(void 0, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1), this.sh = t
                    }
                    copy(t) {
                        return super.copy(t), this.sh.copy(t.sh), this
                    }
                    fromJSON(t) {
                        return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.sh = this.sh.toArray(), e
                    }
                }
                Uu.prototype.isLightProbe = !0;
                class zu extends Hh {
                    constructor(t) {
                        super(t), this.textures = {}
                    }
                    load(t, e, n, i) {
                        const r = this,
                            o = new Yh(r.manager);
                        o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(t, (function(n) {
                            try {
                                e(r.parse(JSON.parse(n)))
                            } catch (e) {
                                i ? i(e) : console.error(e), r.manager.itemError(t)
                            }
                        }), n, i)
                    }
                    parse(t) {
                        const e = this.textures;

                        function n(t) {
                            return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                        }
                        const i = new Ah[t.type];
                        if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = (new Fr).setHex(t.sheen)), void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.thickness && (i.thickness = t.thickness), void 0 !== t.attenuationDistance && (i.attenuationDistance = t.attenuationDistance), void 0 !== t.attenuationColor && void 0 !== i.attenuationColor && i.attenuationColor.setHex(t.attenuationColor), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                            for (const r in t.uniforms) {
                                const e = t.uniforms[r];
                                switch (i.uniforms[r] = {}, e.type) {
                                    case "t":
                                        i.uniforms[r].value = n(e.value);
                                        break;
                                    case "c":
                                        i.uniforms[r].value = (new Fr).setHex(e.value);
                                        break;
                                    case "v2":
                                        i.uniforms[r].value = (new Qn).fromArray(e.value);
                                        break;
                                    case "v3":
                                        i.uniforms[r].value = (new ai).fromArray(e.value);
                                        break;
                                    case "v4":
                                        i.uniforms[r].value = (new ni).fromArray(e.value);
                                        break;
                                    case "m3":
                                        i.uniforms[r].value = (new Zn).fromArray(e.value);
                                        break;
                                    case "m4":
                                        i.uniforms[r].value = (new Vi).fromArray(e.value);
                                        break;
                                    default:
                                        i.uniforms[r].value = e.value
                                }
                            }
                        if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                            for (const r in t.extensions) i.extensions[r] = t.extensions[r];
                        if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                            let e = t.normalScale;
                            !1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new Qn).fromArray(e)
                        }
                        return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new Qn).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)), i
                    }
                    setTextures(t) {
                        return this.textures = t, this
                    }
                }
                class Gu {
                    static decodeText(t) {
                        if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                        let e = "";
                        for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
                        try {
                            return decodeURIComponent(escape(e))
                        } catch (t) {
                            return e
                        }
                    }
                    static extractUrlBase(t) {
                        const e = t.lastIndexOf("/");
                        return -1 === e ? "./" : t.substr(0, e + 1)
                    }
                }
                class Hu extends ro {
                    constructor() {
                        super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                    }
                    copy(t) {
                        return super.copy(t), this.instanceCount = t.instanceCount, this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    toJSON() {
                        const t = super.toJSON(this);
                        return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                    }
                }
                Hu.prototype.isInstancedBufferGeometry = !0;
                class Wu extends Dr {
                    constructor(t, e, n, i) {
                        "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = i || 1
                    }
                    copy(t) {
                        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                    }
                }
                Wu.prototype.isInstancedBufferAttribute = !0;
                class Yu extends Hh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const r = this,
                            o = new Yh(r.manager);
                        o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(t, (function(n) {
                            try {
                                e(r.parse(JSON.parse(n)))
                            } catch (e) {
                                i ? i(e) : console.error(e), r.manager.itemError(t)
                            }
                        }), n, i)
                    }
                    parse(t) {
                        const e = {},
                            n = {};

                        function i(t, i) {
                            if (void 0 !== e[i]) return e[i];
                            const r = t.interleavedBuffers[i],
                                o = function(t, e) {
                                    if (void 0 !== n[e]) return n[e];
                                    const i = t.arrayBuffers[e],
                                        r = new Uint32Array(i).buffer;
                                    return n[e] = r, r
                                }(t, r.buffer),
                                s = Zr(r.type, o),
                                a = new cl(s, r.stride);
                            return a.uuid = r.uuid, e[i] = a, a
                        }
                        const r = t.isInstancedBufferGeometry ? new Hu : new ro,
                            o = t.data.index;
                        if (void 0 !== o) {
                            const t = Zr(o.type, o.array);
                            r.setIndex(new Dr(t, 1))
                        }
                        const s = t.data.attributes;
                        for (const h in s) {
                            const e = s[h];
                            let n;
                            if (e.isInterleavedBufferAttribute) {
                                const r = i(t.data, e.data);
                                n = new ul(r, e.itemSize, e.offset, e.normalized)
                            } else {
                                const t = Zr(e.type, e.array);
                                n = new(e.isInstancedBufferAttribute ? Wu : Dr)(t, e.itemSize, e.normalized)
                            }
                            void 0 !== e.name && (n.name = e.name), void 0 !== e.usage && n.setUsage(e.usage), void 0 !== e.updateRange && (n.updateRange.offset = e.updateRange.offset, n.updateRange.count = e.updateRange.count), r.setAttribute(h, n)
                        }
                        const a = t.data.morphAttributes;
                        if (a)
                            for (const h in a) {
                                const e = a[h],
                                    n = [];
                                for (let r = 0, o = e.length; r < o; r++) {
                                    const o = e[r];
                                    let s;
                                    if (o.isInterleavedBufferAttribute) {
                                        const e = i(t.data, o.data);
                                        s = new ul(e, o.itemSize, o.offset, o.normalized)
                                    } else {
                                        const t = Zr(o.type, o.array);
                                        s = new Dr(t, o.itemSize, o.normalized)
                                    }
                                    void 0 !== o.name && (s.name = o.name), n.push(s)
                                }
                                r.morphAttributes[h] = n
                            }
                        t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
                        const l = t.data.groups || t.data.drawcalls || t.data.offsets;
                        if (void 0 !== l)
                            for (let h = 0, u = l.length; h !== u; ++h) {
                                const t = l[h];
                                r.addGroup(t.start, t.count, t.materialIndex)
                            }
                        const c = t.data.boundingSphere;
                        if (void 0 !== c) {
                            const t = new ai;
                            void 0 !== c.center && t.fromArray(c.center), r.boundingSphere = new Pi(t, c.radius)
                        }
                        return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r
                    }
                }
                class Xu extends Hh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const r = this,
                            o = "" === this.path ? Gu.extractUrlBase(t) : this.path;
                        this.resourcePath = this.resourcePath || o;
                        const s = new Yh(this.manager);
                        s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) {
                            let o = null;
                            try {
                                o = JSON.parse(n)
                            } catch (e) {
                                return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                            }
                            const s = o.metadata;
                            void 0 !== s && void 0 !== s.type && "geometry" !== s.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t)
                        }), n, i)
                    }
                    parse(t, e) {
                        const n = this.parseAnimations(t.animations),
                            i = this.parseShapes(t.shapes),
                            r = this.parseGeometries(t.geometries, i),
                            o = this.parseImages(t.images, (function() {
                                void 0 !== e && e(l)
                            })),
                            s = this.parseTextures(t.textures, o),
                            a = this.parseMaterials(t.materials, s),
                            l = this.parseObject(t.object, r, a, n),
                            c = this.parseSkeletons(t.skeletons, l);
                        if (this.bindSkeletons(l, c), void 0 !== e) {
                            let t = !1;
                            for (const e in o)
                                if (o[e] instanceof HTMLImageElement) {
                                    t = !0;
                                    break
                                }!1 === t && e(l)
                        }
                        return l
                    }
                    parseShapes(t) {
                        const e = {};
                        if (void 0 !== t)
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = (new wu).fromJSON(t[n]);
                                e[i.uuid] = i
                            }
                        return e
                    }
                    parseSkeletons(t, e) {
                        const n = {},
                            i = {};
                        if (e.traverse((function(t) {
                                t.isBone && (i[t.uuid] = t)
                            })), void 0 !== t)
                            for (let r = 0, o = t.length; r < o; r++) {
                                const e = (new Ul).fromJSON(t[r], i);
                                n[e.uuid] = e
                            }
                        return n
                    }
                    parseGeometries(t, e) {
                        const n = {};
                        let i;
                        if (void 0 !== t) {
                            const r = new Yu;
                            for (let o = 0, s = t.length; o < s; o++) {
                                let s;
                                const a = t[o];
                                switch (a.type) {
                                    case "PlaneGeometry":
                                    case "PlaneBufferGeometry":
                                        s = new fh[a.type](a.width, a.height, a.widthSegments, a.heightSegments);
                                        break;
                                    case "BoxGeometry":
                                    case "BoxBufferGeometry":
                                        s = new fh[a.type](a.width, a.height, a.depth, a.widthSegments, a.heightSegments, a.depthSegments);
                                        break;
                                    case "CircleGeometry":
                                    case "CircleBufferGeometry":
                                        s = new fh[a.type](a.radius, a.segments, a.thetaStart, a.thetaLength);
                                        break;
                                    case "CylinderGeometry":
                                    case "CylinderBufferGeometry":
                                        s = new fh[a.type](a.radiusTop, a.radiusBottom, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
                                        break;
                                    case "ConeGeometry":
                                    case "ConeBufferGeometry":
                                        s = new fh[a.type](a.radius, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
                                        break;
                                    case "SphereGeometry":
                                    case "SphereBufferGeometry":
                                        s = new fh[a.type](a.radius, a.widthSegments, a.heightSegments, a.phiStart, a.phiLength, a.thetaStart, a.thetaLength);
                                        break;
                                    case "DodecahedronGeometry":
                                    case "DodecahedronBufferGeometry":
                                    case "IcosahedronGeometry":
                                    case "IcosahedronBufferGeometry":
                                    case "OctahedronGeometry":
                                    case "OctahedronBufferGeometry":
                                    case "TetrahedronGeometry":
                                    case "TetrahedronBufferGeometry":
                                        s = new fh[a.type](a.radius, a.detail);
                                        break;
                                    case "RingGeometry":
                                    case "RingBufferGeometry":
                                        s = new fh[a.type](a.innerRadius, a.outerRadius, a.thetaSegments, a.phiSegments, a.thetaStart, a.thetaLength);
                                        break;
                                    case "TorusGeometry":
                                    case "TorusBufferGeometry":
                                        s = new fh[a.type](a.radius, a.tube, a.radialSegments, a.tubularSegments, a.arc);
                                        break;
                                    case "TorusKnotGeometry":
                                    case "TorusKnotBufferGeometry":
                                        s = new fh[a.type](a.radius, a.tube, a.tubularSegments, a.radialSegments, a.p, a.q);
                                        break;
                                    case "TubeGeometry":
                                    case "TubeBufferGeometry":
                                        s = new fh[a.type]((new yu[a.path.type]).fromJSON(a.path), a.tubularSegments, a.radius, a.radialSegments, a.closed);
                                        break;
                                    case "LatheGeometry":
                                    case "LatheBufferGeometry":
                                        s = new fh[a.type](a.points, a.segments, a.phiStart, a.phiLength);
                                        break;
                                    case "PolyhedronGeometry":
                                    case "PolyhedronBufferGeometry":
                                        s = new fh[a.type](a.vertices, a.indices, a.radius, a.details);
                                        break;
                                    case "ShapeGeometry":
                                    case "ShapeBufferGeometry":
                                        i = [];
                                        for (let n = 0, r = a.shapes.length; n < r; n++) {
                                            const t = e[a.shapes[n]];
                                            i.push(t)
                                        }
                                        s = new fh[a.type](i, a.curveSegments);
                                        break;
                                    case "ExtrudeGeometry":
                                    case "ExtrudeBufferGeometry":
                                        i = [];
                                        for (let n = 0, r = a.shapes.length; n < r; n++) {
                                            const t = e[a.shapes[n]];
                                            i.push(t)
                                        }
                                        const t = a.options.extrudePath;
                                        void 0 !== t && (a.options.extrudePath = (new yu[t.type]).fromJSON(t)), s = new fh[a.type](i, a.options);
                                        break;
                                    case "BufferGeometry":
                                    case "InstancedBufferGeometry":
                                        s = r.parse(a);
                                        break;
                                    case "Geometry":
                                        console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                                        break;
                                    default:
                                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + a.type + '"');
                                        continue
                                }
                                s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData), n[a.uuid] = s
                            }
                        }
                        return n
                    }
                    parseMaterials(t, e) {
                        const n = {},
                            i = {};
                        if (void 0 !== t) {
                            const r = new zu;
                            r.setTextures(e);
                            for (let e = 0, o = t.length; e < o; e++) {
                                const o = t[e];
                                if ("MultiMaterial" === o.type) {
                                    const t = [];
                                    for (let e = 0; e < o.materials.length; e++) {
                                        const i = o.materials[e];
                                        void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)), t.push(n[i.uuid])
                                    }
                                    i[o.uuid] = t
                                } else void 0 === n[o.uuid] && (n[o.uuid] = r.parse(o)), i[o.uuid] = n[o.uuid]
                            }
                        }
                        return i
                    }
                    parseAnimations(t) {
                        const e = {};
                        if (void 0 !== t)
                            for (let n = 0; n < t.length; n++) {
                                const i = t[n],
                                    r = jh.parse(i);
                                e[r.uuid] = r
                            }
                        return e
                    }
                    parseImages(t, e) {
                        const n = this,
                            i = {};
                        let r;

                        function o(t) {
                            if ("string" == typeof t) {
                                const e = t;
                                return function(t) {
                                    return n.manager.itemStart(t), r.load(t, (function() {
                                        n.manager.itemEnd(t)
                                    }), void 0, (function() {
                                        n.manager.itemError(t), n.manager.itemEnd(t)
                                    }))
                                }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e)
                            }
                            return t.data ? {
                                data: Zr(t.type, t.data),
                                width: t.width,
                                height: t.height
                            } : null
                        }
                        if (void 0 !== t && t.length > 0) {
                            const n = new zh(e);
                            r = new Qh(n), r.setCrossOrigin(this.crossOrigin);
                            for (let e = 0, r = t.length; e < r; e++) {
                                const n = t[e],
                                    r = n.url;
                                if (Array.isArray(r)) {
                                    i[n.uuid] = [];
                                    for (let t = 0, e = r.length; t < e; t++) {
                                        const e = o(r[t]);
                                        null !== e && (e instanceof HTMLImageElement ? i[n.uuid].push(e) : i[n.uuid].push(new Vl(e.data, e.width, e.height)))
                                    }
                                } else {
                                    const t = o(n.url);
                                    null !== t && (i[n.uuid] = t)
                                }
                            }
                        }
                        return i
                    }
                    parseTextures(t, e) {
                        function n(t, e) {
                            return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                        }
                        const i = {};
                        if (void 0 !== t)
                            for (let r = 0, o = t.length; r < o; r++) {
                                const o = t[r];
                                let s;
                                void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === e[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image);
                                const a = e[o.image];
                                Array.isArray(a) ? (s = new Do(a), 6 === a.length && (s.needsUpdate = !0)) : (s = a && a.data ? new Vl(a.data, a.width, a.height) : new ti(a), a && (s.needsUpdate = !0)), s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), void 0 !== o.mapping && (s.mapping = n(o.mapping, qu)), void 0 !== o.offset && s.offset.fromArray(o.offset), void 0 !== o.repeat && s.repeat.fromArray(o.repeat), void 0 !== o.center && s.center.fromArray(o.center), void 0 !== o.rotation && (s.rotation = o.rotation), void 0 !== o.wrap && (s.wrapS = n(o.wrap[0], Qu), s.wrapT = n(o.wrap[1], Qu)), void 0 !== o.format && (s.format = o.format), void 0 !== o.type && (s.type = o.type), void 0 !== o.encoding && (s.encoding = o.encoding), void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, Zu)), void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, Zu)), void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy), void 0 !== o.flipY && (s.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (s.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (s.unpackAlignment = o.unpackAlignment), i[o.uuid] = s
                            }
                        return i
                    }
                    parseObject(t, e, n, i) {
                        let r, o, s;

                        function a(t) {
                            return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                        }

                        function l(t) {
                            if (void 0 !== t) {
                                if (Array.isArray(t)) {
                                    const e = [];
                                    for (let i = 0, r = t.length; i < r; i++) {
                                        const r = t[i];
                                        void 0 === n[r] && console.warn("THREE.ObjectLoader: Undefined material", r), e.push(n[r])
                                    }
                                    return e
                                }
                                return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                            }
                        }
                        switch (t.type) {
                            case "Scene":
                                r = new ll, void 0 !== t.background && Number.isInteger(t.background) && (r.background = new Fr(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? r.fog = new al(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (r.fog = new sl(t.fog.color, t.fog.density)));
                                break;
                            case "PerspectiveCamera":
                                r = new Fo(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (r.focus = t.focus), void 0 !== t.zoom && (r.zoom = t.zoom), void 0 !== t.filmGauge && (r.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (r.filmOffset = t.filmOffset), void 0 !== t.view && (r.view = Object.assign({}, t.view));
                                break;
                            case "OrthographicCamera":
                                r = new Nu(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (r.zoom = t.zoom), void 0 !== t.view && (r.view = Object.assign({}, t.view));
                                break;
                            case "AmbientLight":
                                r = new Vu(t.color, t.intensity);
                                break;
                            case "DirectionalLight":
                                r = new Du(t.color, t.intensity);
                                break;
                            case "PointLight":
                                r = new Ou(t.color, t.intensity, t.distance, t.decay);
                                break;
                            case "RectAreaLight":
                                r = new ju(t.color, t.intensity, t.width, t.height);
                                break;
                            case "SpotLight":
                                r = new Pu(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                                break;
                            case "HemisphereLight":
                                r = new Su(t.color, t.groundColor, t.intensity);
                                break;
                            case "LightProbe":
                                r = (new Uu).fromJSON(t);
                                break;
                            case "SkinnedMesh":
                                o = a(t.geometry), s = l(t.material), r = new Bl(o, s), void 0 !== t.bindMode && (r.bindMode = t.bindMode), void 0 !== t.bindMatrix && r.bindMatrix.fromArray(t.bindMatrix), void 0 !== t.skeleton && (r.skeleton = t.skeleton);
                                break;
                            case "Mesh":
                                o = a(t.geometry), s = l(t.material), r = new So(o, s);
                                break;
                            case "InstancedMesh":
                                o = a(t.geometry), s = l(t.material);
                                const e = t.count,
                                    n = t.instanceMatrix,
                                    i = t.instanceColor;
                                r = new Yl(o, s, e), r.instanceMatrix = new Dr(new Float32Array(n.array), 16), void 0 !== i && (r.instanceColor = new Dr(new Float32Array(i.array), i.itemSize));
                                break;
                            case "LOD":
                                r = new Ll;
                                break;
                            case "Line":
                                r = new $l(a(t.geometry), l(t.material));
                                break;
                            case "LineLoop":
                                r = new ic(a(t.geometry), l(t.material));
                                break;
                            case "LineSegments":
                                r = new nc(a(t.geometry), l(t.material));
                                break;
                            case "PointCloud":
                            case "Points":
                                r = new cc(a(t.geometry), l(t.material));
                                break;
                            case "Sprite":
                                r = new Tl(l(t.material));
                                break;
                            case "Group":
                                r = new $a;
                                break;
                            case "Bone":
                                r = new Dl;
                                break;
                            default:
                                r = new cr
                        }
                        if (r.uuid = t.uuid, void 0 !== t.name && (r.name = t.name), void 0 !== t.matrix ? (r.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (r.matrixAutoUpdate = t.matrixAutoUpdate), r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== t.position && r.position.fromArray(t.position), void 0 !== t.rotation && r.rotation.fromArray(t.rotation), void 0 !== t.quaternion && r.quaternion.fromArray(t.quaternion), void 0 !== t.scale && r.scale.fromArray(t.scale)), void 0 !== t.castShadow && (r.castShadow = t.castShadow), void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (r.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (r.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (r.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && r.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (r.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.frustumCulled && (r.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (r.renderOrder = t.renderOrder), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.layers && (r.layers.mask = t.layers), void 0 !== t.children) {
                            const o = t.children;
                            for (let t = 0; t < o.length; t++) r.add(this.parseObject(o[t], e, n, i))
                        }
                        if (void 0 !== t.animations) {
                            const e = t.animations;
                            for (let t = 0; t < e.length; t++) {
                                const n = e[t];
                                r.animations.push(i[n])
                            }
                        }
                        if ("LOD" === t.type) {
                            void 0 !== t.autoUpdate && (r.autoUpdate = t.autoUpdate);
                            const e = t.levels;
                            for (let t = 0; t < e.length; t++) {
                                const n = e[t],
                                    i = r.getObjectByProperty("uuid", n.object);
                                void 0 !== i && r.addLevel(i, n.distance)
                            }
                        }
                        return r
                    }
                    bindSkeletons(t, e) {
                        0 !== Object.keys(e).length && t.traverse((function(t) {
                            if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                                const n = e[t.skeleton];
                                void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton) : t.bind(n, t.bindMatrix)
                            }
                        }))
                    }
                    setTexturePath(t) {
                        return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
                    }
                }
                const qu = {
                        UVMapping: rt,
                        CubeReflectionMapping: ot,
                        CubeRefractionMapping: st,
                        EquirectangularReflectionMapping: at,
                        EquirectangularRefractionMapping: lt,
                        CubeUVReflectionMapping: ct,
                        CubeUVRefractionMapping: ht
                    },
                    Qu = {
                        RepeatWrapping: ut,
                        ClampToEdgeWrapping: dt,
                        MirroredRepeatWrapping: pt
                    },
                    Zu = {
                        NearestFilter: ft,
                        NearestMipmapNearestFilter: mt,
                        NearestMipmapLinearFilter: vt,
                        LinearFilter: xt,
                        LinearMipmapNearestFilter: bt,
                        LinearMipmapLinearFilter: _t
                    };
                class Ju extends Hh {
                    constructor(t) {
                        super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                            premultiplyAlpha: "none"
                        }
                    }
                    setOptions(t) {
                        return this.options = t, this
                    }
                    load(t, e, n, i) {
                        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const r = this,
                            o = Uh.get(t);
                        if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function() {
                            e && e(o), r.manager.itemEnd(t)
                        }), 0), o;
                        const s = {};
                        s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader, fetch(t, s).then((function(t) {
                            return t.blob()
                        })).then((function(t) {
                            return createImageBitmap(t, Object.assign(r.options, {
                                colorSpaceConversion: "none"
                            }))
                        })).then((function(n) {
                            Uh.add(t, n), e && e(n), r.manager.itemEnd(t)
                        })).catch((function(e) {
                            i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                        })), r.manager.itemStart(t)
                    }
                }
                Ju.prototype.isImageBitmapLoader = !0;
                class Ku {
                    constructor() {
                        this.type = "ShapePath", this.color = new Fr, this.subPaths = [], this.currentPath = null
                    }
                    moveTo(t, e) {
                        return this.currentPath = new bu, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
                    }
                    lineTo(t, e) {
                        return this.currentPath.lineTo(t, e), this
                    }
                    quadraticCurveTo(t, e, n, i) {
                        return this.currentPath.quadraticCurveTo(t, e, n, i), this
                    }
                    bezierCurveTo(t, e, n, i, r, o) {
                        return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this
                    }
                    splineThru(t) {
                        return this.currentPath.splineThru(t), this
                    }
                    toShapes(t, e) {
                        function n(t) {
                            const e = [];
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = t[n],
                                    r = new wu;
                                r.curves = i.curves, e.push(r)
                            }
                            return e
                        }

                        function i(t, e) {
                            const n = e.length;
                            let i = !1;
                            for (let r = n - 1, o = 0; o < n; r = o++) {
                                let n = e[r],
                                    s = e[o],
                                    a = s.x - n.x,
                                    l = s.y - n.y;
                                if (Math.abs(l) > Number.EPSILON) {
                                    if (l < 0 && (n = e[o], a = -a, s = e[r], l = -l), t.y < n.y || t.y > s.y) continue;
                                    if (t.y === n.y) {
                                        if (t.x === n.x) return !0
                                    } else {
                                        const e = l * (t.x - n.x) - a * (t.y - n.y);
                                        if (0 === e) return !0;
                                        if (e < 0) continue;
                                        i = !i
                                    }
                                } else {
                                    if (t.y !== n.y) continue;
                                    if (s.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= s.x) return !0
                                }
                            }
                            return i
                        }
                        const r = Zc.isClockWise,
                            o = this.subPaths;
                        if (0 === o.length) return [];
                        if (!0 === e) return n(o);
                        let s, a, l;
                        const c = [];
                        if (1 === o.length) return a = o[0], l = new wu, l.curves = a.curves, c.push(l), c;
                        let h = !r(o[0].getPoints());
                        h = t ? !h : h;
                        const u = [],
                            d = [];
                        let p, f, m = [],
                            g = 0;
                        d[g] = void 0, m[g] = [];
                        for (let v = 0, y = o.length; v < y; v++) a = o[v], p = a.getPoints(), s = r(p), s = t ? !s : s, s ? (!h && d[g] && g++, d[g] = {
                            s: new wu,
                            p: p
                        }, d[g].s.curves = a.curves, h && g++, m[g] = []) : m[g].push({
                            h: a,
                            p: p[0]
                        });
                        if (!d[0]) return n(o);
                        if (d.length > 1) {
                            let t = !1;
                            const e = [];
                            for (let n = 0, i = d.length; n < i; n++) u[n] = [];
                            for (let n = 0, r = d.length; n < r; n++) {
                                const r = m[n];
                                for (let o = 0; o < r.length; o++) {
                                    const s = r[o];
                                    let a = !0;
                                    for (let r = 0; r < d.length; r++) i(s.p, d[r].p) && (n !== r && e.push({
                                        froms: n,
                                        tos: r,
                                        hole: o
                                    }), a ? (a = !1, u[r].push(s)) : t = !0);
                                    a && u[n].push(s)
                                }
                            }
                            e.length > 0 && (t || (m = u))
                        }
                        for (let v = 0, y = d.length; v < y; v++) {
                            l = d[v].s, c.push(l), f = m[v];
                            for (let t = 0, e = f.length; t < e; t++) l.holes.push(f[t].h)
                        }
                        return c
                    }
                }
                class $u {
                    constructor(t) {
                        this.type = "Font", this.data = t
                    }
                    generateShapes(t) {
                        const e = [],
                            n = function(t, e, n) {
                                const i = Array.from(t),
                                    r = e / n.resolution,
                                    o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
                                    s = [];
                                let a = 0,
                                    l = 0;
                                for (let c = 0; c < i.length; c++) {
                                    const t = i[c];
                                    if ("\n" === t) a = 0, l -= o;
                                    else {
                                        const e = td(t, r, a, l, n);
                                        a += e.offsetX, s.push(e.path)
                                    }
                                }
                                return s
                            }(t, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100, this.data);
                        for (let i = 0, r = n.length; i < r; i++) Array.prototype.push.apply(e, n[i].toShapes());
                        return e
                    }
                }

                function td(t, e, n, i, r) {
                    const o = r.glyphs[t] || r.glyphs["?"];
                    if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".");
                    const s = new Ku;
                    let a, l, c, h, u, d, p, f;
                    if (o.o) {
                        const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
                        for (let r = 0, o = t.length; r < o;) switch (t[r++]) {
                            case "m":
                                a = t[r++] * e + n, l = t[r++] * e + i, s.moveTo(a, l);
                                break;
                            case "l":
                                a = t[r++] * e + n, l = t[r++] * e + i, s.lineTo(a, l);
                                break;
                            case "q":
                                c = t[r++] * e + n, h = t[r++] * e + i, u = t[r++] * e + n, d = t[r++] * e + i, s.quadraticCurveTo(u, d, c, h);
                                break;
                            case "b":
                                c = t[r++] * e + n, h = t[r++] * e + i, u = t[r++] * e + n, d = t[r++] * e + i, p = t[r++] * e + n, f = t[r++] * e + i, s.bezierCurveTo(u, d, p, f, c, h)
                        }
                    }
                    return {
                        offsetX: o.ha * e,
                        path: s
                    }
                }
                $u.prototype.isFont = !0;
                class ed extends Hh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const r = this,
                            o = new Yh(this.manager);
                        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(r.withCredentials), o.load(t, (function(t) {
                            let n;
                            try {
                                n = JSON.parse(t)
                            } catch (e) {
                                console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                            }
                            const i = r.parse(n);
                            e && e(i)
                        }), n, i)
                    }
                    parse(t) {
                        return new $u(t)
                    }
                }
                let nd;
                const id = {
                    getContext: function() {
                        return void 0 === nd && (nd = new(window.AudioContext || window.webkitAudioContext)), nd
                    },
                    setContext: function(t) {
                        nd = t
                    }
                };
                class rd extends Hh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const r = this,
                            o = new Yh(this.manager);
                        o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, (function(n) {
                            try {
                                const t = n.slice(0);
                                id.getContext().decodeAudioData(t, (function(t) {
                                    e(t)
                                }))
                            } catch (e) {
                                i ? i(e) : console.error(e), r.manager.itemError(t)
                            }
                        }), n, i)
                    }
                }
                class od extends Uu {
                    constructor(t, e) {
                        super(void 0, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1);
                        const n = (new Fr).set(t),
                            i = (new Fr).set(e),
                            r = new ai(n.r, n.g, n.b),
                            o = new ai(i.r, i.g, i.b),
                            s = Math.sqrt(Math.PI),
                            a = s * Math.sqrt(.75);
                        this.sh.coefficients[0].copy(r).add(o).multiplyScalar(s), this.sh.coefficients[1].copy(r).sub(o).multiplyScalar(a)
                    }
                }
                od.prototype.isHemisphereLightProbe = !0;
                class sd extends Uu {
                    constructor(t) {
                        super(void 0, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1);
                        const e = (new Fr).set(t);
                        this.sh.coefficients[0].set(e.r, e.g, e.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                    }
                }
                sd.prototype.isAmbientLightProbe = !0;
                const ad = new Vi,
                    ld = new Vi;
                class cd {
                    constructor() {
                        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Fo, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Fo, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                            focus: null,
                            fov: null,
                            aspect: null,
                            near: null,
                            far: null,
                            zoom: null,
                            eyeSep: null
                        }
                    }
                    update(t) {
                        const e = this._cache;
                        if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                            e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
                            const n = t.projectionMatrix.clone(),
                                i = e.eyeSep / 2,
                                r = i * e.near / e.focus,
                                o = e.near * Math.tan(jn * e.fov * .5) / e.zoom;
                            let s, a;
                            ld.elements[12] = -i, ad.elements[12] = i, s = -o * e.aspect + r, a = o * e.aspect + r, n.elements[0] = 2 * e.near / (a - s), n.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy(n), s = -o * e.aspect - r, a = o * e.aspect - r, n.elements[0] = 2 * e.near / (a - s), n.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy(n)
                        }
                        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(ld), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(ad)
                    }
                }
                class hd {
                    constructor() {
                        let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                        this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                    }
                    start() {
                        this.startTime = ud(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                    }
                    stop() {
                        this.getElapsedTime(), this.running = !1, this.autoStart = !1
                    }
                    getElapsedTime() {
                        return this.getDelta(), this.elapsedTime
                    }
                    getDelta() {
                        let t = 0;
                        if (this.autoStart && !this.running) return this.start(), 0;
                        if (this.running) {
                            const e = ud();
                            t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                        }
                        return t
                    }
                }

                function ud() {
                    return ("undefined" == typeof performance ? Date : performance).now()
                }
                const dd = new ai,
                    pd = new si,
                    fd = new ai,
                    md = new ai;
                class gd extends cr {
                    constructor() {
                        super(), this.type = "AudioListener", this.context = id.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new hd
                    }
                    getInput() {
                        return this.gain
                    }
                    removeFilter() {
                        return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                    }
                    getFilter() {
                        return this.filter
                    }
                    setFilter(t) {
                        return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                    }
                    getMasterVolume() {
                        return this.gain.gain.value
                    }
                    setMasterVolume(t) {
                        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t);
                        const e = this.context.listener,
                            n = this.up;
                        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(dd, pd, fd), md.set(0, 0, -1).applyQuaternion(pd), e.positionX) {
                            const t = this.context.currentTime + this.timeDelta;
                            e.positionX.linearRampToValueAtTime(dd.x, t), e.positionY.linearRampToValueAtTime(dd.y, t), e.positionZ.linearRampToValueAtTime(dd.z, t), e.forwardX.linearRampToValueAtTime(md.x, t), e.forwardY.linearRampToValueAtTime(md.y, t), e.forwardZ.linearRampToValueAtTime(md.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)
                        } else e.setPosition(dd.x, dd.y, dd.z), e.setOrientation(md.x, md.y, md.z, n.x, n.y, n.z)
                    }
                }
                class vd extends cr {
                    constructor(t) {
                        super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                    }
                    getOutput() {
                        return this.gain
                    }
                    setNodeSource(t) {
                        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                    }
                    setMediaElementSource(t) {
                        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                    }
                    setMediaStreamSource(t) {
                        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
                    }
                    setBuffer(t) {
                        return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                    }
                    play() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                        if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                        if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                        this._startedAt = this.context.currentTime + t;
                        const e = this.context.createBufferSource();
                        return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                    }
                    pause() {
                        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    stop() {
                        if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else this.source.connect(this.getOutput());
                        return this._connected = !0, this
                    }
                    disconnect() {
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                            this.filters[this.filters.length - 1].disconnect(this.getOutput())
                        } else this.source.disconnect(this.getOutput());
                        return this._connected = !1, this
                    }
                    getFilters() {
                        return this.filters
                    }
                    setFilters(t) {
                        return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
                    }
                    setDetune(t) {
                        if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                    }
                    getDetune() {
                        return this.detune
                    }
                    getFilter() {
                        return this.getFilters()[0]
                    }
                    setFilter(t) {
                        return this.setFilters(t ? [t] : [])
                    }
                    setPlaybackRate(t) {
                        if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    getPlaybackRate() {
                        return this.playbackRate
                    }
                    onEnded() {
                        this.isPlaying = !1
                    }
                    getLoop() {
                        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                    }
                    setLoop(t) {
                        if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    setLoopStart(t) {
                        return this.loopStart = t, this
                    }
                    setLoopEnd(t) {
                        return this.loopEnd = t, this
                    }
                    getVolume() {
                        return this.gain.gain.value
                    }
                    setVolume(t) {
                        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                    }
                }
                const yd = new ai,
                    xd = new si,
                    bd = new ai,
                    wd = new ai;
                class _d extends vd {
                    constructor(t) {
                        super(t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
                    }
                    getOutput() {
                        return this.panner
                    }
                    getRefDistance() {
                        return this.panner.refDistance
                    }
                    setRefDistance(t) {
                        return this.panner.refDistance = t, this
                    }
                    getRolloffFactor() {
                        return this.panner.rolloffFactor
                    }
                    setRolloffFactor(t) {
                        return this.panner.rolloffFactor = t, this
                    }
                    getDistanceModel() {
                        return this.panner.distanceModel
                    }
                    setDistanceModel(t) {
                        return this.panner.distanceModel = t, this
                    }
                    getMaxDistance() {
                        return this.panner.maxDistance
                    }
                    setMaxDistance(t) {
                        return this.panner.maxDistance = t, this
                    }
                    setDirectionalCone(t, e, n) {
                        return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
                    }
                    updateMatrixWorld(t) {
                        if (super.updateMatrixWorld(t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
                        this.matrixWorld.decompose(yd, xd, bd), wd.set(0, 0, 1).applyQuaternion(xd);
                        const e = this.panner;
                        if (e.positionX) {
                            const t = this.context.currentTime + this.listener.timeDelta;
                            e.positionX.linearRampToValueAtTime(yd.x, t), e.positionY.linearRampToValueAtTime(yd.y, t), e.positionZ.linearRampToValueAtTime(yd.z, t), e.orientationX.linearRampToValueAtTime(wd.x, t), e.orientationY.linearRampToValueAtTime(wd.y, t), e.orientationZ.linearRampToValueAtTime(wd.z, t)
                        } else e.setPosition(yd.x, yd.y, yd.z), e.setOrientation(wd.x, wd.y, wd.z)
                    }
                }
                class Sd {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2048;
                        this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
                    }
                    getFrequencyData() {
                        return this.analyser.getByteFrequencyData(this.data), this.data
                    }
                    getAverageFrequency() {
                        let t = 0;
                        const e = this.getFrequencyData();
                        for (let n = 0; n < e.length; n++) t += e[n];
                        return t / e.length
                    }
                }
                class Md {
                    constructor(t, e, n) {
                        let i, r, o;
                        switch (this.binding = t, this.valueSize = n, e) {
                            case "quaternion":
                                i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                                break;
                            case "string":
                            case "bool":
                                i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                                break;
                            default:
                                i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                        }
                        this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                    }
                    accumulate(t, e) {
                        const n = this.buffer,
                            i = this.valueSize,
                            r = t * i + i;
                        let o = this.cumulativeWeight;
                        if (0 === o) {
                            for (let t = 0; t !== i; ++t) n[r + t] = n[t];
                            o = e
                        } else {
                            o += e;
                            const t = e / o;
                            this._mixBufferRegion(n, r, 0, t, i)
                        }
                        this.cumulativeWeight = o
                    }
                    accumulateAdditive(t) {
                        const e = this.buffer,
                            n = this.valueSize,
                            i = n * this._addIndex;
                        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t
                    }
                    apply(t) {
                        const e = this.valueSize,
                            n = this.buffer,
                            i = t * e + e,
                            r = this.cumulativeWeight,
                            o = this.cumulativeWeightAdditive,
                            s = this.binding;
                        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                            const t = e * this._origIndex;
                            this._mixBufferRegion(n, i, t, 1 - r, e)
                        }
                        o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                        for (let a = e, l = e + e; a !== l; ++a)
                            if (n[a] !== n[a + e]) {
                                s.setValue(n, i);
                                break
                            }
                    }
                    saveOriginalState() {
                        const t = this.binding,
                            e = this.buffer,
                            n = this.valueSize,
                            i = n * this._origIndex;
                        t.getValue(e, i);
                        for (let r = n, o = i; r !== o; ++r) e[r] = e[i + r % n];
                        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                    }
                    restoreOriginalState() {
                        const t = 3 * this.valueSize;
                        this.binding.setValue(this.buffer, t)
                    }
                    _setAdditiveIdentityNumeric() {
                        const t = this._addIndex * this.valueSize,
                            e = t + this.valueSize;
                        for (let n = t; n < e; n++) this.buffer[n] = 0
                    }
                    _setAdditiveIdentityQuaternion() {
                        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                    }
                    _setAdditiveIdentityOther() {
                        const t = this._origIndex * this.valueSize,
                            e = this._addIndex * this.valueSize;
                        for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                    }
                    _select(t, e, n, i, r) {
                        if (i >= .5)
                            for (let o = 0; o !== r; ++o) t[e + o] = t[n + o]
                    }
                    _slerp(t, e, n, i) {
                        si.slerpFlat(t, e, t, e, t, n, i)
                    }
                    _slerpAdditive(t, e, n, i, r) {
                        const o = this._workIndex * r;
                        si.multiplyQuaternionsFlat(t, o, t, e, t, n), si.slerpFlat(t, e, t, e, t, o, i)
                    }
                    _lerp(t, e, n, i, r) {
                        const o = 1 - i;
                        for (let s = 0; s !== r; ++s) {
                            const r = e + s;
                            t[r] = t[r] * o + t[n + s] * i
                        }
                    }
                    _lerpAdditive(t, e, n, i, r) {
                        for (let o = 0; o !== r; ++o) {
                            const r = e + o;
                            t[r] = t[r] + t[n + o] * i
                        }
                    }
                }
                const Ad = new RegExp("[\\[\\]\\.:\\/]", "g"),
                    Td = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                    Ed = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                    Cd = /(WCOD+)?/.source.replace("WCOD", Td),
                    Pd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                    Ld = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                    Rd = new RegExp("^" + Ed + Cd + Pd + Ld + "$"),
                    Id = ["material", "materials", "bones"];
                class Fd {
                    constructor(t, e, n) {
                        this.path = e, this.parsedPath = n || Fd.parseTrackName(e), this.node = Fd.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                    static create(t, e, n) {
                        return t && t.isAnimationObjectGroup ? new Fd.Composite(t, e, n) : new Fd(t, e, n)
                    }
                    static sanitizeNodeName(t) {
                        return t.replace(/\s/g, "_").replace(Ad, "")
                    }
                    static parseTrackName(t) {
                        const e = Rd.exec(t);
                        if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                        const n = {
                                nodeName: e[2],
                                objectName: e[3],
                                objectIndex: e[4],
                                propertyName: e[5],
                                propertyIndex: e[6]
                            },
                            i = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== i && -1 !== i) {
                            const t = n.nodeName.substring(i + 1); - 1 !== Id.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
                        }
                        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                        return n
                    }
                    static findNode(t, e) {
                        if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                        if (t.skeleton) {
                            const n = t.skeleton.getBoneByName(e);
                            if (void 0 !== n) return n
                        }
                        if (t.children) {
                            const n = function(t) {
                                    for (let i = 0; i < t.length; i++) {
                                        const r = t[i];
                                        if (r.name === e || r.uuid === e) return r;
                                        const o = n(r.children);
                                        if (o) return o
                                    }
                                    return null
                                },
                                i = n(t.children);
                            if (i) return i
                        }
                        return null
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(t, e) {
                        t[e] = this.node[this.propertyName]
                    }
                    _getValue_array(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
                    }
                    _getValue_arrayElement(t, e) {
                        t[e] = this.resolvedProperty[this.propertyIndex]
                    }
                    _getValue_toArray(t, e) {
                        this.resolvedProperty.toArray(t, e)
                    }
                    _setValue_direct(t, e) {
                        this.targetObject[this.propertyName] = t[e]
                    }
                    _setValue_direct_setNeedsUpdate(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                    }
                    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_array(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
                    }
                    _setValue_array_setNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_arrayElement(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e]
                    }
                    _setValue_arrayElement_setNeedsUpdate(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                    }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_fromArray(t, e) {
                        this.resolvedProperty.fromArray(t, e)
                    }
                    _setValue_fromArray_setNeedsUpdate(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                    }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _getValue_unbound(t, e) {
                        this.bind(), this.getValue(t, e)
                    }
                    _setValue_unbound(t, e) {
                        this.bind(), this.setValue(t, e)
                    }
                    bind() {
                        let t = this.node;
                        const e = this.parsedPath,
                            n = e.objectName,
                            i = e.propertyName;
                        let r = e.propertyIndex;
                        if (t || (t = Fd.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                        if (n) {
                            let i = e.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    t = t.material.materials;
                                    break;
                                case "bones":
                                    if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    t = t.skeleton.bones;
                                    for (let e = 0; e < t.length; e++)
                                        if (t[e].name === i) {
                                            i = e;
                                            break
                                        }
                                    break;
                                default:
                                    if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    t = t[n]
                            }
                            if (void 0 !== i) {
                                if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                t = t[i]
                            }
                        }
                        const o = t[i];
                        if (void 0 === o) {
                            const n = e.nodeName;
                            return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
                        }
                        let s = this.Versioning.None;
                        this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
                        let a = this.BindingType.Direct;
                        if (void 0 !== r) {
                            if ("morphTargetInfluences" === i) {
                                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                            }
                            a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                        } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
                        this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s]
                    }
                    unbind() {
                        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                }
                Fd.Composite = class {
                    constructor(t, e, n) {
                        const i = n || Fd.parseTrackName(e);
                        this._targetGroup = t, this._bindings = t.subscribe_(e, i)
                    }
                    getValue(t, e) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_,
                            i = this._bindings[n];
                        void 0 !== i && i.getValue(t, e)
                    }
                    setValue(t, e) {
                        const n = this._bindings;
                        for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
                    }
                    bind() {
                        const t = this._bindings;
                        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                    }
                    unbind() {
                        const t = this._bindings;
                        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                    }
                }, Fd.prototype.BindingType = {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                }, Fd.prototype.Versioning = {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                }, Fd.prototype.GetterByBindingType = [Fd.prototype._getValue_direct, Fd.prototype._getValue_array, Fd.prototype._getValue_arrayElement, Fd.prototype._getValue_toArray], Fd.prototype.SetterByBindingTypeAndVersioning = [
                    [Fd.prototype._setValue_direct, Fd.prototype._setValue_direct_setNeedsUpdate, Fd.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                    [Fd.prototype._setValue_array, Fd.prototype._setValue_array_setNeedsUpdate, Fd.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                    [Fd.prototype._setValue_arrayElement, Fd.prototype._setValue_arrayElement_setNeedsUpdate, Fd.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                    [Fd.prototype._setValue_fromArray, Fd.prototype._setValue_fromArray_setNeedsUpdate, Fd.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
                ];
                class Od {
                    constructor() {
                        this.uuid = Un(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                        const t = {};
                        this._indicesByUUID = t;
                        for (let n = 0, i = arguments.length; n !== i; ++n) t[arguments[n].uuid] = n;
                        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                        const e = this;
                        this.stats = {
                            objects: {get total() {
                                    return e._objects.length
                                },
                                get inUse() {
                                    return this.total - e.nCachedObjects_
                                }
                            },
                            get bindingsPerObject() {
                                return e._bindings.length
                            }
                        }
                    }
                    add() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._paths,
                            i = this._parsedPaths,
                            r = this._bindings,
                            o = r.length;
                        let s, a = t.length,
                            l = this.nCachedObjects_;
                        for (let c = 0, h = arguments.length; c !== h; ++c) {
                            const h = arguments[c],
                                u = h.uuid;
                            let d = e[u];
                            if (void 0 === d) {
                                d = a++, e[u] = d, t.push(h);
                                for (let t = 0, e = o; t !== e; ++t) r[t].push(new Fd(h, n[t], i[t]))
                            } else if (d < l) {
                                s = t[d];
                                const a = --l,
                                    c = t[a];
                                e[c.uuid] = d, t[d] = c, e[u] = a, t[a] = h;
                                for (let t = 0, e = o; t !== e; ++t) {
                                    const e = r[t],
                                        o = e[a];
                                    let s = e[d];
                                    e[d] = o, void 0 === s && (s = new Fd(h, n[t], i[t])), e[a] = s
                                }
                            } else t[d] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = l
                    }
                    remove() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._bindings,
                            i = n.length;
                        let r = this.nCachedObjects_;
                        for (let o = 0, s = arguments.length; o !== s; ++o) {
                            const s = arguments[o],
                                a = s.uuid,
                                l = e[a];
                            if (void 0 !== l && l >= r) {
                                const o = r++,
                                    c = t[o];
                                e[c.uuid] = l, t[l] = c, e[a] = o, t[o] = s;
                                for (let t = 0, e = i; t !== e; ++t) {
                                    const e = n[t],
                                        i = e[o],
                                        r = e[l];
                                    e[l] = i, e[o] = r
                                }
                            }
                        }
                        this.nCachedObjects_ = r
                    }
                    uncache() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._bindings,
                            i = n.length;
                        let r = this.nCachedObjects_,
                            o = t.length;
                        for (let s = 0, a = arguments.length; s !== a; ++s) {
                            const a = arguments[s].uuid,
                                l = e[a];
                            if (void 0 !== l)
                                if (delete e[a], l < r) {
                                    const s = --r,
                                        a = t[s],
                                        c = --o,
                                        h = t[c];
                                    e[a.uuid] = l, t[l] = a, e[h.uuid] = s, t[s] = h, t.pop();
                                    for (let t = 0, e = i; t !== e; ++t) {
                                        const e = n[t],
                                            i = e[s],
                                            r = e[c];
                                        e[l] = i, e[s] = r, e.pop()
                                    }
                                } else {
                                    const r = --o,
                                        s = t[r];
                                    r > 0 && (e[s.uuid] = l), t[l] = s, t.pop();
                                    for (let t = 0, e = i; t !== e; ++t) {
                                        const e = n[t];
                                        e[l] = e[r], e.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = r
                    }
                    subscribe_(t, e) {
                        const n = this._bindingsIndicesByPath;
                        let i = n[t];
                        const r = this._bindings;
                        if (void 0 !== i) return r[i];
                        const o = this._paths,
                            s = this._parsedPaths,
                            a = this._objects,
                            l = a.length,
                            c = this.nCachedObjects_,
                            h = new Array(l);
                        i = r.length, n[t] = i, o.push(t), s.push(e), r.push(h);
                        for (let u = c, d = a.length; u !== d; ++u) {
                            const n = a[u];
                            h[u] = new Fd(n, t, e)
                        }
                        return h
                    }
                    unsubscribe_(t) {
                        const e = this._bindingsIndicesByPath,
                            n = e[t];
                        if (void 0 !== n) {
                            const i = this._paths,
                                r = this._parsedPaths,
                                o = this._bindings,
                                s = o.length - 1,
                                a = o[s];
                            e[t[s]] = n, o[n] = a, o.pop(), r[n] = r[s], r.pop(), i[n] = i[s], i.pop()
                        }
                    }
                }
                Od.prototype.isAnimationObjectGroup = !0;
                class Nd {
                    constructor(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.blendMode;
                        this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
                        const r = e.tracks,
                            o = r.length,
                            s = new Array(o),
                            a = {
                                endingStart: ze,
                                endingEnd: ze
                            };
                        for (let l = 0; l !== o; ++l) {
                            const t = r[l].createInterpolant(null);
                            s[l] = t, t.settings = a
                        }
                        this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = De, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                    }
                    play() {
                        return this._mixer._activateAction(this), this
                    }
                    stop() {
                        return this._mixer._deactivateAction(this), this.reset()
                    }
                    reset() {
                        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                    }
                    isRunning() {
                        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                    }
                    isScheduled() {
                        return this._mixer._isActiveAction(this)
                    }
                    startAt(t) {
                        return this._startTime = t, this
                    }
                    setLoop(t, e) {
                        return this.loop = t, this.repetitions = e, this
                    }
                    setEffectiveWeight(t) {
                        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                    }
                    getEffectiveWeight() {
                        return this._effectiveWeight
                    }
                    fadeIn(t) {
                        return this._scheduleFading(t, 0, 1)
                    }
                    fadeOut(t) {
                        return this._scheduleFading(t, 1, 0)
                    }
                    crossFadeFrom(t, e, n) {
                        if (t.fadeOut(e), this.fadeIn(e), n) {
                            const n = this._clip.duration,
                                i = t._clip.duration,
                                r = i / n,
                                o = n / i;
                            t.warp(1, r, e), this.warp(o, 1, e)
                        }
                        return this
                    }
                    crossFadeTo(t, e, n) {
                        return t.crossFadeFrom(this, e, n)
                    }
                    stopFading() {
                        const t = this._weightInterpolant;
                        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    }
                    setEffectiveTimeScale(t) {
                        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                    }
                    getEffectiveTimeScale() {
                        return this._effectiveTimeScale
                    }
                    setDuration(t) {
                        return this.timeScale = this._clip.duration / t, this.stopWarping()
                    }
                    syncWith(t) {
                        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                    }
                    halt(t) {
                        return this.warp(this._effectiveTimeScale, 0, t)
                    }
                    warp(t, e, n) {
                        const i = this._mixer,
                            r = i.time,
                            o = this.timeScale;
                        let s = this._timeScaleInterpolant;
                        null === s && (s = i._lendControlInterpolant(), this._timeScaleInterpolant = s);
                        const a = s.parameterPositions,
                            l = s.sampleValues;
                        return a[0] = r, a[1] = r + n, l[0] = t / o, l[1] = e / o, this
                    }
                    stopWarping() {
                        const t = this._timeScaleInterpolant;
                        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    }
                    getMixer() {
                        return this._mixer
                    }
                    getClip() {
                        return this._clip
                    }
                    getRoot() {
                        return this._localRoot || this._mixer._root
                    }
                    _update(t, e, n, i) {
                        if (!this.enabled) return void this._updateWeight(t);
                        const r = this._startTime;
                        if (null !== r) {
                            const i = (t - r) * n;
                            if (i < 0 || 0 === n) return;
                            this._startTime = null, e = n * i
                        }
                        e *= this._updateTimeScale(t);
                        const o = this._updateTime(e),
                            s = this._updateWeight(t);
                        if (s > 0) {
                            const t = this._interpolants,
                                e = this._propertyBindings;
                            if (this.blendMode === Ye)
                                for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(o), e[n].accumulateAdditive(s);
                            else
                                for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(o), e[n].accumulate(i, s)
                        }
                    }
                    _updateWeight(t) {
                        let e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            const n = this._weightInterpolant;
                            if (null !== n) {
                                const i = n.evaluate(t)[0];
                                e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e, e
                    }
                    _updateTimeScale(t) {
                        let e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            const n = this._timeScaleInterpolant;
                            null !== n && (e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e))
                        }
                        return this._effectiveTimeScale = e, e
                    }
                    _updateTime(t) {
                        const e = this._clip.duration,
                            n = this.loop;
                        let i = this.time + t,
                            r = this._loopCount;
                        const o = n === Ve;
                        if (0 === t) return -1 === r ? i : o && 1 == (1 & r) ? e - i : i;
                        if (n === Be) {
                            -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                            t: {
                                if (i >= e) i = e;
                                else {
                                    if (!(i < 0)) {
                                        this.time = i;
                                        break t
                                    }
                                    i = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this.time = i,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), i >= e || i < 0) {
                                const n = Math.floor(i / e);
                                i -= e * n, r += Math.abs(n);
                                const s = this.repetitions - r;
                                if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t > 0 ? 1 : -1
                                });
                                else {
                                    if (1 === s) {
                                        const e = t < 0;
                                        this._setEndings(e, !e, o)
                                    } else this._setEndings(!1, !1, o);
                                    this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: n
                                    })
                                }
                            } else this.time = i;
                            if (o && 1 == (1 & r)) return e - i
                        }
                        return i
                    }
                    _setEndings(t, e, n) {
                        const i = this._interpolantSettings;
                        n ? (i.endingStart = Ge, i.endingEnd = Ge) : (i.endingStart = t ? this.zeroSlopeAtStart ? Ge : ze : He, i.endingEnd = e ? this.zeroSlopeAtEnd ? Ge : ze : He)
                    }
                    _scheduleFading(t, e, n) {
                        const i = this._mixer,
                            r = i.time;
                        let o = this._weightInterpolant;
                        null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
                        const s = o.parameterPositions,
                            a = o.sampleValues;
                        return s[0] = r, a[0] = e, s[1] = r + t, a[1] = n, this
                    }
                }
                class Bd extends Bn {
                    constructor(t) {
                        super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                    }
                    _bindAction(t, e) {
                        const n = t._localRoot || this._root,
                            i = t._clip.tracks,
                            r = i.length,
                            o = t._propertyBindings,
                            s = t._interpolants,
                            a = n.uuid,
                            l = this._bindingsByRootAndName;
                        let c = l[a];
                        void 0 === c && (c = {}, l[a] = c);
                        for (let h = 0; h !== r; ++h) {
                            const t = i[h],
                                r = t.name;
                            let l = c[r];
                            if (void 0 !== l) o[h] = l;
                            else {
                                if (l = o[h], void 0 !== l) {
                                    null === l._cacheIndex && (++l.referenceCount, this._addInactiveBinding(l, a, r));
                                    continue
                                }
                                const i = e && e._propertyBindings[h].binding.parsedPath;
                                l = new Md(Fd.create(n, r, i), t.ValueTypeName, t.getValueSize()), ++l.referenceCount, this._addInactiveBinding(l, a, r), o[h] = l
                            }
                            s[h].resultBuffer = l.buffer
                        }
                    }
                    _activateAction(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                const e = (t._localRoot || this._root).uuid,
                                    n = t._clip.uuid,
                                    i = this._actionsByClip[n];
                                this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                            }
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    }
                    _deactivateAction(t) {
                        if (this._isActiveAction(t)) {
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                            }
                            this._takeBackAction(t)
                        }
                    }
                    _initMemoryManager() {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        const t = this;
                        this.stats = {
                            actions: {get total() {
                                    return t._actions.length
                                },
                                get inUse() {
                                    return t._nActiveActions
                                }
                            },
                            bindings: {get total() {
                                    return t._bindings.length
                                },
                                get inUse() {
                                    return t._nActiveBindings
                                }
                            },
                            controlInterpolants: {get total() {
                                    return t._controlInterpolants.length
                                },
                                get inUse() {
                                    return t._nActiveControlInterpolants
                                }
                            }
                        }
                    }
                    _isActiveAction(t) {
                        const e = t._cacheIndex;
                        return null !== e && e < this._nActiveActions
                    }
                    _addInactiveAction(t, e, n) {
                        const i = this._actions,
                            r = this._actionsByClip;
                        let o = r[e];
                        if (void 0 === o) o = {
                            knownActions: [t],
                            actionByRoot: {}
                        }, t._byClipCacheIndex = 0, r[e] = o;
                        else {
                            const e = o.knownActions;
                            t._byClipCacheIndex = e.length, e.push(t)
                        }
                        t._cacheIndex = i.length, i.push(t), o.actionByRoot[n] = t
                    }
                    _removeInactiveAction(t) {
                        const e = this._actions,
                            n = e[e.length - 1],
                            i = t._cacheIndex;
                        n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                        const r = t._clip.uuid,
                            o = this._actionsByClip,
                            s = o[r],
                            a = s.knownActions,
                            l = a[a.length - 1],
                            c = t._byClipCacheIndex;
                        l._byClipCacheIndex = c, a[c] = l, a.pop(), t._byClipCacheIndex = null, delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete o[r], this._removeInactiveBindingsForAction(t)
                    }
                    _removeInactiveBindingsForAction(t) {
                        const e = t._propertyBindings;
                        for (let n = 0, i = e.length; n !== i; ++n) {
                            const t = e[n];
                            0 == --t.referenceCount && this._removeInactiveBinding(t)
                        }
                    }
                    _lendAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            i = this._nActiveActions++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _takeBackAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            i = --this._nActiveActions,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _addInactiveBinding(t, e, n) {
                        const i = this._bindingsByRootAndName,
                            r = this._bindings;
                        let o = i[e];
                        void 0 === o && (o = {}, i[e] = o), o[n] = t, t._cacheIndex = r.length, r.push(t)
                    }
                    _removeInactiveBinding(t) {
                        const e = this._bindings,
                            n = t.binding,
                            i = n.rootNode.uuid,
                            r = n.path,
                            o = this._bindingsByRootAndName,
                            s = o[i],
                            a = e[e.length - 1],
                            l = t._cacheIndex;
                        a._cacheIndex = l, e[l] = a, e.pop(), delete s[r], 0 === Object.keys(s).length && delete o[i]
                    }
                    _lendBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            i = this._nActiveBindings++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _takeBackBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            i = --this._nActiveBindings,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _lendControlInterpolant() {
                        const t = this._controlInterpolants,
                            e = this._nActiveControlInterpolants++;
                        let n = t[e];
                        return void 0 === n && (n = new Ph(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
                    }
                    _takeBackControlInterpolant(t) {
                        const e = this._controlInterpolants,
                            n = t.__cacheIndex,
                            i = --this._nActiveControlInterpolants,
                            r = e[i];
                        t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                    }
                    clipAction(t, e, n) {
                        const i = e || this._root,
                            r = i.uuid;
                        let o = "string" == typeof t ? jh.findByName(i, t) : t;
                        const s = null !== o ? o.uuid : t,
                            a = this._actionsByClip[s];
                        let l = null;
                        if (void 0 === n && (n = null !== o ? o.blendMode : We), void 0 !== a) {
                            const t = a.actionByRoot[r];
                            if (void 0 !== t && t.blendMode === n) return t;
                            l = a.knownActions[0], null === o && (o = l._clip)
                        }
                        if (null === o) return null;
                        const c = new Nd(this, o, e, n);
                        return this._bindAction(c, l), this._addInactiveAction(c, s, r), c
                    }
                    existingAction(t, e) {
                        const n = e || this._root,
                            i = n.uuid,
                            r = "string" == typeof t ? jh.findByName(n, t) : t,
                            o = r ? r.uuid : t,
                            s = this._actionsByClip[o];
                        return void 0 !== s && s.actionByRoot[i] || null
                    }
                    stopAllAction() {
                        const t = this._actions;
                        for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                        return this
                    }
                    update(t) {
                        t *= this.timeScale;
                        const e = this._actions,
                            n = this._nActiveActions,
                            i = this.time += t,
                            r = Math.sign(t),
                            o = this._accuIndex ^= 1;
                        for (let l = 0; l !== n; ++l) e[l]._update(i, t, r, o);
                        const s = this._bindings,
                            a = this._nActiveBindings;
                        for (let l = 0; l !== a; ++l) s[l].apply(o);
                        return this
                    }
                    setTime(t) {
                        this.time = 0;
                        for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                        return this.update(t)
                    }
                    getRoot() {
                        return this._root
                    }
                    uncacheClip(t) {
                        const e = this._actions,
                            n = t.uuid,
                            i = this._actionsByClip,
                            r = i[n];
                        if (void 0 !== r) {
                            const t = r.knownActions;
                            for (let n = 0, i = t.length; n !== i; ++n) {
                                const i = t[n];
                                this._deactivateAction(i);
                                const r = i._cacheIndex,
                                    o = e[e.length - 1];
                                i._cacheIndex = null, i._byClipCacheIndex = null, o._cacheIndex = r, e[r] = o, e.pop(), this._removeInactiveBindingsForAction(i)
                            }
                            delete i[n]
                        }
                    }
                    uncacheRoot(t) {
                        const e = t.uuid,
                            n = this._actionsByClip;
                        for (const r in n) {
                            const t = n[r].actionByRoot[e];
                            void 0 !== t && (this._deactivateAction(t), this._removeInactiveAction(t))
                        }
                        const i = this._bindingsByRootAndName[e];
                        if (void 0 !== i)
                            for (const r in i) {
                                const t = i[r];
                                t.restoreOriginalState(), this._removeInactiveBinding(t)
                            }
                    }
                    uncacheAction(t, e) {
                        const n = this.existingAction(t, e);
                        null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                    }
                }
                Bd.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
                class Dd {
                    constructor(t) {
                        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
                    }
                    clone() {
                        return new Dd(void 0 === this.value.clone ? this.value : this.value.clone())
                    }
                }
                class Vd extends cl {
                    constructor(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                        super(t, e), this.meshPerAttribute = n || 1
                    }
                    copy(t) {
                        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                    clone(t) {
                        const e = super.clone(t);
                        return e.meshPerAttribute = this.meshPerAttribute, e
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                    }
                }
                Vd.prototype.isInstancedInterleavedBuffer = !0;
                class jd {
                    constructor(t, e, n, i, r) {
                        this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                    setBuffer(t) {
                        return this.buffer = t, this
                    }
                    setType(t, e) {
                        return this.type = t, this.elementSize = e, this
                    }
                    setItemSize(t) {
                        return this.itemSize = t, this
                    }
                    setCount(t) {
                        return this.count = t, this
                    }
                }
                jd.prototype.isGLBufferAttribute = !0;
                class kd {
                    constructor(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
                        this.ray = new Di(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new Qi, this.params = {
                            Mesh: {},
                            Line: {
                                threshold: 1
                            },
                            LOD: {},
                            Points: {
                                threshold: 1
                            },
                            Sprite: {}
                        }
                    }
                    set(t, e) {
                        this.ray.set(t, e)
                    }
                    setFromCamera(t, e) {
                        e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
                    }
                    intersectObject(t) {
                        let e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                        return zd(t, this, e, arguments.length > 1 && void 0 !== arguments[1] && arguments[1]), e.sort(Ud), e
                    }
                    intersectObjects(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                        for (let i = 0, r = t.length; i < r; i++) zd(t[i], this, n, e);
                        return n.sort(Ud), n
                    }
                }

                function Ud(t, e) {
                    return t.distance - e.distance
                }

                function zd(t, e, n, i) {
                    if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
                        const i = t.children;
                        for (let t = 0, r = i.length; t < r; t++) zd(i[t], e, n, !0)
                    }
                }
                class Gd {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return this.radius = t, this.phi = e, this.theta = n, this
                    }
                    set(t, e, n) {
                        return this.radius = t, this.phi = e, this.theta = n, this
                    }
                    copy(t) {
                        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                    }
                    makeSafe() {
                        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                    }
                    setFromVector3(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    }
                    setFromCartesianCoords(t, e, n) {
                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(zn(e / this.radius, -1, 1))), this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                class Hd {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return this.radius = t, this.theta = e, this.y = n, this
                    }
                    set(t, e, n) {
                        return this.radius = t, this.theta = e, this.y = n, this
                    }
                    copy(t) {
                        return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
                    }
                    setFromVector3(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    }
                    setFromCartesianCoords(t, e, n) {
                        return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                const Wd = new Qn;
                class Yd {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Qn(1 / 0, 1 / 0),
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Qn(-1 / 0, -1 / 0);
                        this.min = t, this.max = e
                    }
                    set(t, e) {
                        return this.min.copy(t), this.max.copy(e), this
                    }
                    setFromPoints(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                        return this
                    }
                    setFromCenterAndSize(t, e) {
                        const n = Wd.copy(e).multiplyScalar(.5);
                        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    }
                    getCenter(t) {
                        return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new Qn), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(t) {
                        return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new Qn), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                    }
                    expandByPoint(t) {
                        return this.min.min(t), this.max.max(t), this
                    }
                    expandByVector(t) {
                        return this.min.sub(t), this.max.add(t), this
                    }
                    expandByScalar(t) {
                        return this.min.addScalar(-t), this.max.addScalar(t), this
                    }
                    containsPoint(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                    }
                    containsBox(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                    }
                    getParameter(t, e) {
                        return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new Qn), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                    }
                    intersectsBox(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                    }
                    clampPoint(t, e) {
                        return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new Qn), e.copy(t).clamp(this.min, this.max)
                    }
                    distanceToPoint(t) {
                        return Wd.copy(t).clamp(this.min, this.max).sub(t).length()
                    }
                    intersect(t) {
                        return this.min.max(t.min), this.max.min(t.max), this
                    }
                    union(t) {
                        return this.min.min(t.min), this.max.max(t.max), this
                    }
                    translate(t) {
                        return this.min.add(t), this.max.add(t), this
                    }
                    equals(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }
                Yd.prototype.isBox2 = !0;
                const Xd = new ai,
                    qd = new ai;
                class Qd {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ai,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ai;
                        this.start = t, this.end = e
                    }
                    set(t, e) {
                        return this.start.copy(t), this.end.copy(e), this
                    }
                    copy(t) {
                        return this.start.copy(t.start), this.end.copy(t.end), this
                    }
                    getCenter(t) {
                        return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new ai), t.addVectors(this.start, this.end).multiplyScalar(.5)
                    }
                    delta(t) {
                        return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new ai), t.subVectors(this.end, this.start)
                    }
                    distanceSq() {
                        return this.start.distanceToSquared(this.end)
                    }
                    distance() {
                        return this.start.distanceTo(this.end)
                    }
                    at(t, e) {
                        return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new ai), this.delta(e).multiplyScalar(t).add(this.start)
                    }
                    closestPointToPointParameter(t, e) {
                        Xd.subVectors(t, this.start), qd.subVectors(this.end, this.start);
                        const n = qd.dot(qd);
                        let i = qd.dot(Xd) / n;
                        return e && (i = zn(i, 0, 1)), i
                    }
                    closestPointToPoint(t, e, n) {
                        const i = this.closestPointToPointParameter(t, e);
                        return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new ai), this.delta(n).multiplyScalar(i).add(this.start)
                    }
                    applyMatrix4(t) {
                        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                    }
                    equals(t) {
                        return t.start.equals(this.start) && t.end.equals(this.end)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                class Zd extends cr {
                    constructor(t) {
                        super(), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
                    }
                }
                Zd.prototype.isImmediateRenderObject = !0;
                const Jd = new ai;
                class Kd extends cr {
                    constructor(t, e) {
                        super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                        const n = new ro,
                            i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                        for (let o = 0, s = 1, a = 32; o < a; o++, s++) {
                            const t = o / a * Math.PI * 2,
                                e = s / a * Math.PI * 2;
                            i.push(Math.cos(t), Math.sin(t), 1, Math.cos(e), Math.sin(e), 1)
                        }
                        n.setAttribute("position", new Yr(i, 3));
                        const r = new Xl({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.cone = new nc(n, r), this.add(this.cone), this.update()
                    }
                    dispose() {
                        this.cone.geometry.dispose(), this.cone.material.dispose()
                    }
                    update() {
                        this.light.updateMatrixWorld();
                        const t = this.light.distance ? this.light.distance : 1e3,
                            e = t * Math.tan(this.light.angle);
                        this.cone.scale.set(e, e, t), Jd.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Jd), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }
                const $d = new ai,
                    tp = new Vi,
                    ep = new Vi;
                class np extends nc {
                    constructor(t) {
                        const e = function t(e) {
                                const n = [];
                                e && e.isBone && n.push(e);
                                for (let i = 0; i < e.children.length; i++) n.push.apply(n, t(e.children[i]));
                                return n
                            }(t),
                            n = new ro,
                            i = [],
                            r = [],
                            o = new Fr(0, 0, 1),
                            s = new Fr(0, 1, 0);
                        for (let a = 0; a < e.length; a++) {
                            const t = e[a];
                            t.parent && t.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(s.r, s.g, s.b))
                        }
                        n.setAttribute("position", new Yr(i, 3)), n.setAttribute("color", new Yr(r, 3)), super(n, new Xl({
                            vertexColors: !0,
                            depthTest: !1,
                            depthWrite: !1,
                            toneMapped: !1,
                            transparent: !0
                        })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                    }
                    updateMatrixWorld(t) {
                        const e = this.bones,
                            n = this.geometry,
                            i = n.getAttribute("position");
                        ep.copy(this.root.matrixWorld).invert();
                        for (let r = 0, o = 0; r < e.length; r++) {
                            const t = e[r];
                            t.parent && t.parent.isBone && (tp.multiplyMatrices(ep, t.matrixWorld), $d.setFromMatrixPosition(tp), i.setXYZ(o, $d.x, $d.y, $d.z), tp.multiplyMatrices(ep, t.parent.matrixWorld), $d.setFromMatrixPosition(tp), i.setXYZ(o + 1, $d.x, $d.y, $d.z), o += 2)
                        }
                        n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                    }
                }
                class ip extends So {
                    constructor(t, e, n) {
                        super(new ah(e, 4, 2), new Or({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        })), this.light = t, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                    update() {
                        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                    }
                }
                const rp = new ai,
                    op = new Fr,
                    sp = new Fr;
                class ap extends cr {
                    constructor(t, e, n) {
                        super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                        const i = new ih(e);
                        i.rotateY(.5 * Math.PI), this.material = new Or({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        }), void 0 === this.color && (this.material.vertexColors = !0);
                        const r = i.getAttribute("position"),
                            o = new Float32Array(3 * r.count);
                        i.setAttribute("color", new Dr(o, 3)), this.add(new So(i, this.material)), this.update()
                    }
                    dispose() {
                        this.children[0].geometry.dispose(), this.children[0].material.dispose()
                    }
                    update() {
                        const t = this.children[0];
                        if (void 0 !== this.color) this.material.color.set(this.color);
                        else {
                            const e = t.geometry.getAttribute("color");
                            op.copy(this.light.color), sp.copy(this.light.groundColor);
                            for (let t = 0, n = e.count; t < n; t++) {
                                const i = t < n / 2 ? op : sp;
                                e.setXYZ(t, i.r, i.g, i.b)
                            }
                            e.needsUpdate = !0
                        }
                        t.lookAt(rp.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }
                class lp extends nc {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 4473924,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8947848;
                        n = new Fr(n), i = new Fr(i);
                        const r = e / 2,
                            o = t / e,
                            s = t / 2,
                            a = [],
                            l = [];
                        for (let h = 0, u = 0, d = -s; h <= e; h++, d += o) {
                            a.push(-s, 0, d, s, 0, d), a.push(d, 0, -s, d, 0, s);
                            const t = h === r ? n : i;
                            t.toArray(l, u), u += 3, t.toArray(l, u), u += 3, t.toArray(l, u), u += 3, t.toArray(l, u), u += 3
                        }
                        const c = new ro;
                        c.setAttribute("position", new Yr(a, 3)), c.setAttribute("color", new Yr(l, 3)), super(c, new Xl({
                            vertexColors: !0,
                            toneMapped: !1
                        })), this.type = "GridHelper"
                    }
                }
                class cp extends nc {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10,
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 64,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 4473924,
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 8947848;
                        r = new Fr(r), o = new Fr(o);
                        const s = [],
                            a = [];
                        for (let c = 0; c <= e; c++) {
                            const n = c / e * (2 * Math.PI),
                                i = Math.sin(n) * t,
                                l = Math.cos(n) * t;
                            s.push(0, 0, 0), s.push(i, 0, l);
                            const h = 1 & c ? r : o;
                            a.push(h.r, h.g, h.b), a.push(h.r, h.g, h.b)
                        }
                        for (let c = 0; c <= n; c++) {
                            const e = 1 & c ? r : o,
                                l = t - t / n * c;
                            for (let t = 0; t < i; t++) {
                                let n = t / i * (2 * Math.PI),
                                    r = Math.sin(n) * l,
                                    o = Math.cos(n) * l;
                                s.push(r, 0, o), a.push(e.r, e.g, e.b), n = (t + 1) / i * (2 * Math.PI), r = Math.sin(n) * l, o = Math.cos(n) * l, s.push(r, 0, o), a.push(e.r, e.g, e.b)
                            }
                        }
                        const l = new ro;
                        l.setAttribute("position", new Yr(s, 3)), l.setAttribute("color", new Yr(a, 3)), super(l, new Xl({
                            vertexColors: !0,
                            toneMapped: !1
                        })), this.type = "PolarGridHelper"
                    }
                }
                const hp = new ai,
                    up = new ai,
                    dp = new ai;
                class pp extends cr {
                    constructor(t, e, n) {
                        super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
                        let i = new ro;
                        i.setAttribute("position", new Yr([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                        const r = new Xl({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.lightPlane = new $l(i, r), this.add(this.lightPlane), i = new ro, i.setAttribute("position", new Yr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new $l(i, r), this.add(this.targetLine), this.update()
                    }
                    dispose() {
                        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                    }
                    update() {
                        hp.setFromMatrixPosition(this.light.matrixWorld), up.setFromMatrixPosition(this.light.target.matrixWorld), dp.subVectors(up, hp), this.lightPlane.lookAt(up), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(up), this.targetLine.scale.z = dp.length()
                    }
                }
                const fp = new ai,
                    mp = new Io;
                class gp extends nc {
                    constructor(t) {
                        const e = new ro,
                            n = new Xl({
                                color: 16777215,
                                vertexColors: !0,
                                toneMapped: !1
                            }),
                            i = [],
                            r = [],
                            o = {},
                            s = new Fr(16755200),
                            a = new Fr(16711680),
                            l = new Fr(43775),
                            c = new Fr(16777215),
                            h = new Fr(3355443);

                        function u(t, e, n) {
                            d(t, n), d(e, n)
                        }

                        function d(t, e) {
                            i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(i.length / 3 - 1)
                        }
                        u("n1", "n2", s), u("n2", "n4", s), u("n4", "n3", s), u("n3", "n1", s), u("f1", "f2", s), u("f2", "f4", s), u("f4", "f3", s), u("f3", "f1", s), u("n1", "f1", s), u("n2", "f2", s), u("n3", "f3", s), u("n4", "f4", s), u("p", "n1", a), u("p", "n2", a), u("p", "n3", a), u("p", "n4", a), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.setAttribute("position", new Yr(i, 3)), e.setAttribute("color", new Yr(r, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
                    }
                    update() {
                        const t = this.geometry,
                            e = this.pointMap;
                        mp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), vp("c", e, t, mp, 0, 0, -1), vp("t", e, t, mp, 0, 0, 1), vp("n1", e, t, mp, -1, -1, -1), vp("n2", e, t, mp, 1, -1, -1), vp("n3", e, t, mp, -1, 1, -1), vp("n4", e, t, mp, 1, 1, -1), vp("f1", e, t, mp, -1, -1, 1), vp("f2", e, t, mp, 1, -1, 1), vp("f3", e, t, mp, -1, 1, 1), vp("f4", e, t, mp, 1, 1, 1), vp("u1", e, t, mp, .7, 1.1, -1), vp("u2", e, t, mp, -.7, 1.1, -1), vp("u3", e, t, mp, 0, 2, -1), vp("cf1", e, t, mp, -1, 0, 1), vp("cf2", e, t, mp, 1, 0, 1), vp("cf3", e, t, mp, 0, -1, 1), vp("cf4", e, t, mp, 0, 1, 1), vp("cn1", e, t, mp, -1, 0, -1), vp("cn2", e, t, mp, 1, 0, -1), vp("cn3", e, t, mp, 0, -1, -1), vp("cn4", e, t, mp, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                }

                function vp(t, e, n, i, r, o, s) {
                    fp.set(r, o, s).unproject(i);
                    const a = e[t];
                    if (void 0 !== a) {
                        const t = n.getAttribute("position");
                        for (let e = 0, n = a.length; e < n; e++) t.setXYZ(a[e], fp.x, fp.y, fp.z)
                    }
                }
                const yp = new hi;
                class xp extends nc {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16776960;
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                            i = new Float32Array(24),
                            r = new ro;
                        r.setIndex(new Dr(n, 1)), r.setAttribute("position", new Dr(i, 3)), super(r, new Xl({
                            color: e,
                            toneMapped: !1
                        })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
                    }
                    update(t) {
                        if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && yp.setFromObject(this.object), yp.isEmpty()) return;
                        const e = yp.min,
                            n = yp.max,
                            i = this.geometry.attributes.position,
                            r = i.array;
                        r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
                    }
                    setFromObject(t) {
                        return this.object = t, this.update(), this
                    }
                    copy(t) {
                        return nc.prototype.copy.call(this, t), this.object = t.object, this
                    }
                }
                class bp extends nc {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16776960;
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                            i = new ro;
                        i.setIndex(new Dr(n, 1)), i.setAttribute("position", new Yr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(i, new Xl({
                            color: e,
                            toneMapped: !1
                        })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                    }
                    updateMatrixWorld(t) {
                        const e = this.box;
                        e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(t))
                    }
                }
                class wp extends $l {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 16776960,
                            i = new ro;
                        i.setAttribute("position", new Yr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), super(i, new Xl({
                            color: n,
                            toneMapped: !1
                        })), this.type = "PlaneHelper", this.plane = t, this.size = e;
                        const r = new ro;
                        r.setAttribute("position", new Yr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), r.computeBoundingSphere(), this.add(new So(r, new Or({
                            color: n,
                            opacity: .2,
                            transparent: !0,
                            depthWrite: !1,
                            toneMapped: !1
                        })))
                    }
                    updateMatrixWorld(t) {
                        let e = -this.plane.constant;
                        Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? m : f, this.lookAt(this.plane.normal), super.updateMatrixWorld(t)
                    }
                }
                const _p = new ai;
                let Sp, Mp;
                class Ap extends cr {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ai(0, 0, 1),
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ai(0, 0, 0),
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 16776960,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .2 * n,
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : .2 * r;
                        super(), this.type = "ArrowHelper", void 0 === Sp && (Sp = new ro, Sp.setAttribute("position", new Yr([0, 0, 0, 0, 1, 0], 3)), Mp = new gc(0, .5, 1, 5, 1), Mp.translate(0, -.5, 0)), this.position.copy(e), this.line = new $l(Sp, new Xl({
                            color: i,
                            toneMapped: !1
                        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new So(Mp, new Or({
                            color: i,
                            toneMapped: !1
                        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, o)
                    }
                    setDirection(t) {
                        if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);
                        else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                        else {
                            _p.set(t.z, 0, -t.x).normalize();
                            const e = Math.acos(t.y);
                            this.quaternion.setFromAxisAngle(_p, e)
                        }
                    }
                    setLength(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .2 * t,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .2 * e;
                        this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
                    }
                    setColor(t) {
                        this.line.material.color.set(t), this.cone.material.color.set(t)
                    }
                    copy(t) {
                        return super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
                    }
                }
                class Tp extends nc {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                        const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                            n = new ro;
                        n.setAttribute("position", new Yr(e, 3)), n.setAttribute("color", new Yr([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new Xl({
                            vertexColors: !0,
                            toneMapped: !1
                        })), this.type = "AxesHelper"
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                }
                const Ep = new Float32Array(1),
                    Cp = new Int32Array(Ep.buffer);
                class Pp {
                    static toHalfFloat(t) {
                        Ep[0] = t;
                        const e = Cp[0];
                        let n = e >> 16 & 32768,
                            i = e >> 12 & 2047;
                        const r = e >> 23 & 255;
                        return r < 103 ? n : r > 142 ? (n |= 31744, n |= (255 == r ? 0 : 1) && 8388607 & e, n) : r < 113 ? (i |= 2048, n |= (i >> 114 - r) + (i >> 113 - r & 1), n) : (n |= r - 112 << 10 | i >> 1, n += 1 & i, n)
                    }
                }
                const Lp = 4,
                    Rp = 8,
                    Ip = Math.pow(2, Rp),
                    Fp = [.125, .215, .35, .446, .526, .582],
                    Op = Rp - Lp + 1 + Fp.length,
                    Np = 20,
                    Bp = {
                        [Ze]: 0,
                        [Je]: 1,
                        [$e]: 2,
                        [en]: 3,
                        [nn]: 4,
                        [rn]: 5,
                        [Ke]: 6
                    },
                    Dp = new Or({
                        side: m,
                        depthWrite: !1,
                        depthTest: !1
                    }),
                    Vp = new So(new Ao, Dp),
                    jp = new Nu,
                    {
                        _lodPlanes: kp,
                        _sizeLods: Up,
                        _sigmas: zp
                    } = Jp(),
                    Gp = new Fr;
                let Hp = null;
                const Wp = (1 + Math.sqrt(5)) / 2,
                    Yp = 1 / Wp,
                    Xp = [new ai(1, 1, 1), new ai(-1, 1, 1), new ai(1, 1, -1), new ai(-1, 1, -1), new ai(0, Wp, Yp), new ai(0, Wp, -Yp), new ai(Yp, 0, Wp), new ai(-Yp, 0, Wp), new ai(Wp, Yp, 0), new ai(-Wp, Yp, 0)];

                function qp(t) {
                    const e = Math.max(t.r, t.g, t.b),
                        n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
                    return t.multiplyScalar(Math.pow(2, -n)), (n + 128) / 255
                }
                class Qp {
                    constructor(t) {
                        this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function(t) {
                            const e = new Float32Array(t),
                                n = new ai(0, 1, 0);
                            return new gh({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: t
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: e
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: n
                                    },
                                    inputEncoding: {
                                        value: Bp[Ze]
                                    },
                                    outputEncoding: {
                                        value: Bp[Ze]
                                    }
                                },
                                vertexShader: nf(),
                                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t".concat(rf(), "\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),
                                blending: x,
                                depthTest: !1,
                                depthWrite: !1
                            })
                        }(Np), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                    }
                    fromScene(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 100;
                        Hp = this._renderer.getRenderTarget();
                        const r = this._allocateTargets();
                        return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
                    }
                    fromEquirectangular(t) {
                        return this._fromTexture(t)
                    }
                    fromCubemap(t) {
                        return this._fromTexture(t)
                    }
                    compileCubemapShader() {
                        null === this._cubemapShader && (this._cubemapShader = ef(), this._compileMaterial(this._cubemapShader))
                    }
                    compileEquirectangularShader() {
                        null === this._equirectShader && (this._equirectShader = tf(), this._compileMaterial(this._equirectShader))
                    }
                    dispose() {
                        this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
                        for (let t = 0; t < kp.length; t++) kp[t].dispose()
                    }
                    _cleanup(t) {
                        this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Hp), t.scissorTest = !1, $p(t, 0, 0, t.width, t.height)
                    }
                    _fromTexture(t) {
                        Hp = this._renderer.getRenderTarget();
                        const e = this._allocateTargets(t);
                        return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
                    }
                    _allocateTargets(t) {
                        const e = {
                                magFilter: ft,
                                minFilter: ft,
                                generateMipmaps: !1,
                                type: Mt,
                                format: Ut,
                                encoding: Zp(t) ? t.encoding : $e,
                                depthBuffer: !1
                            },
                            n = Kp(e);
                        return n.depthBuffer = !t, this._pingPongRenderTarget = Kp(e), n
                    }
                    _compileMaterial(t) {
                        const e = new So(kp[0], t);
                        this._renderer.compile(e, jp)
                    }
                    _sceneToCubeUV(t, e, n, i) {
                        const r = new Fo(90, 1, e, n),
                            o = [1, -1, 1, 1, 1, 1],
                            s = [1, 1, 1, -1, -1, -1],
                            a = this._renderer,
                            l = a.autoClear,
                            c = a.outputEncoding,
                            h = a.toneMapping;
                        a.getClearColor(Gp), a.toneMapping = K, a.outputEncoding = Ze, a.autoClear = !1;
                        let u = !1;
                        const d = t.background;
                        if (d) {
                            if (d.isColor) {
                                Dp.color.copy(d).convertSRGBToLinear(), t.background = null;
                                const e = qp(Dp.color);
                                Dp.opacity = e, u = !0
                            }
                        } else {
                            Dp.color.copy(Gp).convertSRGBToLinear();
                            const t = qp(Dp.color);
                            Dp.opacity = t, u = !0
                        }
                        for (let p = 0; p < 6; p++) {
                            const e = p % 3;
                            0 == e ? (r.up.set(0, o[p], 0), r.lookAt(s[p], 0, 0)) : 1 == e ? (r.up.set(0, 0, o[p]), r.lookAt(0, s[p], 0)) : (r.up.set(0, o[p], 0), r.lookAt(0, 0, s[p])), $p(i, e * Ip, p > 2 ? Ip : 0, Ip, Ip), a.setRenderTarget(i), u && a.render(Vp, r), a.render(t, r)
                        }
                        a.toneMapping = h, a.outputEncoding = c, a.autoClear = l
                    }
                    _textureToCubeUV(t, e) {
                        const n = this._renderer;
                        t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = ef()) : null == this._equirectShader && (this._equirectShader = tf());
                        const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
                            r = new So(kp[0], i),
                            o = i.uniforms;
                        o.envMap.value = t, t.isCubeTexture || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height), o.inputEncoding.value = Bp[t.encoding], o.outputEncoding.value = Bp[e.texture.encoding], $p(e, 0, 0, 3 * Ip, 2 * Ip), n.setRenderTarget(e), n.render(r, jp)
                    }
                    _applyPMREM(t) {
                        const e = this._renderer,
                            n = e.autoClear;
                        e.autoClear = !1;
                        for (let i = 1; i < Op; i++) {
                            const e = Math.sqrt(zp[i] * zp[i] - zp[i - 1] * zp[i - 1]),
                                n = Xp[(i - 1) % Xp.length];
                            this._blur(t, i - 1, i, e, n)
                        }
                        e.autoClear = n
                    }
                    _blur(t, e, n, i, r) {
                        const o = this._pingPongRenderTarget;
                        this._halfBlur(t, o, e, n, i, "latitudinal", r), this._halfBlur(o, t, n, n, i, "longitudinal", r)
                    }
                    _halfBlur(t, e, n, i, r, o, s) {
                        const a = this._renderer,
                            l = this._blurMaterial;
                        "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
                        const c = new So(kp[i], l),
                            h = l.uniforms,
                            u = Up[n] - 1,
                            d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / (2 * Np - 1),
                            p = r / d,
                            f = isFinite(r) ? 1 + Math.floor(3 * p) : Np;
                        f > Np && console.warn("sigmaRadians, ".concat(r, ", is too large and will clip, as it requested ").concat(f, " samples when the maximum is set to ").concat(Np));
                        const m = [];
                        let g = 0;
                        for (let y = 0; y < Np; ++y) {
                            const t = y / p,
                                e = Math.exp(-t * t / 2);
                            m.push(e), 0 == y ? g += e : y < f && (g += 2 * e)
                        }
                        for (let y = 0; y < m.length; y++) m[y] = m[y] / g;
                        h.envMap.value = t.texture, h.samples.value = f, h.weights.value = m, h.latitudinal.value = "latitudinal" === o, s && (h.poleAxis.value = s), h.dTheta.value = d, h.mipInt.value = Rp - n, h.inputEncoding.value = Bp[t.texture.encoding], h.outputEncoding.value = Bp[t.texture.encoding];
                        const v = Up[i];
                        $p(e, 3 * Math.max(0, Ip - 2 * v), (0 === i ? 0 : 2 * Ip) + 2 * v * (i > Rp - Lp ? i - Rp + Lp : 0), 3 * v, 2 * v), a.setRenderTarget(e), a.render(c, jp)
                    }
                }

                function Zp(t) {
                    return void 0 !== t && t.type === Mt && (t.encoding === Ze || t.encoding === Je || t.encoding === Ke)
                }

                function Jp() {
                    const t = [],
                        e = [],
                        n = [];
                    let i = Rp;
                    for (let r = 0; r < Op; r++) {
                        const o = Math.pow(2, i);
                        e.push(o);
                        let s = 1 / o;
                        r > Rp - Lp ? s = Fp[r - Rp + Lp - 1] : 0 == r && (s = 0), n.push(s);
                        const a = 1 / (o - 1),
                            l = -a / 2,
                            c = 1 + a / 2,
                            h = [l, l, c, l, c, c, l, l, c, c, l, c],
                            u = 6,
                            d = 6,
                            p = 3,
                            f = 2,
                            m = 1,
                            g = new Float32Array(p * d * u),
                            v = new Float32Array(f * d * u),
                            y = new Float32Array(m * d * u);
                        for (let t = 0; t < u; t++) {
                            const e = t % 3 * 2 / 3 - 1,
                                n = t > 2 ? 0 : -1,
                                i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                            g.set(i, p * d * t), v.set(h, f * d * t);
                            const r = [t, t, t, t, t, t];
                            y.set(r, m * d * t)
                        }
                        const x = new ro;
                        x.setAttribute("position", new Dr(g, p)), x.setAttribute("uv", new Dr(v, f)), x.setAttribute("faceIndex", new Dr(y, m)), t.push(x), i > Lp && i--
                    }
                    return {
                        _lodPlanes: t,
                        _sizeLods: e,
                        _sigmas: n
                    }
                }

                function Kp(t) {
                    const e = new ii(3 * Ip, 3 * Ip, t);
                    return e.texture.mapping = ct, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
                }

                function $p(t, e, n, i, r) {
                    t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
                }

                function tf() {
                    const t = new Qn(1, 1);
                    return new gh({
                        name: "EquirectangularToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            texelSize: {
                                value: t
                            },
                            inputEncoding: {
                                value: Bp[Ze]
                            },
                            outputEncoding: {
                                value: Bp[Ze]
                            }
                        },
                        vertexShader: nf(),
                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t".concat(rf(), "\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),
                        blending: x,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }

                function ef() {
                    return new gh({
                        name: "CubemapToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            inputEncoding: {
                                value: Bp[Ze]
                            },
                            outputEncoding: {
                                value: Bp[Ze]
                            }
                        },
                        vertexShader: nf(),
                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t".concat(rf(), "\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),
                        blending: x,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }

                function nf() {
                    return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
                }

                function rf() {
                    return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
                }
                const of = 0,
                    sf = 1,
                    af = 0,
                    lf = 1,
                    cf = 2;

                function hf(t) {
                    return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
                }

                function uf() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                    return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
                        return t.slice()
                    }, t
                }

                function df(t, e) {
                    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new cc(t, e)
                }

                function pf(t) {
                    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Tl(t)
                }

                function ff(t, e) {
                    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new cc(t, e)
                }

                function mf(t) {
                    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new rc(t)
                }

                function gf(t) {
                    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new rc(t)
                }

                function vf(t) {
                    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new rc(t)
                }

                function yf(t, e, n) {
                    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new ai(t, e, n)
                }

                function xf(t, e) {
                    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new Dr(t, e).setUsage(Tn)
                }

                function bf(t, e) {
                    return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Vr(t, e)
                }

                function wf(t, e) {
                    return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new jr(t, e)
                }

                function _f(t, e) {
                    return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new kr(t, e)
                }

                function Sf(t, e) {
                    return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Ur(t, e)
                }

                function Mf(t, e) {
                    return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new zr(t, e)
                }

                function Af(t, e) {
                    return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Gr(t, e)
                }

                function Tf(t, e) {
                    return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Hr(t, e)
                }

                function Ef(t, e) {
                    return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Yr(t, e)
                }

                function Cf(t, e) {
                    return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Xr(t, e)
                }

                function Pf(t) {
                    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Tp(t)
                }

                function Lf(t, e) {
                    return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new xp(t, e)
                }

                function Rf(t, e) {
                    return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new nc(new Mc(t.geometry), new Xl({
                        color: void 0 !== e ? e : 16777215
                    }))
                }

                function If(t, e) {
                    return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new nc(new ph(t.geometry), new Xl({
                        color: void 0 !== e ? e : 16777215
                    }))
                }

                function Ff(t) {
                    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Yh(t)
                }

                function Of(t) {
                    return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Jh(t)
                }

                function Nf(t, e, n) {
                    return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new Vo(t, n)
                }

                function Bf() {
                    console.error("THREE.CanvasRenderer has been removed")
                }

                function Df() {
                    console.error("THREE.JSONLoader has been removed.")
                }
                $h.create = function(t, e) {
                    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create($h.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
                }, bu.prototype.fromPoints = function(t) {
                    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
                }, lp.prototype.setColors = function() {
                    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
                }, np.prototype.update = function() {
                    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
                }, Hh.prototype.extractUrlBase = function(t) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Gu.extractUrlBase(t)
                }, Hh.Handlers = {
                    add: function() {
                        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                    },
                    get: function() {
                        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                    }
                }, Yd.prototype.center = function(t) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
                }, Yd.prototype.empty = function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                }, Yd.prototype.isIntersectionBox = function(t) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                }, Yd.prototype.size = function(t) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
                }, hi.prototype.center = function(t) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                }, hi.prototype.empty = function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                }, hi.prototype.isIntersectionBox = function(t) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                }, hi.prototype.isIntersectionSphere = function(t) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                }, hi.prototype.size = function(t) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
                }, Pi.prototype.empty = function() {
                    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                }, Uo.prototype.setFromMatrix = function(t) {
                    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
                }, Qd.prototype.center = function(t) {
                    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                }, Zn.prototype.flattenToArrayOffset = function(t, e) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                }, Zn.prototype.multiplyVector3 = function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                }, Zn.prototype.multiplyVector3Array = function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                }, Zn.prototype.applyToBufferAttribute = function(t) {
                    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                }, Zn.prototype.applyToVector3Array = function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }, Zn.prototype.getInverse = function(t) {
                    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
                }, Vi.prototype.extractPosition = function(t) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
                }, Vi.prototype.flattenToArrayOffset = function(t, e) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                }, Vi.prototype.getPosition = function() {
                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new ai).setFromMatrixColumn(this, 3)
                }, Vi.prototype.setRotationFromQuaternion = function(t) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
                }, Vi.prototype.multiplyToArray = function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                }, Vi.prototype.multiplyVector3 = function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                }, Vi.prototype.multiplyVector4 = function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                }, Vi.prototype.multiplyVector3Array = function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                }, Vi.prototype.rotateAxis = function(t) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
                }, Vi.prototype.crossVector = function(t) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                }, Vi.prototype.translate = function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                }, Vi.prototype.rotateX = function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                }, Vi.prototype.rotateY = function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                }, Vi.prototype.rotateZ = function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                }, Vi.prototype.rotateByAxis = function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                }, Vi.prototype.applyToBufferAttribute = function(t) {
                    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                }, Vi.prototype.applyToVector3Array = function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                }, Vi.prototype.makeFrustum = function(t, e, n, i, r, o) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, o)
                }, Vi.prototype.getInverse = function(t) {
                    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
                }, pr.prototype.isIntersectionLine = function(t) {
                    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
                }, si.prototype.multiplyVector3 = function(t) {
                    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
                }, si.prototype.inverse = function() {
                    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
                }, Di.prototype.isIntersectionBox = function(t) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                }, Di.prototype.isIntersectionPlane = function(t) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
                }, Di.prototype.isIntersectionSphere = function(t) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                }, Mr.prototype.area = function() {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                }, Mr.prototype.barycoordFromPoint = function(t, e) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
                }, Mr.prototype.midpoint = function(t) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
                }, Mr.prototypenormal = function(t) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
                }, Mr.prototype.plane = function(t) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
                }, Mr.barycoordFromPoint = function(t, e, n, i, r) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Mr.getBarycoord(t, e, n, i, r)
                }, Mr.normal = function(t, e, n, i) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Mr.getNormal(t, e, n, i)
                }, wu.prototype.extractAllPoints = function(t) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
                }, wu.prototype.extrude = function(t) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new $c(this, t)
                }, wu.prototype.makeGeometry = function(t) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new sh(this, t)
                }, Qn.prototype.fromAttribute = function(t, e, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                }, Qn.prototype.distanceToManhattan = function(t) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                }, Qn.prototype.lengthManhattan = function() {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }, ai.prototype.setEulerFromRotationMatrix = function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                }, ai.prototype.setEulerFromQuaternion = function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                }, ai.prototype.getPositionFromMatrix = function(t) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
                }, ai.prototype.getScaleFromMatrix = function(t) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
                }, ai.prototype.getColumnFromMatrix = function(t, e) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                }, ai.prototype.applyProjection = function(t) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
                }, ai.prototype.fromAttribute = function(t, e, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                }, ai.prototype.distanceToManhattan = function(t) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                }, ai.prototype.lengthManhattan = function() {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }, ni.prototype.fromAttribute = function(t, e, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                }, ni.prototype.lengthManhattan = function() {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }, cr.prototype.getChildByName = function(t) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
                }, cr.prototype.renderDepth = function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                }, cr.prototype.translate = function(t, e) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
                }, cr.prototype.getWorldRotation = function() {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }, cr.prototype.applyMatrix = function(t) {
                    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
                }, Object.defineProperties(cr.prototype, {
                    eulerOrder: {
                        get: function() {
                            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                        },
                        set: function(t) {
                            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                        }
                    },
                    useQuaternion: {
                        get: function() {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        },
                        set: function() {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        }
                    }
                }), So.prototype.setDrawMode = function() {
                    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }, Object.defineProperties(So.prototype, {
                    drawMode: {
                        get: function() {
                            return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), Xe
                        },
                        set: function() {
                            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                        }
                    }
                }), Bl.prototype.initBones = function() {
                    console.error("THREE.SkinnedMesh: initBones() has been removed.")
                }, Fo.prototype.setLens = function(t, e) {
                    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
                }, Object.defineProperties(_u.prototype, {
                    onlyShadow: {
                        set: function() {
                            console.warn("THREE.Light: .onlyShadow has been removed.")
                        }
                    },
                    shadowCameraFov: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                        }
                    },
                    shadowCameraLeft: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                        }
                    },
                    shadowCameraRight: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                        }
                    },
                    shadowCameraTop: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                        }
                    },
                    shadowCameraBottom: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                        }
                    },
                    shadowCameraNear: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                        }
                    },
                    shadowCameraFar: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                        }
                    },
                    shadowCameraVisible: {
                        set: function() {
                            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                        }
                    },
                    shadowBias: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                        }
                    },
                    shadowDarkness: {
                        set: function() {
                            console.warn("THREE.Light: .shadowDarkness has been removed.")
                        }
                    },
                    shadowMapWidth: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                        }
                    },
                    shadowMapHeight: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                        }
                    }
                }), Object.defineProperties(Dr.prototype, {
                    length: {
                        get: function() {
                            return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                        }
                    },
                    dynamic: {
                        get: function() {
                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Tn
                        },
                        set: function() {
                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Tn)
                        }
                    }
                }), Dr.prototype.setDynamic = function(t) {
                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Tn : An), this
                }, Dr.prototype.copyIndicesArray = function() {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                }, Dr.prototype.setArray = function() {
                    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                }, ro.prototype.addIndex = function(t) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
                }, ro.prototype.addAttribute = function(t, e) {
                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Dr(arguments[1], arguments[2])))
                }, ro.prototype.addDrawCall = function(t, e, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
                }, ro.prototype.clearDrawCalls = function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                }, ro.prototype.computeOffsets = function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }, ro.prototype.removeAttribute = function(t) {
                    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
                }, ro.prototype.applyMatrix = function(t) {
                    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
                }, Object.defineProperties(ro.prototype, {
                    drawcalls: {
                        get: function() {
                            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                        }
                    },
                    offsets: {
                        get: function() {
                            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                        }
                    }
                }), cl.prototype.setDynamic = function(t) {
                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Tn : An), this
                }, cl.prototype.setArray = function() {
                    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                }, $c.prototype.getArrays = function() {
                    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
                }, $c.prototype.addShapeList = function() {
                    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
                }, $c.prototype.addShape = function() {
                    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
                }, ll.prototype.dispose = function() {
                    console.error("THREE.Scene: .dispose() has been removed.")
                }, Dd.prototype.onUpdate = function() {
                    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                }, Object.defineProperties(Tr.prototype, {
                    wrapAround: {
                        get: function() {
                            console.warn("THREE.Material: .wrapAround has been removed.")
                        },
                        set: function() {
                            console.warn("THREE.Material: .wrapAround has been removed.")
                        }
                    },
                    overdraw: {
                        get: function() {
                            console.warn("THREE.Material: .overdraw has been removed.")
                        },
                        set: function() {
                            console.warn("THREE.Material: .overdraw has been removed.")
                        }
                    },
                    wrapRGB: {
                        get: function() {
                            return console.warn("THREE.Material: .wrapRGB has been removed."), new Fr
                        }
                    },
                    shading: {
                        get: function() {
                            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                        },
                        set: function(t) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === v
                        }
                    },
                    stencilMask: {
                        get: function() {
                            return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                        },
                        set: function(t) {
                            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
                        }
                    }
                }), Object.defineProperties(Ro.prototype, {
                    derivatives: {
                        get: function() {
                            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                        },
                        set: function(t) {
                            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                        }
                    }
                }), rl.prototype.clearTarget = function(t, e, n, i) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
                }, rl.prototype.animate = function(t) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
                }, rl.prototype.getCurrentRenderTarget = function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                }, rl.prototype.getMaxAnisotropy = function() {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                }, rl.prototype.getPrecision = function() {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                }, rl.prototype.resetGLState = function() {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                }, rl.prototype.supportsFloatTextures = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                }, rl.prototype.supportsHalfFloatTextures = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                }, rl.prototype.supportsStandardDerivatives = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                }, rl.prototype.supportsCompressedTextureS3TC = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                }, rl.prototype.supportsCompressedTexturePVRTC = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                }, rl.prototype.supportsBlendMinMax = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                }, rl.prototype.supportsVertexTextures = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                }, rl.prototype.supportsInstancedArrays = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                }, rl.prototype.enableScissorTest = function(t) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
                }, rl.prototype.initMaterial = function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                }, rl.prototype.addPrePlugin = function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                }, rl.prototype.addPostPlugin = function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                }, rl.prototype.updateShadowMap = function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                }, rl.prototype.setFaceCulling = function() {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                }, rl.prototype.allocTextureUnit = function() {
                    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
                }, rl.prototype.setTexture = function() {
                    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
                }, rl.prototype.setTexture2D = function() {
                    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
                }, rl.prototype.setTextureCube = function() {
                    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
                }, rl.prototype.getActiveMipMapLevel = function() {
                    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
                }, Object.defineProperties(rl.prototype, {
                    shadowMapEnabled: {
                        get: function() {
                            return this.shadowMap.enabled
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                        }
                    },
                    shadowMapType: {
                        get: function() {
                            return this.shadowMap.type
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                        }
                    },
                    shadowMapCullFace: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    context: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                        }
                    },
                    vr: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                        }
                    },
                    gammaInput: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                        }
                    },
                    gammaOutput: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? Je : Ze
                        }
                    },
                    toneMappingWhitePoint: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                        }
                    }
                }), Object.defineProperties(qa.prototype, {
                    cullFace: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    renderReverseSided: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    renderSingleSided: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                        }
                    }
                }), Object.defineProperties(ii.prototype, {
                    wrapS: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                        }
                    },
                    wrapT: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                        }
                    },
                    magFilter: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                        }
                    },
                    minFilter: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                        }
                    },
                    anisotropy: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                        }
                    },
                    offset: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                        }
                    },
                    repeat: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                        }
                    },
                    format: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                        }
                    },
                    type: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                        }
                    },
                    generateMipmaps: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                        }
                    }
                }), vd.prototype.load = function(t) {
                    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                    const e = this;
                    return (new rd).load(t, (function(t) {
                        e.setBuffer(t)
                    })), this
                }, Sd.prototype.getData = function() {
                    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
                }, Bo.prototype.updateCubeMap = function(t, e) {
                    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
                }, Bo.prototype.clear = function(t, e, n, i) {
                    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i)
                }, Kn.crossOrigin = void 0, Kn.loadTexture = function(t, e, n, i) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    const r = new Kh;
                    r.setCrossOrigin(this.crossOrigin);
                    const o = r.load(t, n, void 0, i);
                    return e && (o.mapping = e), o
                }, Kn.loadTextureCube = function(t, e, n, i) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    const r = new Zh;
                    r.setCrossOrigin(this.crossOrigin);
                    const o = r.load(t, n, void 0, i);
                    return e && (o.mapping = e), o
                }, Kn.loadCompressedTexture = function() {
                    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                }, Kn.loadCompressedTextureCube = function() {
                    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                };
                const Vf = {
                    createMultiMaterialObject: function() {
                        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                    },
                    detach: function() {
                        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                    },
                    attach: function() {
                        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                    }
                };

                function jf() {
                    console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")
                }
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                    detail: {
                        revision: i
                    }
                })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = i)
            }, function(t, e, n) {
                var i;
                t.exports = function t(e, n, r) {
                    function o(a, l) {
                        if (!n[a]) {
                            if (!e[a]) {
                                if (!l && "function" == typeof i && i) return i(a, !0);
                                if (s) return s(a, !0);
                                throw new Error("Cannot find module '" + a + "'")
                            }
                            var c = n[a] = {
                                exports: {}
                            };
                            e[a][0].call(c.exports, (function(t) {
                                return o(e[a][1][t] || t)
                            }), c, c.exports, t, e, n, r)
                        }
                        return n[a].exports
                    }
                    for (var s = "function" == typeof i && i, a = 0; a < r.length; a++) o(r[a]);
                    return o
                }({
                    1: [function(t, e, n) {
                        e.exports = {
                            name: "cannon",
                            version: "0.6.2",
                            description: "A lightweight 3D physics engine written in JavaScript.",
                            homepage: "https://github.com/schteppe/cannon.js",
                            author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                            keywords: ["cannon.js", "cannon", "physics", "engine", "3d"],
                            main: "./src/Cannon.js",
                            engines: {
                                node: "*"
                            },
                            repository: {
                                type: "git",
                                url: "https://github.com/schteppe/cannon.js.git"
                            },
                            bugs: {
                                url: "https://github.com/schteppe/cannon.js/issues"
                            },
                            licenses: [{
                                type: "MIT"
                            }],
                            devDependencies: {
                                browserify: "*",
                                grunt: "^0.4.5",
                                "grunt-browserify": "^2.1.4",
                                "grunt-contrib-concat": "~0.1.3",
                                "grunt-contrib-jshint": "~0.1.1",
                                "grunt-contrib-nodeunit": "^0.4.1",
                                "grunt-contrib-uglify": "^0.5.1",
                                "grunt-contrib-yuidoc": "^0.5.2",
                                jshint: "latest",
                                nodeunit: "^0.9.0",
                                "uglify-js": "latest"
                            },
                            dependencies: {
                                typescript: "^3.7.4"
                            }
                        }
                    }, {}],
                    2: [function(t, e, n) {
                        e.exports = {
                            version: t("../package.json").version,
                            AABB: t("./collision/AABB"),
                            ArrayCollisionMatrix: t("./collision/ArrayCollisionMatrix"),
                            Body: t("./objects/Body"),
                            Box: t("./shapes/Box"),
                            Broadphase: t("./collision/Broadphase"),
                            Constraint: t("./constraints/Constraint"),
                            ContactEquation: t("./equations/ContactEquation"),
                            Narrowphase: t("./world/Narrowphase"),
                            ConeTwistConstraint: t("./constraints/ConeTwistConstraint"),
                            ContactMaterial: t("./material/ContactMaterial"),
                            ConvexPolyhedron: t("./shapes/ConvexPolyhedron"),
                            Cylinder: t("./shapes/Cylinder"),
                            DistanceConstraint: t("./constraints/DistanceConstraint"),
                            Equation: t("./equations/Equation"),
                            EventTarget: t("./utils/EventTarget"),
                            FrictionEquation: t("./equations/FrictionEquation"),
                            GSSolver: t("./solver/GSSolver"),
                            GridBroadphase: t("./collision/GridBroadphase"),
                            Heightfield: t("./shapes/Heightfield"),
                            HingeConstraint: t("./constraints/HingeConstraint"),
                            LockConstraint: t("./constraints/LockConstraint"),
                            Mat3: t("./math/Mat3"),
                            Material: t("./material/Material"),
                            NaiveBroadphase: t("./collision/NaiveBroadphase"),
                            ObjectCollisionMatrix: t("./collision/ObjectCollisionMatrix"),
                            Pool: t("./utils/Pool"),
                            Particle: t("./shapes/Particle"),
                            Plane: t("./shapes/Plane"),
                            PointToPointConstraint: t("./constraints/PointToPointConstraint"),
                            Quaternion: t("./math/Quaternion"),
                            Ray: t("./collision/Ray"),
                            RaycastVehicle: t("./objects/RaycastVehicle"),
                            RaycastResult: t("./collision/RaycastResult"),
                            RigidVehicle: t("./objects/RigidVehicle"),
                            RotationalEquation: t("./equations/RotationalEquation"),
                            RotationalMotorEquation: t("./equations/RotationalMotorEquation"),
                            SAPBroadphase: t("./collision/SAPBroadphase"),
                            SPHSystem: t("./objects/SPHSystem"),
                            Shape: t("./shapes/Shape"),
                            Solver: t("./solver/Solver"),
                            Sphere: t("./shapes/Sphere"),
                            SplitSolver: t("./solver/SplitSolver"),
                            Spring: t("./objects/Spring"),
                            Transform: t("./math/Transform"),
                            Trimesh: t("./shapes/Trimesh"),
                            Vec3: t("./math/Vec3"),
                            Vec3Pool: t("./utils/Vec3Pool"),
                            World: t("./world/World")
                        }
                    }, {
                        "../package.json": 1,
                        "./collision/AABB": 3,
                        "./collision/ArrayCollisionMatrix": 4,
                        "./collision/Broadphase": 5,
                        "./collision/GridBroadphase": 6,
                        "./collision/NaiveBroadphase": 7,
                        "./collision/ObjectCollisionMatrix": 8,
                        "./collision/Ray": 10,
                        "./collision/RaycastResult": 11,
                        "./collision/SAPBroadphase": 12,
                        "./constraints/ConeTwistConstraint": 13,
                        "./constraints/Constraint": 14,
                        "./constraints/DistanceConstraint": 15,
                        "./constraints/HingeConstraint": 16,
                        "./constraints/LockConstraint": 17,
                        "./constraints/PointToPointConstraint": 18,
                        "./equations/ContactEquation": 20,
                        "./equations/Equation": 21,
                        "./equations/FrictionEquation": 22,
                        "./equations/RotationalEquation": 23,
                        "./equations/RotationalMotorEquation": 24,
                        "./material/ContactMaterial": 25,
                        "./material/Material": 26,
                        "./math/Mat3": 28,
                        "./math/Quaternion": 29,
                        "./math/Transform": 30,
                        "./math/Vec3": 31,
                        "./objects/Body": 32,
                        "./objects/RaycastVehicle": 33,
                        "./objects/RigidVehicle": 34,
                        "./objects/SPHSystem": 35,
                        "./objects/Spring": 36,
                        "./shapes/Box": 38,
                        "./shapes/ConvexPolyhedron": 39,
                        "./shapes/Cylinder": 40,
                        "./shapes/Heightfield": 41,
                        "./shapes/Particle": 42,
                        "./shapes/Plane": 43,
                        "./shapes/Shape": 44,
                        "./shapes/Sphere": 45,
                        "./shapes/Trimesh": 46,
                        "./solver/GSSolver": 47,
                        "./solver/Solver": 48,
                        "./solver/SplitSolver": 49,
                        "./utils/EventTarget": 50,
                        "./utils/Pool": 52,
                        "./utils/Vec3Pool": 55,
                        "./world/Narrowphase": 56,
                        "./world/World": 57
                    }],
                    3: [function(t, e, n) {
                        var i = t("../math/Vec3");

                        function r(t) {
                            t = t || {}, this.lowerBound = new i, t.lowerBound && this.lowerBound.copy(t.lowerBound), this.upperBound = new i, t.upperBound && this.upperBound.copy(t.upperBound)
                        }
                        t("../utils/Utils"), e.exports = r;
                        var o = new i;
                        r.prototype.setFromPoints = function(t, e, n, i) {
                            var r = this.lowerBound,
                                s = this.upperBound,
                                a = n;
                            r.copy(t[0]), a && a.vmult(r, r), s.copy(r);
                            for (var l = 1; l < t.length; l++) {
                                var c = t[l];
                                a && (a.vmult(c, o), c = o), c.x > s.x && (s.x = c.x), c.x < r.x && (r.x = c.x), c.y > s.y && (s.y = c.y), c.y < r.y && (r.y = c.y), c.z > s.z && (s.z = c.z), c.z < r.z && (r.z = c.z)
                            }
                            return e && (e.vadd(r, r), e.vadd(s, s)), i && (r.x -= i, r.y -= i, r.z -= i, s.x += i, s.y += i, s.z += i), this
                        }, r.prototype.copy = function(t) {
                            return this.lowerBound.copy(t.lowerBound), this.upperBound.copy(t.upperBound), this
                        }, r.prototype.clone = function() {
                            return (new r).copy(this)
                        }, r.prototype.extend = function(t) {
                            this.lowerBound.x = Math.min(this.lowerBound.x, t.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, t.upperBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, t.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, t.upperBound.y), this.lowerBound.z = Math.min(this.lowerBound.z, t.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, t.upperBound.z)
                        }, r.prototype.overlaps = function(t) {
                            var e = this.lowerBound,
                                n = this.upperBound,
                                i = t.lowerBound,
                                r = t.upperBound,
                                o = i.x <= n.x && n.x <= r.x || e.x <= r.x && r.x <= n.x,
                                s = i.y <= n.y && n.y <= r.y || e.y <= r.y && r.y <= n.y,
                                a = i.z <= n.z && n.z <= r.z || e.z <= r.z && r.z <= n.z;
                            return o && s && a
                        }, r.prototype.volume = function() {
                            var t = this.lowerBound,
                                e = this.upperBound;
                            return (e.x - t.x) * (e.y - t.y) * (e.z - t.z)
                        }, r.prototype.contains = function(t) {
                            var e = this.lowerBound,
                                n = this.upperBound,
                                i = t.lowerBound,
                                r = t.upperBound;
                            return e.x <= i.x && n.x >= r.x && e.y <= i.y && n.y >= r.y && e.z <= i.z && n.z >= r.z
                        }, r.prototype.getCorners = function(t, e, n, i, r, o, s, a) {
                            var l = this.lowerBound,
                                c = this.upperBound;
                            t.copy(l), e.set(c.x, l.y, l.z), n.set(c.x, c.y, l.z), i.set(l.x, c.y, c.z), r.set(c.x, l.y, c.z), o.set(l.x, c.y, l.z), s.set(l.x, l.y, c.z), a.copy(c)
                        };
                        var s = [new i, new i, new i, new i, new i, new i, new i, new i];
                        r.prototype.toLocalFrame = function(t, e) {
                            var n = s,
                                i = n[0],
                                r = n[1],
                                o = n[2],
                                a = n[3],
                                l = n[4],
                                c = n[5],
                                h = n[6],
                                u = n[7];
                            this.getCorners(i, r, o, a, l, c, h, u);
                            for (var d = 0; 8 !== d; d++) {
                                var p = n[d];
                                t.pointToLocal(p, p)
                            }
                            return e.setFromPoints(n)
                        }, r.prototype.toWorldFrame = function(t, e) {
                            var n = s,
                                i = n[0],
                                r = n[1],
                                o = n[2],
                                a = n[3],
                                l = n[4],
                                c = n[5],
                                h = n[6],
                                u = n[7];
                            this.getCorners(i, r, o, a, l, c, h, u);
                            for (var d = 0; 8 !== d; d++) {
                                var p = n[d];
                                t.pointToWorld(p, p)
                            }
                            return e.setFromPoints(n)
                        }, r.prototype.overlapsRay = function(t) {
                            var e = 1 / t._direction.x,
                                n = 1 / t._direction.y,
                                i = 1 / t._direction.z,
                                r = (this.lowerBound.x - t.from.x) * e,
                                o = (this.upperBound.x - t.from.x) * e,
                                s = (this.lowerBound.y - t.from.y) * n,
                                a = (this.upperBound.y - t.from.y) * n,
                                l = (this.lowerBound.z - t.from.z) * i,
                                c = (this.upperBound.z - t.from.z) * i,
                                h = Math.max(Math.max(Math.min(r, o), Math.min(s, a)), Math.min(l, c)),
                                u = Math.min(Math.min(Math.max(r, o), Math.max(s, a)), Math.max(l, c));
                            return !(u < 0 || h > u)
                        }
                    }, {
                        "../math/Vec3": 31,
                        "../utils/Utils": 54
                    }],
                    4: [function(t, e, n) {
                        function i() {
                            this.matrix = []
                        }
                        e.exports = i, i.prototype.get = function(t, e) {
                            if (t = t.index, (e = e.index) > t) {
                                var n = e;
                                e = t, t = n
                            }
                            return this.matrix[(t * (t + 1) >> 1) + e - 1]
                        }, i.prototype.set = function(t, e, n) {
                            if (t = t.index, (e = e.index) > t) {
                                var i = e;
                                e = t, t = i
                            }
                            this.matrix[(t * (t + 1) >> 1) + e - 1] = n ? 1 : 0
                        }, i.prototype.reset = function() {
                            for (var t = 0, e = this.matrix.length; t !== e; t++) this.matrix[t] = 0
                        }, i.prototype.setNumObjects = function(t) {
                            this.matrix.length = t * (t - 1) >> 1
                        }
                    }, {}],
                    5: [function(t, e, n) {
                        var i = t("../objects/Body"),
                            r = t("../math/Vec3"),
                            o = t("../math/Quaternion");

                        function s() {
                            this.world = null, this.useBoundingBoxes = !1, this.dirty = !0
                        }
                        t("../shapes/Shape"), t("../shapes/Plane"), e.exports = s, s.prototype.collisionPairs = function(t, e, n) {
                            throw new Error("collisionPairs not implemented for this BroadPhase class!")
                        }, s.prototype.needBroadphaseCollision = function(t, e) {
                            return 0 != (t.collisionFilterGroup & e.collisionFilterMask) && 0 != (e.collisionFilterGroup & t.collisionFilterMask) && (0 == (t.type & i.STATIC) && t.sleepState !== i.SLEEPING || 0 == (e.type & i.STATIC) && e.sleepState !== i.SLEEPING)
                        }, s.prototype.intersectionTest = function(t, e, n, i) {
                            this.useBoundingBoxes ? this.doBoundingBoxBroadphase(t, e, n, i) : this.doBoundingSphereBroadphase(t, e, n, i)
                        };
                        var a = new r;
                        new r, new o, new r, s.prototype.doBoundingSphereBroadphase = function(t, e, n, i) {
                            var r = a;
                            e.position.vsub(t.position, r);
                            var o = Math.pow(t.boundingRadius + e.boundingRadius, 2);
                            r.norm2() < o && (n.push(t), i.push(e))
                        }, s.prototype.doBoundingBoxBroadphase = function(t, e, n, i) {
                            t.aabbNeedsUpdate && t.computeAABB(), e.aabbNeedsUpdate && e.computeAABB(), t.aabb.overlaps(e.aabb) && (n.push(t), i.push(e))
                        };
                        var l = {
                                keys: []
                            },
                            c = [],
                            h = [];
                        s.prototype.makePairsUnique = function(t, e) {
                            for (var n = l, i = c, r = h, o = t.length, s = 0; s !== o; s++) i[s] = t[s], r[s] = e[s];
                            for (t.length = 0, e.length = 0, s = 0; s !== o; s++) {
                                var a = i[s].id,
                                    u = r[s].id;
                                n[d = a < u ? a + "," + u : u + "," + a] = s, n.keys.push(d)
                            }
                            for (s = 0; s !== n.keys.length; s++) {
                                var d = n.keys.pop(),
                                    p = n[d];
                                t.push(i[p]), e.push(r[p]), delete n[d]
                            }
                        }, s.prototype.setWorld = function(t) {};
                        var u = new r;
                        s.boundingSphereCheck = function(t, e) {
                            var n = u;
                            return t.position.vsub(e.position, n), Math.pow(t.shape.boundingSphereRadius + e.shape.boundingSphereRadius, 2) > n.norm2()
                        }, s.prototype.aabbQuery = function(t, e, n) {
                            return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), []
                        }
                    }, {
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../objects/Body": 32,
                        "../shapes/Plane": 43,
                        "../shapes/Shape": 44
                    }],
                    6: [function(t, e, n) {
                        e.exports = s;
                        var i = t("./Broadphase"),
                            r = t("../math/Vec3"),
                            o = t("../shapes/Shape");

                        function s(t, e, n, o, s) {
                            i.apply(this), this.nx = n || 10, this.ny = o || 10, this.nz = s || 10, this.aabbMin = t || new r(100, 100, 100), this.aabbMax = e || new r(-100, -100, -100);
                            var a = this.nx * this.ny * this.nz;
                            if (a <= 0) throw "GridBroadphase: Each dimension's n must be >0";
                            this.bins = [], this.binLengths = [], this.bins.length = a, this.binLengths.length = a;
                            for (var l = 0; l < a; l++) this.bins[l] = [], this.binLengths[l] = 0
                        }
                        s.prototype = new i, s.prototype.constructor = s;
                        var a = new r;
                        new r, s.prototype.collisionPairs = function(t, e, n) {
                            for (var i = t.numObjects(), r = t.bodies, s = this.aabbMax, l = this.aabbMin, c = this.nx, h = this.ny, u = this.nz, d = h * u, p = u, f = 1, m = s.x, g = s.y, v = s.z, y = l.x, x = l.y, b = l.z, w = c / (m - y), _ = h / (g - x), S = u / (v - b), M = (m - y) / c, A = (g - x) / h, T = (v - b) / u, E = .5 * Math.sqrt(M * M + A * A + T * T), C = o.types, P = C.SPHERE, L = C.PLANE, R = (C.BOX, C.COMPOUND, C.CONVEXPOLYHEDRON, this.bins), I = this.binLengths, F = this.bins.length, O = 0; O !== F; O++) I[O] = 0;
                            var N = Math.ceil;

                            function B(t, e, n, i, r, o, s) {
                                var a = (t - y) * w | 0,
                                    l = (e - x) * _ | 0,
                                    m = (n - b) * S | 0,
                                    g = N((i - y) * w),
                                    v = N((r - x) * _),
                                    M = N((o - b) * S);
                                a < 0 ? a = 0 : a >= c && (a = c - 1), l < 0 ? l = 0 : l >= h && (l = h - 1), m < 0 ? m = 0 : m >= u && (m = u - 1), g < 0 ? g = 0 : g >= c && (g = c - 1), v < 0 ? v = 0 : v >= h && (v = h - 1), M < 0 ? M = 0 : M >= u && (M = u - 1), l *= p, m *= f, g *= d, v *= p, M *= f;
                                for (var A = a *= d; A <= g; A += d)
                                    for (var T = l; T <= v; T += p)
                                        for (var E = m; E <= M; E += f) {
                                            var C = A + T + E;
                                            R[C][I[C]++] = s
                                        }
                            }
                            for (l = Math.min, s = Math.max, O = 0; O !== i; O++) {
                                var D = (nt = r[O]).shape;
                                switch (D.type) {
                                    case P:
                                        var V = nt.position.x,
                                            j = nt.position.y,
                                            k = nt.position.z,
                                            U = D.radius;
                                        B(V - U, j - U, k - U, V + U, j + U, k + U, nt);
                                        break;
                                    case L:
                                        D.worldNormalNeedsUpdate && D.computeWorldNormal(nt.quaternion);
                                        var z = D.worldNormal,
                                            G = y + .5 * M - nt.position.x,
                                            H = x + .5 * A - nt.position.y,
                                            W = b + .5 * T - nt.position.z,
                                            Y = a;
                                        Y.set(G, H, W);
                                        for (var X = 0, q = 0; X !== c; X++, q += d, Y.y = H, Y.x += M)
                                            for (var Q = 0, Z = 0; Q !== h; Q++, Z += p, Y.z = W, Y.y += A)
                                                for (var J = 0, K = 0; J !== u; J++, K += f, Y.z += T)
                                                    if (Y.dot(z) < E) {
                                                        var $ = q + Z + K;
                                                        R[$][I[$]++] = nt
                                                    }
                                        break;
                                    default:
                                        nt.aabbNeedsUpdate && nt.computeAABB(), B(nt.aabb.lowerBound.x, nt.aabb.lowerBound.y, nt.aabb.lowerBound.z, nt.aabb.upperBound.x, nt.aabb.upperBound.y, nt.aabb.upperBound.z, nt)
                                }
                            }
                            for (O = 0; O !== F; O++) {
                                var tt = I[O];
                                if (tt > 1) {
                                    var et = R[O];
                                    for (X = 0; X !== tt; X++) {
                                        var nt = et[X];
                                        for (Q = 0; Q !== X; Q++) {
                                            var it = et[Q];
                                            this.needBroadphaseCollision(nt, it) && this.intersectionTest(nt, it, e, n)
                                        }
                                    }
                                }
                            }
                            this.makePairsUnique(e, n)
                        }
                    }, {
                        "../math/Vec3": 31,
                        "../shapes/Shape": 44,
                        "./Broadphase": 5
                    }],
                    7: [function(t, e, n) {
                        e.exports = o;
                        var i = t("./Broadphase"),
                            r = t("./AABB");

                        function o() {
                            i.apply(this)
                        }
                        o.prototype = new i, o.prototype.constructor = o, o.prototype.collisionPairs = function(t, e, n) {
                            var i, r, o, s, a = t.bodies,
                                l = a.length;
                            for (i = 0; i !== l; i++)
                                for (r = 0; r !== i; r++) o = a[i], s = a[r], this.needBroadphaseCollision(o, s) && this.intersectionTest(o, s, e, n)
                        }, new r, o.prototype.aabbQuery = function(t, e, n) {
                            n = n || [];
                            for (var i = 0; i < t.bodies.length; i++) {
                                var r = t.bodies[i];
                                r.aabbNeedsUpdate && r.computeAABB(), r.aabb.overlaps(e) && n.push(r)
                            }
                            return n
                        }
                    }, {
                        "./AABB": 3,
                        "./Broadphase": 5
                    }],
                    8: [function(t, e, n) {
                        function i() {
                            this.matrix = {}
                        }
                        e.exports = i, i.prototype.get = function(t, e) {
                            if (t = t.id, (e = e.id) > t) {
                                var n = e;
                                e = t, t = n
                            }
                            return t + "-" + e in this.matrix
                        }, i.prototype.set = function(t, e, n) {
                            if (t = t.id, (e = e.id) > t) {
                                var i = e;
                                e = t, t = i
                            }
                            n ? this.matrix[t + "-" + e] = !0 : delete this.matrix[t + "-" + e]
                        }, i.prototype.reset = function() {
                            this.matrix = {}
                        }, i.prototype.setNumObjects = function(t) {}
                    }, {}],
                    9: [function(t, e, n) {
                        function i() {
                            this.current = [], this.previous = []
                        }

                        function r(t, e) {
                            t.push((4294901760 & e) >> 16, 65535 & e)
                        }
                        e.exports = i, i.prototype.getKey = function(t, e) {
                            if (e < t) {
                                var n = e;
                                e = t, t = n
                            }
                            return t << 16 | e
                        }, i.prototype.set = function(t, e) {
                            for (var n = this.getKey(t, e), i = this.current, r = 0; n > i[r];) r++;
                            if (n !== i[r]) {
                                for (e = i.length - 1; e >= r; e--) i[e + 1] = i[e];
                                i[r] = n
                            }
                        }, i.prototype.tick = function() {
                            var t = this.current;
                            this.current = this.previous, this.previous = t, this.current.length = 0
                        }, i.prototype.getDiff = function(t, e) {
                            for (var n = this.current, i = this.previous, o = n.length, s = i.length, a = 0, l = 0; l < o; l++) {
                                for (var c = n[l]; c > i[a];) a++;
                                c === i[a] || r(t, c)
                            }
                            for (a = 0, l = 0; l < s; l++) {
                                for (var h = i[l]; h > n[a];) a++;
                                n[a] === h || r(e, h)
                            }
                        }
                    }, {}],
                    10: [function(t, e, n) {
                        e.exports = c;
                        var i = t("../math/Vec3"),
                            r = t("../math/Quaternion"),
                            o = t("../math/Transform"),
                            s = (t("../shapes/ConvexPolyhedron"), t("../shapes/Box"), t("../collision/RaycastResult")),
                            a = t("../shapes/Shape"),
                            l = t("../collision/AABB");

                        function c(t, e) {
                            this.from = t ? t.clone() : new i, this.to = e ? e.clone() : new i, this._direction = new i, this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = c.ANY, this.result = new s, this.hasHit = !1, this.callback = function(t) {}
                        }
                        c.prototype.constructor = c, c.CLOSEST = 1, c.ANY = 2, c.ALL = 4;
                        var h = new l,
                            u = [];
                        c.prototype.intersectWorld = function(t, e) {
                            return this.mode = e.mode || c.ANY, this.result = e.result || new s, this.skipBackfaces = !!e.skipBackfaces, this.collisionFilterMask = void 0 !== e.collisionFilterMask ? e.collisionFilterMask : -1, this.collisionFilterGroup = void 0 !== e.collisionFilterGroup ? e.collisionFilterGroup : -1, e.from && this.from.copy(e.from), e.to && this.to.copy(e.to), this.callback = e.callback || function() {}, this.hasHit = !1, this.result.reset(), this._updateDirection(), this.getAABB(h), u.length = 0, t.broadphase.aabbQuery(t, h, u), this.intersectBodies(u), this.hasHit
                        };
                        var d = new i,
                            p = new i;

                        function f(t, e, n, i) {
                            i.vsub(e, D), n.vsub(e, d), t.vsub(e, p);
                            var r, o, s = D.dot(D),
                                a = D.dot(d),
                                l = D.dot(p),
                                c = d.dot(d),
                                h = d.dot(p);
                            return (r = c * l - a * h) >= 0 && (o = s * h - a * l) >= 0 && r + o < s * c - a * a
                        }
                        c.pointInTriangle = f;
                        var m = new i,
                            g = new r;
                        c.prototype.intersectBody = function(t, e) {
                            e && (this.result = e, this._updateDirection());
                            var n = this.checkCollisionResponse;
                            if ((!n || t.collisionResponse) && 0 != (this.collisionFilterGroup & t.collisionFilterMask) && 0 != (t.collisionFilterGroup & this.collisionFilterMask))
                                for (var i = m, r = g, o = 0, s = t.shapes.length; o < s; o++) {
                                    var a = t.shapes[o];
                                    if ((!n || a.collisionResponse) && 0 != (this.collisionFilterGroup & a.collisionFilterMask) && 0 != (a.collisionFilterGroup & this.collisionFilterMask) && (t.quaternion.mult(t.shapeOrientations[o], r), t.quaternion.vmult(t.shapeOffsets[o], i), i.vadd(t.position, i), this.intersectShape(a, r, i, t), this.result._shouldStop)) break
                                }
                        }, c.prototype.intersectBodies = function(t, e) {
                            e && (this.result = e, this._updateDirection());
                            for (var n = 0, i = t.length; !this.result._shouldStop && n < i; n++) this.intersectBody(t[n])
                        }, c.prototype._updateDirection = function() {
                            this.to.vsub(this.from, this._direction), this._direction.normalize()
                        }, c.prototype.intersectShape = function(t, e, n, i) {
                            if (!(function(t, e, n) {
                                    n.vsub(t, D);
                                    var i = D.dot(e);
                                    return e.mult(i, V), V.vadd(t, V), n.distanceTo(V)
                                }(this.from, this._direction, n) > t.boundingSphereRadius)) {
                                var r = this[t.type];
                                r && r.call(this, t, e, n, i, t)
                            }
                        }, new i, new i;
                        var v = new i,
                            y = new i,
                            x = new i,
                            b = new i;
                        new i, new s, c.prototype.intersectBox = function(t, e, n, i, r) {
                            return this.intersectConvex(t.convexPolyhedronRepresentation, e, n, i, r)
                        }, c.prototype[a.types.BOX] = c.prototype.intersectBox, c.prototype.intersectPlane = function(t, e, n, r, o) {
                            var s = this.from,
                                a = this.to,
                                l = this._direction,
                                c = new i(0, 0, 1);
                            e.vmult(c, c);
                            var h = new i;
                            s.vsub(n, h);
                            var u = h.dot(c);
                            if (a.vsub(n, h), !(u * h.dot(c) > 0 || s.distanceTo(a) < u)) {
                                var d = c.dot(l);
                                if (!(Math.abs(d) < this.precision)) {
                                    var p = new i,
                                        f = new i,
                                        m = new i;
                                    s.vsub(n, p);
                                    var g = -c.dot(p) / d;
                                    l.scale(g, f), s.vadd(f, m), this.reportIntersection(c, m, o, r, -1)
                                }
                            }
                        }, c.prototype[a.types.PLANE] = c.prototype.intersectPlane, c.prototype.getAABB = function(t) {
                            var e = this.to,
                                n = this.from;
                            t.lowerBound.x = Math.min(e.x, n.x), t.lowerBound.y = Math.min(e.y, n.y), t.lowerBound.z = Math.min(e.z, n.z), t.upperBound.x = Math.max(e.x, n.x), t.upperBound.y = Math.max(e.y, n.y), t.upperBound.z = Math.max(e.z, n.z)
                        };
                        var w = {
                                faceList: [0]
                            },
                            _ = new i,
                            S = new c,
                            M = [];
                        c.prototype.intersectHeightfield = function(t, e, n, i, r) {
                            t.data, t.elementSize;
                            var s = S;
                            s.from.copy(this.from), s.to.copy(this.to), o.pointToLocalFrame(n, e, s.from, s.from), o.pointToLocalFrame(n, e, s.to, s.to), s._updateDirection();
                            var a, c, h, u, d = M;
                            a = c = 0, h = u = t.data.length - 1;
                            var p = new l;
                            s.getAABB(p), t.getIndexOfPosition(p.lowerBound.x, p.lowerBound.y, d, !0), a = Math.max(a, d[0]), c = Math.max(c, d[1]), t.getIndexOfPosition(p.upperBound.x, p.upperBound.y, d, !0), h = Math.min(h, d[0] + 1), u = Math.min(u, d[1] + 1);
                            for (var f = a; f < h; f++)
                                for (var m = c; m < u; m++) {
                                    if (this.result._shouldStop) return;
                                    if (t.getAabbAtIndex(f, m, p), p.overlapsRay(s)) {
                                        if (t.getConvexTrianglePillar(f, m, !1), o.pointToWorldFrame(n, e, t.pillarOffset, _), this.intersectConvex(t.pillarConvex, e, _, i, r, w), this.result._shouldStop) return;
                                        t.getConvexTrianglePillar(f, m, !0), o.pointToWorldFrame(n, e, t.pillarOffset, _), this.intersectConvex(t.pillarConvex, e, _, i, r, w)
                                    }
                                }
                        }, c.prototype[a.types.HEIGHTFIELD] = c.prototype.intersectHeightfield;
                        var A = new i,
                            T = new i;
                        c.prototype.intersectSphere = function(t, e, n, i, r) {
                            var o = this.from,
                                s = this.to,
                                a = t.radius,
                                l = Math.pow(s.x - o.x, 2) + Math.pow(s.y - o.y, 2) + Math.pow(s.z - o.z, 2),
                                c = 2 * ((s.x - o.x) * (o.x - n.x) + (s.y - o.y) * (o.y - n.y) + (s.z - o.z) * (o.z - n.z)),
                                h = Math.pow(o.x - n.x, 2) + Math.pow(o.y - n.y, 2) + Math.pow(o.z - n.z, 2) - Math.pow(a, 2),
                                u = Math.pow(c, 2) - 4 * l * h,
                                d = A,
                                p = T;
                            if (!(u < 0))
                                if (0 === u) o.lerp(s, u, d), d.vsub(n, p), p.normalize(), this.reportIntersection(p, d, r, i, -1);
                                else {
                                    var f = (-c - Math.sqrt(u)) / (2 * l),
                                        m = (-c + Math.sqrt(u)) / (2 * l);
                                    if (f >= 0 && f <= 1 && (o.lerp(s, f, d), d.vsub(n, p), p.normalize(), this.reportIntersection(p, d, r, i, -1)), this.result._shouldStop) return;
                                    m >= 0 && m <= 1 && (o.lerp(s, m, d), d.vsub(n, p), p.normalize(), this.reportIntersection(p, d, r, i, -1))
                                }
                        }, c.prototype[a.types.SPHERE] = c.prototype.intersectSphere;
                        var E = new i,
                            C = (new i, new i, new i);
                        c.prototype.intersectConvex = function(t, e, n, i, r, o) {
                            for (var s = E, a = C, l = o && o.faceList || null, c = t.faces, h = t.vertices, u = t.faceNormals, d = this._direction, p = this.from, m = this.to, g = p.distanceTo(m), w = l ? l.length : c.length, _ = this.result, S = 0; !_._shouldStop && S < w; S++) {
                                var M = l ? l[S] : S,
                                    A = c[M],
                                    T = u[M],
                                    P = e,
                                    L = n;
                                a.copy(h[A[0]]), P.vmult(a, a), a.vadd(L, a), a.vsub(p, a), P.vmult(T, s);
                                var R = d.dot(s);
                                if (!(Math.abs(R) < this.precision)) {
                                    var I = s.dot(a) / R;
                                    if (!(I < 0)) {
                                        d.mult(I, v), v.vadd(p, v), y.copy(h[A[0]]), P.vmult(y, y), L.vadd(y, y);
                                        for (var F = 1; !_._shouldStop && F < A.length - 1; F++) {
                                            x.copy(h[A[F]]), b.copy(h[A[F + 1]]), P.vmult(x, x), P.vmult(b, b), L.vadd(x, x), L.vadd(b, b);
                                            var O = v.distanceTo(p);
                                            !f(v, y, x, b) && !f(v, x, y, b) || O > g || this.reportIntersection(s, v, r, i, M)
                                        }
                                    }
                                }
                            }
                        }, c.prototype[a.types.CONVEXPOLYHEDRON] = c.prototype.intersectConvex;
                        var P = new i,
                            L = new i,
                            R = new i,
                            I = new i,
                            F = new i,
                            O = new i,
                            N = (new l, []),
                            B = new o;
                        c.prototype.intersectTrimesh = function(t, e, n, i, r, s) {
                            var a = P,
                                l = N,
                                c = B,
                                h = C,
                                u = L,
                                d = R,
                                p = I,
                                m = O,
                                g = F,
                                w = (s && s.faceList, t.indices),
                                _ = (t.vertices, t.faceNormals, this.from),
                                S = this.to,
                                M = this._direction;
                            c.position.copy(n), c.quaternion.copy(e), o.vectorToLocalFrame(n, e, M, u), o.pointToLocalFrame(n, e, _, d), o.pointToLocalFrame(n, e, S, p), p.x *= t.scale.x, p.y *= t.scale.y, p.z *= t.scale.z, d.x *= t.scale.x, d.y *= t.scale.y, d.z *= t.scale.z, p.vsub(d, u), u.normalize();
                            var A = d.distanceSquared(p);
                            t.tree.rayQuery(this, c, l);
                            for (var T = 0, E = l.length; !this.result._shouldStop && T !== E; T++) {
                                var D = l[T];
                                t.getNormal(D, a), t.getVertex(w[3 * D], y), y.vsub(d, h);
                                var V = u.dot(a),
                                    j = a.dot(h) / V;
                                if (!(j < 0)) {
                                    u.scale(j, v), v.vadd(d, v), t.getVertex(w[3 * D + 1], x), t.getVertex(w[3 * D + 2], b);
                                    var k = v.distanceSquared(d);
                                    !f(v, x, y, b) && !f(v, y, x, b) || k > A || (o.vectorToWorldFrame(e, a, g), o.pointToWorldFrame(n, e, v, m), this.reportIntersection(g, m, r, i, D))
                                }
                            }
                            l.length = 0
                        }, c.prototype[a.types.TRIMESH] = c.prototype.intersectTrimesh, c.prototype.reportIntersection = function(t, e, n, i, r) {
                            var o = this.from,
                                s = this.to,
                                a = o.distanceTo(e),
                                l = this.result;
                            if (!(this.skipBackfaces && t.dot(this._direction) > 0)) switch (l.hitFaceIndex = void 0 !== r ? r : -1, this.mode) {
                                case c.ALL:
                                    this.hasHit = !0, l.set(o, s, t, e, n, i, a), l.hasHit = !0, this.callback(l);
                                    break;
                                case c.CLOSEST:
                                    (a < l.distance || !l.hasHit) && (this.hasHit = !0, l.hasHit = !0, l.set(o, s, t, e, n, i, a));
                                    break;
                                case c.ANY:
                                    this.hasHit = !0, l.hasHit = !0, l.set(o, s, t, e, n, i, a), l._shouldStop = !0
                            }
                        };
                        var D = new i,
                            V = new i
                    }, {
                        "../collision/AABB": 3,
                        "../collision/RaycastResult": 11,
                        "../math/Quaternion": 29,
                        "../math/Transform": 30,
                        "../math/Vec3": 31,
                        "../shapes/Box": 38,
                        "../shapes/ConvexPolyhedron": 39,
                        "../shapes/Shape": 44
                    }],
                    11: [function(t, e, n) {
                        var i = t("../math/Vec3");

                        function r() {
                            this.rayFromWorld = new i, this.rayToWorld = new i, this.hitNormalWorld = new i, this.hitPointWorld = new i, this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1
                        }
                        e.exports = r, r.prototype.reset = function() {
                            this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1
                        }, r.prototype.abort = function() {
                            this._shouldStop = !0
                        }, r.prototype.set = function(t, e, n, i, r, o, s) {
                            this.rayFromWorld.copy(t), this.rayToWorld.copy(e), this.hitNormalWorld.copy(n), this.hitPointWorld.copy(i), this.shape = r, this.body = o, this.distance = s
                        }
                    }, {
                        "../math/Vec3": 31
                    }],
                    12: [function(t, e, n) {
                        t("../shapes/Shape");
                        var i = t("../collision/Broadphase");

                        function r(t) {
                            i.apply(this), this.axisList = [], this.world = null, this.axisIndex = 0;
                            var e = this.axisList;
                            this._addBodyHandler = function(t) {
                                e.push(t.body)
                            }, this._removeBodyHandler = function(t) {
                                var n = e.indexOf(t.body); - 1 !== n && e.splice(n, 1)
                            }, t && this.setWorld(t)
                        }
                        e.exports = r, r.prototype = new i, r.prototype.setWorld = function(t) {
                            this.axisList.length = 0;
                            for (var e = 0; e < t.bodies.length; e++) this.axisList.push(t.bodies[e]);
                            t.removeEventListener("addBody", this._addBodyHandler), t.removeEventListener("removeBody", this._removeBodyHandler), t.addEventListener("addBody", this._addBodyHandler), t.addEventListener("removeBody", this._removeBodyHandler), this.world = t, this.dirty = !0
                        }, r.insertionSortX = function(t) {
                            for (var e = 1, n = t.length; e < n; e++) {
                                for (var i = t[e], r = e - 1; r >= 0 && !(t[r].aabb.lowerBound.x <= i.aabb.lowerBound.x); r--) t[r + 1] = t[r];
                                t[r + 1] = i
                            }
                            return t
                        }, r.insertionSortY = function(t) {
                            for (var e = 1, n = t.length; e < n; e++) {
                                for (var i = t[e], r = e - 1; r >= 0 && !(t[r].aabb.lowerBound.y <= i.aabb.lowerBound.y); r--) t[r + 1] = t[r];
                                t[r + 1] = i
                            }
                            return t
                        }, r.insertionSortZ = function(t) {
                            for (var e = 1, n = t.length; e < n; e++) {
                                for (var i = t[e], r = e - 1; r >= 0 && !(t[r].aabb.lowerBound.z <= i.aabb.lowerBound.z); r--) t[r + 1] = t[r];
                                t[r + 1] = i
                            }
                            return t
                        }, r.prototype.collisionPairs = function(t, e, n) {
                            var i, o, s = this.axisList,
                                a = s.length,
                                l = this.axisIndex;
                            for (this.dirty && (this.sortList(), this.dirty = !1), i = 0; i !== a; i++) {
                                var c = s[i];
                                for (o = i + 1; o < a; o++) {
                                    var h = s[o];
                                    if (this.needBroadphaseCollision(c, h)) {
                                        if (!r.checkBounds(c, h, l)) break;
                                        this.intersectionTest(c, h, e, n)
                                    }
                                }
                            }
                        }, r.prototype.sortList = function() {
                            for (var t = this.axisList, e = this.axisIndex, n = t.length, i = 0; i !== n; i++) {
                                var o = t[i];
                                o.aabbNeedsUpdate && o.computeAABB()
                            }
                            0 === e ? r.insertionSortX(t) : 1 === e ? r.insertionSortY(t) : 2 === e && r.insertionSortZ(t)
                        }, r.checkBounds = function(t, e, n) {
                            var i, r;
                            0 === n ? (i = t.position.x, r = e.position.x) : 1 === n ? (i = t.position.y, r = e.position.y) : 2 === n && (i = t.position.z, r = e.position.z);
                            var o = t.boundingRadius;
                            return r - e.boundingRadius < i + o
                        }, r.prototype.autoDetectAxis = function() {
                            for (var t = 0, e = 0, n = 0, i = 0, r = 0, o = 0, s = this.axisList, a = s.length, l = 1 / a, c = 0; c !== a; c++) {
                                var h = s[c],
                                    u = h.position.x;
                                t += u, e += u * u;
                                var d = h.position.y;
                                n += d, i += d * d;
                                var p = h.position.z;
                                r += p, o += p * p
                            }
                            var f = e - t * t * l,
                                m = i - n * n * l,
                                g = o - r * r * l;
                            this.axisIndex = f > m ? f > g ? 0 : 2 : m > g ? 1 : 2
                        }, r.prototype.aabbQuery = function(t, e, n) {
                            n = n || [], this.dirty && (this.sortList(), this.dirty = !1);
                            var i = this.axisIndex,
                                r = "x";
                            1 === i && (r = "y"), 2 === i && (r = "z");
                            for (var o = this.axisList, s = (e.lowerBound[r], e.upperBound[r], 0); s < o.length; s++) {
                                var a = o[s];
                                a.aabbNeedsUpdate && a.computeAABB(), a.aabb.overlaps(e) && n.push(a)
                            }
                            return n
                        }
                    }, {
                        "../collision/Broadphase": 5,
                        "../shapes/Shape": 44
                    }],
                    13: [function(t, e, n) {
                        e.exports = a, t("./Constraint");
                        var i = t("./PointToPointConstraint"),
                            r = t("../equations/ConeEquation"),
                            o = t("../equations/RotationalEquation"),
                            s = (t("../equations/ContactEquation"), t("../math/Vec3"));

                        function a(t, e, n) {
                            var a = void 0 !== (n = n || {}).maxForce ? n.maxForce : 1e6,
                                l = n.pivotA ? n.pivotA.clone() : new s,
                                c = n.pivotB ? n.pivotB.clone() : new s;
                            this.axisA = n.axisA ? n.axisA.clone() : new s, this.axisB = n.axisB ? n.axisB.clone() : new s, i.call(this, t, l, e, c, a), this.collideConnected = !!n.collideConnected, this.angle = void 0 !== n.angle ? n.angle : 0;
                            var h = this.coneEquation = new r(t, e, n),
                                u = this.twistEquation = new o(t, e, n);
                            this.twistAngle = void 0 !== n.twistAngle ? n.twistAngle : 0, h.maxForce = 0, h.minForce = -a, u.maxForce = 0, u.minForce = -a, this.equations.push(h, u)
                        }
                        a.prototype = new i, a.constructor = a, new s, new s, a.prototype.update = function() {
                            var t = this.bodyA,
                                e = this.bodyB,
                                n = this.coneEquation,
                                r = this.twistEquation;
                            i.prototype.update.call(this), t.vectorToWorldFrame(this.axisA, n.axisA), e.vectorToWorldFrame(this.axisB, n.axisB), this.axisA.tangents(r.axisA, r.axisA), t.vectorToWorldFrame(r.axisA, r.axisA), this.axisB.tangents(r.axisB, r.axisB), e.vectorToWorldFrame(r.axisB, r.axisB), n.angle = this.angle, r.maxAngle = this.twistAngle
                        }
                    }, {
                        "../equations/ConeEquation": 19,
                        "../equations/ContactEquation": 20,
                        "../equations/RotationalEquation": 23,
                        "../math/Vec3": 31,
                        "./Constraint": 14,
                        "./PointToPointConstraint": 18
                    }],
                    14: [function(t, e, n) {
                        e.exports = r;
                        var i = t("../utils/Utils");

                        function r(t, e, n) {
                            n = i.defaults(n, {
                                collideConnected: !0,
                                wakeUpBodies: !0
                            }), this.equations = [], this.bodyA = t, this.bodyB = e, this.id = r.idCounter++, this.collideConnected = n.collideConnected, n.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp())
                        }
                        r.prototype.update = function() {
                            throw new Error("method update() not implmemented in this Constraint subclass!")
                        }, r.prototype.enable = function() {
                            for (var t = this.equations, e = 0; e < t.length; e++) t[e].enabled = !0
                        }, r.prototype.disable = function() {
                            for (var t = this.equations, e = 0; e < t.length; e++) t[e].enabled = !1
                        }, r.idCounter = 0
                    }, {
                        "../utils/Utils": 54
                    }],
                    15: [function(t, e, n) {
                        e.exports = o;
                        var i = t("./Constraint"),
                            r = t("../equations/ContactEquation");

                        function o(t, e, n, o) {
                            i.call(this, t, e), void 0 === n && (n = t.position.distanceTo(e.position)), void 0 === o && (o = 1e6), this.distance = n;
                            var s = this.distanceEquation = new r(t, e);
                            this.equations.push(s), s.minForce = -o, s.maxForce = o
                        }
                        o.prototype = new i, o.prototype.update = function() {
                            var t = this.bodyA,
                                e = this.bodyB,
                                n = this.distanceEquation,
                                i = .5 * this.distance,
                                r = n.ni;
                            e.position.vsub(t.position, r), r.normalize(), r.mult(i, n.ri), r.mult(-i, n.rj)
                        }
                    }, {
                        "../equations/ContactEquation": 20,
                        "./Constraint": 14
                    }],
                    16: [function(t, e, n) {
                        e.exports = a, t("./Constraint");
                        var i = t("./PointToPointConstraint"),
                            r = t("../equations/RotationalEquation"),
                            o = t("../equations/RotationalMotorEquation"),
                            s = (t("../equations/ContactEquation"), t("../math/Vec3"));

                        function a(t, e, n) {
                            var a = void 0 !== (n = n || {}).maxForce ? n.maxForce : 1e6,
                                l = n.pivotA ? n.pivotA.clone() : new s,
                                c = n.pivotB ? n.pivotB.clone() : new s;
                            i.call(this, t, l, e, c, a), (this.axisA = n.axisA ? n.axisA.clone() : new s(1, 0, 0)).normalize(), (this.axisB = n.axisB ? n.axisB.clone() : new s(1, 0, 0)).normalize();
                            var h = this.rotationalEquation1 = new r(t, e, n),
                                u = this.rotationalEquation2 = new r(t, e, n),
                                d = this.motorEquation = new o(t, e, a);
                            d.enabled = !1, this.equations.push(h, u, d)
                        }
                        a.prototype = new i, a.constructor = a, a.prototype.enableMotor = function() {
                            this.motorEquation.enabled = !0
                        }, a.prototype.disableMotor = function() {
                            this.motorEquation.enabled = !1
                        }, a.prototype.setMotorSpeed = function(t) {
                            this.motorEquation.targetVelocity = t
                        }, a.prototype.setMotorMaxForce = function(t) {
                            this.motorEquation.maxForce = t, this.motorEquation.minForce = -t
                        };
                        var l = new s,
                            c = new s;
                        a.prototype.update = function() {
                            var t = this.bodyA,
                                e = this.bodyB,
                                n = this.motorEquation,
                                r = this.rotationalEquation1,
                                o = this.rotationalEquation2,
                                s = l,
                                a = c,
                                h = this.axisA,
                                u = this.axisB;
                            i.prototype.update.call(this), t.quaternion.vmult(h, s), e.quaternion.vmult(u, a), s.tangents(r.axisA, o.axisA), r.axisB.copy(a), o.axisB.copy(a), this.motorEquation.enabled && (t.quaternion.vmult(this.axisA, n.axisA), e.quaternion.vmult(this.axisB, n.axisB))
                        }
                    }, {
                        "../equations/ContactEquation": 20,
                        "../equations/RotationalEquation": 23,
                        "../equations/RotationalMotorEquation": 24,
                        "../math/Vec3": 31,
                        "./Constraint": 14,
                        "./PointToPointConstraint": 18
                    }],
                    17: [function(t, e, n) {
                        e.exports = s, t("./Constraint");
                        var i = t("./PointToPointConstraint"),
                            r = t("../equations/RotationalEquation"),
                            o = (t("../equations/RotationalMotorEquation"), t("../equations/ContactEquation"), t("../math/Vec3"));

                        function s(t, e, n) {
                            var s = void 0 !== (n = n || {}).maxForce ? n.maxForce : 1e6,
                                a = new o,
                                l = new o,
                                c = new o;
                            t.position.vadd(e.position, c), c.scale(.5, c), e.pointToLocalFrame(c, l), t.pointToLocalFrame(c, a), i.call(this, t, a, e, l, s), this.xA = t.vectorToLocalFrame(o.UNIT_X), this.xB = e.vectorToLocalFrame(o.UNIT_X), this.yA = t.vectorToLocalFrame(o.UNIT_Y), this.yB = e.vectorToLocalFrame(o.UNIT_Y), this.zA = t.vectorToLocalFrame(o.UNIT_Z), this.zB = e.vectorToLocalFrame(o.UNIT_Z);
                            var h = this.rotationalEquation1 = new r(t, e, n),
                                u = this.rotationalEquation2 = new r(t, e, n),
                                d = this.rotationalEquation3 = new r(t, e, n);
                            this.equations.push(h, u, d)
                        }
                        s.prototype = new i, s.constructor = s, new o, new o, s.prototype.update = function() {
                            var t = this.bodyA,
                                e = this.bodyB,
                                n = (this.motorEquation, this.rotationalEquation1),
                                r = this.rotationalEquation2,
                                o = this.rotationalEquation3;
                            i.prototype.update.call(this), t.vectorToWorldFrame(this.xA, n.axisA), e.vectorToWorldFrame(this.yB, n.axisB), t.vectorToWorldFrame(this.yA, r.axisA), e.vectorToWorldFrame(this.zB, r.axisB), t.vectorToWorldFrame(this.zA, o.axisA), e.vectorToWorldFrame(this.xB, o.axisB)
                        }
                    }, {
                        "../equations/ContactEquation": 20,
                        "../equations/RotationalEquation": 23,
                        "../equations/RotationalMotorEquation": 24,
                        "../math/Vec3": 31,
                        "./Constraint": 14,
                        "./PointToPointConstraint": 18
                    }],
                    18: [function(t, e, n) {
                        e.exports = s;
                        var i = t("./Constraint"),
                            r = t("../equations/ContactEquation"),
                            o = t("../math/Vec3");

                        function s(t, e, n, s, a) {
                            i.call(this, t, n), a = void 0 !== a ? a : 1e6, this.pivotA = e ? e.clone() : new o, this.pivotB = s ? s.clone() : new o;
                            var l = this.equationX = new r(t, n),
                                c = this.equationY = new r(t, n),
                                h = this.equationZ = new r(t, n);
                            this.equations.push(l, c, h), l.minForce = c.minForce = h.minForce = -a, l.maxForce = c.maxForce = h.maxForce = a, l.ni.set(1, 0, 0), c.ni.set(0, 1, 0), h.ni.set(0, 0, 1)
                        }
                        s.prototype = new i, s.prototype.update = function() {
                            var t = this.bodyA,
                                e = this.bodyB,
                                n = this.equationX,
                                i = this.equationY,
                                r = this.equationZ;
                            t.quaternion.vmult(this.pivotA, n.ri), e.quaternion.vmult(this.pivotB, n.rj), i.ri.copy(n.ri), i.rj.copy(n.rj), r.ri.copy(n.ri), r.rj.copy(n.rj)
                        }
                    }, {
                        "../equations/ContactEquation": 20,
                        "../math/Vec3": 31,
                        "./Constraint": 14
                    }],
                    19: [function(t, e, n) {
                        e.exports = o;
                        var i = t("../math/Vec3"),
                            r = (t("../math/Mat3"), t("./Equation"));

                        function o(t, e, n) {
                            var o = void 0 !== (n = n || {}).maxForce ? n.maxForce : 1e6;
                            r.call(this, t, e, -o, o), this.axisA = n.axisA ? n.axisA.clone() : new i(1, 0, 0), this.axisB = n.axisB ? n.axisB.clone() : new i(0, 1, 0), this.angle = void 0 !== n.angle ? n.angle : 0
                        }
                        o.prototype = new r, o.prototype.constructor = o;
                        var s = new i,
                            a = new i;
                        o.prototype.computeB = function(t) {
                            var e = this.a,
                                n = this.b,
                                i = this.axisA,
                                r = this.axisB,
                                o = s,
                                l = a,
                                c = this.jacobianElementA,
                                h = this.jacobianElementB;
                            return i.cross(r, o), r.cross(i, l), c.rotational.copy(l), h.rotational.copy(o), -(Math.cos(this.angle) - i.dot(r)) * e - this.computeGW() * n - t * this.computeGiMf()
                        }
                    }, {
                        "../math/Mat3": 28,
                        "../math/Vec3": 31,
                        "./Equation": 21
                    }],
                    20: [function(t, e, n) {
                        e.exports = o;
                        var i = t("./Equation"),
                            r = t("../math/Vec3");

                        function o(t, e, n) {
                            n = void 0 !== n ? n : 1e6, i.call(this, t, e, 0, n), this.restitution = 0, this.ri = new r, this.rj = new r, this.ni = new r
                        }
                        t("../math/Mat3"), o.prototype = new i, o.prototype.constructor = o;
                        var s = new r,
                            a = new r,
                            l = new r;
                        o.prototype.computeB = function(t) {
                            var e = this.a,
                                n = this.b,
                                i = this.bi,
                                r = this.bj,
                                o = this.ri,
                                c = this.rj,
                                h = s,
                                u = a,
                                d = i.velocity,
                                p = i.angularVelocity,
                                f = (i.force, i.torque, r.velocity),
                                m = r.angularVelocity,
                                g = (r.force, r.torque, l),
                                v = this.jacobianElementA,
                                y = this.jacobianElementB,
                                x = this.ni;
                            o.cross(x, h), c.cross(x, u), x.negate(v.spatial), h.negate(v.rotational), y.spatial.copy(x), y.rotational.copy(u), g.copy(r.position), g.vadd(c, g), g.vsub(i.position, g), g.vsub(o, g);
                            var b = x.dot(g),
                                w = this.restitution + 1;
                            return -b * e - (w * f.dot(x) - w * d.dot(x) + m.dot(u) - p.dot(h)) * n - t * this.computeGiMf()
                        };
                        var c = new r,
                            h = new r,
                            u = new r,
                            d = new r,
                            p = new r;
                        o.prototype.getImpactVelocityAlongNormal = function() {
                            var t = c,
                                e = h,
                                n = u,
                                i = d,
                                r = p;
                            return this.bi.position.vadd(this.ri, n), this.bj.position.vadd(this.rj, i), this.bi.getVelocityAtWorldPoint(n, t), this.bj.getVelocityAtWorldPoint(i, e), t.vsub(e, r), this.ni.dot(r)
                        }
                    }, {
                        "../math/Mat3": 28,
                        "../math/Vec3": 31,
                        "./Equation": 21
                    }],
                    21: [function(t, e, n) {
                        e.exports = o;
                        var i = t("../math/JacobianElement"),
                            r = t("../math/Vec3");

                        function o(t, e, n, r) {
                            this.id = o.id++, this.minForce = void 0 === n ? -1e6 : n, this.maxForce = void 0 === r ? 1e6 : r, this.bi = t, this.bj = e, this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new i, this.jacobianElementB = new i, this.enabled = !0, this.multiplier = 0, this.setSpookParams(1e7, 4, 1 / 60)
                        }
                        o.prototype.constructor = o, o.id = 0, o.prototype.setSpookParams = function(t, e, n) {
                            var i = e,
                                r = t,
                                o = n;
                            this.a = 4 / (o * (1 + 4 * i)), this.b = 4 * i / (1 + 4 * i), this.eps = 4 / (o * o * r * (1 + 4 * i))
                        }, o.prototype.computeB = function(t, e, n) {
                            var i = this.computeGW();
                            return -this.computeGq() * t - i * e - this.computeGiMf() * n
                        }, o.prototype.computeGq = function() {
                            var t = this.jacobianElementA,
                                e = this.jacobianElementB,
                                n = this.bi,
                                i = this.bj,
                                r = n.position,
                                o = i.position;
                            return t.spatial.dot(r) + e.spatial.dot(o)
                        }, new r, o.prototype.computeGW = function() {
                            var t = this.jacobianElementA,
                                e = this.jacobianElementB,
                                n = this.bi,
                                i = this.bj,
                                r = n.velocity,
                                o = i.velocity,
                                s = n.angularVelocity,
                                a = i.angularVelocity;
                            return t.multiplyVectors(r, s) + e.multiplyVectors(o, a)
                        }, o.prototype.computeGWlambda = function() {
                            var t = this.jacobianElementA,
                                e = this.jacobianElementB,
                                n = this.bi,
                                i = this.bj,
                                r = n.vlambda,
                                o = i.vlambda,
                                s = n.wlambda,
                                a = i.wlambda;
                            return t.multiplyVectors(r, s) + e.multiplyVectors(o, a)
                        };
                        var s = new r,
                            a = new r,
                            l = new r,
                            c = new r;
                        o.prototype.computeGiMf = function() {
                            var t = this.jacobianElementA,
                                e = this.jacobianElementB,
                                n = this.bi,
                                i = this.bj,
                                r = n.force,
                                o = n.torque,
                                h = i.force,
                                u = i.torque,
                                d = n.invMassSolve,
                                p = i.invMassSolve;
                            return r.scale(d, s), h.scale(p, a), n.invInertiaWorldSolve.vmult(o, l), i.invInertiaWorldSolve.vmult(u, c), t.multiplyVectors(s, l) + e.multiplyVectors(a, c)
                        };
                        var h = new r;
                        o.prototype.computeGiMGt = function() {
                            var t = this.jacobianElementA,
                                e = this.jacobianElementB,
                                n = this.bi,
                                i = this.bj,
                                r = n.invMassSolve,
                                o = i.invMassSolve,
                                s = n.invInertiaWorldSolve,
                                a = i.invInertiaWorldSolve,
                                l = r + o;
                            return s.vmult(t.rotational, h), l += h.dot(t.rotational), a.vmult(e.rotational, h), l + h.dot(e.rotational)
                        };
                        var u = new r;
                        new r, new r, new r, new r, new r, o.prototype.addToWlambda = function(t) {
                            var e = this.jacobianElementA,
                                n = this.jacobianElementB,
                                i = this.bi,
                                r = this.bj,
                                o = u;
                            i.vlambda.addScaledVector(i.invMassSolve * t, e.spatial, i.vlambda), r.vlambda.addScaledVector(r.invMassSolve * t, n.spatial, r.vlambda), i.invInertiaWorldSolve.vmult(e.rotational, o), i.wlambda.addScaledVector(t, o, i.wlambda), r.invInertiaWorldSolve.vmult(n.rotational, o), r.wlambda.addScaledVector(t, o, r.wlambda)
                        }, o.prototype.computeC = function() {
                            return this.computeGiMGt() + this.eps
                        }
                    }, {
                        "../math/JacobianElement": 27,
                        "../math/Vec3": 31
                    }],
                    22: [function(t, e, n) {
                        e.exports = o;
                        var i = t("./Equation"),
                            r = t("../math/Vec3");

                        function o(t, e, n) {
                            i.call(this, t, e, -n, n), this.ri = new r, this.rj = new r, this.t = new r
                        }
                        t("../math/Mat3"), o.prototype = new i, o.prototype.constructor = o;
                        var s = new r,
                            a = new r;
                        o.prototype.computeB = function(t) {
                            this.a;
                            var e = this.b,
                                n = (this.bi, this.bj, this.ri),
                                i = this.rj,
                                r = s,
                                o = a,
                                l = this.t;
                            n.cross(l, r), i.cross(l, o);
                            var c = this.jacobianElementA,
                                h = this.jacobianElementB;
                            return l.negate(c.spatial), r.negate(c.rotational), h.spatial.copy(l), h.rotational.copy(o), -this.computeGW() * e - t * this.computeGiMf()
                        }
                    }, {
                        "../math/Mat3": 28,
                        "../math/Vec3": 31,
                        "./Equation": 21
                    }],
                    23: [function(t, e, n) {
                        e.exports = o;
                        var i = t("../math/Vec3"),
                            r = (t("../math/Mat3"), t("./Equation"));

                        function o(t, e, n) {
                            var o = void 0 !== (n = n || {}).maxForce ? n.maxForce : 1e6;
                            r.call(this, t, e, -o, o), this.axisA = n.axisA ? n.axisA.clone() : new i(1, 0, 0), this.axisB = n.axisB ? n.axisB.clone() : new i(0, 1, 0), this.maxAngle = Math.PI / 2
                        }
                        o.prototype = new r, o.prototype.constructor = o;
                        var s = new i,
                            a = new i;
                        o.prototype.computeB = function(t) {
                            var e = this.a,
                                n = this.b,
                                i = this.axisA,
                                r = this.axisB,
                                o = s,
                                l = a,
                                c = this.jacobianElementA,
                                h = this.jacobianElementB;
                            return i.cross(r, o), r.cross(i, l), c.rotational.copy(l), h.rotational.copy(o), -(Math.cos(this.maxAngle) - i.dot(r)) * e - this.computeGW() * n - t * this.computeGiMf()
                        }
                    }, {
                        "../math/Mat3": 28,
                        "../math/Vec3": 31,
                        "./Equation": 21
                    }],
                    24: [function(t, e, n) {
                        e.exports = o;
                        var i = t("../math/Vec3"),
                            r = (t("../math/Mat3"), t("./Equation"));

                        function o(t, e, n) {
                            n = void 0 !== n ? n : 1e6, r.call(this, t, e, -n, n), this.axisA = new i, this.axisB = new i, this.targetVelocity = 0
                        }
                        o.prototype = new r, o.prototype.constructor = o, o.prototype.computeB = function(t) {
                            this.a;
                            var e = this.b,
                                n = (this.bi, this.bj, this.axisA),
                                i = this.axisB,
                                r = this.jacobianElementA,
                                o = this.jacobianElementB;
                            return r.rotational.copy(n), i.negate(o.rotational), -(this.computeGW() - this.targetVelocity) * e - t * this.computeGiMf()
                        }
                    }, {
                        "../math/Mat3": 28,
                        "../math/Vec3": 31,
                        "./Equation": 21
                    }],
                    25: [function(t, e, n) {
                        var i = t("../utils/Utils");

                        function r(t, e, n) {
                            n = i.defaults(n, {
                                friction: .3,
                                restitution: .3,
                                contactEquationStiffness: 1e7,
                                contactEquationRelaxation: 3,
                                frictionEquationStiffness: 1e7,
                                frictionEquationRelaxation: 3
                            }), this.id = r.idCounter++, this.materials = [t, e], this.friction = n.friction, this.restitution = n.restitution, this.contactEquationStiffness = n.contactEquationStiffness, this.contactEquationRelaxation = n.contactEquationRelaxation, this.frictionEquationStiffness = n.frictionEquationStiffness, this.frictionEquationRelaxation = n.frictionEquationRelaxation
                        }
                        e.exports = r, r.idCounter = 0
                    }, {
                        "../utils/Utils": 54
                    }],
                    26: [function(t, e, n) {
                        function i(t) {
                            var e = "";
                            "string" == typeof(t = t || {}) ? (e = t, t = {}) : "object" == typeof t && (e = ""), this.name = e, this.id = i.idCounter++, this.friction = void 0 !== t.friction ? t.friction : -1, this.restitution = void 0 !== t.restitution ? t.restitution : -1
                        }
                        e.exports = i, i.idCounter = 0
                    }, {}],
                    27: [function(t, e, n) {
                        e.exports = r;
                        var i = t("./Vec3");

                        function r() {
                            this.spatial = new i, this.rotational = new i
                        }
                        r.prototype.multiplyElement = function(t) {
                            return t.spatial.dot(this.spatial) + t.rotational.dot(this.rotational)
                        }, r.prototype.multiplyVectors = function(t, e) {
                            return t.dot(this.spatial) + e.dot(this.rotational)
                        }
                    }, {
                        "./Vec3": 31
                    }],
                    28: [function(t, e, n) {
                        e.exports = r;
                        var i = t("./Vec3");

                        function r(t) {
                            this.elements = t || [0, 0, 0, 0, 0, 0, 0, 0, 0]
                        }
                        r.prototype.identity = function() {
                            var t = this.elements;
                            t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1
                        }, r.prototype.setZero = function() {
                            var t = this.elements;
                            t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 0
                        }, r.prototype.setTrace = function(t) {
                            var e = this.elements;
                            e[0] = t.x, e[4] = t.y, e[8] = t.z
                        }, r.prototype.getTrace = function(t) {
                            t = t || new i;
                            var e = this.elements;
                            t.x = e[0], t.y = e[4], t.z = e[8]
                        }, r.prototype.vmult = function(t, e) {
                            e = e || new i;
                            var n = this.elements,
                                r = t.x,
                                o = t.y,
                                s = t.z;
                            return e.x = n[0] * r + n[1] * o + n[2] * s, e.y = n[3] * r + n[4] * o + n[5] * s, e.z = n[6] * r + n[7] * o + n[8] * s, e
                        }, r.prototype.smult = function(t) {
                            for (var e = 0; e < this.elements.length; e++) this.elements[e] *= t
                        }, r.prototype.mmult = function(t, e) {
                            for (var n = e || new r, i = 0; i < 3; i++)
                                for (var o = 0; o < 3; o++) {
                                    for (var s = 0, a = 0; a < 3; a++) s += t.elements[i + 3 * a] * this.elements[a + 3 * o];
                                    n.elements[i + 3 * o] = s
                                }
                            return n
                        }, r.prototype.scale = function(t, e) {
                            e = e || new r;
                            for (var n = this.elements, i = e.elements, o = 0; 3 !== o; o++) i[3 * o + 0] = t.x * n[3 * o + 0], i[3 * o + 1] = t.y * n[3 * o + 1], i[3 * o + 2] = t.z * n[3 * o + 2];
                            return e
                        }, r.prototype.solve = function(t, e) {
                            e = e || new i;
                            for (var n, r = [], o = 0; o < 12; o++) r.push(0);
                            for (o = 0; o < 3; o++)
                                for (n = 0; n < 3; n++) r[o + 4 * n] = this.elements[o + 3 * n];
                            r[3] = t.x, r[7] = t.y, r[11] = t.z;
                            var s, a, l = 3,
                                c = l;
                            do {
                                if (0 === r[(o = c - l) + 4 * o])
                                    for (n = o + 1; n < c; n++)
                                        if (0 !== r[o + 4 * n]) {
                                            s = 4;
                                            do {
                                                r[(a = 4 - s) + 4 * o] += r[a + 4 * n]
                                            } while (--s);
                                            break
                                        }
                                if (0 !== r[o + 4 * o])
                                    for (n = o + 1; n < c; n++) {
                                        var h = r[o + 4 * n] / r[o + 4 * o];
                                        s = 4;
                                        do {
                                            r[(a = 4 - s) + 4 * n] = a <= o ? 0 : r[a + 4 * n] - r[a + 4 * o] * h
                                        } while (--s)
                                    }
                            } while (--l);
                            if (e.z = r[11] / r[10], e.y = (r[7] - r[6] * e.z) / r[5], e.x = (r[3] - r[2] * e.z - r[1] * e.y) / r[0], isNaN(e.x) || isNaN(e.y) || isNaN(e.z) || e.x === 1 / 0 || e.y === 1 / 0 || e.z === 1 / 0) throw "Could not solve equation! Got x=[" + e.toString() + "], b=[" + t.toString() + "], A=[" + this.toString() + "]";
                            return e
                        }, r.prototype.e = function(t, e, n) {
                            if (void 0 === n) return this.elements[e + 3 * t];
                            this.elements[e + 3 * t] = n
                        }, r.prototype.copy = function(t) {
                            for (var e = 0; e < t.elements.length; e++) this.elements[e] = t.elements[e];
                            return this
                        }, r.prototype.toString = function() {
                            for (var t = "", e = 0; e < 9; e++) t += this.elements[e] + ",";
                            return t
                        }, r.prototype.reverse = function(t) {
                            t = t || new r;
                            for (var e, n = [], i = 0; i < 18; i++) n.push(0);
                            for (i = 0; i < 3; i++)
                                for (e = 0; e < 3; e++) n[i + 6 * e] = this.elements[i + 3 * e];
                            n[3] = 1, n[9] = 0, n[15] = 0, n[4] = 0, n[10] = 1, n[16] = 0, n[5] = 0, n[11] = 0, n[17] = 1;
                            var o, s, a = 3,
                                l = a;
                            do {
                                if (0 === n[(i = l - a) + 6 * i])
                                    for (e = i + 1; e < l; e++)
                                        if (0 !== n[i + 6 * e]) {
                                            o = 6;
                                            do {
                                                n[(s = 6 - o) + 6 * i] += n[s + 6 * e]
                                            } while (--o);
                                            break
                                        }
                                if (0 !== n[i + 6 * i])
                                    for (e = i + 1; e < l; e++) {
                                        var c = n[i + 6 * e] / n[i + 6 * i];
                                        o = 6;
                                        do {
                                            n[(s = 6 - o) + 6 * e] = s <= i ? 0 : n[s + 6 * e] - n[s + 6 * i] * c
                                        } while (--o)
                                    }
                            } while (--a);
                            i = 2;
                            do {
                                e = i - 1;
                                do {
                                    c = n[i + 6 * e] / n[i + 6 * i], o = 6;
                                    do {
                                        n[(s = 6 - o) + 6 * e] = n[s + 6 * e] - n[s + 6 * i] * c
                                    } while (--o)
                                } while (e--)
                            } while (--i);
                            i = 2;
                            do {
                                c = 1 / n[i + 6 * i], o = 6;
                                do {
                                    n[(s = 6 - o) + 6 * i] = n[s + 6 * i] * c
                                } while (--o)
                            } while (i--);
                            i = 2;
                            do {
                                e = 2;
                                do {
                                    if (s = n[3 + e + 6 * i], isNaN(s) || s === 1 / 0) throw "Could not reverse! A=[" + this.toString() + "]";
                                    t.e(i, e, s)
                                } while (e--)
                            } while (i--);
                            return t
                        }, r.prototype.setRotationFromQuaternion = function(t) {
                            var e = t.x,
                                n = t.y,
                                i = t.z,
                                r = t.w,
                                o = e + e,
                                s = n + n,
                                a = i + i,
                                l = e * o,
                                c = e * s,
                                h = e * a,
                                u = n * s,
                                d = n * a,
                                p = i * a,
                                f = r * o,
                                m = r * s,
                                g = r * a,
                                v = this.elements;
                            return v[0] = 1 - (u + p), v[1] = c - g, v[2] = h + m, v[3] = c + g, v[4] = 1 - (l + p), v[5] = d - f, v[6] = h - m, v[7] = d + f, v[8] = 1 - (l + u), this
                        }, r.prototype.transpose = function(t) {
                            for (var e = (t = t || new r).elements, n = this.elements, i = 0; 3 !== i; i++)
                                for (var o = 0; 3 !== o; o++) e[3 * i + o] = n[3 * o + i];
                            return t
                        }
                    }, {
                        "./Vec3": 31
                    }],
                    29: [function(t, e, n) {
                        e.exports = r;
                        var i = t("./Vec3");

                        function r(t, e, n, i) {
                            this.x = void 0 !== t ? t : 0, this.y = void 0 !== e ? e : 0, this.z = void 0 !== n ? n : 0, this.w = void 0 !== i ? i : 1
                        }
                        r.prototype.set = function(t, e, n, i) {
                            return this.x = t, this.y = e, this.z = n, this.w = i, this
                        }, r.prototype.toString = function() {
                            return this.x + "," + this.y + "," + this.z + "," + this.w
                        }, r.prototype.toArray = function() {
                            return [this.x, this.y, this.z, this.w]
                        }, r.prototype.setFromAxisAngle = function(t, e) {
                            var n = Math.sin(.5 * e);
                            return this.x = t.x * n, this.y = t.y * n, this.z = t.z * n, this.w = Math.cos(.5 * e), this
                        }, r.prototype.toAxisAngle = function(t) {
                            t = t || new i, this.normalize();
                            var e = 2 * Math.acos(this.w),
                                n = Math.sqrt(1 - this.w * this.w);
                            return n < .001 ? (t.x = this.x, t.y = this.y, t.z = this.z) : (t.x = this.x / n, t.y = this.y / n, t.z = this.z / n), [t, e]
                        };
                        var o = new i,
                            s = new i;
                        r.prototype.setFromVectors = function(t, e) {
                            if (t.isAntiparallelTo(e)) {
                                var n = o,
                                    i = s;
                                t.tangents(n, i), this.setFromAxisAngle(n, Math.PI)
                            } else {
                                var r = t.cross(e);
                                this.x = r.x, this.y = r.y, this.z = r.z, this.w = Math.sqrt(Math.pow(t.norm(), 2) * Math.pow(e.norm(), 2)) + t.dot(e), this.normalize()
                            }
                            return this
                        }, new i, new i, new i, r.prototype.mult = function(t, e) {
                            e = e || new r;
                            var n = this.x,
                                i = this.y,
                                o = this.z,
                                s = this.w,
                                a = t.x,
                                l = t.y,
                                c = t.z,
                                h = t.w;
                            return e.x = n * h + s * a + i * c - o * l, e.y = i * h + s * l + o * a - n * c, e.z = o * h + s * c + n * l - i * a, e.w = s * h - n * a - i * l - o * c, e
                        }, r.prototype.inverse = function(t) {
                            var e = this.x,
                                n = this.y,
                                i = this.z,
                                o = this.w;
                            t = t || new r, this.conjugate(t);
                            var s = 1 / (e * e + n * n + i * i + o * o);
                            return t.x *= s, t.y *= s, t.z *= s, t.w *= s, t
                        }, r.prototype.conjugate = function(t) {
                            return (t = t || new r).x = -this.x, t.y = -this.y, t.z = -this.z, t.w = this.w, t
                        }, r.prototype.normalize = function() {
                            var t = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                            return 0 === t ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (t = 1 / t, this.x *= t, this.y *= t, this.z *= t, this.w *= t), this
                        }, r.prototype.normalizeFast = function() {
                            var t = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
                            return 0 === t ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= t, this.y *= t, this.z *= t, this.w *= t), this
                        }, r.prototype.vmult = function(t, e) {
                            e = e || new i;
                            var n = t.x,
                                r = t.y,
                                o = t.z,
                                s = this.x,
                                a = this.y,
                                l = this.z,
                                c = this.w,
                                h = c * n + a * o - l * r,
                                u = c * r + l * n - s * o,
                                d = c * o + s * r - a * n,
                                p = -s * n - a * r - l * o;
                            return e.x = h * c + p * -s + u * -l - d * -a, e.y = u * c + p * -a + d * -s - h * -l, e.z = d * c + p * -l + h * -a - u * -s, e
                        }, r.prototype.copy = function(t) {
                            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this
                        }, r.prototype.toEuler = function(t, e) {
                            var n, i, r;
                            e = e || "YZX";
                            var o = this.x,
                                s = this.y,
                                a = this.z,
                                l = this.w;
                            if ("YZX" !== e) throw new Error("Euler order " + e + " not supported yet.");
                            var c = o * s + a * l;
                            if (c > .499 && (n = 2 * Math.atan2(o, l), i = Math.PI / 2, r = 0), c < -.499 && (n = -2 * Math.atan2(o, l), i = -Math.PI / 2, r = 0), isNaN(n)) {
                                var h = o * o,
                                    u = s * s,
                                    d = a * a;
                                n = Math.atan2(2 * s * l - 2 * o * a, 1 - 2 * u - 2 * d), i = Math.asin(2 * c), r = Math.atan2(2 * o * l - 2 * s * a, 1 - 2 * h - 2 * d)
                            }
                            t.y = n, t.z = i, t.x = r
                        }, r.prototype.setFromEuler = function(t, e, n, i) {
                            i = i || "XYZ";
                            var r = Math.cos(t / 2),
                                o = Math.cos(e / 2),
                                s = Math.cos(n / 2),
                                a = Math.sin(t / 2),
                                l = Math.sin(e / 2),
                                c = Math.sin(n / 2);
                            return "XYZ" === i ? (this.x = a * o * s + r * l * c, this.y = r * l * s - a * o * c, this.z = r * o * c + a * l * s, this.w = r * o * s - a * l * c) : "YXZ" === i ? (this.x = a * o * s + r * l * c, this.y = r * l * s - a * o * c, this.z = r * o * c - a * l * s, this.w = r * o * s + a * l * c) : "ZXY" === i ? (this.x = a * o * s - r * l * c, this.y = r * l * s + a * o * c, this.z = r * o * c + a * l * s, this.w = r * o * s - a * l * c) : "ZYX" === i ? (this.x = a * o * s - r * l * c, this.y = r * l * s + a * o * c, this.z = r * o * c - a * l * s, this.w = r * o * s + a * l * c) : "YZX" === i ? (this.x = a * o * s + r * l * c, this.y = r * l * s + a * o * c, this.z = r * o * c - a * l * s, this.w = r * o * s - a * l * c) : "XZY" === i && (this.x = a * o * s - r * l * c, this.y = r * l * s - a * o * c, this.z = r * o * c + a * l * s, this.w = r * o * s + a * l * c), this
                        }, r.prototype.clone = function() {
                            return new r(this.x, this.y, this.z, this.w)
                        }, r.prototype.slerp = function(t, e, n) {
                            n = n || new r;
                            var i, o, s, a, l, c = this.x,
                                h = this.y,
                                u = this.z,
                                d = this.w,
                                p = t.x,
                                f = t.y,
                                m = t.z,
                                g = t.w;
                            return (o = c * p + h * f + u * m + d * g) < 0 && (o = -o, p = -p, f = -f, m = -m, g = -g), 1 - o > 1e-6 ? (i = Math.acos(o), s = Math.sin(i), a = Math.sin((1 - e) * i) / s, l = Math.sin(e * i) / s) : (a = 1 - e, l = e), n.x = a * c + l * p, n.y = a * h + l * f, n.z = a * u + l * m, n.w = a * d + l * g, n
                        }, r.prototype.integrate = function(t, e, n, i) {
                            i = i || new r;
                            var o = t.x * n.x,
                                s = t.y * n.y,
                                a = t.z * n.z,
                                l = this.x,
                                c = this.y,
                                h = this.z,
                                u = this.w,
                                d = .5 * e;
                            return i.x += d * (o * u + s * h - a * c), i.y += d * (s * u + a * l - o * h), i.z += d * (a * u + o * c - s * l), i.w += d * (-o * l - s * c - a * h), i
                        }
                    }, {
                        "./Vec3": 31
                    }],
                    30: [function(t, e, n) {
                        var i = t("./Vec3"),
                            r = t("./Quaternion");

                        function o(t) {
                            t = t || {}, this.position = new i, t.position && this.position.copy(t.position), this.quaternion = new r, t.quaternion && this.quaternion.copy(t.quaternion)
                        }
                        e.exports = o;
                        var s = new r;
                        o.pointToLocalFrame = function(t, e, n, r) {
                            return r = r || new i, n.vsub(t, r), e.conjugate(s), s.vmult(r, r), r
                        }, o.prototype.pointToLocal = function(t, e) {
                            return o.pointToLocalFrame(this.position, this.quaternion, t, e)
                        }, o.pointToWorldFrame = function(t, e, n, r) {
                            return r = r || new i, e.vmult(n, r), r.vadd(t, r), r
                        }, o.prototype.pointToWorld = function(t, e) {
                            return o.pointToWorldFrame(this.position, this.quaternion, t, e)
                        }, o.prototype.vectorToWorldFrame = function(t, e) {
                            return e = e || new i, this.quaternion.vmult(t, e), e
                        }, o.vectorToWorldFrame = function(t, e, n) {
                            return t.vmult(e, n), n
                        }, o.vectorToLocalFrame = function(t, e, n, r) {
                            return r = r || new i, e.w *= -1, e.vmult(n, r), e.w *= -1, r
                        }
                    }, {
                        "./Quaternion": 29,
                        "./Vec3": 31
                    }],
                    31: [function(t, e, n) {
                        e.exports = r;
                        var i = t("./Mat3");

                        function r(t, e, n) {
                            this.x = t || 0, this.y = e || 0, this.z = n || 0
                        }
                        r.ZERO = new r(0, 0, 0), r.UNIT_X = new r(1, 0, 0), r.UNIT_Y = new r(0, 1, 0), r.UNIT_Z = new r(0, 0, 1), r.prototype.cross = function(t, e) {
                            var n = t.x,
                                i = t.y,
                                o = t.z,
                                s = this.x,
                                a = this.y,
                                l = this.z;
                            return (e = e || new r).x = a * o - l * i, e.y = l * n - s * o, e.z = s * i - a * n, e
                        }, r.prototype.set = function(t, e, n) {
                            return this.x = t, this.y = e, this.z = n, this
                        }, r.prototype.setZero = function() {
                            this.x = this.y = this.z = 0
                        }, r.prototype.vadd = function(t, e) {
                            if (!e) return new r(this.x + t.x, this.y + t.y, this.z + t.z);
                            e.x = t.x + this.x, e.y = t.y + this.y, e.z = t.z + this.z
                        }, r.prototype.vsub = function(t, e) {
                            if (!e) return new r(this.x - t.x, this.y - t.y, this.z - t.z);
                            e.x = this.x - t.x, e.y = this.y - t.y, e.z = this.z - t.z
                        }, r.prototype.crossmat = function() {
                            return new i([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0])
                        }, r.prototype.normalize = function() {
                            var t = this.x,
                                e = this.y,
                                n = this.z,
                                i = Math.sqrt(t * t + e * e + n * n);
                            if (i > 0) {
                                var r = 1 / i;
                                this.x *= r, this.y *= r, this.z *= r
                            } else this.x = 0, this.y = 0, this.z = 0;
                            return i
                        }, r.prototype.unit = function(t) {
                            t = t || new r;
                            var e = this.x,
                                n = this.y,
                                i = this.z,
                                o = Math.sqrt(e * e + n * n + i * i);
                            return o > 0 ? (o = 1 / o, t.x = e * o, t.y = n * o, t.z = i * o) : (t.x = 1, t.y = 0, t.z = 0), t
                        }, r.prototype.norm = function() {
                            var t = this.x,
                                e = this.y,
                                n = this.z;
                            return Math.sqrt(t * t + e * e + n * n)
                        }, r.prototype.length = r.prototype.norm, r.prototype.norm2 = function() {
                            return this.dot(this)
                        }, r.prototype.lengthSquared = r.prototype.norm2, r.prototype.distanceTo = function(t) {
                            var e = this.x,
                                n = this.y,
                                i = this.z,
                                r = t.x,
                                o = t.y,
                                s = t.z;
                            return Math.sqrt((r - e) * (r - e) + (o - n) * (o - n) + (s - i) * (s - i))
                        }, r.prototype.distanceSquared = function(t) {
                            var e = this.x,
                                n = this.y,
                                i = this.z,
                                r = t.x,
                                o = t.y,
                                s = t.z;
                            return (r - e) * (r - e) + (o - n) * (o - n) + (s - i) * (s - i)
                        }, r.prototype.mult = function(t, e) {
                            e = e || new r;
                            var n = this.x,
                                i = this.y,
                                o = this.z;
                            return e.x = t * n, e.y = t * i, e.z = t * o, e
                        }, r.prototype.vmul = function(t, e) {
                            return (e = e || new r).x = t.x * this.x, e.y = t.y * this.y, e.z = t.z * this.z, e
                        }, r.prototype.scale = r.prototype.mult, r.prototype.addScaledVector = function(t, e, n) {
                            return (n = n || new r).x = this.x + t * e.x, n.y = this.y + t * e.y, n.z = this.z + t * e.z, n
                        }, r.prototype.dot = function(t) {
                            return this.x * t.x + this.y * t.y + this.z * t.z
                        }, r.prototype.isZero = function() {
                            return 0 === this.x && 0 === this.y && 0 === this.z
                        }, r.prototype.negate = function(t) {
                            return (t = t || new r).x = -this.x, t.y = -this.y, t.z = -this.z, t
                        };
                        var o = new r,
                            s = new r;
                        r.prototype.tangents = function(t, e) {
                            var n = this.norm();
                            if (n > 0) {
                                var i = o,
                                    r = 1 / n;
                                i.set(this.x * r, this.y * r, this.z * r);
                                var a = s;
                                Math.abs(i.x) < .9 ? (a.set(1, 0, 0), i.cross(a, t)) : (a.set(0, 1, 0), i.cross(a, t)), i.cross(t, e)
                            } else t.set(1, 0, 0), e.set(0, 1, 0)
                        }, r.prototype.toString = function() {
                            return this.x + "," + this.y + "," + this.z
                        }, r.prototype.toArray = function() {
                            return [this.x, this.y, this.z]
                        }, r.prototype.copy = function(t) {
                            return this.x = t.x, this.y = t.y, this.z = t.z, this
                        }, r.prototype.lerp = function(t, e, n) {
                            var i = this.x,
                                r = this.y,
                                o = this.z;
                            n.x = i + (t.x - i) * e, n.y = r + (t.y - r) * e, n.z = o + (t.z - o) * e
                        }, r.prototype.almostEquals = function(t, e) {
                            return void 0 === e && (e = 1e-6), !(Math.abs(this.x - t.x) > e || Math.abs(this.y - t.y) > e || Math.abs(this.z - t.z) > e)
                        }, r.prototype.almostZero = function(t) {
                            return void 0 === t && (t = 1e-6), !(Math.abs(this.x) > t || Math.abs(this.y) > t || Math.abs(this.z) > t)
                        };
                        var a = new r;
                        r.prototype.isAntiparallelTo = function(t, e) {
                            return this.negate(a), a.almostEquals(t, e)
                        }, r.prototype.clone = function() {
                            return new r(this.x, this.y, this.z)
                        }
                    }, {
                        "./Mat3": 28
                    }],
                    32: [function(t, e, n) {
                        e.exports = c;
                        var i = t("../utils/EventTarget"),
                            r = (t("../shapes/Shape"), t("../math/Vec3")),
                            o = t("../math/Mat3"),
                            s = t("../math/Quaternion"),
                            a = (t("../material/Material"), t("../collision/AABB")),
                            l = t("../shapes/Box");

                        function c(t) {
                            t = t || {}, i.apply(this), this.id = c.idCounter++, this.world = null, this.preStep = null, this.postStep = null, this.vlambda = new r, this.collisionFilterGroup = "number" == typeof t.collisionFilterGroup ? t.collisionFilterGroup : 1, this.collisionFilterMask = "number" == typeof t.collisionFilterMask ? t.collisionFilterMask : -1, this.collisionResponse = !0, this.position = new r, this.previousPosition = new r, this.interpolatedPosition = new r, this.initPosition = new r, t.position && (this.position.copy(t.position), this.previousPosition.copy(t.position), this.interpolatedPosition.copy(t.position), this.initPosition.copy(t.position)), this.velocity = new r, t.velocity && this.velocity.copy(t.velocity), this.initVelocity = new r, this.force = new r;
                            var e = "number" == typeof t.mass ? t.mass : 0;
                            this.mass = e, this.invMass = e > 0 ? 1 / e : 0, this.material = t.material || null, this.linearDamping = "number" == typeof t.linearDamping ? t.linearDamping : .01, this.type = e <= 0 ? c.STATIC : c.DYNAMIC, typeof t.type == typeof c.STATIC && (this.type = t.type), this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.sleepState = 0, this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .03, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, this.timeLastSleepy = 0, this._wakeUpAfterNarrowphase = !1, this.torque = new r, this.quaternion = new s, this.initQuaternion = new s, this.previousQuaternion = new s, this.interpolatedQuaternion = new s, t.quaternion && (this.quaternion.copy(t.quaternion), this.initQuaternion.copy(t.quaternion), this.previousQuaternion.copy(t.quaternion), this.interpolatedQuaternion.copy(t.quaternion)), this.angularVelocity = new r, t.angularVelocity && this.angularVelocity.copy(t.angularVelocity), this.initAngularVelocity = new r, this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], this.inertia = new r, this.invInertia = new r, this.invInertiaWorld = new o, this.invMassSolve = 0, this.invInertiaSolve = new r, this.invInertiaWorldSolve = new o, this.fixedRotation = void 0 !== t.fixedRotation && t.fixedRotation, this.angularDamping = void 0 !== t.angularDamping ? t.angularDamping : .01, this.linearFactor = new r(1, 1, 1), t.linearFactor && this.linearFactor.copy(t.linearFactor), this.angularFactor = new r(1, 1, 1), t.angularFactor && this.angularFactor.copy(t.angularFactor), this.aabb = new a, this.aabbNeedsUpdate = !0, this.boundingRadius = 0, this.wlambda = new r, t.shape && this.addShape(t.shape), this.updateMassProperties()
                        }
                        c.prototype = new i, c.prototype.constructor = c, c.COLLIDE_EVENT_NAME = "collide", c.DYNAMIC = 1, c.STATIC = 2, c.KINEMATIC = 4, c.AWAKE = 0, c.SLEEPY = 1, c.SLEEPING = 2, c.idCounter = 0, c.wakeupEvent = {
                            type: "wakeup"
                        }, c.prototype.wakeUp = function() {
                            var t = this.sleepState;
                            this.sleepState = 0, this._wakeUpAfterNarrowphase = !1, t === c.SLEEPING && this.dispatchEvent(c.wakeupEvent)
                        }, c.prototype.sleep = function() {
                            this.sleepState = c.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this._wakeUpAfterNarrowphase = !1
                        }, c.sleepyEvent = {
                            type: "sleepy"
                        }, c.sleepEvent = {
                            type: "sleep"
                        }, c.prototype.sleepTick = function(t) {
                            if (this.allowSleep) {
                                var e = this.sleepState,
                                    n = this.velocity.norm2() + this.angularVelocity.norm2(),
                                    i = Math.pow(this.sleepSpeedLimit, 2);
                                e === c.AWAKE && n < i ? (this.sleepState = c.SLEEPY, this.timeLastSleepy = t, this.dispatchEvent(c.sleepyEvent)) : e === c.SLEEPY && n > i ? this.wakeUp() : e === c.SLEEPY && t - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(c.sleepEvent))
                            }
                        }, c.prototype.updateSolveMassProperties = function() {
                            this.sleepState === c.SLEEPING || this.type === c.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld))
                        }, c.prototype.pointToLocalFrame = function(t, e) {
                            return e = e || new r, t.vsub(this.position, e), this.quaternion.conjugate().vmult(e, e), e
                        }, c.prototype.vectorToLocalFrame = function(t, e) {
                            return e = e || new r, this.quaternion.conjugate().vmult(t, e), e
                        }, c.prototype.pointToWorldFrame = function(t, e) {
                            return e = e || new r, this.interpolatedQuaternion.vmult(t, e), e.vadd(this.interpolatedPosition, e), e
                        }, c.prototype.vectorToWorldFrame = function(t, e) {
                            return e = e || new r, this.interpolatedQuaternion.vmult(t, e), e
                        };
                        var h = new r,
                            u = new s;
                        c.prototype.addShape = function(t, e, n) {
                            var i = new r,
                                o = new s;
                            return e && i.copy(e), n && o.copy(n), this.shapes.push(t), this.shapeOffsets.push(i), this.shapeOrientations.push(o), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, t.body = this, this
                        }, c.prototype.updateBoundingRadius = function() {
                            for (var t = this.shapes, e = this.shapeOffsets, n = t.length, i = 0, r = 0; r !== n; r++) {
                                var o = t[r];
                                o.updateBoundingSphereRadius();
                                var s = e[r].norm(),
                                    a = o.boundingSphereRadius;
                                s + a > i && (i = s + a)
                            }
                            this.boundingRadius = i
                        };
                        var d = new a;
                        c.prototype.computeAABB = function() {
                            for (var t = this.shapes, e = this.shapeOffsets, n = this.shapeOrientations, i = t.length, r = h, o = u, s = this.quaternion, a = this.aabb, l = d, c = 0; c !== i; c++) {
                                var p = t[c];
                                s.vmult(e[c], r), r.vadd(this.position, r), n[c].mult(s, o), p.calculateWorldAABB(r, o, l.lowerBound, l.upperBound), 0 === c ? a.copy(l) : a.extend(l)
                            }
                            this.aabbNeedsUpdate = !1
                        };
                        var p = new o,
                            f = new o;
                        new o, c.prototype.updateInertiaWorld = function(t) {
                            var e = this.invInertia;
                            if (e.x !== e.y || e.y !== e.z || t) {
                                var n = p,
                                    i = f;
                                n.setRotationFromQuaternion(this.quaternion), n.transpose(i), n.scale(e, n), n.mmult(i, this.invInertiaWorld)
                            }
                        }, new r;
                        var m = new r;
                        c.prototype.applyForce = function(t, e) {
                            if (this.type === c.DYNAMIC) {
                                var n = m;
                                e.cross(t, n), this.force.vadd(t, this.force), this.torque.vadd(n, this.torque)
                            }
                        };
                        var g = new r,
                            v = new r;
                        c.prototype.applyLocalForce = function(t, e) {
                            if (this.type === c.DYNAMIC) {
                                var n = g,
                                    i = v;
                                this.vectorToWorldFrame(t, n), this.vectorToWorldFrame(e, i), this.applyForce(n, i)
                            }
                        }, new r;
                        var y = new r,
                            x = new r;
                        c.prototype.applyImpulse = function(t, e) {
                            if (this.type === c.DYNAMIC) {
                                var n = e,
                                    i = y;
                                i.copy(t), i.mult(this.invMass, i), this.velocity.vadd(i, this.velocity);
                                var r = x;
                                n.cross(t, r), this.invInertiaWorld.vmult(r, r), this.angularVelocity.vadd(r, this.angularVelocity)
                            }
                        };
                        var b = new r,
                            w = new r;
                        c.prototype.applyLocalImpulse = function(t, e) {
                            if (this.type === c.DYNAMIC) {
                                var n = b,
                                    i = w;
                                this.vectorToWorldFrame(t, n), this.vectorToWorldFrame(e, i), this.applyImpulse(n, i)
                            }
                        };
                        var _ = new r;
                        c.prototype.updateMassProperties = function() {
                            var t = _;
                            this.invMass = this.mass > 0 ? 1 / this.mass : 0;
                            var e = this.inertia,
                                n = this.fixedRotation;
                            this.computeAABB(), t.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), l.calculateInertia(t, this.mass, e), this.invInertia.set(e.x > 0 && !n ? 1 / e.x : 0, e.y > 0 && !n ? 1 / e.y : 0, e.z > 0 && !n ? 1 / e.z : 0), this.updateInertiaWorld(!0)
                        }, c.prototype.getVelocityAtWorldPoint = function(t, e) {
                            var n = new r;
                            return t.vsub(this.position, n), this.angularVelocity.cross(n, e), this.velocity.vadd(e, e), e
                        }, new r, new r, new s, new s, c.prototype.integrate = function(t, e, n) {
                            if (this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), (this.type === c.DYNAMIC || this.type === c.KINEMATIC) && this.sleepState !== c.SLEEPING) {
                                var i = this.velocity,
                                    r = this.angularVelocity,
                                    o = this.position,
                                    s = this.force,
                                    a = this.torque,
                                    l = this.quaternion,
                                    h = this.invMass,
                                    u = this.invInertiaWorld,
                                    d = this.linearFactor,
                                    p = h * t;
                                i.x += s.x * p * d.x, i.y += s.y * p * d.y, i.z += s.z * p * d.z;
                                var f = u.elements,
                                    m = this.angularFactor,
                                    g = a.x * m.x,
                                    v = a.y * m.y,
                                    y = a.z * m.z;
                                r.x += t * (f[0] * g + f[1] * v + f[2] * y), r.y += t * (f[3] * g + f[4] * v + f[5] * y), r.z += t * (f[6] * g + f[7] * v + f[8] * y), o.x += i.x * t, o.y += i.y * t, o.z += i.z * t, l.integrate(this.angularVelocity, t, this.angularFactor, l), e && (n ? l.normalizeFast() : l.normalize()), this.aabbNeedsUpdate = !0, this.updateInertiaWorld()
                            }
                        }
                    }, {
                        "../collision/AABB": 3,
                        "../material/Material": 26,
                        "../math/Mat3": 28,
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../shapes/Box": 38,
                        "../shapes/Shape": 44,
                        "../utils/EventTarget": 50
                    }],
                    33: [function(t, e, n) {
                        t("./Body");
                        var i = t("../math/Vec3"),
                            r = t("../math/Quaternion"),
                            o = (t("../collision/RaycastResult"), t("../collision/Ray")),
                            s = t("../objects/WheelInfo");

                        function a(t) {
                            this.chassisBody = t.chassisBody, this.wheelInfos = [], this.sliding = !1, this.world = null, this.indexRightAxis = void 0 !== t.indexRightAxis ? t.indexRightAxis : 1, this.indexForwardAxis = void 0 !== t.indexForwardAxis ? t.indexForwardAxis : 0, this.indexUpAxis = void 0 !== t.indexUpAxis ? t.indexUpAxis : 2, this.numWheelsOnGround = 0
                        }
                        e.exports = a, new i, new i, new i;
                        var l = new i,
                            c = new i,
                            h = new i;
                        new o, a.prototype.addWheel = function(t) {
                            var e = new s(t = t || {}),
                                n = this.wheelInfos.length;
                            return this.wheelInfos.push(e), n
                        }, a.prototype.setSteeringValue = function(t, e) {
                            this.wheelInfos[e].steering = t
                        }, new i, a.prototype.applyEngineForce = function(t, e) {
                            this.wheelInfos[e].engineForce = t
                        }, a.prototype.setBrake = function(t, e) {
                            this.wheelInfos[e].brake = t
                        }, a.prototype.addToWorld = function(t) {
                            this.constraints, t.addBody(this.chassisBody);
                            var e = this;
                            this.preStepCallback = function() {
                                e.updateVehicle(t.dt)
                            }, t.addEventListener("preStep", this.preStepCallback), this.world = t
                        }, a.prototype.getVehicleAxisWorld = function(t, e) {
                            e.set(0 === t ? 1 : 0, 1 === t ? 1 : 0, 2 === t ? 1 : 0), this.chassisBody.vectorToWorldFrame(e, e)
                        }, a.prototype.updateVehicle = function(t) {
                            if (!(this.chassisBody.sleepState > 1)) {
                                for (var e = this.wheelInfos, n = e.length, r = this.chassisBody, o = 0; o < n; o++) this.updateWheelTransform(o);
                                this.currentVehicleSpeedKmHour = 3.6 * r.velocity.norm();
                                var s = new i;
                                for (this.getVehicleAxisWorld(this.indexForwardAxis, s), s.dot(r.velocity) < 0 && (this.currentVehicleSpeedKmHour *= -1), o = 0; o < n; o++) this.castRay(e[o]);
                                this.updateSuspension(t);
                                var a = new i,
                                    l = new i;
                                for (o = 0; o < n; o++) {
                                    var c = (p = e[o]).suspensionForce;
                                    c > p.maxSuspensionForce && (c = p.maxSuspensionForce), p.raycastResult.hitNormalWorld.scale(c * t, a), p.raycastResult.hitPointWorld.vsub(r.position, l), r.applyImpulse(a, l)
                                }
                                this.updateFriction(t);
                                var h = new i,
                                    u = new i,
                                    d = new i;
                                for (o = 0; o < n; o++) {
                                    var p = e[o];
                                    r.getVelocityAtWorldPoint(p.chassisConnectionPointWorld, d);
                                    var f = 1;
                                    if (1 === this.indexUpAxis && (f = -1), p.isInContact) {
                                        this.getVehicleAxisWorld(this.indexForwardAxis, u);
                                        var m = u.dot(p.raycastResult.hitNormalWorld);
                                        p.raycastResult.hitNormalWorld.scale(m, h), u.vsub(h, u);
                                        var g = u.dot(d);
                                        p.deltaRotation = f * g * t / p.radius
                                    }!p.sliding && p.isInContact || 0 === p.engineForce || !p.useCustomSlidingRotationalSpeed || (p.deltaRotation = (p.engineForce > 0 ? 1 : -1) * p.customSlidingRotationalSpeed * t), Math.abs(p.brake) > Math.abs(p.engineForce) && (p.deltaRotation = 0), p.lastRotation = p.rotation, p.rotation += p.deltaRotation, p.deltaRotation *= .99
                                }
                            }
                        }, a.prototype.updateSuspension = function(t) {
                            for (var e = this.chassisBody.mass, n = this.wheelInfos, i = n.length, r = 0; r < i; r++) {
                                var o = n[r];
                                if (o.isInContact) {
                                    var s, a = o.suspensionRestLength - o.suspensionLength;
                                    s = o.suspensionStiffness * a * o.clippedInvContactDotSuspension;
                                    var l = o.suspensionRelativeVelocity;
                                    s -= (l < 0 ? o.dampingCompression : o.dampingRelaxation) * l, o.suspensionForce = s * e, o.suspensionForce < 0 && (o.suspensionForce = 0)
                                } else o.suspensionForce = 0
                            }
                        }, a.prototype.removeFromWorld = function(t) {
                            this.constraints, t.remove(this.chassisBody), t.removeEventListener("preStep", this.preStepCallback), this.world = null
                        };
                        var u = new i,
                            d = new i;
                        a.prototype.castRay = function(t) {
                            var e = u,
                                n = d;
                            this.updateWheelTransformWorld(t);
                            var r = this.chassisBody,
                                o = -1,
                                s = t.suspensionRestLength + t.radius;
                            t.directionWorld.scale(s, e);
                            var a = t.chassisConnectionPointWorld;
                            a.vadd(e, n);
                            var l = t.raycastResult;
                            l.reset();
                            var c = r.collisionResponse;
                            r.collisionResponse = !1, this.world.rayTest(a, n, l), r.collisionResponse = c;
                            var h = l.body;
                            if (t.raycastResult.groundObject = 0, t.lastSuspensionLength = t.suspensionLength, h) {
                                o = l.distance, t.raycastResult.hitNormalWorld = l.hitNormalWorld, t.isInContact = !0;
                                var p = l.distance;
                                t.suspensionLength = p - t.radius;
                                var f = t.suspensionRestLength - t.maxSuspensionTravel,
                                    m = t.suspensionRestLength + t.maxSuspensionTravel;
                                t.suspensionLength < f && (t.suspensionLength = f), t.suspensionLength > m && (t.suspensionLength = m, t.raycastResult.reset());
                                var g = t.raycastResult.hitNormalWorld.dot(t.directionWorld),
                                    v = new i;
                                r.getVelocityAtWorldPoint(t.raycastResult.hitPointWorld, v);
                                var y = t.raycastResult.hitNormalWorld.dot(v);
                                if (g >= -.1) t.suspensionRelativeVelocity = 0, t.clippedInvContactDotSuspension = 10;
                                else {
                                    var x = -1 / g;
                                    t.suspensionRelativeVelocity = y * x, t.clippedInvContactDotSuspension = x
                                }
                            } else t.suspensionLength = t.suspensionRestLength + 0 * t.maxSuspensionTravel, t.suspensionRelativeVelocity = 0, t.directionWorld.scale(-1, t.raycastResult.hitNormalWorld), t.clippedInvContactDotSuspension = 1;
                            return o
                        }, a.prototype.updateWheelTransformWorld = function(t) {
                            t.isInContact = !1;
                            var e = this.chassisBody;
                            e.pointToWorldFrame(t.chassisConnectionPointLocal, t.chassisConnectionPointWorld), e.vectorToWorldFrame(t.directionLocal, t.directionWorld), e.vectorToWorldFrame(t.axleLocal, t.axleWorld)
                        }, a.prototype.updateWheelTransform = function(t) {
                            var e = l,
                                n = c,
                                i = h,
                                o = this.wheelInfos[t];
                            this.updateWheelTransformWorld(o), o.directionLocal.scale(-1, e), n.copy(o.axleLocal), e.cross(n, i), i.normalize(), n.normalize();
                            var s = o.steering,
                                a = new r;
                            a.setFromAxisAngle(e, s);
                            var u = new r;
                            u.setFromAxisAngle(n, this.lerp(o.lastRotation, o.rotation, this.world.interpolationFactor));
                            var d = o.worldTransform.quaternion;
                            this.chassisBody.quaternion.mult(a, d), d.mult(u, d), d.normalize();
                            var p = o.worldTransform.position;
                            p.copy(o.directionWorld), p.scale(this.lerp(o.lastSuspensionLength, o.suspensionLength, this.world.interpolationFactor), p), p.vadd(o.chassisConnectionPointWorld, p)
                        }, a.prototype.lerp = function(t, e, n) {
                            return t + (e - t) * ((n = n < 0 ? 0 : n) > 1 ? 1 : n)
                        };
                        var p = [new i(1, 0, 0), new i(0, 1, 0), new i(0, 0, 1)];
                        a.prototype.getWheelTransformWorld = function(t) {
                            return this.wheelInfos[t].worldTransform
                        };
                        var f = new i,
                            m = [],
                            g = [];
                        a.prototype.updateFriction = function(t) {
                            var e = f,
                                n = this.wheelInfos,
                                r = n.length,
                                o = this.chassisBody,
                                s = g,
                                a = m;
                            this.numWheelsOnGround = 0;
                            for (var l = 0; l < r; l++)(d = (T = n[l]).raycastResult.body) && this.numWheelsOnGround++, T.sideImpulse = 0, T.forwardImpulse = 0, s[l] || (s[l] = new i), a[l] || (a[l] = new i);
                            for (l = 0; l < r; l++)
                                if (d = (T = n[l]).raycastResult.body) {
                                    var c = a[l];
                                    this.getWheelTransformWorld(l).vectorToWorldFrame(p[this.indexRightAxis], c);
                                    var h = T.raycastResult.hitNormalWorld,
                                        u = c.dot(h);
                                    h.scale(u, e), c.vsub(e, c), c.normalize(), h.cross(c, s[l]), s[l].normalize(), T.sideImpulse = P(o, T.raycastResult.hitPointWorld, d, T.raycastResult.hitPointWorld, c), T.sideImpulse *= 1
                                }
                            for (this.sliding = !1, l = 0; l < r; l++) {
                                var d = (T = n[l]).raycastResult.body,
                                    v = 0;
                                if (T.slipInfo = 1, d) {
                                    var y = T.brake ? T.brake : 0;
                                    v = b(o, d, T.raycastResult.hitPointWorld, s[l], y);
                                    var x = y / (v += T.engineForce * t);
                                    T.slipInfo *= x
                                }
                                if (T.forwardImpulse = 0, T.skidInfo = 1, d) {
                                    T.skidInfo = 1;
                                    var w = T.suspensionForce * t * T.frictionSlip,
                                        _ = w * w;
                                    T.forwardImpulse = v;
                                    var S = 1 * T.forwardImpulse,
                                        M = 1 * T.sideImpulse,
                                        A = S * S + M * M;
                                    T.sliding = !1, A > _ && (this.sliding = !0, T.sliding = !0, x = w / Math.sqrt(A), T.skidInfo *= x)
                                }
                            }
                            if (this.sliding)
                                for (l = 0; l < r; l++) 0 !== (T = n[l]).sideImpulse && T.skidInfo < 1 && (T.forwardImpulse *= T.skidInfo, T.sideImpulse *= T.skidInfo);
                            for (l = 0; l < r; l++) {
                                var T = n[l],
                                    E = new i;
                                if (T.raycastResult.hitPointWorld.vsub(o.position, E), 0 !== T.forwardImpulse) {
                                    var C = new i;
                                    s[l].scale(T.forwardImpulse, C), o.applyImpulse(C, E)
                                }
                                if (0 !== T.sideImpulse) {
                                    d = T.raycastResult.body;
                                    var L = new i;
                                    T.raycastResult.hitPointWorld.vsub(d.position, L);
                                    var R = new i;
                                    a[l].scale(T.sideImpulse, R), o.vectorToLocalFrame(E, E), E["xyz" [this.indexUpAxis]] *= T.rollInfluence, o.vectorToWorldFrame(E, E), o.applyImpulse(R, E), R.scale(-1, R), d.applyImpulse(R, L)
                                }
                            }
                        };
                        var v = new i,
                            y = new i,
                            x = new i;

                        function b(t, e, n, i, r) {
                            var o = 0,
                                s = n,
                                a = v,
                                l = y,
                                c = x;
                            return t.getVelocityAtWorldPoint(s, a), e.getVelocityAtWorldPoint(s, l), a.vsub(l, c), r < (o = -i.dot(c) * (1 / (A(t, n, i) + A(e, n, i)))) && (o = r), o < -r && (o = -r), o
                        }
                        var w = new i,
                            _ = new i,
                            S = new i,
                            M = new i;

                        function A(t, e, n) {
                            var i = w,
                                r = _,
                                o = S,
                                s = M;
                            return e.vsub(t.position, i), i.cross(n, r), t.invInertiaWorld.vmult(r, s), s.cross(i, o), t.invMass + n.dot(o)
                        }
                        var T = new i,
                            E = new i,
                            C = new i;

                        function P(t, e, n, i, r, o) {
                            if (r.norm2() > 1.1) return 0;
                            var s = T,
                                a = E,
                                l = C;
                            return t.getVelocityAtWorldPoint(e, s), n.getVelocityAtWorldPoint(i, a), s.vsub(a, l), -.2 * r.dot(l) * (1 / (t.invMass + n.invMass))
                        }
                    }, {
                        "../collision/Ray": 10,
                        "../collision/RaycastResult": 11,
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../objects/WheelInfo": 37,
                        "./Body": 32
                    }],
                    34: [function(t, e, n) {
                        var i = t("./Body"),
                            r = t("../shapes/Sphere"),
                            o = t("../shapes/Box"),
                            s = t("../math/Vec3"),
                            a = t("../constraints/HingeConstraint");

                        function l(t) {
                            if (this.wheelBodies = [], this.coordinateSystem = void 0 === t.coordinateSystem ? new s(1, 2, 3) : t.coordinateSystem.clone(), this.chassisBody = t.chassisBody, !this.chassisBody) {
                                var e = new o(new s(5, 2, .5));
                                this.chassisBody = new i(1, e)
                            }
                            this.constraints = [], this.wheelAxes = [], this.wheelForces = []
                        }
                        e.exports = l, l.prototype.addWheel = function(t) {
                            var e = (t = t || {}).body;
                            e || (e = new i(1, new r(1.2))), this.wheelBodies.push(e), this.wheelForces.push(0), new s;
                            var n = void 0 !== t.position ? t.position.clone() : new s,
                                o = new s;
                            this.chassisBody.pointToWorldFrame(n, o), e.position.set(o.x, o.y, o.z);
                            var l = void 0 !== t.axis ? t.axis.clone() : new s(0, 1, 0);
                            this.wheelAxes.push(l);
                            var c = new a(this.chassisBody, e, {
                                pivotA: n,
                                axisA: l,
                                pivotB: s.ZERO,
                                axisB: l,
                                collideConnected: !1
                            });
                            return this.constraints.push(c), this.wheelBodies.length - 1
                        }, l.prototype.setSteeringValue = function(t, e) {
                            var n = this.wheelAxes[e],
                                i = Math.cos(t),
                                r = Math.sin(t),
                                o = n.x,
                                s = n.y;
                            this.constraints[e].axisA.set(i * o - r * s, r * o + i * s, 0)
                        }, l.prototype.setMotorSpeed = function(t, e) {
                            var n = this.constraints[e];
                            n.enableMotor(), n.motorTargetVelocity = t
                        }, l.prototype.disableMotor = function(t) {
                            this.constraints[t].disableMotor()
                        };
                        var c = new s;
                        l.prototype.setWheelForce = function(t, e) {
                            this.wheelForces[e] = t
                        }, l.prototype.applyWheelForce = function(t, e) {
                            var n = this.wheelAxes[e],
                                i = this.wheelBodies[e],
                                r = i.torque;
                            n.scale(t, c), i.vectorToWorldFrame(c, c), r.vadd(c, r)
                        }, l.prototype.addToWorld = function(t) {
                            for (var e = this.constraints, n = this.wheelBodies.concat([this.chassisBody]), i = 0; i < n.length; i++) t.addBody(n[i]);
                            for (i = 0; i < e.length; i++) t.addConstraint(e[i]);
                            t.addEventListener("preStep", this._update.bind(this))
                        }, l.prototype._update = function() {
                            for (var t = this.wheelForces, e = 0; e < t.length; e++) this.applyWheelForce(t[e], e)
                        }, l.prototype.removeFromWorld = function(t) {
                            for (var e = this.constraints, n = this.wheelBodies.concat([this.chassisBody]), i = 0; i < n.length; i++) t.remove(n[i]);
                            for (i = 0; i < e.length; i++) t.removeConstraint(e[i])
                        };
                        var h = new s;
                        l.prototype.getWheelSpeed = function(t) {
                            var e = this.wheelAxes[t],
                                n = this.wheelBodies[t].angularVelocity;
                            return this.chassisBody.vectorToWorldFrame(e, h), n.dot(h)
                        }
                    }, {
                        "../constraints/HingeConstraint": 16,
                        "../math/Vec3": 31,
                        "../shapes/Box": 38,
                        "../shapes/Sphere": 45,
                        "./Body": 32
                    }],
                    35: [function(t, e, n) {
                        e.exports = r, t("../shapes/Shape");
                        var i = t("../math/Vec3");

                        function r() {
                            this.particles = [], this.density = 1, this.smoothingRadius = 1, this.speedOfSound = 1, this.viscosity = .01, this.eps = 1e-6, this.pressures = [], this.densities = [], this.neighbors = []
                        }
                        t("../math/Quaternion"), t("../shapes/Particle"), t("../objects/Body"), t("../material/Material"), r.prototype.add = function(t) {
                            this.particles.push(t), this.neighbors.length < this.particles.length && this.neighbors.push([])
                        }, r.prototype.remove = function(t) {
                            var e = this.particles.indexOf(t); - 1 !== e && (this.particles.splice(e, 1), this.neighbors.length > this.particles.length && this.neighbors.pop())
                        };
                        var o = new i;
                        r.prototype.getNeighbors = function(t, e) {
                            for (var n = this.particles.length, i = t.id, r = this.smoothingRadius * this.smoothingRadius, s = o, a = 0; a !== n; a++) {
                                var l = this.particles[a];
                                l.position.vsub(t.position, s), i !== l.id && s.norm2() < r && e.push(l)
                            }
                        };
                        var s = new i,
                            a = new i,
                            l = new i,
                            c = new i,
                            h = new i,
                            u = new i;
                        r.prototype.update = function() {
                            for (var t = this.particles.length, e = s, n = this.speedOfSound, i = this.eps, r = 0; r !== t; r++) {
                                var o = this.particles[r];
                                (M = this.neighbors[r]).length = 0, this.getNeighbors(o, M), M.push(this.particles[r]);
                                for (var d = M.length, p = 0, f = 0; f !== d; f++) {
                                    o.position.vsub(M[f].position, e);
                                    var m = e.norm(),
                                        g = this.w(m);
                                    p += M[f].mass * g
                                }
                                this.densities[r] = p, this.pressures[r] = n * n * (this.densities[r] - this.density)
                            }
                            var v = a,
                                y = l,
                                x = c,
                                b = h,
                                w = u;
                            for (r = 0; r !== t; r++) {
                                var _, S, M, A = this.particles[r];
                                for (v.set(0, 0, 0), y.set(0, 0, 0), d = (M = this.neighbors[r]).length, f = 0; f !== d; f++) {
                                    var T = M[f];
                                    A.position.vsub(T.position, b);
                                    var E = b.norm();
                                    _ = -T.mass * (this.pressures[r] / (this.densities[r] * this.densities[r] + i) + this.pressures[f] / (this.densities[f] * this.densities[f] + i)), this.gradw(b, x), x.mult(_, x), v.vadd(x, v), T.velocity.vsub(A.velocity, w), w.mult(1 / (1e-4 + this.densities[r] * this.densities[f]) * this.viscosity * T.mass, w), S = this.nablaw(E), w.mult(S, w), y.vadd(w, y)
                                }
                                y.mult(A.mass, y), v.mult(A.mass, v), A.force.vadd(y, A.force), A.force.vadd(v, A.force)
                            }
                        }, r.prototype.w = function(t) {
                            var e = this.smoothingRadius;
                            return 315 / (64 * Math.PI * Math.pow(e, 9)) * Math.pow(e * e - t * t, 3)
                        }, r.prototype.gradw = function(t, e) {
                            var n = t.norm(),
                                i = this.smoothingRadius;
                            t.mult(945 / (32 * Math.PI * Math.pow(i, 9)) * Math.pow(i * i - n * n, 2), e)
                        }, r.prototype.nablaw = function(t) {
                            var e = this.smoothingRadius;
                            return 945 / (32 * Math.PI * Math.pow(e, 9)) * (e * e - t * t) * (7 * t * t - 3 * e * e)
                        }
                    }, {
                        "../material/Material": 26,
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../objects/Body": 32,
                        "../shapes/Particle": 42,
                        "../shapes/Shape": 44
                    }],
                    36: [function(t, e, n) {
                        var i = t("../math/Vec3");

                        function r(t, e, n) {
                            n = n || {}, this.restLength = "number" == typeof n.restLength ? n.restLength : 1, this.stiffness = n.stiffness || 100, this.damping = n.damping || 1, this.bodyA = t, this.bodyB = e, this.localAnchorA = new i, this.localAnchorB = new i, n.localAnchorA && this.localAnchorA.copy(n.localAnchorA), n.localAnchorB && this.localAnchorB.copy(n.localAnchorB), n.worldAnchorA && this.setWorldAnchorA(n.worldAnchorA), n.worldAnchorB && this.setWorldAnchorB(n.worldAnchorB)
                        }
                        e.exports = r, r.prototype.setWorldAnchorA = function(t) {
                            this.bodyA.pointToLocalFrame(t, this.localAnchorA)
                        }, r.prototype.setWorldAnchorB = function(t) {
                            this.bodyB.pointToLocalFrame(t, this.localAnchorB)
                        }, r.prototype.getWorldAnchorA = function(t) {
                            this.bodyA.pointToWorldFrame(this.localAnchorA, t)
                        }, r.prototype.getWorldAnchorB = function(t) {
                            this.bodyB.pointToWorldFrame(this.localAnchorB, t)
                        };
                        var o = new i,
                            s = new i,
                            a = new i,
                            l = new i,
                            c = new i,
                            h = new i,
                            u = new i,
                            d = new i,
                            p = new i,
                            f = new i,
                            m = new i;
                        r.prototype.applyForce = function() {
                            var t = this.stiffness,
                                e = this.damping,
                                n = this.restLength,
                                i = this.bodyA,
                                r = this.bodyB,
                                g = o,
                                v = s,
                                y = a,
                                x = l,
                                b = m,
                                w = c,
                                _ = h,
                                S = u,
                                M = d,
                                A = p,
                                T = f;
                            this.getWorldAnchorA(w), this.getWorldAnchorB(_), w.vsub(i.position, S), _.vsub(r.position, M), _.vsub(w, g);
                            var E = g.norm();
                            v.copy(g), v.normalize(), r.velocity.vsub(i.velocity, y), r.angularVelocity.cross(M, b), y.vadd(b, y), i.angularVelocity.cross(S, b), y.vsub(b, y), v.mult(-t * (E - n) - e * y.dot(v), x), i.force.vsub(x, i.force), r.force.vadd(x, r.force), S.cross(x, A), M.cross(x, T), i.torque.vsub(A, i.torque), r.torque.vadd(T, r.torque)
                        }
                    }, {
                        "../math/Vec3": 31
                    }],
                    37: [function(t, e, n) {
                        var i = t("../math/Vec3"),
                            r = t("../math/Transform"),
                            o = t("../collision/RaycastResult"),
                            s = t("../utils/Utils");

                        function a(t) {
                            t = s.defaults(t, {
                                chassisConnectionPointLocal: new i,
                                chassisConnectionPointWorld: new i,
                                directionLocal: new i,
                                directionWorld: new i,
                                axleLocal: new i,
                                axleWorld: new i,
                                suspensionRestLength: 1,
                                suspensionMaxLength: 2,
                                radius: 1,
                                suspensionStiffness: 100,
                                dampingCompression: 10,
                                dampingRelaxation: 10,
                                frictionSlip: 1,
                                steering: 0,
                                rotation: 0,
                                deltaRotation: 0,
                                rollInfluence: 1,
                                maxSuspensionForce: Number.MAX_VALUE,
                                isFrontWheel: !0,
                                clippedInvContactDotSuspension: 1,
                                suspensionRelativeVelocity: 0,
                                suspensionForce: 0,
                                skidInfo: 0,
                                suspensionLength: 0,
                                maxSuspensionTravel: 1,
                                useCustomSlidingRotationalSpeed: !1,
                                customSlidingRotationalSpeed: -.1
                            }), this.maxSuspensionTravel = t.maxSuspensionTravel, this.customSlidingRotationalSpeed = t.customSlidingRotationalSpeed, this.useCustomSlidingRotationalSpeed = t.useCustomSlidingRotationalSpeed, this.sliding = !1, this.chassisConnectionPointLocal = t.chassisConnectionPointLocal.clone(), this.chassisConnectionPointWorld = t.chassisConnectionPointWorld.clone(), this.directionLocal = t.directionLocal.clone(), this.directionWorld = t.directionWorld.clone(), this.axleLocal = t.axleLocal.clone(), this.axleWorld = t.axleWorld.clone(), this.suspensionRestLength = t.suspensionRestLength, this.suspensionMaxLength = t.suspensionMaxLength, this.radius = t.radius, this.suspensionStiffness = t.suspensionStiffness, this.dampingCompression = t.dampingCompression, this.dampingRelaxation = t.dampingRelaxation, this.frictionSlip = t.frictionSlip, this.steering = 0, this.rotation = 0, this.lastRotation = 0, this.deltaRotation = 0, this.rollInfluence = t.rollInfluence, this.maxSuspensionForce = t.maxSuspensionForce, this.engineForce = 0, this.brake = 0, this.isFrontWheel = t.isFrontWheel, this.clippedInvContactDotSuspension = 1, this.suspensionRelativeVelocity = 0, this.suspensionForce = 0, this.skidInfo = 0, this.suspensionLength = 0, this.lastSuspensionLength = 0, this.sideImpulse = 0, this.forwardImpulse = 0, this.raycastResult = new o, this.worldTransform = new r, this.isInContact = !1
                        }
                        e.exports = a;
                        var l = new i,
                            c = new i;
                        l = new i, a.prototype.updateWheel = function(t) {
                            var e = this.raycastResult;
                            if (this.isInContact) {
                                var n = e.hitNormalWorld.dot(e.directionWorld);
                                e.hitPointWorld.vsub(t.position, c), t.getVelocityAtWorldPoint(c, l);
                                var i = e.hitNormalWorld.dot(l);
                                if (n >= -.1) this.suspensionRelativeVelocity = 0, this.clippedInvContactDotSuspension = 10;
                                else {
                                    var r = -1 / n;
                                    this.suspensionRelativeVelocity = i * r, this.clippedInvContactDotSuspension = r
                                }
                            } else e.suspensionLength = this.suspensionRestLength, this.suspensionRelativeVelocity = 0, e.directionWorld.scale(-1, e.hitNormalWorld), this.clippedInvContactDotSuspension = 1
                        }
                    }, {
                        "../collision/RaycastResult": 11,
                        "../math/Transform": 30,
                        "../math/Vec3": 31,
                        "../utils/Utils": 54
                    }],
                    38: [function(t, e, n) {
                        e.exports = s;
                        var i = t("./Shape"),
                            r = t("../math/Vec3"),
                            o = t("./ConvexPolyhedron");

                        function s(t) {
                            i.call(this, {
                                type: i.types.BOX
                            }), this.halfExtents = t, this.convexPolyhedronRepresentation = null, this.updateConvexPolyhedronRepresentation(), this.updateBoundingSphereRadius()
                        }
                        s.prototype = new i, s.prototype.constructor = s, s.prototype.updateConvexPolyhedronRepresentation = function() {
                            var t = this.halfExtents.x,
                                e = this.halfExtents.y,
                                n = this.halfExtents.z,
                                i = r,
                                s = [new i(-t, -e, -n), new i(t, -e, -n), new i(t, e, -n), new i(-t, e, -n), new i(-t, -e, n), new i(t, -e, n), new i(t, e, n), new i(-t, e, n)],
                                a = (new i(0, 0, 1), new i(0, 1, 0), new i(1, 0, 0), new o(s, [
                                    [3, 2, 1, 0],
                                    [4, 5, 6, 7],
                                    [5, 4, 0, 1],
                                    [2, 3, 7, 6],
                                    [0, 4, 7, 3],
                                    [1, 2, 6, 5]
                                ]));
                            this.convexPolyhedronRepresentation = a, a.material = this.material
                        }, s.prototype.calculateLocalInertia = function(t, e) {
                            return e = e || new r, s.calculateInertia(this.halfExtents, t, e), e
                        }, s.calculateInertia = function(t, e, n) {
                            var i = t;
                            n.x = 1 / 12 * e * (2 * i.y * 2 * i.y + 2 * i.z * 2 * i.z), n.y = 1 / 12 * e * (2 * i.x * 2 * i.x + 2 * i.z * 2 * i.z), n.z = 1 / 12 * e * (2 * i.y * 2 * i.y + 2 * i.x * 2 * i.x)
                        }, s.prototype.getSideNormals = function(t, e) {
                            var n = t,
                                i = this.halfExtents;
                            if (n[0].set(i.x, 0, 0), n[1].set(0, i.y, 0), n[2].set(0, 0, i.z), n[3].set(-i.x, 0, 0), n[4].set(0, -i.y, 0), n[5].set(0, 0, -i.z), void 0 !== e)
                                for (var r = 0; r !== n.length; r++) e.vmult(n[r], n[r]);
                            return n
                        }, s.prototype.volume = function() {
                            return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z
                        }, s.prototype.updateBoundingSphereRadius = function() {
                            this.boundingSphereRadius = this.halfExtents.norm()
                        };
                        var a = new r;
                        new r, s.prototype.forEachWorldCorner = function(t, e, n) {
                            for (var i = this.halfExtents, r = [
                                    [i.x, i.y, i.z],
                                    [-i.x, i.y, i.z],
                                    [-i.x, -i.y, i.z],
                                    [-i.x, -i.y, -i.z],
                                    [i.x, -i.y, -i.z],
                                    [i.x, i.y, -i.z],
                                    [-i.x, i.y, -i.z],
                                    [i.x, -i.y, i.z]
                                ], o = 0; o < r.length; o++) a.set(r[o][0], r[o][1], r[o][2]), e.vmult(a, a), t.vadd(a, a), n(a.x, a.y, a.z)
                        };
                        var l = [new r, new r, new r, new r, new r, new r, new r, new r];
                        s.prototype.calculateWorldAABB = function(t, e, n, i) {
                            var r = this.halfExtents;
                            l[0].set(r.x, r.y, r.z), l[1].set(-r.x, r.y, r.z), l[2].set(-r.x, -r.y, r.z), l[3].set(-r.x, -r.y, -r.z), l[4].set(r.x, -r.y, -r.z), l[5].set(r.x, r.y, -r.z), l[6].set(-r.x, r.y, -r.z), l[7].set(r.x, -r.y, r.z);
                            var o = l[0];
                            e.vmult(o, o), t.vadd(o, o), i.copy(o), n.copy(o);
                            for (var s = 1; s < 8; s++) {
                                o = l[s], e.vmult(o, o), t.vadd(o, o);
                                var a = o.x,
                                    c = o.y,
                                    h = o.z;
                                a > i.x && (i.x = a), c > i.y && (i.y = c), h > i.z && (i.z = h), a < n.x && (n.x = a), c < n.y && (n.y = c), h < n.z && (n.z = h)
                            }
                        }
                    }, {
                        "../math/Vec3": 31,
                        "./ConvexPolyhedron": 39,
                        "./Shape": 44
                    }],
                    39: [function(t, e, n) {
                        e.exports = s;
                        var i = t("./Shape"),
                            r = t("../math/Vec3"),
                            o = (t("../math/Quaternion"), t("../math/Transform"));

                        function s(t, e, n) {
                            i.call(this, {
                                type: i.types.CONVEXPOLYHEDRON
                            }), this.vertices = t || [], this.worldVertices = [], this.worldVerticesNeedsUpdate = !0, this.faces = e || [], this.faceNormals = [], this.computeNormals(), this.worldFaceNormalsNeedsUpdate = !0, this.worldFaceNormals = [], this.uniqueEdges = [], this.uniqueAxes = n ? n.slice() : null, this.computeEdges(), this.updateBoundingSphereRadius()
                        }
                        s.prototype = new i, s.prototype.constructor = s;
                        var a = new r;
                        s.prototype.computeEdges = function() {
                            var t = this.faces,
                                e = this.vertices,
                                n = (e.length, this.uniqueEdges);
                            n.length = 0;
                            for (var i = a, r = 0; r !== t.length; r++)
                                for (var o = t[r], s = o.length, l = 0; l !== s; l++) {
                                    var c = (l + 1) % s;
                                    e[o[l]].vsub(e[o[c]], i), i.normalize();
                                    for (var h = !1, u = 0; u !== n.length; u++)
                                        if (n[u].almostEquals(i) || n[u].almostEquals(i)) {
                                            h = !0;
                                            break
                                        }
                                    h || n.push(i.clone())
                                }
                        }, s.prototype.computeNormals = function() {
                            this.faceNormals.length = this.faces.length;
                            for (var t = 0; t < this.faces.length; t++) {
                                for (var e = 0; e < this.faces[t].length; e++)
                                    if (!this.vertices[this.faces[t][e]]) throw new Error("Vertex " + this.faces[t][e] + " not found!");
                                var n = this.faceNormals[t] || new r;
                                this.getFaceNormal(t, n), n.negate(n), this.faceNormals[t] = n;
                                var i = this.vertices[this.faces[t][0]];
                                if (n.dot(i) < 0)
                                    for (e = 0; e < this.faces[t].length; e++);
                            }
                        };
                        var l = new r,
                            c = new r;
                        s.computeNormal = function(t, e, n, i) {
                            e.vsub(t, c), n.vsub(e, l), l.cross(c, i), i.isZero() || i.normalize()
                        }, s.prototype.getFaceNormal = function(t, e) {
                            var n = this.faces[t],
                                i = this.vertices[n[0]],
                                r = this.vertices[n[1]],
                                o = this.vertices[n[2]];
                            return s.computeNormal(i, r, o, e)
                        };
                        var h = new r;
                        s.prototype.clipAgainstHull = function(t, e, n, i, o, s, a, l, c) {
                            for (var u = h, d = -1, p = -Number.MAX_VALUE, f = 0; f < n.faces.length; f++) {
                                u.copy(n.faceNormals[f]), o.vmult(u, u);
                                var m = u.dot(s);
                                m > p && (p = m, d = f)
                            }
                            for (var g = [], v = n.faces[d], y = v.length, x = 0; x < y; x++) {
                                var b = n.vertices[v[x]],
                                    w = new r;
                                w.copy(b), o.vmult(w, w), i.vadd(w, w), g.push(w)
                            }
                            d >= 0 && this.clipFaceAgainstHull(s, t, e, g, a, l, c)
                        };
                        var u = new r,
                            d = new r,
                            p = new r,
                            f = new r,
                            m = new r,
                            g = new r;
                        s.prototype.findSeparatingAxis = function(t, e, n, i, r, o, s, a) {
                            var l = u,
                                c = d,
                                h = p,
                                v = f,
                                y = m,
                                x = g,
                                b = Number.MAX_VALUE;
                            if (this.uniqueAxes)
                                for (_ = 0; _ !== this.uniqueAxes.length; _++) {
                                    if (n.vmult(this.uniqueAxes[_], l), !1 === (A = this.testSepAxis(l, t, e, n, i, r))) return !1;
                                    A < b && (b = A, o.copy(l))
                                } else
                                    for (var w = s ? s.length : this.faces.length, _ = 0; _ < w; _++) {
                                        var S = s ? s[_] : _;
                                        if (l.copy(this.faceNormals[S]), n.vmult(l, l), !1 === (A = this.testSepAxis(l, t, e, n, i, r))) return !1;
                                        A < b && (b = A, o.copy(l))
                                    }
                            if (t.uniqueAxes)
                                for (_ = 0; _ !== t.uniqueAxes.length; _++) {
                                    if (r.vmult(t.uniqueAxes[_], c), !1 === (A = this.testSepAxis(c, t, e, n, i, r))) return !1;
                                    A < b && (b = A, o.copy(c))
                                } else {
                                    var M = a ? a.length : t.faces.length;
                                    for (_ = 0; _ < M; _++) {
                                        var A;
                                        if (S = a ? a[_] : _, c.copy(t.faceNormals[S]), r.vmult(c, c), !1 === (A = this.testSepAxis(c, t, e, n, i, r))) return !1;
                                        A < b && (b = A, o.copy(c))
                                    }
                                }
                            for (var T = 0; T !== this.uniqueEdges.length; T++) {
                                n.vmult(this.uniqueEdges[T], v);
                                for (var E = 0; E !== t.uniqueEdges.length; E++)
                                    if (r.vmult(t.uniqueEdges[E], y), v.cross(y, x), !x.almostZero()) {
                                        x.normalize();
                                        var C = this.testSepAxis(x, t, e, n, i, r);
                                        if (!1 === C) return !1;
                                        C < b && (b = C, o.copy(x))
                                    }
                            }
                            return i.vsub(e, h), h.dot(o) > 0 && o.negate(o), !0
                        };
                        var v = [],
                            y = [];
                        s.prototype.testSepAxis = function(t, e, n, i, r, o) {
                            s.project(this, t, n, i, v), s.project(e, t, r, o, y);
                            var a = v[0],
                                l = v[1],
                                c = y[0],
                                h = y[1];
                            if (a < h || c < l) return !1;
                            var u = a - h,
                                d = c - l;
                            return u < d ? u : d
                        };
                        var x = new r,
                            b = new r;
                        s.prototype.calculateLocalInertia = function(t, e) {
                            this.computeLocalAABB(x, b);
                            var n = b.x - x.x,
                                i = b.y - x.y,
                                r = b.z - x.z;
                            e.x = 1 / 12 * t * (2 * i * 2 * i + 2 * r * 2 * r), e.y = 1 / 12 * t * (2 * n * 2 * n + 2 * r * 2 * r), e.z = 1 / 12 * t * (2 * i * 2 * i + 2 * n * 2 * n)
                        }, s.prototype.getPlaneConstantOfFace = function(t) {
                            var e = this.faces[t],
                                n = this.faceNormals[t],
                                i = this.vertices[e[0]];
                            return -n.dot(i)
                        };
                        var w = new r,
                            _ = new r,
                            S = new r,
                            M = new r,
                            A = new r,
                            T = new r,
                            E = new r,
                            C = new r;
                        s.prototype.clipFaceAgainstHull = function(t, e, n, i, r, o, s) {
                            for (var a = w, l = _, c = S, h = M, u = A, d = T, p = E, f = C, m = i, g = [], v = -1, y = Number.MAX_VALUE, x = 0; x < this.faces.length; x++) {
                                a.copy(this.faceNormals[x]), n.vmult(a, a);
                                var b = a.dot(t);
                                b < y && (y = b, v = x)
                            }
                            if (!(v < 0)) {
                                var P = this.faces[v];
                                P.connectedFaces = [];
                                for (var L = 0; L < this.faces.length; L++)
                                    for (var R = 0; R < this.faces[L].length; R++) - 1 !== P.indexOf(this.faces[L][R]) && L !== v && -1 === P.connectedFaces.indexOf(L) && P.connectedFaces.push(L);
                                m.length;
                                for (var I = P.length, F = 0; F < I; F++) {
                                    var O = this.vertices[P[F]],
                                        N = this.vertices[P[(F + 1) % I]];
                                    O.vsub(N, l), c.copy(l), n.vmult(c, c), e.vadd(c, c), h.copy(this.faceNormals[v]), n.vmult(h, h), e.vadd(h, h), c.cross(h, u), u.negate(u), d.copy(O), n.vmult(d, d), e.vadd(d, d), d.dot(u);
                                    var B = P.connectedFaces[F];
                                    p.copy(this.faceNormals[B]);
                                    var D = this.getPlaneConstantOfFace(B);
                                    f.copy(p), n.vmult(f, f);
                                    var V = D - f.dot(e);
                                    for (this.clipFaceAgainstPlane(m, g, f, V); m.length;) m.shift();
                                    for (; g.length;) m.push(g.shift())
                                }
                                for (p.copy(this.faceNormals[v]), D = this.getPlaneConstantOfFace(v), f.copy(p), n.vmult(f, f), V = D - f.dot(e), L = 0; L < m.length; L++) {
                                    var j = f.dot(m[L]) + V;
                                    if (j <= r && (console.log("clamped: depth=" + j + " to minDist=" + r), j = r), j <= o) {
                                        var k = m[L];
                                        if (j <= 0) {
                                            var U = {
                                                point: k,
                                                normal: f,
                                                depth: j
                                            };
                                            s.push(U)
                                        }
                                    }
                                }
                            }
                        }, s.prototype.clipFaceAgainstPlane = function(t, e, n, i) {
                            var o, s, a = t.length;
                            if (a < 2) return e;
                            var l = t[t.length - 1],
                                c = t[0];
                            o = n.dot(l) + i;
                            for (var h = 0; h < a; h++) {
                                if (c = t[h], s = n.dot(c) + i, o < 0)
                                    if (s < 0)(u = new r).copy(c), e.push(u);
                                    else {
                                        var u = new r;
                                        l.lerp(c, o / (o - s), u), e.push(u)
                                    }
                                else s < 0 && (u = new r, l.lerp(c, o / (o - s), u), e.push(u), e.push(c));
                                l = c, o = s
                            }
                            return e
                        }, s.prototype.computeWorldVertices = function(t, e) {
                            for (var n = this.vertices.length; this.worldVertices.length < n;) this.worldVertices.push(new r);
                            for (var i = this.vertices, o = this.worldVertices, s = 0; s !== n; s++) e.vmult(i[s], o[s]), t.vadd(o[s], o[s]);
                            this.worldVerticesNeedsUpdate = !1
                        }, new r, s.prototype.computeLocalAABB = function(t, e) {
                            var n = this.vertices.length,
                                i = this.vertices;
                            t.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), e.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                            for (var r = 0; r < n; r++) {
                                var o = i[r];
                                o.x < t.x ? t.x = o.x : o.x > e.x && (e.x = o.x), o.y < t.y ? t.y = o.y : o.y > e.y && (e.y = o.y), o.z < t.z ? t.z = o.z : o.z > e.z && (e.z = o.z)
                            }
                        }, s.prototype.computeWorldFaceNormals = function(t) {
                            for (var e = this.faceNormals.length; this.worldFaceNormals.length < e;) this.worldFaceNormals.push(new r);
                            for (var n = this.faceNormals, i = this.worldFaceNormals, o = 0; o !== e; o++) t.vmult(n[o], i[o]);
                            this.worldFaceNormalsNeedsUpdate = !1
                        }, s.prototype.updateBoundingSphereRadius = function() {
                            for (var t = 0, e = this.vertices, n = 0, i = e.length; n !== i; n++) {
                                var r = e[n].norm2();
                                r > t && (t = r)
                            }
                            this.boundingSphereRadius = Math.sqrt(t)
                        };
                        var P = new r;
                        s.prototype.calculateWorldAABB = function(t, e, n, i) {
                            for (var r, o, s, a, l, c, h = this.vertices.length, u = this.vertices, d = 0; d < h; d++) {
                                P.copy(u[d]), e.vmult(P, P), t.vadd(P, P);
                                var p = P;
                                (p.x < r || void 0 === r) && (r = p.x), (p.x > a || void 0 === a) && (a = p.x), (p.y < o || void 0 === o) && (o = p.y), (p.y > l || void 0 === l) && (l = p.y), (p.z < s || void 0 === s) && (s = p.z), (p.z > c || void 0 === c) && (c = p.z)
                            }
                            n.set(r, o, s), i.set(a, l, c)
                        }, s.prototype.volume = function() {
                            return 4 * Math.PI * this.boundingSphereRadius / 3
                        }, s.prototype.getAveragePointLocal = function(t) {
                            t = t || new r;
                            for (var e = this.vertices.length, n = this.vertices, i = 0; i < e; i++) t.vadd(n[i], t);
                            return t.mult(1 / e, t), t
                        }, s.prototype.transformAllPoints = function(t, e) {
                            var n = this.vertices.length,
                                i = this.vertices;
                            if (e) {
                                for (var r = 0; r < n; r++) {
                                    var o = i[r];
                                    e.vmult(o, o)
                                }
                                for (r = 0; r < this.faceNormals.length; r++) o = this.faceNormals[r], e.vmult(o, o)
                            }
                            if (t)
                                for (r = 0; r < n; r++)(o = i[r]).vadd(t, o)
                        };
                        var L = new r,
                            R = new r,
                            I = new r;
                        s.prototype.pointIsInside = function(t) {
                            var e = this.vertices.length,
                                n = this.vertices,
                                i = this.faces,
                                r = this.faceNormals,
                                o = this.faces.length,
                                s = L;
                            this.getAveragePointLocal(s);
                            for (var a = 0; a < o; a++) {
                                this.faces[a].length, e = r[a];
                                var l = n[i[a][0]],
                                    c = R;
                                t.vsub(l, c);
                                var h = e.dot(c),
                                    u = I;
                                s.vsub(l, u);
                                var d = e.dot(u);
                                if (h < 0 && d > 0 || h > 0 && d < 0) return !1
                            }
                            return -1
                        }, new r;
                        var F = new r,
                            O = new r;
                        s.project = function(t, e, n, i, r) {
                            var s = t.vertices.length,
                                a = F,
                                l = 0,
                                c = 0,
                                h = O,
                                u = t.vertices;
                            h.setZero(), o.vectorToLocalFrame(n, i, e, a), o.pointToLocalFrame(n, i, h, h);
                            var d = h.dot(a);
                            c = l = u[0].dot(a);
                            for (var p = 1; p < s; p++) {
                                var f = u[p].dot(a);
                                f > l && (l = f), f < c && (c = f)
                            }
                            if ((c -= d) > (l -= d)) {
                                var m = c;
                                c = l, l = m
                            }
                            r[0] = l, r[1] = c
                        }
                    }, {
                        "../math/Quaternion": 29,
                        "../math/Transform": 30,
                        "../math/Vec3": 31,
                        "./Shape": 44
                    }],
                    40: [function(t, e, n) {
                        e.exports = o, t("./Shape");
                        var i = t("../math/Vec3"),
                            r = (t("../math/Quaternion"), t("./ConvexPolyhedron"));

                        function o(t, e, n, o) {
                            var s = o,
                                a = [],
                                l = [],
                                c = [],
                                h = [],
                                u = [],
                                d = Math.cos,
                                p = Math.sin;
                            a.push(new i(e * d(0), e * p(0), .5 * -n)), h.push(0), a.push(new i(t * d(0), t * p(0), .5 * n)), u.push(1);
                            for (var f = 0; f < s; f++) {
                                var m = 2 * Math.PI / s * (f + 1),
                                    g = 2 * Math.PI / s * (f + .5);
                                f < s - 1 ? (a.push(new i(e * d(m), e * p(m), .5 * -n)), h.push(2 * f + 2), a.push(new i(t * d(m), t * p(m), .5 * n)), u.push(2 * f + 3), c.push([2 * f + 2, 2 * f + 3, 2 * f + 1, 2 * f])) : c.push([0, 1, 2 * f + 1, 2 * f]), (s % 2 == 1 || f < s / 2) && l.push(new i(d(g), p(g), 0))
                            }
                            c.push(u), l.push(new i(0, 0, 1));
                            var v = [];
                            for (f = 0; f < h.length; f++) v.push(h[h.length - f - 1]);
                            c.push(v), r.call(this, a, c, l)
                        }
                        o.prototype = new r
                    }, {
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "./ConvexPolyhedron": 39,
                        "./Shape": 44
                    }],
                    41: [function(t, e, n) {
                        var i = t("./Shape"),
                            r = t("./ConvexPolyhedron"),
                            o = t("../math/Vec3"),
                            s = t("../utils/Utils");

                        function a(t, e) {
                            e = s.defaults(e, {
                                maxValue: null,
                                minValue: null,
                                elementSize: 1
                            }), this.data = t, this.maxValue = e.maxValue, this.minValue = e.minValue, this.elementSize = e.elementSize, null === e.minValue && this.updateMinValue(), null === e.maxValue && this.updateMaxValue(), this.cacheEnabled = !0, i.call(this, {
                                type: i.types.HEIGHTFIELD
                            }), this.pillarConvex = new r, this.pillarOffset = new o, this.updateBoundingSphereRadius(), this._cachedPillars = {}
                        }
                        e.exports = a, a.prototype = new i, a.prototype.update = function() {
                            this._cachedPillars = {}
                        }, a.prototype.updateMinValue = function() {
                            for (var t = this.data, e = t[0][0], n = 0; n !== t.length; n++)
                                for (var i = 0; i !== t[n].length; i++) {
                                    var r = t[n][i];
                                    r < e && (e = r)
                                }
                            this.minValue = e
                        }, a.prototype.updateMaxValue = function() {
                            for (var t = this.data, e = t[0][0], n = 0; n !== t.length; n++)
                                for (var i = 0; i !== t[n].length; i++) {
                                    var r = t[n][i];
                                    r > e && (e = r)
                                }
                            this.maxValue = e
                        }, a.prototype.setHeightValueAtIndex = function(t, e, n) {
                            this.data[t][e] = n, this.clearCachedConvexTrianglePillar(t, e, !1), t > 0 && (this.clearCachedConvexTrianglePillar(t - 1, e, !0), this.clearCachedConvexTrianglePillar(t - 1, e, !1)), e > 0 && (this.clearCachedConvexTrianglePillar(t, e - 1, !0), this.clearCachedConvexTrianglePillar(t, e - 1, !1)), e > 0 && t > 0 && this.clearCachedConvexTrianglePillar(t - 1, e - 1, !0)
                        }, a.prototype.getRectMinMax = function(t, e, n, i, r) {
                            r = r || [];
                            for (var o = this.data, s = this.minValue, a = t; a <= n; a++)
                                for (var l = e; l <= i; l++) {
                                    var c = o[a][l];
                                    c > s && (s = c)
                                }
                            r[0] = this.minValue, r[1] = s
                        }, a.prototype.getIndexOfPosition = function(t, e, n, i) {
                            var r = this.elementSize,
                                o = this.data,
                                s = Math.floor(t / r),
                                a = Math.floor(e / r);
                            return n[0] = s, n[1] = a, i && (s < 0 && (s = 0), a < 0 && (a = 0), s >= o.length - 1 && (s = o.length - 1), a >= o[0].length - 1 && (a = o[0].length - 1)), !(s < 0 || a < 0 || s >= o.length - 1 || a >= o[0].length - 1)
                        };
                        var l = [],
                            c = new o,
                            h = new o,
                            u = new o,
                            d = new o;
                        a.prototype.getTriangleAt = function(t, e, n, i, r, o) {
                            var s = l;
                            this.getIndexOfPosition(t, e, s, n);
                            var a = s[0],
                                c = s[1],
                                h = this.data;
                            n && (a = Math.min(h.length - 2, Math.max(0, a)), c = Math.min(h[0].length - 2, Math.max(0, c)));
                            var u = this.elementSize,
                                d = Math.pow(t / u - a, 2) + Math.pow(e / u - c, 2) > Math.pow(t / u - (a + 1), 2) + Math.pow(e / u - (c + 1), 2);
                            return this.getTriangle(a, c, d, i, r, o), d
                        };
                        var p = new o,
                            f = new o,
                            m = new o,
                            g = new o,
                            v = new o;
                        a.prototype.getNormalAt = function(t, e, n, i) {
                            var r = p,
                                o = f,
                                s = m,
                                a = g,
                                l = v;
                            this.getTriangleAt(t, e, n, r, o, s), o.vsub(r, a), s.vsub(r, l), a.cross(l, i), i.normalize()
                        }, a.prototype.getAabbAtIndex = function(t, e, n) {
                            var i = this.data,
                                r = this.elementSize;
                            n.lowerBound.set(t * r, e * r, i[t][e]), n.upperBound.set((t + 1) * r, (e + 1) * r, i[t + 1][e + 1])
                        }, a.prototype.getHeightAt = function(t, e, n) {
                            var i = this.data,
                                r = h,
                                o = u,
                                s = d,
                                a = l;
                            this.getIndexOfPosition(t, e, a, n);
                            var p = a[0],
                                f = a[1];
                            n && (p = Math.min(i.length - 2, Math.max(0, p)), f = Math.min(i[0].length - 2, Math.max(0, f)));
                            var m = this.getTriangleAt(t, e, n, r, o, s);
                            ! function(t, e, n, i, r, o, s, a, l) {
                                l.x = ((o - a) * (t - s) + (s - r) * (e - a)) / ((o - a) * (n - s) + (s - r) * (i - a)), l.y = ((a - i) * (t - s) + (n - s) * (e - a)) / ((o - a) * (n - s) + (s - r) * (i - a)), l.z = 1 - l.x - l.y
                            }(t, e, r.x, r.y, o.x, o.y, s.x, s.y, c);
                            var g = c;
                            return m ? i[p + 1][f + 1] * g.x + i[p][f + 1] * g.y + i[p + 1][f] * g.z : i[p][f] * g.x + i[p + 1][f] * g.y + i[p][f + 1] * g.z
                        }, a.prototype.getCacheConvexTrianglePillarKey = function(t, e, n) {
                            return t + "_" + e + "_" + (n ? 1 : 0)
                        }, a.prototype.getCachedConvexTrianglePillar = function(t, e, n) {
                            return this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, n)]
                        }, a.prototype.setCachedConvexTrianglePillar = function(t, e, n, i, r) {
                            this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, n)] = {
                                convex: i,
                                offset: r
                            }
                        }, a.prototype.clearCachedConvexTrianglePillar = function(t, e, n) {
                            delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, n)]
                        }, a.prototype.getTriangle = function(t, e, n, i, r, o) {
                            var s = this.data,
                                a = this.elementSize;
                            n ? (i.set((t + 1) * a, (e + 1) * a, s[t + 1][e + 1]), r.set(t * a, (e + 1) * a, s[t][e + 1]), o.set((t + 1) * a, e * a, s[t + 1][e])) : (i.set(t * a, e * a, s[t][e]), r.set((t + 1) * a, e * a, s[t + 1][e]), o.set(t * a, (e + 1) * a, s[t][e + 1]))
                        }, a.prototype.getConvexTrianglePillar = function(t, e, n) {
                            var i = this.pillarConvex,
                                s = this.pillarOffset;
                            if (this.cacheEnabled) {
                                if (a = this.getCachedConvexTrianglePillar(t, e, n)) return this.pillarConvex = a.convex, void(this.pillarOffset = a.offset);
                                i = new r, s = new o, this.pillarConvex = i, this.pillarOffset = s
                            }
                            var a = this.data,
                                l = this.elementSize,
                                c = i.faces;
                            i.vertices.length = 6;
                            for (var h = 0; h < 6; h++) i.vertices[h] || (i.vertices[h] = new o);
                            for (c.length = 5, h = 0; h < 5; h++) c[h] || (c[h] = []);
                            var u = i.vertices,
                                d = (Math.min(a[t][e], a[t + 1][e], a[t][e + 1], a[t + 1][e + 1]) - this.minValue) / 2 + this.minValue;
                            n ? (s.set((t + .75) * l, (e + .75) * l, d), u[0].set(.25 * l, .25 * l, a[t + 1][e + 1] - d), u[1].set(-.75 * l, .25 * l, a[t][e + 1] - d), u[2].set(.25 * l, -.75 * l, a[t + 1][e] - d), u[3].set(.25 * l, .25 * l, -d - 1), u[4].set(-.75 * l, .25 * l, -d - 1), u[5].set(.25 * l, -.75 * l, -d - 1), c[0][0] = 0, c[0][1] = 1, c[0][2] = 2, c[1][0] = 5, c[1][1] = 4, c[1][2] = 3, c[2][0] = 2, c[2][1] = 5, c[2][2] = 3, c[2][3] = 0, c[3][0] = 3, c[3][1] = 4, c[3][2] = 1, c[3][3] = 0, c[4][0] = 1, c[4][1] = 4, c[4][2] = 5, c[4][3] = 2) : (s.set((t + .25) * l, (e + .25) * l, d), u[0].set(-.25 * l, -.25 * l, a[t][e] - d), u[1].set(.75 * l, -.25 * l, a[t + 1][e] - d), u[2].set(-.25 * l, .75 * l, a[t][e + 1] - d), u[3].set(-.25 * l, -.25 * l, -d - 1), u[4].set(.75 * l, -.25 * l, -d - 1), u[5].set(-.25 * l, .75 * l, -d - 1), c[0][0] = 0, c[0][1] = 1, c[0][2] = 2, c[1][0] = 5, c[1][1] = 4, c[1][2] = 3, c[2][0] = 0, c[2][1] = 2, c[2][2] = 5, c[2][3] = 3, c[3][0] = 1, c[3][1] = 0, c[3][2] = 3, c[3][3] = 4, c[4][0] = 4, c[4][1] = 5, c[4][2] = 2, c[4][3] = 1), i.computeNormals(), i.computeEdges(), i.updateBoundingSphereRadius(), this.setCachedConvexTrianglePillar(t, e, n, i, s)
                        }, a.prototype.calculateLocalInertia = function(t, e) {
                            return (e = e || new o).set(0, 0, 0), e
                        }, a.prototype.volume = function() {
                            return Number.MAX_VALUE
                        }, a.prototype.calculateWorldAABB = function(t, e, n, i) {
                            n.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), i.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)
                        }, a.prototype.updateBoundingSphereRadius = function() {
                            var t = this.data,
                                e = this.elementSize;
                            this.boundingSphereRadius = new o(t.length * e, t[0].length * e, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm()
                        }, a.prototype.setHeightsFromImage = function(t, e) {
                            var n = document.createElement("canvas");
                            n.width = t.width, n.height = t.height;
                            var i = n.getContext("2d");
                            i.drawImage(t, 0, 0);
                            var r = i.getImageData(0, 0, t.width, t.height),
                                o = this.data;
                            o.length = 0, this.elementSize = Math.abs(e.x) / r.width;
                            for (var s = 0; s < r.height; s++) {
                                for (var a = [], l = 0; l < r.width; l++) {
                                    var c = (r.data[4 * (s * r.height + l)] + r.data[4 * (s * r.height + l) + 1] + r.data[4 * (s * r.height + l) + 2]) / 4 / 255 * e.z;
                                    e.x < 0 ? a.push(c) : a.unshift(c)
                                }
                                e.y < 0 ? o.unshift(a) : o.push(a)
                            }
                            this.updateMaxValue(), this.updateMinValue(), this.update()
                        }
                    }, {
                        "../math/Vec3": 31,
                        "../utils/Utils": 54,
                        "./ConvexPolyhedron": 39,
                        "./Shape": 44
                    }],
                    42: [function(t, e, n) {
                        e.exports = o;
                        var i = t("./Shape"),
                            r = t("../math/Vec3");

                        function o() {
                            i.call(this, {
                                type: i.types.PARTICLE
                            })
                        }
                        o.prototype = new i, o.prototype.constructor = o, o.prototype.calculateLocalInertia = function(t, e) {
                            return (e = e || new r).set(0, 0, 0), e
                        }, o.prototype.volume = function() {
                            return 0
                        }, o.prototype.updateBoundingSphereRadius = function() {
                            this.boundingSphereRadius = 0
                        }, o.prototype.calculateWorldAABB = function(t, e, n, i) {
                            n.copy(t), i.copy(t)
                        }
                    }, {
                        "../math/Vec3": 31,
                        "./Shape": 44
                    }],
                    43: [function(t, e, n) {
                        e.exports = o;
                        var i = t("./Shape"),
                            r = t("../math/Vec3");

                        function o() {
                            i.call(this, {
                                type: i.types.PLANE
                            }), this.worldNormal = new r, this.worldNormalNeedsUpdate = !0, this.boundingSphereRadius = Number.MAX_VALUE
                        }
                        o.prototype = new i, o.prototype.constructor = o, o.prototype.computeWorldNormal = function(t) {
                            var e = this.worldNormal;
                            e.set(0, 0, 1), t.vmult(e, e), this.worldNormalNeedsUpdate = !1
                        }, o.prototype.calculateLocalInertia = function(t, e) {
                            return e || new r
                        }, o.prototype.volume = function() {
                            return Number.MAX_VALUE
                        };
                        var s = new r;
                        o.prototype.calculateWorldAABB = function(t, e, n, i) {
                            s.set(0, 0, 1), e.vmult(s, s);
                            var r = Number.MAX_VALUE;
                            n.set(-r, -r, -r), i.set(r, r, r), 1 === s.x && (i.x = t.x), 1 === s.y && (i.y = t.y), 1 === s.z && (i.z = t.z), -1 === s.x && (n.x = t.x), -1 === s.y && (n.y = t.y), -1 === s.z && (n.z = t.z)
                        }, o.prototype.updateBoundingSphereRadius = function() {
                            this.boundingSphereRadius = Number.MAX_VALUE
                        }
                    }, {
                        "../math/Vec3": 31,
                        "./Shape": 44
                    }],
                    44: [function(t, e, n) {
                        e.exports = i;
                        var i = t("./Shape");

                        function i(t) {
                            t = t || {}, this.id = i.idCounter++, this.type = t.type || 0, this.boundingSphereRadius = 0, this.collisionResponse = !t.collisionResponse || t.collisionResponse, this.collisionFilterGroup = void 0 !== t.collisionFilterGroup ? t.collisionFilterGroup : 1, this.collisionFilterMask = void 0 !== t.collisionFilterMask ? t.collisionFilterMask : -1, this.material = t.material ? t.material : null, this.body = null
                        }
                        t("../math/Vec3"), t("../math/Quaternion"), t("../material/Material"), i.prototype.constructor = i, i.prototype.updateBoundingSphereRadius = function() {
                            throw "computeBoundingSphereRadius() not implemented for shape type " + this.type
                        }, i.prototype.volume = function() {
                            throw "volume() not implemented for shape type " + this.type
                        }, i.prototype.calculateLocalInertia = function(t, e) {
                            throw "calculateLocalInertia() not implemented for shape type " + this.type
                        }, i.idCounter = 0, i.types = {
                            SPHERE: 1,
                            PLANE: 2,
                            BOX: 4,
                            COMPOUND: 8,
                            CONVEXPOLYHEDRON: 16,
                            HEIGHTFIELD: 32,
                            PARTICLE: 64,
                            CYLINDER: 128,
                            TRIMESH: 256
                        }
                    }, {
                        "../material/Material": 26,
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "./Shape": 44
                    }],
                    45: [function(t, e, n) {
                        e.exports = o;
                        var i = t("./Shape"),
                            r = t("../math/Vec3");

                        function o(t) {
                            if (i.call(this, {
                                    type: i.types.SPHERE
                                }), this.radius = void 0 !== t ? t : 1, this.radius < 0) throw new Error("The sphere radius cannot be negative.");
                            this.updateBoundingSphereRadius()
                        }
                        o.prototype = new i, o.prototype.constructor = o, o.prototype.calculateLocalInertia = function(t, e) {
                            e = e || new r;
                            var n = 2 * t * this.radius * this.radius / 5;
                            return e.x = n, e.y = n, e.z = n, e
                        }, o.prototype.volume = function() {
                            return 4 * Math.PI * Math.pow(this.radius, 3) / 3
                        }, o.prototype.updateBoundingSphereRadius = function() {
                            this.boundingSphereRadius = this.radius
                        }, o.prototype.calculateWorldAABB = function(t, e, n, i) {
                            for (var r = this.radius, o = ["x", "y", "z"], s = 0; s < o.length; s++) {
                                var a = o[s];
                                n[a] = t[a] - r, i[a] = t[a] + r
                            }
                        }
                    }, {
                        "../math/Vec3": 31,
                        "./Shape": 44
                    }],
                    46: [function(t, e, n) {
                        e.exports = l;
                        var i = t("./Shape"),
                            r = t("../math/Vec3"),
                            o = (t("../math/Quaternion"), t("../math/Transform")),
                            s = t("../collision/AABB"),
                            a = t("../utils/Octree");

                        function l(t, e) {
                            i.call(this, {
                                type: i.types.TRIMESH
                            }), this.vertices = new Float32Array(t), this.indices = new Int16Array(e), this.normals = new Float32Array(e.length), this.aabb = new s, this.edges = null, this.scale = new r(1, 1, 1), this.tree = new a, this.updateEdges(), this.updateNormals(), this.updateAABB(), this.updateBoundingSphereRadius(), this.updateTree()
                        }
                        l.prototype = new i, l.prototype.constructor = l;
                        var c = new r;
                        l.prototype.updateTree = function() {
                            var t = this.tree;
                            t.reset(), t.aabb.copy(this.aabb);
                            var e = this.scale;
                            t.aabb.lowerBound.x *= 1 / e.x, t.aabb.lowerBound.y *= 1 / e.y, t.aabb.lowerBound.z *= 1 / e.z, t.aabb.upperBound.x *= 1 / e.x, t.aabb.upperBound.y *= 1 / e.y, t.aabb.upperBound.z *= 1 / e.z;
                            for (var n = new s, i = new r, o = new r, a = new r, l = [i, o, a], c = 0; c < this.indices.length / 3; c++) {
                                var h = 3 * c;
                                this._getUnscaledVertex(this.indices[h], i), this._getUnscaledVertex(this.indices[h + 1], o), this._getUnscaledVertex(this.indices[h + 2], a), n.setFromPoints(l), t.insert(n, c)
                            }
                            t.removeEmptyNodes()
                        };
                        var h = new s;
                        l.prototype.getTrianglesInAABB = function(t, e) {
                            h.copy(t);
                            var n = this.scale,
                                i = n.x,
                                r = n.y,
                                o = n.z,
                                s = h.lowerBound,
                                a = h.upperBound;
                            return s.x /= i, s.y /= r, s.z /= o, a.x /= i, a.y /= r, a.z /= o, this.tree.aabbQuery(h, e)
                        }, l.prototype.setScale = function(t) {
                            var e = this.scale.x === this.scale.y === this.scale.z,
                                n = t.x === t.y === t.z;
                            e && n || this.updateNormals(), this.scale.copy(t), this.updateAABB(), this.updateBoundingSphereRadius()
                        }, l.prototype.updateNormals = function() {
                            for (var t = c, e = this.normals, n = 0; n < this.indices.length / 3; n++) {
                                var i = 3 * n,
                                    r = this.indices[i],
                                    o = this.indices[i + 1],
                                    s = this.indices[i + 2];
                                this.getVertex(r, m), this.getVertex(o, g), this.getVertex(s, v), l.computeNormal(g, m, v, t), e[i] = t.x, e[i + 1] = t.y, e[i + 2] = t.z
                            }
                        }, l.prototype.updateEdges = function() {
                            for (var t = {}, e = function(e, n) {
                                    t[r < o ? r + "_" + o : o + "_" + r] = !0
                                }, n = 0; n < this.indices.length / 3; n++) {
                                var i = 3 * n,
                                    r = this.indices[i],
                                    o = this.indices[i + 1];
                                this.indices[i + 2], e(), e(), e()
                            }
                            var s = Object.keys(t);
                            for (this.edges = new Int16Array(2 * s.length), n = 0; n < s.length; n++) {
                                var a = s[n].split("_");
                                this.edges[2 * n] = parseInt(a[0], 10), this.edges[2 * n + 1] = parseInt(a[1], 10)
                            }
                        }, l.prototype.getEdgeVertex = function(t, e, n) {
                            var i = this.edges[2 * t + (e ? 1 : 0)];
                            this.getVertex(i, n)
                        };
                        var u = new r,
                            d = new r;
                        l.prototype.getEdgeVector = function(t, e) {
                            var n = u,
                                i = d;
                            this.getEdgeVertex(t, 0, n), this.getEdgeVertex(t, 1, i), i.vsub(n, e)
                        };
                        var p = new r,
                            f = new r;
                        l.computeNormal = function(t, e, n, i) {
                            e.vsub(t, f), n.vsub(e, p), p.cross(f, i), i.isZero() || i.normalize()
                        };
                        var m = new r,
                            g = new r,
                            v = new r;
                        l.prototype.getVertex = function(t, e) {
                            var n = this.scale;
                            return this._getUnscaledVertex(t, e), e.x *= n.x, e.y *= n.y, e.z *= n.z, e
                        }, l.prototype._getUnscaledVertex = function(t, e) {
                            var n = 3 * t,
                                i = this.vertices;
                            return e.set(i[n], i[n + 1], i[n + 2])
                        }, l.prototype.getWorldVertex = function(t, e, n, i) {
                            return this.getVertex(t, i), o.pointToWorldFrame(e, n, i, i), i
                        }, l.prototype.getTriangleVertices = function(t, e, n, i) {
                            var r = 3 * t;
                            this.getVertex(this.indices[r], e), this.getVertex(this.indices[r + 1], n), this.getVertex(this.indices[r + 2], i)
                        }, l.prototype.getNormal = function(t, e) {
                            var n = 3 * t;
                            return e.set(this.normals[n], this.normals[n + 1], this.normals[n + 2])
                        };
                        var y = new s;
                        l.prototype.calculateLocalInertia = function(t, e) {
                            this.computeLocalAABB(y);
                            var n = y.upperBound.x - y.lowerBound.x,
                                i = y.upperBound.y - y.lowerBound.y,
                                r = y.upperBound.z - y.lowerBound.z;
                            return e.set(1 / 12 * t * (2 * i * 2 * i + 2 * r * 2 * r), 1 / 12 * t * (2 * n * 2 * n + 2 * r * 2 * r), 1 / 12 * t * (2 * i * 2 * i + 2 * n * 2 * n))
                        };
                        var x = new r;
                        l.prototype.computeLocalAABB = function(t) {
                            var e = t.lowerBound,
                                n = t.upperBound,
                                i = this.vertices.length,
                                r = (this.vertices, x);
                            this.getVertex(0, r), e.copy(r), n.copy(r);
                            for (var o = 0; o !== i; o++) this.getVertex(o, r), r.x < e.x ? e.x = r.x : r.x > n.x && (n.x = r.x), r.y < e.y ? e.y = r.y : r.y > n.y && (n.y = r.y), r.z < e.z ? e.z = r.z : r.z > n.z && (n.z = r.z)
                        }, l.prototype.updateAABB = function() {
                            this.computeLocalAABB(this.aabb)
                        }, l.prototype.updateBoundingSphereRadius = function() {
                            for (var t = 0, e = this.vertices, n = new r, i = 0, o = e.length / 3; i !== o; i++) {
                                this.getVertex(i, n);
                                var s = n.norm2();
                                s > t && (t = s)
                            }
                            this.boundingSphereRadius = Math.sqrt(t)
                        }, new r;
                        var b = new o,
                            w = new s;
                        l.prototype.calculateWorldAABB = function(t, e, n, i) {
                            var r = b,
                                o = w;
                            r.position = t, r.quaternion = e, this.aabb.toWorldFrame(r, o), n.copy(o.lowerBound), i.copy(o.upperBound)
                        }, l.prototype.volume = function() {
                            return 4 * Math.PI * this.boundingSphereRadius / 3
                        }, l.createTorus = function(t, e, n, i, r) {
                            t = t || 1, e = e || .5, n = n || 8, i = i || 6, r = r || 2 * Math.PI;
                            for (var o = [], s = [], a = 0; a <= n; a++)
                                for (var c = 0; c <= i; c++) {
                                    var h = c / i * r,
                                        u = a / n * Math.PI * 2,
                                        d = (t + e * Math.cos(u)) * Math.cos(h),
                                        p = (t + e * Math.cos(u)) * Math.sin(h),
                                        f = e * Math.sin(u);
                                    o.push(d, p, f)
                                }
                            for (a = 1; a <= n; a++)
                                for (c = 1; c <= i; c++) {
                                    var m = (i + 1) * a + c - 1,
                                        g = (i + 1) * (a - 1) + c - 1,
                                        v = (i + 1) * (a - 1) + c,
                                        y = (i + 1) * a + c;
                                    s.push(m, g, y), s.push(g, v, y)
                                }
                            return new l(o, s)
                        }
                    }, {
                        "../collision/AABB": 3,
                        "../math/Quaternion": 29,
                        "../math/Transform": 30,
                        "../math/Vec3": 31,
                        "../utils/Octree": 51,
                        "./Shape": 44
                    }],
                    47: [function(t, e, n) {
                        e.exports = r, t("../math/Vec3"), t("../math/Quaternion");
                        var i = t("./Solver");

                        function r() {
                            i.call(this), this.iterations = 10, this.tolerance = 1e-7
                        }
                        r.prototype = new i;
                        var o = [],
                            s = [],
                            a = [];
                        r.prototype.solve = function(t, e) {
                            var n, i, r, l, c, h = 0,
                                u = this.iterations,
                                d = this.tolerance * this.tolerance,
                                p = this.equations,
                                f = p.length,
                                m = e.bodies,
                                g = m.length,
                                v = t;
                            if (0 !== f)
                                for (var y = 0; y !== g; y++) m[y].updateSolveMassProperties();
                            var x = s,
                                b = a,
                                w = o;
                            for (x.length = f, b.length = f, w.length = f, y = 0; y !== f; y++) {
                                var _ = p[y];
                                w[y] = 0, b[y] = _.computeB(v), x[y] = 1 / _.computeC()
                            }
                            if (0 !== f) {
                                for (y = 0; y !== g; y++) {
                                    var S = (T = m[y]).vlambda,
                                        M = T.wlambda;
                                    S.set(0, 0, 0), M.set(0, 0, 0)
                                }
                                for (h = 0; h !== u; h++) {
                                    l = 0;
                                    for (var A = 0; A !== f; A++) _ = p[A], n = b[A], i = x[A], (c = w[A]) + (r = i * (n - _.computeGWlambda() - _.eps * c)) < _.minForce ? r = _.minForce - c : c + r > _.maxForce && (r = _.maxForce - c), w[A] += r, l += r > 0 ? r : -r, _.addToWlambda(r);
                                    if (l * l < d) break
                                }
                                for (y = 0; y !== g; y++) {
                                    var T, E = (T = m[y]).velocity,
                                        C = T.angularVelocity;
                                    T.vlambda.vmul(T.linearFactor, T.vlambda), E.vadd(T.vlambda, E), T.wlambda.vmul(T.angularFactor, T.wlambda), C.vadd(T.wlambda, C)
                                }
                                for (var P = p.length, L = 1 / v; P--;) p[P].multiplier = w[P] * L
                            }
                            return h
                        }
                    }, {
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "./Solver": 48
                    }],
                    48: [function(t, e, n) {
                        function i() {
                            this.equations = []
                        }
                        e.exports = i, i.prototype.solve = function(t, e) {
                            return 0
                        }, i.prototype.addEquation = function(t) {
                            t.enabled && this.equations.push(t)
                        }, i.prototype.removeEquation = function(t) {
                            var e = this.equations,
                                n = e.indexOf(t); - 1 !== n && e.splice(n, 1)
                        }, i.prototype.removeAllEquations = function() {
                            this.equations.length = 0
                        }
                    }, {}],
                    49: [function(t, e, n) {
                        e.exports = o, t("../math/Vec3"), t("../math/Quaternion");
                        var i = t("./Solver"),
                            r = t("../objects/Body");

                        function o(t) {
                            for (i.call(this), this.iterations = 10, this.tolerance = 1e-7, this.subsolver = t, this.nodes = [], this.nodePool = []; this.nodePool.length < 128;) this.nodePool.push(this.createNode())
                        }
                        o.prototype = new i;
                        var s = [],
                            a = [],
                            l = {
                                bodies: []
                            },
                            c = r.STATIC;

                        function h(t) {
                            for (var e = t.length, n = 0; n !== e; n++) {
                                var i = t[n];
                                if (!(i.visited || i.body.type & c)) return i
                            }
                            return !1
                        }
                        var u = [];

                        function d(t, e, n, i) {
                            for (u.push(t), t.visited = !0, e(t, n, i); u.length;)
                                for (var r, o = u.pop(); r = h(o.children);) r.visited = !0, e(r, n, i), u.push(r)
                        }

                        function p(t, e, n) {
                            e.push(t.body);
                            for (var i = t.eqs.length, r = 0; r !== i; r++) {
                                var o = t.eqs[r]; - 1 === n.indexOf(o) && n.push(o)
                            }
                        }

                        function f(t, e) {
                            return e.id - t.id
                        }
                        o.prototype.createNode = function() {
                            return {
                                body: null,
                                children: [],
                                eqs: [],
                                visited: !1
                            }
                        }, o.prototype.solve = function(t, e) {
                            for (var n = s, i = this.nodePool, r = e.bodies, o = this.equations, c = o.length, u = r.length, m = this.subsolver; i.length < u;) i.push(this.createNode());
                            n.length = u;
                            for (var g = 0; g < u; g++) n[g] = i[g];
                            for (g = 0; g !== u; g++) {
                                var v = n[g];
                                v.body = r[g], v.children.length = 0, v.eqs.length = 0, v.visited = !1
                            }
                            for (var y = 0; y !== c; y++) {
                                var x = o[y],
                                    b = (g = r.indexOf(x.bi), r.indexOf(x.bj)),
                                    w = n[g],
                                    _ = n[b];
                                w.children.push(_), w.eqs.push(x), _.children.push(w), _.eqs.push(x)
                            }
                            var S, M = 0,
                                A = a;
                            m.tolerance = this.tolerance, m.iterations = this.iterations;
                            for (var T = l; S = h(n);) {
                                A.length = 0, T.bodies.length = 0, d(S, p, T.bodies, A);
                                var E = A.length;
                                for (A = A.sort(f), g = 0; g !== E; g++) m.addEquation(A[g]);
                                m.solve(t, T), m.removeAllEquations(), M++
                            }
                            return M
                        }
                    }, {
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../objects/Body": 32,
                        "./Solver": 48
                    }],
                    50: [function(t, e, n) {
                        function i() {}
                        e.exports = i, i.prototype.addEventListener = function(t, e) {
                            void 0 === this._listeners && (this._listeners = {});
                            var n = this._listeners;
                            return void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e), this
                        }, i.prototype.hasEventListener = function(t, e) {
                            if (void 0 === this._listeners) return !1;
                            var n = this._listeners;
                            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                        }, i.prototype.hasAnyEventListener = function(t) {
                            return void 0 !== this._listeners && void 0 !== this._listeners[t]
                        }, i.prototype.removeEventListener = function(t, e) {
                            if (void 0 === this._listeners) return this;
                            var n = this._listeners;
                            if (void 0 === n[t]) return this;
                            var i = n[t].indexOf(e);
                            return -1 !== i && n[t].splice(i, 1), this
                        }, i.prototype.dispatchEvent = function(t) {
                            if (void 0 === this._listeners) return this;
                            var e = this._listeners[t.type];
                            if (void 0 !== e) {
                                t.target = this;
                                for (var n = 0, i = e.length; n < i; n++) e[n].call(this, t)
                            }
                            return this
                        }
                    }, {}],
                    51: [function(t, e, n) {
                        var i = t("../collision/AABB"),
                            r = t("../math/Vec3");

                        function o(t) {
                            t = t || {}, this.root = t.root || null, this.aabb = t.aabb ? t.aabb.clone() : new i, this.data = [], this.children = []
                        }

                        function s(t, e) {
                            (e = e || {}).root = null, e.aabb = t, o.call(this, e), this.maxDepth = void 0 !== e.maxDepth ? e.maxDepth : 8
                        }
                        e.exports = s, s.prototype = new o, o.prototype.reset = function(t, e) {
                            this.children.length = this.data.length = 0
                        }, o.prototype.insert = function(t, e, n) {
                            var i = this.data;
                            if (n = n || 0, !this.aabb.contains(t)) return !1;
                            var r = this.children;
                            if (n < (this.maxDepth || this.root.maxDepth)) {
                                var o = !1;
                                r.length || (this.subdivide(), o = !0);
                                for (var s = 0; 8 !== s; s++)
                                    if (r[s].insert(t, e, n + 1)) return !0;
                                o && (r.length = 0)
                            }
                            return i.push(e), !0
                        };
                        var a = new r;
                        o.prototype.subdivide = function() {
                            var t = this.aabb,
                                e = t.lowerBound,
                                n = t.upperBound,
                                s = this.children;
                            s.push(new o({
                                aabb: new i({
                                    lowerBound: new r(0, 0, 0)
                                })
                            }), new o({
                                aabb: new i({
                                    lowerBound: new r(1, 0, 0)
                                })
                            }), new o({
                                aabb: new i({
                                    lowerBound: new r(1, 1, 0)
                                })
                            }), new o({
                                aabb: new i({
                                    lowerBound: new r(1, 1, 1)
                                })
                            }), new o({
                                aabb: new i({
                                    lowerBound: new r(0, 1, 1)
                                })
                            }), new o({
                                aabb: new i({
                                    lowerBound: new r(0, 0, 1)
                                })
                            }), new o({
                                aabb: new i({
                                    lowerBound: new r(1, 0, 1)
                                })
                            }), new o({
                                aabb: new i({
                                    lowerBound: new r(0, 1, 0)
                                })
                            })), n.vsub(e, a), a.scale(.5, a);
                            for (var l = this.root || this, c = 0; 8 !== c; c++) {
                                var h = s[c];
                                h.root = l;
                                var u = h.aabb.lowerBound;
                                u.x *= a.x, u.y *= a.y, u.z *= a.z, u.vadd(e, u), u.vadd(a, h.aabb.upperBound)
                            }
                        }, o.prototype.aabbQuery = function(t, e) {
                            this.data, this.children;
                            for (var n = [this]; n.length;) {
                                var i = n.pop();
                                i.aabb.overlaps(t) && Array.prototype.push.apply(e, i.data), Array.prototype.push.apply(n, i.children)
                            }
                            return e
                        };
                        var l = new i;
                        o.prototype.rayQuery = function(t, e, n) {
                            return t.getAABB(l), l.toLocalFrame(e, l), this.aabbQuery(l, n), n
                        }, o.prototype.removeEmptyNodes = function() {
                            for (var t = this.children.length - 1; t >= 0; t--) this.children[t].removeEmptyNodes(), this.children[t].children.length || this.children[t].data.length || this.children.splice(t, 1)
                        }
                    }, {
                        "../collision/AABB": 3,
                        "../math/Vec3": 31
                    }],
                    52: [function(t, e, n) {
                        function i() {
                            this.objects = [], this.type = Object
                        }
                        e.exports = i, i.prototype.release = function() {
                            for (var t = arguments.length, e = 0; e !== t; e++) this.objects.push(arguments[e]);
                            return this
                        }, i.prototype.get = function() {
                            return 0 === this.objects.length ? this.constructObject() : this.objects.pop()
                        }, i.prototype.constructObject = function() {
                            throw new Error("constructObject() not implemented in this Pool subclass yet!")
                        }, i.prototype.resize = function(t) {
                            for (var e = this.objects; e.length > t;) e.pop();
                            for (; e.length < t;) e.push(this.constructObject());
                            return this
                        }
                    }, {}],
                    53: [function(t, e, n) {
                        function i() {
                            this.data = {
                                keys: []
                            }
                        }
                        e.exports = i, i.prototype.get = function(t, e) {
                            if (t > e) {
                                var n = e;
                                e = t, t = n
                            }
                            return this.data[t + "-" + e]
                        }, i.prototype.set = function(t, e, n) {
                            if (t > e) {
                                var i = e;
                                e = t, t = i
                            }
                            var r = t + "-" + e;
                            this.get(t, e) || this.data.keys.push(r), this.data[r] = n
                        }, i.prototype.reset = function() {
                            for (var t = this.data, e = t.keys; e.length > 0;) delete t[e.pop()]
                        }
                    }, {}],
                    54: [function(t, e, n) {
                        function i() {}
                        e.exports = i, i.defaults = function(t, e) {
                            for (var n in t = t || {}, e) n in t || (t[n] = e[n]);
                            return t
                        }
                    }, {}],
                    55: [function(t, e, n) {
                        e.exports = o;
                        var i = t("../math/Vec3"),
                            r = t("./Pool");

                        function o() {
                            r.call(this), this.type = i
                        }
                        o.prototype = new r, o.prototype.constructObject = function() {
                            return new i
                        }
                    }, {
                        "../math/Vec3": 31,
                        "./Pool": 52
                    }],
                    56: [function(t, e, n) {
                        e.exports = p;
                        var i = t("../collision/AABB"),
                            r = t("../objects/Body"),
                            o = t("../shapes/Shape"),
                            s = t("../collision/Ray"),
                            a = t("../math/Vec3"),
                            l = t("../math/Transform"),
                            c = (t("../shapes/ConvexPolyhedron"), t("../math/Quaternion")),
                            h = (t("../solver/Solver"), t("../utils/Vec3Pool")),
                            u = t("../equations/ContactEquation"),
                            d = t("../equations/FrictionEquation");

                        function p(t) {
                            this.contactPointPool = [], this.frictionEquationPool = [], this.result = [], this.frictionResult = [], this.v3pool = new h, this.world = t, this.currentContactMaterial = null, this.enableFrictionReduction = !1
                        }
                        p.prototype.createContactEquation = function(t, e, n, i, r, o) {
                            var s;
                            this.contactPointPool.length ? ((s = this.contactPointPool.pop()).bi = t, s.bj = e) : s = new u(t, e), s.enabled = t.collisionResponse && e.collisionResponse && n.collisionResponse && i.collisionResponse;
                            var a = this.currentContactMaterial;
                            s.restitution = a.restitution, s.setSpookParams(a.contactEquationStiffness, a.contactEquationRelaxation, this.world.dt);
                            var l = n.material || t.material,
                                c = i.material || e.material;
                            return l && c && l.restitution >= 0 && c.restitution >= 0 && (s.restitution = l.restitution * c.restitution), s.si = r || n, s.sj = o || i, s
                        }, p.prototype.createFrictionEquationsFromContact = function(t, e) {
                            var n = t.bi,
                                i = t.bj,
                                r = t.si,
                                o = t.sj,
                                s = this.world,
                                a = this.currentContactMaterial,
                                l = a.friction,
                                c = r.material || n.material,
                                h = o.material || i.material;
                            if (c && h && c.friction >= 0 && h.friction >= 0 && (l = c.friction * h.friction), l > 0) {
                                var u = l * s.gravity.length(),
                                    p = n.invMass + i.invMass;
                                p > 0 && (p = 1 / p);
                                var f = this.frictionEquationPool,
                                    m = f.length ? f.pop() : new d(n, i, u * p),
                                    g = f.length ? f.pop() : new d(n, i, u * p);
                                return m.bi = g.bi = n, m.bj = g.bj = i, m.minForce = g.minForce = -u * p, m.maxForce = g.maxForce = u * p, m.ri.copy(t.ri), m.rj.copy(t.rj), g.ri.copy(t.ri), g.rj.copy(t.rj), t.ni.tangents(m.t, g.t), m.setSpookParams(a.frictionEquationStiffness, a.frictionEquationRelaxation, s.dt), g.setSpookParams(a.frictionEquationStiffness, a.frictionEquationRelaxation, s.dt), m.enabled = g.enabled = t.enabled, e.push(m, g), !0
                            }
                            return !1
                        };
                        var f = new a,
                            m = new a,
                            g = new a;
                        p.prototype.createFrictionFromAverage = function(t) {
                            var e = this.result[this.result.length - 1];
                            if (this.createFrictionEquationsFromContact(e, this.frictionResult) && 1 !== t) {
                                var n = this.frictionResult[this.frictionResult.length - 2],
                                    i = this.frictionResult[this.frictionResult.length - 1];
                                f.setZero(), m.setZero(), g.setZero();
                                for (var r = e.bi, o = (e.bj, 0); o !== t; o++)(e = this.result[this.result.length - 1 - o]).bodyA !== r ? (f.vadd(e.ni, f), m.vadd(e.ri, m), g.vadd(e.rj, g)) : (f.vsub(e.ni, f), m.vadd(e.rj, m), g.vadd(e.ri, g));
                                var s = 1 / t;
                                m.scale(s, n.ri), g.scale(s, n.rj), i.ri.copy(n.ri), i.rj.copy(n.rj), f.normalize(), f.tangents(n.t, i.t)
                            }
                        };
                        var v = new a,
                            y = new a,
                            x = new c,
                            b = new c;
                        p.prototype.getContacts = function(t, e, n, i, o, s, a) {
                            this.contactPointPool = o, this.frictionEquationPool = a, this.result = i, this.frictionResult = s;
                            for (var l = x, c = b, h = v, u = y, d = 0, p = t.length; d !== p; d++) {
                                var f = t[d],
                                    m = e[d],
                                    g = null;
                                f.material && m.material && (g = n.getContactMaterial(f.material, m.material) || null);
                                for (var w = f.type & r.KINEMATIC && m.type & r.STATIC || f.type & r.STATIC && m.type & r.KINEMATIC || f.type & r.KINEMATIC && m.type & r.KINEMATIC, _ = 0; _ < f.shapes.length; _++) {
                                    f.quaternion.mult(f.shapeOrientations[_], l), f.quaternion.vmult(f.shapeOffsets[_], h), h.vadd(f.position, h);
                                    for (var S = f.shapes[_], M = 0; M < m.shapes.length; M++) {
                                        m.quaternion.mult(m.shapeOrientations[M], c), m.quaternion.vmult(m.shapeOffsets[M], u), u.vadd(m.position, u);
                                        var A = m.shapes[M];
                                        if (0 != (S.collisionFilterGroup & A.collisionFilterMask) && 0 != (A.collisionFilterGroup & S.collisionFilterMask) && !(h.distanceTo(u) > S.boundingSphereRadius + A.boundingSphereRadius)) {
                                            var T = null;
                                            S.material && A.material && (T = n.getContactMaterial(S.material, A.material) || null), this.currentContactMaterial = T || g || n.defaultContactMaterial;
                                            var E = this[S.type | A.type];
                                            E && (S.type < A.type ? E.call(this, S, A, h, u, l, c, f, m, S, A, w) : E.call(this, A, S, u, h, c, l, m, f, S, A, w)) && w && (n.shapeOverlapKeeper.set(S.id, A.id), n.bodyOverlapKeeper.set(f.id, m.id))
                                        }
                                    }
                                }
                            }
                        }, p.prototype[o.types.BOX | o.types.BOX] = p.prototype.boxBox = function(t, e, n, i, r, o, s, a, l, c, h) {
                            return t.convexPolyhedronRepresentation.material = t.material, e.convexPolyhedronRepresentation.material = e.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, this.convexConvex(t.convexPolyhedronRepresentation, e.convexPolyhedronRepresentation, n, i, r, o, s, a, t, e, h)
                        }, p.prototype[o.types.BOX | o.types.CONVEXPOLYHEDRON] = p.prototype.boxConvex = function(t, e, n, i, r, o, s, a, l, c, h) {
                            return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, this.convexConvex(t.convexPolyhedronRepresentation, e, n, i, r, o, s, a, t, e, h)
                        }, p.prototype[o.types.BOX | o.types.PARTICLE] = p.prototype.boxParticle = function(t, e, n, i, r, o, s, a, l, c, h) {
                            return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, this.convexParticle(t.convexPolyhedronRepresentation, e, n, i, r, o, s, a, t, e, h)
                        }, p.prototype[o.types.SPHERE] = p.prototype.sphereSphere = function(t, e, n, i, r, o, s, a, l, c, h) {
                            if (h) return n.distanceSquared(i) < Math.pow(t.radius + e.radius, 2);
                            var u = this.createContactEquation(s, a, t, e, l, c);
                            i.vsub(n, u.ni), u.ni.normalize(), u.ri.copy(u.ni), u.rj.copy(u.ni), u.ri.mult(t.radius, u.ri), u.rj.mult(-e.radius, u.rj), u.ri.vadd(n, u.ri), u.ri.vsub(s.position, u.ri), u.rj.vadd(i, u.rj), u.rj.vsub(a.position, u.rj), this.result.push(u), this.createFrictionEquationsFromContact(u, this.frictionResult)
                        };
                        var w = new a,
                            _ = new a,
                            S = new a;
                        p.prototype[o.types.PLANE | o.types.TRIMESH] = p.prototype.planeTrimesh = function(t, e, n, i, r, o, s, c, h, u, d) {
                            var p = new a,
                                f = w;
                            f.set(0, 0, 1), r.vmult(f, f);
                            for (var m = 0; m < e.vertices.length / 3; m++) {
                                e.getVertex(m, p);
                                var g = new a;
                                g.copy(p), l.pointToWorldFrame(i, o, g, p);
                                var v = _;
                                if (p.vsub(n, v), f.dot(v) <= 0) {
                                    if (d) return !0;
                                    var y = this.createContactEquation(s, c, t, e, h, u);
                                    y.ni.copy(f);
                                    var x = S;
                                    f.scale(v.dot(f), x), p.vsub(x, x), y.ri.copy(x), y.ri.vsub(s.position, y.ri), y.rj.copy(p), y.rj.vsub(c.position, y.rj), this.result.push(y), this.createFrictionEquationsFromContact(y, this.frictionResult)
                                }
                            }
                        };
                        var M = new a,
                            A = new a,
                            T = (new a, new a),
                            E = new a,
                            C = new a,
                            P = new a,
                            L = new a,
                            R = new a,
                            I = new a,
                            F = new a,
                            O = new a,
                            N = new a,
                            B = new a,
                            D = new i,
                            V = [];
                        p.prototype[o.types.SPHERE | o.types.TRIMESH] = p.prototype.sphereTrimesh = function(t, e, n, i, r, o, a, c, h, u, d) {
                            var p = C,
                                f = P,
                                m = L,
                                g = R,
                                v = I,
                                y = F,
                                x = D,
                                b = E,
                                w = A,
                                _ = V;
                            l.pointToLocalFrame(i, o, n, v);
                            var S = t.radius;
                            x.lowerBound.set(v.x - S, v.y - S, v.z - S), x.upperBound.set(v.x + S, v.y + S, v.z + S), e.getTrianglesInAABB(x, _);
                            for (var j = T, k = t.radius * t.radius, U = 0; U < _.length; U++)
                                for (var z = 0; z < 3; z++)
                                    if (e.getVertex(e.indices[3 * _[U] + z], j), j.vsub(v, w), w.norm2() <= k) {
                                        if (b.copy(j), l.pointToWorldFrame(i, o, b, j), j.vsub(n, w), d) return !0;
                                        (W = this.createContactEquation(a, c, t, e, h, u)).ni.copy(w), W.ni.normalize(), W.ri.copy(W.ni), W.ri.scale(t.radius, W.ri), W.ri.vadd(n, W.ri), W.ri.vsub(a.position, W.ri), W.rj.copy(j), W.rj.vsub(c.position, W.rj), this.result.push(W), this.createFrictionEquationsFromContact(W, this.frictionResult)
                                    }
                            for (U = 0; U < _.length; U++)
                                for (z = 0; z < 3; z++) {
                                    e.getVertex(e.indices[3 * _[U] + z], p), e.getVertex(e.indices[3 * _[U] + (z + 1) % 3], f), f.vsub(p, m), v.vsub(f, y);
                                    var G = y.dot(m);
                                    v.vsub(p, y);
                                    var H = y.dot(m);
                                    if (H > 0 && G < 0 && (v.vsub(p, y), g.copy(m), g.normalize(), H = y.dot(g), g.scale(H, y), y.vadd(p, y), (J = y.distanceTo(v)) < t.radius)) {
                                        if (d) return !0;
                                        var W = this.createContactEquation(a, c, t, e, h, u);
                                        y.vsub(v, W.ni), W.ni.normalize(), W.ni.scale(t.radius, W.ri), W.ri.vadd(n, W.ri), W.ri.vsub(a.position, W.ri), l.pointToWorldFrame(i, o, y, y), y.vsub(c.position, W.rj), l.vectorToWorldFrame(o, W.ni, W.ni), l.vectorToWorldFrame(o, W.ri, W.ri), this.result.push(W), this.createFrictionEquationsFromContact(W, this.frictionResult)
                                    }
                                }
                            for (var Y = O, X = N, q = B, Q = M, Z = (U = 0, _.length); U !== Z; U++) {
                                e.getTriangleVertices(_[U], Y, X, q), e.getNormal(_[U], Q), v.vsub(Y, y);
                                var J = y.dot(Q);
                                if (Q.scale(J, y), v.vsub(y, y), J = y.distanceTo(v), s.pointInTriangle(y, Y, X, q) && J < t.radius) {
                                    if (d) return !0;
                                    W = this.createContactEquation(a, c, t, e, h, u), y.vsub(v, W.ni), W.ni.normalize(), W.ni.scale(t.radius, W.ri), W.ri.vadd(n, W.ri), W.ri.vsub(a.position, W.ri), l.pointToWorldFrame(i, o, y, y), y.vsub(c.position, W.rj), l.vectorToWorldFrame(o, W.ni, W.ni), l.vectorToWorldFrame(o, W.ri, W.ri), this.result.push(W), this.createFrictionEquationsFromContact(W, this.frictionResult)
                                }
                            }
                            _.length = 0
                        };
                        var j = new a,
                            k = new a;
                        p.prototype[o.types.SPHERE | o.types.PLANE] = p.prototype.spherePlane = function(t, e, n, i, r, o, s, a, l, c, h) {
                            var u = this.createContactEquation(s, a, t, e, l, c);
                            if (u.ni.set(0, 0, 1), o.vmult(u.ni, u.ni), u.ni.negate(u.ni), u.ni.normalize(), u.ni.mult(t.radius, u.ri), n.vsub(i, j), u.ni.mult(u.ni.dot(j), k), j.vsub(k, u.rj), -j.dot(u.ni) <= t.radius) {
                                if (h) return !0;
                                var d = u.ri,
                                    p = u.rj;
                                d.vadd(n, d), d.vsub(s.position, d), p.vadd(i, p), p.vsub(a.position, p), this.result.push(u), this.createFrictionEquationsFromContact(u, this.frictionResult)
                            }
                        };
                        var U = new a,
                            z = new a,
                            G = new a;

                        function H(t, e, n) {
                            for (var i = null, r = t.length, o = 0; o !== r; o++) {
                                var s = t[o],
                                    a = U;
                                t[(o + 1) % r].vsub(s, a);
                                var l = z;
                                a.cross(e, l);
                                var c = G;
                                n.vsub(s, c);
                                var h = l.dot(c);
                                if (!(null === i || h > 0 && !0 === i || h <= 0 && !1 === i)) return !1;
                                null === i && (i = h > 0)
                            }
                            return !0
                        }
                        var W = new a,
                            Y = new a,
                            X = new a,
                            q = new a,
                            Q = [new a, new a, new a, new a, new a, new a],
                            Z = new a,
                            J = new a,
                            K = new a,
                            $ = new a;
                        p.prototype[o.types.SPHERE | o.types.BOX] = p.prototype.sphereBox = function(t, e, n, i, r, o, s, a, l, c, h) {
                            var u = this.v3pool,
                                d = Q;
                            n.vsub(i, W), e.getSideNormals(d, o);
                            for (var p = t.radius, f = !1, m = J, g = K, v = $, y = null, x = 0, b = 0, w = 0, _ = null, S = 0, M = d.length; S !== M && !1 === f; S++) {
                                var A = Y;
                                A.copy(d[S]);
                                var T = A.norm();
                                A.normalize();
                                var E = W.dot(A);
                                if (E < T + p && E > 0) {
                                    var C = X,
                                        P = q;
                                    C.copy(d[(S + 1) % 3]), P.copy(d[(S + 2) % 3]);
                                    var L = C.norm(),
                                        R = P.norm();
                                    C.normalize(), P.normalize();
                                    var I = W.dot(C),
                                        F = W.dot(P);
                                    if (I < L && I > -L && F < R && F > -R) {
                                        var O = Math.abs(E - T - p);
                                        if ((null === _ || O < _) && (_ = O, b = I, w = F, y = T, m.copy(A), g.copy(C), v.copy(P), x++, h)) return !0
                                    }
                                }
                            }
                            if (x) {
                                f = !0;
                                var N = this.createContactEquation(s, a, t, e, l, c);
                                m.mult(-p, N.ri), N.ni.copy(m), N.ni.negate(N.ni), m.mult(y, m), g.mult(b, g), m.vadd(g, m), v.mult(w, v), m.vadd(v, N.rj), N.ri.vadd(n, N.ri), N.ri.vsub(s.position, N.ri), N.rj.vadd(i, N.rj), N.rj.vsub(a.position, N.rj), this.result.push(N), this.createFrictionEquationsFromContact(N, this.frictionResult)
                            }
                            for (var B = u.get(), D = Z, V = 0; 2 !== V && !f; V++)
                                for (var j = 0; 2 !== j && !f; j++)
                                    for (var k = 0; 2 !== k && !f; k++)
                                        if (B.set(0, 0, 0), V ? B.vadd(d[0], B) : B.vsub(d[0], B), j ? B.vadd(d[1], B) : B.vsub(d[1], B), k ? B.vadd(d[2], B) : B.vsub(d[2], B), i.vadd(B, D), D.vsub(n, D), D.norm2() < p * p) {
                                            if (h) return !0;
                                            f = !0, (N = this.createContactEquation(s, a, t, e, l, c)).ri.copy(D), N.ri.normalize(), N.ni.copy(N.ri), N.ri.mult(p, N.ri), N.rj.copy(B), N.ri.vadd(n, N.ri), N.ri.vsub(s.position, N.ri), N.rj.vadd(i, N.rj), N.rj.vsub(a.position, N.rj), this.result.push(N), this.createFrictionEquationsFromContact(N, this.frictionResult)
                                        }
                            u.release(B), B = null;
                            var U = u.get(),
                                z = u.get(),
                                G = (N = u.get(), u.get()),
                                H = (O = u.get(), d.length);
                            for (V = 0; V !== H && !f; V++)
                                for (j = 0; j !== H && !f; j++)
                                    if (V % 3 != j % 3) {
                                        d[j].cross(d[V], U), U.normalize(), d[V].vadd(d[j], z), N.copy(n), N.vsub(z, N), N.vsub(i, N);
                                        var tt = N.dot(U);
                                        for (U.mult(tt, G), k = 0; k === V % 3 || k === j % 3;) k++;
                                        O.copy(n), O.vsub(G, O), O.vsub(z, O), O.vsub(i, O);
                                        var et = Math.abs(tt),
                                            nt = O.norm();
                                        if (et < d[k].norm() && nt < p) {
                                            if (h) return !0;
                                            f = !0;
                                            var it = this.createContactEquation(s, a, t, e, l, c);
                                            z.vadd(G, it.rj), it.rj.copy(it.rj), O.negate(it.ni), it.ni.normalize(), it.ri.copy(it.rj), it.ri.vadd(i, it.ri), it.ri.vsub(n, it.ri), it.ri.normalize(), it.ri.mult(p, it.ri), it.ri.vadd(n, it.ri), it.ri.vsub(s.position, it.ri), it.rj.vadd(i, it.rj), it.rj.vsub(a.position, it.rj), this.result.push(it), this.createFrictionEquationsFromContact(it, this.frictionResult)
                                        }
                                    }
                            u.release(U, z, N, G, O)
                        };
                        var tt = new a,
                            et = new a,
                            nt = new a,
                            it = new a,
                            rt = new a,
                            ot = new a,
                            st = new a,
                            at = new a,
                            lt = new a,
                            ct = new a;
                        p.prototype[o.types.SPHERE | o.types.CONVEXPOLYHEDRON] = p.prototype.sphereConvex = function(t, e, n, i, r, o, s, a, l, c, h) {
                            var u = this.v3pool;
                            n.vsub(i, tt);
                            for (var d = e.faceNormals, p = e.faces, f = e.vertices, m = t.radius, g = 0; g !== f.length; g++) {
                                var v = f[g],
                                    y = rt;
                                o.vmult(v, y), i.vadd(y, y);
                                var x = it;
                                if (y.vsub(n, x), x.norm2() < m * m) return !!h || (b = !0, (O = this.createContactEquation(s, a, t, e, l, c)).ri.copy(x), O.ri.normalize(), O.ni.copy(O.ri), O.ri.mult(m, O.ri), y.vsub(i, O.rj), O.ri.vadd(n, O.ri), O.ri.vsub(s.position, O.ri), O.rj.vadd(i, O.rj), O.rj.vsub(a.position, O.rj), this.result.push(O), void this.createFrictionEquationsFromContact(O, this.frictionResult))
                            }
                            for (var b = !1, w = (g = 0, p.length); g !== w && !1 === b; g++) {
                                var _ = d[g],
                                    S = p[g],
                                    M = ot;
                                o.vmult(_, M);
                                var A = st;
                                o.vmult(f[S[0]], A), A.vadd(i, A);
                                var T = at;
                                M.mult(-m, T), n.vadd(T, T);
                                var E = lt;
                                T.vsub(A, E);
                                var C = E.dot(M),
                                    P = ct;
                                if (n.vsub(A, P), C < 0 && P.dot(M) > 0) {
                                    for (var L = [], R = 0, I = S.length; R !== I; R++) {
                                        var F = u.get();
                                        o.vmult(f[S[R]], F), i.vadd(F, F), L.push(F)
                                    }
                                    if (H(L, M, n)) {
                                        if (h) return !0;
                                        b = !0;
                                        var O = this.createContactEquation(s, a, t, e, l, c);
                                        M.mult(-m, O.ri), M.negate(O.ni);
                                        var N = u.get();
                                        M.mult(-C, N);
                                        var B = u.get();
                                        M.mult(-m, B), n.vsub(i, O.rj), O.rj.vadd(B, O.rj), O.rj.vadd(N, O.rj), O.rj.vadd(i, O.rj), O.rj.vsub(a.position, O.rj), O.ri.vadd(n, O.ri), O.ri.vsub(s.position, O.ri), u.release(N), u.release(B), this.result.push(O), this.createFrictionEquationsFromContact(O, this.frictionResult), R = 0;
                                        for (var D = L.length; R !== D; R++) u.release(L[R]);
                                        return
                                    }
                                    for (R = 0; R !== S.length; R++) {
                                        var V = u.get(),
                                            j = u.get();
                                        o.vmult(f[S[(R + 1) % S.length]], V), o.vmult(f[S[(R + 2) % S.length]], j), i.vadd(V, V), i.vadd(j, j);
                                        var k = et;
                                        j.vsub(V, k);
                                        var U = nt;
                                        k.unit(U);
                                        var z = u.get(),
                                            G = u.get();
                                        n.vsub(V, G);
                                        var W = G.dot(U);
                                        U.mult(W, z), z.vadd(V, z);
                                        var Y = u.get();
                                        if (z.vsub(n, Y), W > 0 && W * W < k.norm2() && Y.norm2() < m * m) {
                                            if (h) return !0;
                                            for (O = this.createContactEquation(s, a, t, e, l, c), z.vsub(i, O.rj), z.vsub(n, O.ni), O.ni.normalize(), O.ni.mult(m, O.ri), O.rj.vadd(i, O.rj), O.rj.vsub(a.position, O.rj), O.ri.vadd(n, O.ri), O.ri.vsub(s.position, O.ri), this.result.push(O), this.createFrictionEquationsFromContact(O, this.frictionResult), R = 0, D = L.length; R !== D; R++) u.release(L[R]);
                                            return u.release(V), u.release(j), u.release(z), u.release(Y), void u.release(G)
                                        }
                                        u.release(V), u.release(j), u.release(z), u.release(Y), u.release(G)
                                    }
                                    for (R = 0, D = L.length; R !== D; R++) u.release(L[R])
                                }
                            }
                        }, new a, new a, p.prototype[o.types.PLANE | o.types.BOX] = p.prototype.planeBox = function(t, e, n, i, r, o, s, a, l, c, h) {
                            return e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, e.convexPolyhedronRepresentation.id = e.id, this.planeConvex(t, e.convexPolyhedronRepresentation, n, i, r, o, s, a, t, e, h)
                        };
                        var ht = new a,
                            ut = new a,
                            dt = new a,
                            pt = new a;
                        p.prototype[o.types.PLANE | o.types.CONVEXPOLYHEDRON] = p.prototype.planeConvex = function(t, e, n, i, r, o, s, a, l, c, h) {
                            var u = ht,
                                d = ut;
                            d.set(0, 0, 1), r.vmult(d, d);
                            for (var p = 0, f = dt, m = 0; m !== e.vertices.length; m++)
                                if (u.copy(e.vertices[m]), o.vmult(u, u), i.vadd(u, u), u.vsub(n, f), d.dot(f) <= 0) {
                                    if (h) return !0;
                                    var g = this.createContactEquation(s, a, t, e, l, c),
                                        v = pt;
                                    d.mult(d.dot(f), v), u.vsub(v, v), v.vsub(n, g.ri), g.ni.copy(d), u.vsub(i, g.rj), g.ri.vadd(n, g.ri), g.ri.vsub(s.position, g.ri), g.rj.vadd(i, g.rj), g.rj.vsub(a.position, g.rj), this.result.push(g), p++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(g, this.frictionResult)
                                }
                            this.enableFrictionReduction && p && this.createFrictionFromAverage(p)
                        };
                        var ft = new a,
                            mt = new a;
                        p.prototype[o.types.CONVEXPOLYHEDRON] = p.prototype.convexConvex = function(t, e, n, i, r, o, s, a, l, c, h, u, d) {
                            var p = ft;
                            if (!(n.distanceTo(i) > t.boundingSphereRadius + e.boundingSphereRadius) && t.findSeparatingAxis(e, n, r, i, o, p, u, d)) {
                                var f = [],
                                    m = mt;
                                t.clipAgainstHull(n, r, e, i, o, p, -100, 100, f);
                                for (var g = 0, v = 0; v !== f.length; v++) {
                                    if (h) return !0;
                                    var y = this.createContactEquation(s, a, t, e, l, c),
                                        x = y.ri,
                                        b = y.rj;
                                    p.negate(y.ni), f[v].normal.negate(m), m.mult(f[v].depth, m), f[v].point.vadd(m, x), b.copy(f[v].point), x.vsub(n, x), b.vsub(i, b), x.vadd(n, x), x.vsub(s.position, x), b.vadd(i, b), b.vsub(a.position, b), this.result.push(y), g++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(y, this.frictionResult)
                                }
                                this.enableFrictionReduction && g && this.createFrictionFromAverage(g)
                            }
                        };
                        var gt = new a,
                            vt = new a,
                            yt = new a;
                        p.prototype[o.types.PLANE | o.types.PARTICLE] = p.prototype.planeParticle = function(t, e, n, i, r, o, s, a, l, c, h) {
                            var u = gt;
                            u.set(0, 0, 1), s.quaternion.vmult(u, u);
                            var d = vt;
                            if (i.vsub(s.position, d), u.dot(d) <= 0) {
                                if (h) return !0;
                                var p = this.createContactEquation(a, s, e, t, l, c);
                                p.ni.copy(u), p.ni.negate(p.ni), p.ri.set(0, 0, 0);
                                var f = yt;
                                u.mult(u.dot(i), f), i.vsub(f, f), p.rj.copy(f), this.result.push(p), this.createFrictionEquationsFromContact(p, this.frictionResult)
                            }
                        };
                        var xt = new a;
                        p.prototype[o.types.PARTICLE | o.types.SPHERE] = p.prototype.sphereParticle = function(t, e, n, i, r, o, s, a, l, c, h) {
                            var u = xt;
                            if (u.set(0, 0, 1), i.vsub(n, u), u.norm2() <= t.radius * t.radius) {
                                if (h) return !0;
                                var d = this.createContactEquation(a, s, e, t, l, c);
                                u.normalize(), d.rj.copy(u), d.rj.mult(t.radius, d.rj), d.ni.copy(u), d.ni.negate(d.ni), d.ri.set(0, 0, 0), this.result.push(d), this.createFrictionEquationsFromContact(d, this.frictionResult)
                            }
                        };
                        var bt = new c,
                            wt = new a,
                            _t = (new a, new a),
                            St = new a,
                            Mt = new a;
                        p.prototype[o.types.PARTICLE | o.types.CONVEXPOLYHEDRON] = p.prototype.convexParticle = function(t, e, n, i, r, o, s, a, l, c, h) {
                            var u = -1,
                                d = _t,
                                p = Mt,
                                f = null,
                                m = wt;
                            if (m.copy(i), m.vsub(n, m), r.conjugate(bt), bt.vmult(m, m), t.pointIsInside(m)) {
                                t.worldVerticesNeedsUpdate && t.computeWorldVertices(n, r), t.worldFaceNormalsNeedsUpdate && t.computeWorldFaceNormals(r);
                                for (var g = 0, v = t.faces.length; g !== v; g++) {
                                    var y = [t.worldVertices[t.faces[g][0]]],
                                        x = t.worldFaceNormals[g];
                                    i.vsub(y[0], St);
                                    var b = -x.dot(St);
                                    if (null === f || Math.abs(b) < Math.abs(f)) {
                                        if (h) return !0;
                                        f = b, u = g, d.copy(x)
                                    }
                                }
                                if (-1 !== u) {
                                    var w = this.createContactEquation(a, s, e, t, l, c);
                                    d.mult(f, p), p.vadd(i, p), p.vsub(n, p), w.rj.copy(p), d.negate(w.ni), w.ri.set(0, 0, 0);
                                    var _ = w.ri,
                                        S = w.rj;
                                    _.vadd(i, _), _.vsub(a.position, _), S.vadd(n, S), S.vsub(s.position, S), this.result.push(w), this.createFrictionEquationsFromContact(w, this.frictionResult)
                                } else console.warn("Point found inside convex, but did not find penetrating face!")
                            }
                        }, p.prototype[o.types.BOX | o.types.HEIGHTFIELD] = p.prototype.boxHeightfield = function(t, e, n, i, r, o, s, a, l, c, h) {
                            return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, this.convexHeightfield(t.convexPolyhedronRepresentation, e, n, i, r, o, s, a, t, e, h)
                        };
                        var At = new a,
                            Tt = new a,
                            Et = [0];
                        p.prototype[o.types.CONVEXPOLYHEDRON | o.types.HEIGHTFIELD] = p.prototype.convexHeightfield = function(t, e, n, i, r, o, s, a, c, h, u) {
                            var d = e.data,
                                p = e.elementSize,
                                f = t.boundingSphereRadius,
                                m = Tt,
                                g = Et,
                                v = At;
                            l.pointToLocalFrame(i, o, n, v);
                            var y = Math.floor((v.x - f) / p) - 1,
                                x = Math.ceil((v.x + f) / p) + 1,
                                b = Math.floor((v.y - f) / p) - 1,
                                w = Math.ceil((v.y + f) / p) + 1;
                            if (!(x < 0 || w < 0 || y > d.length || b > d[0].length)) {
                                y < 0 && (y = 0), x < 0 && (x = 0), b < 0 && (b = 0), w < 0 && (w = 0), y >= d.length && (y = d.length - 1), x >= d.length && (x = d.length - 1), w >= d[0].length && (w = d[0].length - 1), b >= d[0].length && (b = d[0].length - 1);
                                var _ = [];
                                e.getRectMinMax(y, b, x, w, _);
                                var S = _[0],
                                    M = _[1];
                                if (!(v.z - f > M || v.z + f < S))
                                    for (var A = y; A < x; A++)
                                        for (var T = b; T < w; T++) {
                                            var E = !1;
                                            if (e.getConvexTrianglePillar(A, T, !1), l.pointToWorldFrame(i, o, e.pillarOffset, m), n.distanceTo(m) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (E = this.convexConvex(t, e.pillarConvex, n, m, r, o, s, a, null, null, u, g, null)), u && E) return !0;
                                            if (e.getConvexTrianglePillar(A, T, !0), l.pointToWorldFrame(i, o, e.pillarOffset, m), n.distanceTo(m) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (E = this.convexConvex(t, e.pillarConvex, n, m, r, o, s, a, null, null, u, g, null)), u && E) return !0
                                        }
                            }
                        };
                        var Ct = new a,
                            Pt = new a;
                        p.prototype[o.types.SPHERE | o.types.HEIGHTFIELD] = p.prototype.sphereHeightfield = function(t, e, n, i, r, o, s, a, c, h, u) {
                            var d = e.data,
                                p = t.radius,
                                f = e.elementSize,
                                m = Pt,
                                g = Ct;
                            l.pointToLocalFrame(i, o, n, g);
                            var v = Math.floor((g.x - p) / f) - 1,
                                y = Math.ceil((g.x + p) / f) + 1,
                                x = Math.floor((g.y - p) / f) - 1,
                                b = Math.ceil((g.y + p) / f) + 1;
                            if (!(y < 0 || b < 0 || v > d.length || x > d[0].length)) {
                                v < 0 && (v = 0), y < 0 && (y = 0), x < 0 && (x = 0), b < 0 && (b = 0), v >= d.length && (v = d.length - 1), y >= d.length && (y = d.length - 1), b >= d[0].length && (b = d[0].length - 1), x >= d[0].length && (x = d[0].length - 1);
                                var w = [];
                                e.getRectMinMax(v, x, y, b, w);
                                var _ = w[0],
                                    S = w[1];
                                if (!(g.z - p > S || g.z + p < _))
                                    for (var M = this.result, A = v; A < y; A++)
                                        for (var T = x; T < b; T++) {
                                            var E = M.length,
                                                C = !1;
                                            if (e.getConvexTrianglePillar(A, T, !1), l.pointToWorldFrame(i, o, e.pillarOffset, m), n.distanceTo(m) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (C = this.sphereConvex(t, e.pillarConvex, n, m, r, o, s, a, t, e, u)), u && C) return !0;
                                            if (e.getConvexTrianglePillar(A, T, !0), l.pointToWorldFrame(i, o, e.pillarOffset, m), n.distanceTo(m) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (C = this.sphereConvex(t, e.pillarConvex, n, m, r, o, s, a, t, e, u)), u && C) return !0;
                                            if (M.length - E > 2) return
                                        }
                            }
                        }
                    }, {
                        "../collision/AABB": 3,
                        "../collision/Ray": 10,
                        "../equations/ContactEquation": 20,
                        "../equations/FrictionEquation": 22,
                        "../math/Quaternion": 29,
                        "../math/Transform": 30,
                        "../math/Vec3": 31,
                        "../objects/Body": 32,
                        "../shapes/ConvexPolyhedron": 39,
                        "../shapes/Shape": 44,
                        "../solver/Solver": 48,
                        "../utils/Vec3Pool": 55
                    }],
                    57: [function(t, e, n) {
                        e.exports = y, t("../shapes/Shape");
                        var i = t("../math/Vec3"),
                            r = t("../math/Quaternion"),
                            o = t("../solver/GSSolver"),
                            s = (t("../equations/ContactEquation"), t("../equations/FrictionEquation"), t("./Narrowphase")),
                            a = t("../utils/EventTarget"),
                            l = t("../collision/ArrayCollisionMatrix"),
                            c = t("../collision/OverlapKeeper"),
                            h = t("../material/Material"),
                            u = t("../material/ContactMaterial"),
                            d = t("../objects/Body"),
                            p = t("../utils/TupleDictionary"),
                            f = t("../collision/RaycastResult"),
                            m = t("../collision/AABB"),
                            g = t("../collision/Ray"),
                            v = t("../collision/NaiveBroadphase");

                        function y(t) {
                            t = t || {}, a.apply(this), this.dt = -1, this.allowSleep = !!t.allowSleep, this.contacts = [], this.frictionEquations = [], this.quatNormalizeSkip = void 0 !== t.quatNormalizeSkip ? t.quatNormalizeSkip : 0, this.quatNormalizeFast = void 0 !== t.quatNormalizeFast && t.quatNormalizeFast, this.time = 0, this.interpolationFactor = 0, this.stepnumber = 0, this.default_dt = 1 / 60, this.nextId = 0, this.gravity = new i, t.gravity && this.gravity.copy(t.gravity), this.broadphase = void 0 !== t.broadphase ? t.broadphase : new v, this.bodies = [], this.solver = void 0 !== t.solver ? t.solver : new o, this.constraints = [], this.narrowphase = new s(this), this.collisionMatrix = new l, this.collisionMatrixPrevious = new l, this.bodyOverlapKeeper = new c, this.shapeOverlapKeeper = new c, this.materials = [], this.contactmaterials = [], this.contactMaterialTable = new p, this.defaultMaterial = new h("default"), this.defaultContactMaterial = new u(this.defaultMaterial, this.defaultMaterial, {
                                friction: .3,
                                restitution: 0
                            }), this.doProfiling = !1, this.profile = {
                                solve: 0,
                                makeContactConstraints: 0,
                                broadphase: 0,
                                integrate: 0,
                                narrowphase: 0
                            }, this.accumulator = 0, this.subsystems = [], this.addBodyEvent = {
                                type: "addBody",
                                body: null
                            }, this.removeBodyEvent = {
                                type: "removeBody",
                                body: null
                            }, this.idToBodyMap = {}, this.broadphase.setWorld(this)
                        }
                        y.prototype = new a, new m;
                        var x = new g;
                        if (y.prototype.getContactMaterial = function(t, e) {
                                return this.contactMaterialTable.get(t.id, e.id)
                            }, y.prototype.numObjects = function() {
                                return this.bodies.length
                            }, y.prototype.collisionMatrixTick = function() {
                                var t = this.collisionMatrixPrevious;
                                this.collisionMatrixPrevious = this.collisionMatrix, this.collisionMatrix = t, this.collisionMatrix.reset(), this.bodyOverlapKeeper.tick(), this.shapeOverlapKeeper.tick()
                            }, y.prototype.add = y.prototype.addBody = function(t) {
                                -1 === this.bodies.indexOf(t) && (t.index = this.bodies.length, this.bodies.push(t), t.world = this, t.initPosition.copy(t.position), t.initVelocity.copy(t.velocity), t.timeLastSleepy = this.time, t instanceof d && (t.initAngularVelocity.copy(t.angularVelocity), t.initQuaternion.copy(t.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = t, this.idToBodyMap[t.id] = t, this.dispatchEvent(this.addBodyEvent))
                            }, y.prototype.addConstraint = function(t) {
                                this.constraints.push(t)
                            }, y.prototype.removeConstraint = function(t) {
                                var e = this.constraints.indexOf(t); - 1 !== e && this.constraints.splice(e, 1)
                            }, y.prototype.rayTest = function(t, e, n) {
                                n instanceof f ? this.raycastClosest(t, e, {
                                    skipBackfaces: !0
                                }, n) : this.raycastAll(t, e, {
                                    skipBackfaces: !0
                                }, n)
                            }, y.prototype.raycastAll = function(t, e, n, i) {
                                return n.mode = g.ALL, n.from = t, n.to = e, n.callback = i, x.intersectWorld(this, n)
                            }, y.prototype.raycastAny = function(t, e, n, i) {
                                return n.mode = g.ANY, n.from = t, n.to = e, n.result = i, x.intersectWorld(this, n)
                            }, y.prototype.raycastClosest = function(t, e, n, i) {
                                return n.mode = g.CLOSEST, n.from = t, n.to = e, n.result = i, x.intersectWorld(this, n)
                            }, y.prototype.remove = function(t) {
                                t.world = null;
                                var e = this.bodies.length - 1,
                                    n = this.bodies,
                                    i = n.indexOf(t);
                                if (-1 !== i) {
                                    n.splice(i, 1);
                                    for (var r = 0; r !== n.length; r++) n[r].index = r;
                                    this.collisionMatrix.setNumObjects(e), this.removeBodyEvent.body = t, delete this.idToBodyMap[t.id], this.dispatchEvent(this.removeBodyEvent)
                                }
                            }, y.prototype.removeBody = y.prototype.remove, y.prototype.getBodyById = function(t) {
                                return this.idToBodyMap[t]
                            }, y.prototype.getShapeById = function(t) {
                                for (var e = this.bodies, n = 0, i = e.length; n < i; n++)
                                    for (var r = e[n].shapes, o = 0, s = r.length; o < s; o++) {
                                        var a = r[o];
                                        if (a.id === t) return a
                                    }
                            }, y.prototype.addMaterial = function(t) {
                                this.materials.push(t)
                            }, y.prototype.addContactMaterial = function(t) {
                                this.contactmaterials.push(t), this.contactMaterialTable.set(t.materials[0].id, t.materials[1].id, t)
                            }, "undefined" == typeof performance && (performance = {}), !performance.now) {
                            var b = Date.now();
                            performance.timing && performance.timing.navigationStart && (b = performance.timing.navigationStart), performance.now = function() {
                                return Date.now() - b
                            }
                        }
                        new i, y.prototype.step = function(t, e, n) {
                            if (n = n || 10, void 0 === e) this.internalStep(t), this.time += t;
                            else {
                                this.accumulator += e;
                                for (var i = 0; this.accumulator >= t && i < n;) this.internalStep(t), this.accumulator -= t, i++;
                                this.accumulator %= t;
                                var r = this.accumulator / t;
                                this.interpolationFactor = r;
                                for (var o = 0; o !== this.bodies.length; o++) {
                                    var s = this.bodies[o];
                                    s.previousPosition.lerp(s.position, r, s.interpolatedPosition), s.previousQuaternion.slerp(s.quaternion, r, s.interpolatedQuaternion), s.previousQuaternion.normalize()
                                }
                                this.time += e
                            }
                        };
                        var w, _, S, M, A, T, E = {
                                type: "postStep"
                            },
                            C = {
                                type: "preStep"
                            },
                            P = {
                                type: d.COLLIDE_EVENT_NAME,
                                body: null,
                                contact: null
                            },
                            L = [],
                            R = [],
                            I = [],
                            F = [],
                            O = (new i, new i, new i, new i, new i, new i, new i, new i, new i, new r, new r, new r, new i, function(t) {
                                return Math.min(Math.max(t, 0), 1)
                            });
                        y.prototype.internalStep = function(t) {
                            this.dt = t;
                            var e, n = this.contacts,
                                i = I,
                                r = F,
                                o = this.numObjects(),
                                s = this.bodies,
                                a = this.solver,
                                l = this.gravity,
                                c = this.doProfiling,
                                h = this.profile,
                                u = d.DYNAMIC,
                                p = this.constraints,
                                f = R,
                                m = (l.norm(), l.x),
                                g = l.y,
                                v = l.z,
                                y = 0;
                            for (c && (e = performance.now()), y = 0; y !== o; y++)
                                if ((D = s[y]).type === u) {
                                    var x = D.force,
                                        b = D.mass;
                                    x.x += b * m, x.y += b * g, x.z += b * v
                                }
                            y = 0;
                            for (var w = this.subsystems.length; y !== w; y++) this.subsystems[y].update();
                            c && (e = performance.now()), i.length = 0, r.length = 0, this.broadphase.collisionPairs(this, i, r), c && (h.broadphase = performance.now() - e);
                            var _ = p.length;
                            for (y = 0; y !== _; y++)
                                if (!(U = p[y]).collideConnected)
                                    for (var S = i.length - 1; S >= 0; S -= 1)(U.bodyA === i[S] && U.bodyB === r[S] || U.bodyB === i[S] && U.bodyA === r[S]) && (i.splice(S, 1), r.splice(S, 1));
                            this.collisionMatrixTick(), c && (e = performance.now());
                            var M = L,
                                A = n.length;
                            for (y = 0; y !== A; y++) M.push(n[y]);
                            n.length = 0;
                            var T = this.frictionEquations.length;
                            for (y = 0; y !== T; y++) f.push(this.frictionEquations[y]);
                            for (this.frictionEquations.length = 0, this.narrowphase.getContacts(i, r, this, n, M, this.frictionEquations, f), c && (h.narrowphase = performance.now() - e), c && (e = performance.now()), y = 0; y < this.frictionEquations.length; y++) a.addEquation(this.frictionEquations[y]);
                            for (var N = n.length, B = 0; B !== N; B++) {
                                var D = (U = n[B]).bi,
                                    V = U.bj,
                                    j = U.si,
                                    k = U.sj;
                                (D.material && V.material && this.getContactMaterial(D.material, V.material) || this.defaultContactMaterial).friction, D.material && V.material && (D.material.friction >= 0 && V.material.friction >= 0 && (D.material.friction, V.material.friction), D.material.restitution >= 0 && V.material.restitution >= 0 && (U.restitution = D.material.restitution * V.material.restitution)), a.addEquation(U), D.allowSleep && D.type === d.DYNAMIC && D.sleepState === d.SLEEPING && V.sleepState === d.AWAKE && V.type !== d.STATIC && V.velocity.norm2() + V.angularVelocity.norm2() >= 2 * Math.pow(V.sleepSpeedLimit, 2) && (D._wakeUpAfterNarrowphase = !0), V.allowSleep && V.type === d.DYNAMIC && V.sleepState === d.SLEEPING && D.sleepState === d.AWAKE && D.type !== d.STATIC && D.velocity.norm2() + D.angularVelocity.norm2() >= 2 * Math.pow(D.sleepSpeedLimit, 2) && (V._wakeUpAfterNarrowphase = !0), this.collisionMatrix.set(D, V, !0), this.collisionMatrixPrevious.get(D, V) || (P.body = V, P.contact = U, D.dispatchEvent(P), P.body = D, V.dispatchEvent(P)), this.bodyOverlapKeeper.set(D.id, V.id), this.shapeOverlapKeeper.set(j.id, k.id)
                            }
                            for (this.emitContactEvents(), c && (h.makeContactConstraints = performance.now() - e, e = performance.now()), y = 0; y !== o; y++)(D = s[y])._wakeUpAfterNarrowphase && (D.wakeUp(), D._wakeUpAfterNarrowphase = !1);
                            for (_ = p.length, y = 0; y !== _; y++) {
                                var U;
                                (U = p[y]).update(), S = 0;
                                for (var z = U.equations.length; S !== z; S++) {
                                    var G = U.equations[S];
                                    a.addEquation(G)
                                }
                            }
                            a.solve(t, this), c && (h.solve = performance.now() - e), a.removeAllEquations();
                            var H = Math.pow;
                            for (y = 0; y !== o; y++)
                                if ((D = s[y]).type & u) {
                                    var W = H(O(1 - D.linearDamping), t),
                                        Y = D.velocity;
                                    Y.mult(W, Y);
                                    var X = D.angularVelocity;
                                    if (X) {
                                        var q = H(O(1 - D.angularDamping), t);
                                        X.mult(q, X)
                                    }
                                }
                            for (this.dispatchEvent(C), y = 0; y !== o; y++)(D = s[y]).preStep && D.preStep(D);
                            c && (e = performance.now());
                            var Q = this.stepnumber % (this.quatNormalizeSkip + 1) == 0,
                                Z = this.quatNormalizeFast;
                            for (y = 0; y !== o; y++) s[y].integrate(t, Q, Z);
                            for (this.clearForces(), this.broadphase.dirty = !0, c && (h.integrate = performance.now() - e), this.time += t, this.stepnumber += 1, this.dispatchEvent(E), y = 0; y !== o; y++) {
                                var J = (D = s[y]).postStep;
                                J && J(D)
                            }
                            if (this.allowSleep)
                                for (y = 0; y !== o; y++) s[y].sleepTick(this.time)
                        }, y.prototype.emitContactEvents = (w = [], _ = [], S = {
                            type: "beginContact",
                            bodyA: null,
                            bodyB: null
                        }, M = {
                            type: "endContact",
                            bodyA: null,
                            bodyB: null
                        }, A = {
                            type: "beginShapeContact",
                            bodyA: null,
                            bodyB: null,
                            shapeA: null,
                            shapeB: null
                        }, T = {
                            type: "endShapeContact",
                            bodyA: null,
                            bodyB: null,
                            shapeA: null,
                            shapeB: null
                        }, function() {
                            var t = this.hasAnyEventListener("beginContact"),
                                e = this.hasAnyEventListener("endContact");
                            if ((t || e) && this.bodyOverlapKeeper.getDiff(w, _), t) {
                                for (var n = 0, i = w.length; n < i; n += 2) S.bodyA = this.getBodyById(w[n]), S.bodyB = this.getBodyById(w[n + 1]), this.dispatchEvent(S);
                                S.bodyA = S.bodyB = null
                            }
                            if (e) {
                                for (n = 0, i = _.length; n < i; n += 2) M.bodyA = this.getBodyById(_[n]), M.bodyB = this.getBodyById(_[n + 1]), this.dispatchEvent(M);
                                M.bodyA = M.bodyB = null
                            }
                            w.length = _.length = 0;
                            var r = this.hasAnyEventListener("beginShapeContact"),
                                o = this.hasAnyEventListener("endShapeContact");
                            if ((r || o) && this.shapeOverlapKeeper.getDiff(w, _), r) {
                                for (n = 0, i = w.length; n < i; n += 2) {
                                    var s = this.getShapeById(w[n]),
                                        a = this.getShapeById(w[n + 1]);
                                    A.shapeA = s, A.shapeB = a, A.bodyA = s.body, A.bodyB = a.body, this.dispatchEvent(A)
                                }
                                A.bodyA = A.bodyB = A.shapeA = A.shapeB = null
                            }
                            if (o) {
                                for (n = 0, i = _.length; n < i; n += 2) s = this.getShapeById(_[n]), a = this.getShapeById(_[n + 1]), s && a && (T.shapeA = s, T.shapeB = a, T.bodyA = s.body, T.bodyB = a.body, this.dispatchEvent(T));
                                T.bodyA = T.bodyB = T.shapeA = T.shapeB = null
                            }
                        }), y.prototype.clearForces = function() {
                            for (var t = this.bodies, e = t.length, n = 0; n !== e; n++) {
                                var i = t[n];
                                i.force, i.torque, i.force.set(0, 0, 0), i.torque.set(0, 0, 0)
                            }
                        }
                    }, {
                        "../collision/AABB": 3,
                        "../collision/ArrayCollisionMatrix": 4,
                        "../collision/NaiveBroadphase": 7,
                        "../collision/OverlapKeeper": 9,
                        "../collision/Ray": 10,
                        "../collision/RaycastResult": 11,
                        "../equations/ContactEquation": 20,
                        "../equations/FrictionEquation": 22,
                        "../material/ContactMaterial": 25,
                        "../material/Material": 26,
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../objects/Body": 32,
                        "../shapes/Shape": 44,
                        "../solver/GSSolver": 47,
                        "../utils/EventTarget": 50,
                        "../utils/TupleDictionary": 53,
                        "./Narrowphase": 56
                    }]
                }, {}, [2])(2)
            }, function(t, e, n) {
                "use strict";

                function i(t) {
                    for (var n in t) e.hasOwnProperty(n) || (e[n] = t[n])
                }
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), i(n(50)), i(n(51)), i(n(52)), i(n(53)), i(n(54)), i(n(55)), i(n(7)), i(n(56)), i(n(57)), i(n(58)), i(n(59)), i(n(60)), i(n(61)), i(n(62)), i(n(63)), i(n(64)), i(n(65)), i(n(66)), i(n(67)), i(n(30))
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(0),
                    r = n(1),
                    o = n(6),
                    s = n(19),
                    a = n(9);
                e.createCapsuleGeometry = function() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32;
                    const r = new a.Geometry,
                        o = 2 * Math.PI,
                        s = 1.5707963267948966,
                        l = [];
                    for (let a = 0; a <= n / 4; a++)
                        for (let c = 0; c <= n; c++) {
                            let h = c * o / n,
                                u = -s + Math.PI * a / (n / 2),
                                d = new i.Vector3,
                                p = new i.Vector3;
                            d.x = t * Math.cos(u) * Math.cos(h), d.y = t * Math.cos(u) * Math.sin(h), d.z = t * Math.sin(u), d.z -= e / 2, p.x = d.x, p.y = d.y, p.z = d.z, r.vertices.push(d), l.push(p)
                        }
                    for (let a = n / 4; a <= n / 2; a++)
                        for (let c = 0; c <= n; c++) {
                            let h = c * o / n,
                                u = -s + Math.PI * a / (n / 2),
                                d = new i.Vector3,
                                p = new i.Vector3;
                            d.x = t * Math.cos(u) * Math.cos(h), d.y = t * Math.cos(u) * Math.sin(h), d.z = t * Math.sin(u), d.z += e / 2, p.x = d.x, p.y = d.y, p.z = d.z, r.vertices.push(d), l.push(p)
                        }
                    for (let a = 0; a <= n / 2; a++)
                        for (let t = 0; t < n; t++) new i.Vector4(a * (n + 1) + t, a * (n + 1) + (t + 1), (a + 1) * (n + 1) + (t + 1), (a + 1) * (n + 1) + t);
                    return r.rotateX(Math.PI / 2), r.computeVertexNormals(), r.computeFaceNormals(), r
                }, e.appplyVectorMatrixXZ = function(t, e) {
                    return new i.Vector3(t.x * e.z + t.z * e.x, e.y, t.z * e.z + -t.x * e.x)
                }, e.round = function(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    return Math.round(t * Math.pow(10, e)) / Math.pow(10, e)
                }, e.roundVector = function(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    return new i.Vector3(this.round(t.x, e), this.round(t.y, e), this.round(t.z, e))
                }, e.getAngleBetweenVectors = function(t, e) {
                    let n, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5e-4,
                        r = t.dot(e);
                    return n = r > 1 - i ? 0 : r < -1 + i ? Math.PI / 2 : Math.acos(r), n
                }, e.getSignedAngleBetweenVectors = function(t, e) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new i.Vector3(0, 1, 0),
                        r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 5e-4,
                        o = this.getAngleBetweenVectors(t, e, r),
                        s = (new i.Vector3).crossVectors(t, e);
                    return n.dot(s) < 0 && (o = -o), o
                }, e.haveSameSigns = function(t, e) {
                    return t < 0 == e < 0
                }, e.haveDifferentSigns = function(t, e) {
                    return t < 0 != e < 0
                }, e.setDefaults = function(t, e) {
                    return o.defaults({}, o.clone(t), e)
                }, e.getGlobalProperties = function() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                        e = [],
                        n = window;
                    for (let i in n) 0 === i.indexOf(t) && e.push(i);
                    return e
                }, e.spring = function(t, e, n, i, r) {
                    let o = e - t;
                    o /= i, n += o;
                    let a = t + (n *= r);
                    return new s.SimulationFrame(a, n)
                }, e.springV = function(t, e, n, r, o) {
                    let s = (new i.Vector3).subVectors(e, t);
                    s.divideScalar(r), n.add(s), n.multiplyScalar(o), t.add(n)
                }, e.GroundImpactData = class {
                    constructor() {
                        this.velocity = new i.Vector3
                    }
                }, e.threeVector = function(t) {
                    return new i.Vector3(t.x, t.y, t.z)
                }, e.cannonVector = function(t) {
                    return new r.Vec3(t.x, t.y, t.z)
                }, e.threeQuat = function(t) {
                    return new i.Quaternion(t.x, t.y, t.z, t.w)
                }, e.cannonQuat = function(t) {
                    return new r.Quaternion(t.x, t.y, t.z, t.w)
                }, e.setupMeshProperties = function(t) {
                    if (t.castShadow = !0, t.receiveShadow = !0, null !== t.material.map) {
                        let e = new i.MeshPhongMaterial;
                        e.shininess = 0, e.name = t.material.name, e.map = t.material.map, e.transparent = t.material.transparent, e.skinning = t.material.skinning, e.color = t.material.color, t.material = e
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var i = function() {
                        function t(t, e) {
                            for (var n = 0; n < e.length; n++) {
                                var i = e[n];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                            }
                        }
                        return function(e, n, i) {
                            return n && t(e.prototype, n), i && t(e, i), e
                        }
                    }(),
                    r = n(0);

                function o(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }
                var s = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
                    a = new r.PlaneBufferGeometry(2, 2),
                    l = function() {
                        function t(e) {
                            o(this, t), this._mesh = new r.Mesh(a, e)
                        }
                        return i(t, [{
                            key: "render",
                            value: function(t) {
                                t.render(this._mesh, s)
                            }
                        }, {
                            key: "material",
                            get: function() {
                                return this._mesh.material
                            },
                            set: function(t) {
                                this._mesh.material = t
                            }
                        }]), t
                    }(),
                    c = function() {
                        function t() {
                            o(this, t), this.enabled = !0, this.needsSwap = !1, this.clear = !1, this.renderToScreen = !1
                        }
                        return i(t, [{
                            key: "setSize",
                            value: function(t, e) {}
                        }, {
                            key: "render",
                            value: function(t, e, n, i, r) {
                                console.error("THREE.Pass: .render() must be implemented in derived pass.")
                            }
                        }]), t
                    }();
                c.FullScreenQuad = l, e.default = c
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.KeyBinding = class {
                    constructor() {
                        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        this.isPressed = !1, this.justPressed = !1, this.justReleased = !1, this.eventCodes = e
                    }
                }
            }, function(t, e, n) {
                (function(t, i) {
                    var r;
                    (function() {
                        var o, s = 200,
                            a = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
                            l = "Expected a function",
                            c = "__lodash_hash_undefined__",
                            h = 500,
                            u = "__lodash_placeholder__",
                            d = 1,
                            p = 2,
                            f = 4,
                            m = 1,
                            g = 2,
                            v = 1,
                            y = 2,
                            x = 4,
                            b = 8,
                            w = 16,
                            _ = 32,
                            S = 64,
                            M = 128,
                            A = 256,
                            T = 512,
                            E = 30,
                            C = "...",
                            P = 800,
                            L = 16,
                            R = 1,
                            I = 2,
                            F = 1 / 0,
                            O = 9007199254740991,
                            N = 17976931348623157e292,
                            B = NaN,
                            D = 4294967295,
                            V = D - 1,
                            j = D >>> 1,
                            k = [
                                ["ary", M],
                                ["bind", v],
                                ["bindKey", y],
                                ["curry", b],
                                ["curryRight", w],
                                ["flip", T],
                                ["partial", _],
                                ["partialRight", S],
                                ["rearg", A]
                            ],
                            U = "[object Arguments]",
                            z = "[object Array]",
                            G = "[object AsyncFunction]",
                            H = "[object Boolean]",
                            W = "[object Date]",
                            Y = "[object DOMException]",
                            X = "[object Error]",
                            q = "[object Function]",
                            Q = "[object GeneratorFunction]",
                            Z = "[object Map]",
                            J = "[object Number]",
                            K = "[object Null]",
                            $ = "[object Object]",
                            tt = "[object Proxy]",
                            et = "[object RegExp]",
                            nt = "[object Set]",
                            it = "[object String]",
                            rt = "[object Symbol]",
                            ot = "[object Undefined]",
                            st = "[object WeakMap]",
                            at = "[object WeakSet]",
                            lt = "[object ArrayBuffer]",
                            ct = "[object DataView]",
                            ht = "[object Float32Array]",
                            ut = "[object Float64Array]",
                            dt = "[object Int8Array]",
                            pt = "[object Int16Array]",
                            ft = "[object Int32Array]",
                            mt = "[object Uint8Array]",
                            gt = "[object Uint8ClampedArray]",
                            vt = "[object Uint16Array]",
                            yt = "[object Uint32Array]",
                            xt = /\b__p \+= '';/g,
                            bt = /\b(__p \+=) '' \+/g,
                            wt = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
                            _t = /&(?:amp|lt|gt|quot|#39);/g,
                            St = /[&<>"']/g,
                            Mt = RegExp(_t.source),
                            At = RegExp(St.source),
                            Tt = /<%-([\s\S]+?)%>/g,
                            Et = /<%([\s\S]+?)%>/g,
                            Ct = /<%=([\s\S]+?)%>/g,
                            Pt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                            Lt = /^\w*$/,
                            Rt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                            It = /[\\^$.*+?()[\]{}|]/g,
                            Ft = RegExp(It.source),
                            Ot = /^\s+|\s+$/g,
                            Nt = /^\s+/,
                            Bt = /\s+$/,
                            Dt = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                            Vt = /\{\n\/\* \[wrapped with (.+)\] \*/,
                            jt = /,? & /,
                            kt = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
                            Ut = /\\(\\)?/g,
                            zt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
                            Gt = /\w*$/,
                            Ht = /^[-+]0x[0-9a-f]+$/i,
                            Wt = /^0b[01]+$/i,
                            Yt = /^\[object .+?Constructor\]$/,
                            Xt = /^0o[0-7]+$/i,
                            qt = /^(?:0|[1-9]\d*)$/,
                            Qt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
                            Zt = /($^)/,
                            Jt = /['\n\r\u2028\u2029\\]/g,
                            Kt = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",
                            $t = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
                            te = "[\\ud800-\\udfff]",
                            ee = "[" + $t + "]",
                            ne = "[" + Kt + "]",
                            ie = "\\d+",
                            re = "[\\u2700-\\u27bf]",
                            oe = "[a-z\\xdf-\\xf6\\xf8-\\xff]",
                            se = "[^\\ud800-\\udfff" + $t + ie + "\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]",
                            ae = "\\ud83c[\\udffb-\\udfff]",
                            le = "[^\\ud800-\\udfff]",
                            ce = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                            he = "[\\ud800-\\udbff][\\udc00-\\udfff]",
                            ue = "[A-Z\\xc0-\\xd6\\xd8-\\xde]",
                            de = "(?:" + oe + "|" + se + ")",
                            pe = "(?:" + ue + "|" + se + ")",
                            fe = "(?:" + ne + "|" + ae + ")?",
                            me = "[\\ufe0e\\ufe0f]?" + fe + "(?:\\u200d(?:" + [le, ce, he].join("|") + ")[\\ufe0e\\ufe0f]?" + fe + ")*",
                            ge = "(?:" + [re, ce, he].join("|") + ")" + me,
                            ve = "(?:" + [le + ne + "?", ne, ce, he, te].join("|") + ")",
                            ye = RegExp("['\u2019]", "g"),
                            xe = RegExp(ne, "g"),
                            be = RegExp(ae + "(?=" + ae + ")|" + ve + me, "g"),
                            we = RegExp([ue + "?" + oe + "+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=" + [ee, ue, "$"].join("|") + ")", pe + "+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=" + [ee, ue + de, "$"].join("|") + ")", ue + "?" + de + "+(?:['\u2019](?:d|ll|m|re|s|t|ve))?", ue + "+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?", "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", ie, ge].join("|"), "g"),
                            _e = RegExp("[\\u200d\\ud800-\\udfff" + Kt + "\\ufe0e\\ufe0f]"),
                            Se = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
                            Me = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
                            Ae = -1,
                            Te = {};
                        Te[ht] = Te[ut] = Te[dt] = Te[pt] = Te[ft] = Te[mt] = Te[gt] = Te[vt] = Te[yt] = !0, Te[U] = Te[z] = Te[lt] = Te[H] = Te[ct] = Te[W] = Te[X] = Te[q] = Te[Z] = Te[J] = Te[$] = Te[et] = Te[nt] = Te[it] = Te[st] = !1;
                        var Ee = {};
                        Ee[U] = Ee[z] = Ee[lt] = Ee[ct] = Ee[H] = Ee[W] = Ee[ht] = Ee[ut] = Ee[dt] = Ee[pt] = Ee[ft] = Ee[Z] = Ee[J] = Ee[$] = Ee[et] = Ee[nt] = Ee[it] = Ee[rt] = Ee[mt] = Ee[gt] = Ee[vt] = Ee[yt] = !0, Ee[X] = Ee[q] = Ee[st] = !1;
                        var Ce = {
                                "\\": "\\",
                                "'": "'",
                                "\n": "n",
                                "\r": "r",
                                "\u2028": "u2028",
                                "\u2029": "u2029"
                            },
                            Pe = parseFloat,
                            Le = parseInt,
                            Re = "object" == typeof t && t && t.Object === Object && t,
                            Ie = "object" == typeof self && self && self.Object === Object && self,
                            Fe = Re || Ie || Function("return this")(),
                            Oe = e && !e.nodeType && e,
                            Ne = Oe && "object" == typeof i && i && !i.nodeType && i,
                            Be = Ne && Ne.exports === Oe,
                            De = Be && Re.process,
                            Ve = function() {
                                try {
                                    return Ne && Ne.require && Ne.require("util").types || De && De.binding && De.binding("util")
                                } catch (t) {}
                            }(),
                            je = Ve && Ve.isArrayBuffer,
                            ke = Ve && Ve.isDate,
                            Ue = Ve && Ve.isMap,
                            ze = Ve && Ve.isRegExp,
                            Ge = Ve && Ve.isSet,
                            He = Ve && Ve.isTypedArray;

                        function We(t, e, n) {
                            switch (n.length) {
                                case 0:
                                    return t.call(e);
                                case 1:
                                    return t.call(e, n[0]);
                                case 2:
                                    return t.call(e, n[0], n[1]);
                                case 3:
                                    return t.call(e, n[0], n[1], n[2])
                            }
                            return t.apply(e, n)
                        }

                        function Ye(t, e, n, i) {
                            for (var r = -1, o = null == t ? 0 : t.length; ++r < o;) {
                                var s = t[r];
                                e(i, s, n(s), t)
                            }
                            return i
                        }

                        function Xe(t, e) {
                            for (var n = -1, i = null == t ? 0 : t.length; ++n < i && !1 !== e(t[n], n, t););
                            return t
                        }

                        function qe(t, e) {
                            for (var n = null == t ? 0 : t.length; n-- && !1 !== e(t[n], n, t););
                            return t
                        }

                        function Qe(t, e) {
                            for (var n = -1, i = null == t ? 0 : t.length; ++n < i;)
                                if (!e(t[n], n, t)) return !1;
                            return !0
                        }

                        function Ze(t, e) {
                            for (var n = -1, i = null == t ? 0 : t.length, r = 0, o = []; ++n < i;) {
                                var s = t[n];
                                e(s, n, t) && (o[r++] = s)
                            }
                            return o
                        }

                        function Je(t, e) {
                            return !(null == t || !t.length) && ln(t, e, 0) > -1
                        }

                        function Ke(t, e, n) {
                            for (var i = -1, r = null == t ? 0 : t.length; ++i < r;)
                                if (n(e, t[i])) return !0;
                            return !1
                        }

                        function $e(t, e) {
                            for (var n = -1, i = null == t ? 0 : t.length, r = Array(i); ++n < i;) r[n] = e(t[n], n, t);
                            return r
                        }

                        function tn(t, e) {
                            for (var n = -1, i = e.length, r = t.length; ++n < i;) t[r + n] = e[n];
                            return t
                        }

                        function en(t, e, n, i) {
                            var r = -1,
                                o = null == t ? 0 : t.length;
                            for (i && o && (n = t[++r]); ++r < o;) n = e(n, t[r], r, t);
                            return n
                        }

                        function nn(t, e, n, i) {
                            var r = null == t ? 0 : t.length;
                            for (i && r && (n = t[--r]); r--;) n = e(n, t[r], r, t);
                            return n
                        }

                        function rn(t, e) {
                            for (var n = -1, i = null == t ? 0 : t.length; ++n < i;)
                                if (e(t[n], n, t)) return !0;
                            return !1
                        }
                        var on = dn("length");

                        function sn(t, e, n) {
                            var i;
                            return n(t, (function(t, n, r) {
                                if (e(t, n, r)) return i = n, !1
                            })), i
                        }

                        function an(t, e, n, i) {
                            for (var r = t.length, o = n + (i ? 1 : -1); i ? o-- : ++o < r;)
                                if (e(t[o], o, t)) return o;
                            return -1
                        }

                        function ln(t, e, n) {
                            return e == e ? function(t, e, n) {
                                for (var i = n - 1, r = t.length; ++i < r;)
                                    if (t[i] === e) return i;
                                return -1
                            }(t, e, n) : an(t, hn, n)
                        }

                        function cn(t, e, n, i) {
                            for (var r = n - 1, o = t.length; ++r < o;)
                                if (i(t[r], e)) return r;
                            return -1
                        }

                        function hn(t) {
                            return t != t
                        }

                        function un(t, e) {
                            var n = null == t ? 0 : t.length;
                            return n ? mn(t, e) / n : B
                        }

                        function dn(t) {
                            return function(e) {
                                return null == e ? o : e[t]
                            }
                        }

                        function pn(t) {
                            return function(e) {
                                return null == t ? o : t[e]
                            }
                        }

                        function fn(t, e, n, i, r) {
                            return r(t, (function(t, r, o) {
                                n = i ? (i = !1, t) : e(n, t, r, o)
                            })), n
                        }

                        function mn(t, e) {
                            for (var n, i = -1, r = t.length; ++i < r;) {
                                var s = e(t[i]);
                                s !== o && (n = n === o ? s : n + s)
                            }
                            return n
                        }

                        function gn(t, e) {
                            for (var n = -1, i = Array(t); ++n < t;) i[n] = e(n);
                            return i
                        }

                        function vn(t) {
                            return function(e) {
                                return t(e)
                            }
                        }

                        function yn(t, e) {
                            return $e(e, (function(e) {
                                return t[e]
                            }))
                        }

                        function xn(t, e) {
                            return t.has(e)
                        }

                        function bn(t, e) {
                            for (var n = -1, i = t.length; ++n < i && ln(e, t[n], 0) > -1;);
                            return n
                        }

                        function wn(t, e) {
                            for (var n = t.length; n-- && ln(e, t[n], 0) > -1;);
                            return n
                        }
                        var _n = pn({
                                "\xc0": "A",
                                "\xc1": "A",
                                "\xc2": "A",
                                "\xc3": "A",
                                "\xc4": "A",
                                "\xc5": "A",
                                "\xe0": "a",
                                "\xe1": "a",
                                "\xe2": "a",
                                "\xe3": "a",
                                "\xe4": "a",
                                "\xe5": "a",
                                "\xc7": "C",
                                "\xe7": "c",
                                "\xd0": "D",
                                "\xf0": "d",
                                "\xc8": "E",
                                "\xc9": "E",
                                "\xca": "E",
                                "\xcb": "E",
                                "\xe8": "e",
                                "\xe9": "e",
                                "\xea": "e",
                                "\xeb": "e",
                                "\xcc": "I",
                                "\xcd": "I",
                                "\xce": "I",
                                "\xcf": "I",
                                "\xec": "i",
                                "\xed": "i",
                                "\xee": "i",
                                "\xef": "i",
                                "\xd1": "N",
                                "\xf1": "n",
                                "\xd2": "O",
                                "\xd3": "O",
                                "\xd4": "O",
                                "\xd5": "O",
                                "\xd6": "O",
                                "\xd8": "O",
                                "\xf2": "o",
                                "\xf3": "o",
                                "\xf4": "o",
                                "\xf5": "o",
                                "\xf6": "o",
                                "\xf8": "o",
                                "\xd9": "U",
                                "\xda": "U",
                                "\xdb": "U",
                                "\xdc": "U",
                                "\xf9": "u",
                                "\xfa": "u",
                                "\xfb": "u",
                                "\xfc": "u",
                                "\xdd": "Y",
                                "\xfd": "y",
                                "\xff": "y",
                                "\xc6": "Ae",
                                "\xe6": "ae",
                                "\xde": "Th",
                                "\xfe": "th",
                                "\xdf": "ss",
                                "\u0100": "A",
                                "\u0102": "A",
                                "\u0104": "A",
                                "\u0101": "a",
                                "\u0103": "a",
                                "\u0105": "a",
                                "\u0106": "C",
                                "\u0108": "C",
                                "\u010a": "C",
                                "\u010c": "C",
                                "\u0107": "c",
                                "\u0109": "c",
                                "\u010b": "c",
                                "\u010d": "c",
                                "\u010e": "D",
                                "\u0110": "D",
                                "\u010f": "d",
                                "\u0111": "d",
                                "\u0112": "E",
                                "\u0114": "E",
                                "\u0116": "E",
                                "\u0118": "E",
                                "\u011a": "E",
                                "\u0113": "e",
                                "\u0115": "e",
                                "\u0117": "e",
                                "\u0119": "e",
                                "\u011b": "e",
                                "\u011c": "G",
                                "\u011e": "G",
                                "\u0120": "G",
                                "\u0122": "G",
                                "\u011d": "g",
                                "\u011f": "g",
                                "\u0121": "g",
                                "\u0123": "g",
                                "\u0124": "H",
                                "\u0126": "H",
                                "\u0125": "h",
                                "\u0127": "h",
                                "\u0128": "I",
                                "\u012a": "I",
                                "\u012c": "I",
                                "\u012e": "I",
                                "\u0130": "I",
                                "\u0129": "i",
                                "\u012b": "i",
                                "\u012d": "i",
                                "\u012f": "i",
                                "\u0131": "i",
                                "\u0134": "J",
                                "\u0135": "j",
                                "\u0136": "K",
                                "\u0137": "k",
                                "\u0138": "k",
                                "\u0139": "L",
                                "\u013b": "L",
                                "\u013d": "L",
                                "\u013f": "L",
                                "\u0141": "L",
                                "\u013a": "l",
                                "\u013c": "l",
                                "\u013e": "l",
                                "\u0140": "l",
                                "\u0142": "l",
                                "\u0143": "N",
                                "\u0145": "N",
                                "\u0147": "N",
                                "\u014a": "N",
                                "\u0144": "n",
                                "\u0146": "n",
                                "\u0148": "n",
                                "\u014b": "n",
                                "\u014c": "O",
                                "\u014e": "O",
                                "\u0150": "O",
                                "\u014d": "o",
                                "\u014f": "o",
                                "\u0151": "o",
                                "\u0154": "R",
                                "\u0156": "R",
                                "\u0158": "R",
                                "\u0155": "r",
                                "\u0157": "r",
                                "\u0159": "r",
                                "\u015a": "S",
                                "\u015c": "S",
                                "\u015e": "S",
                                "\u0160": "S",
                                "\u015b": "s",
                                "\u015d": "s",
                                "\u015f": "s",
                                "\u0161": "s",
                                "\u0162": "T",
                                "\u0164": "T",
                                "\u0166": "T",
                                "\u0163": "t",
                                "\u0165": "t",
                                "\u0167": "t",
                                "\u0168": "U",
                                "\u016a": "U",
                                "\u016c": "U",
                                "\u016e": "U",
                                "\u0170": "U",
                                "\u0172": "U",
                                "\u0169": "u",
                                "\u016b": "u",
                                "\u016d": "u",
                                "\u016f": "u",
                                "\u0171": "u",
                                "\u0173": "u",
                                "\u0174": "W",
                                "\u0175": "w",
                                "\u0176": "Y",
                                "\u0177": "y",
                                "\u0178": "Y",
                                "\u0179": "Z",
                                "\u017b": "Z",
                                "\u017d": "Z",
                                "\u017a": "z",
                                "\u017c": "z",
                                "\u017e": "z",
                                "\u0132": "IJ",
                                "\u0133": "ij",
                                "\u0152": "Oe",
                                "\u0153": "oe",
                                "\u0149": "'n",
                                "\u017f": "s"
                            }),
                            Sn = pn({
                                "&": "&amp;",
                                "<": "&lt;",
                                ">": "&gt;",
                                '"': "&quot;",
                                "'": "&#39;"
                            });

                        function Mn(t) {
                            return "\\" + Ce[t]
                        }

                        function An(t) {
                            return _e.test(t)
                        }

                        function Tn(t) {
                            var e = -1,
                                n = Array(t.size);
                            return t.forEach((function(t, i) {
                                n[++e] = [i, t]
                            })), n
                        }

                        function En(t, e) {
                            return function(n) {
                                return t(e(n))
                            }
                        }

                        function Cn(t, e) {
                            for (var n = -1, i = t.length, r = 0, o = []; ++n < i;) {
                                var s = t[n];
                                s !== e && s !== u || (t[n] = u, o[r++] = n)
                            }
                            return o
                        }

                        function Pn(t) {
                            var e = -1,
                                n = Array(t.size);
                            return t.forEach((function(t) {
                                n[++e] = t
                            })), n
                        }

                        function Ln(t) {
                            var e = -1,
                                n = Array(t.size);
                            return t.forEach((function(t) {
                                n[++e] = [t, t]
                            })), n
                        }

                        function Rn(t) {
                            return An(t) ? function(t) {
                                for (var e = be.lastIndex = 0; be.test(t);) ++e;
                                return e
                            }(t) : on(t)
                        }

                        function In(t) {
                            return An(t) ? function(t) {
                                return t.match(be) || []
                            }(t) : function(t) {
                                return t.split("")
                            }(t)
                        }
                        var Fn = pn({
                                "&amp;": "&",
                                "&lt;": "<",
                                "&gt;": ">",
                                "&quot;": '"',
                                "&#39;": "'"
                            }),
                            On = function t(e) {
                                var n, i = (e = null == e ? Fe : On.defaults(Fe.Object(), e, On.pick(Fe, Me))).Array,
                                    r = e.Date,
                                    Kt = e.Error,
                                    $t = e.Function,
                                    te = e.Math,
                                    ee = e.Object,
                                    ne = e.RegExp,
                                    ie = e.String,
                                    re = e.TypeError,
                                    oe = i.prototype,
                                    se = $t.prototype,
                                    ae = ee.prototype,
                                    le = e["__core-js_shared__"],
                                    ce = se.toString,
                                    he = ae.hasOwnProperty,
                                    ue = 0,
                                    de = (n = /[^.]+$/.exec(le && le.keys && le.keys.IE_PROTO || "")) ? "Symbol(src)_1." + n : "",
                                    pe = ae.toString,
                                    fe = ce.call(ee),
                                    me = Fe._,
                                    ge = ne("^" + ce.call(he).replace(It, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                                    ve = Be ? e.Buffer : o,
                                    be = e.Symbol,
                                    _e = e.Uint8Array,
                                    Ce = ve ? ve.allocUnsafe : o,
                                    Re = En(ee.getPrototypeOf, ee),
                                    Ie = ee.create,
                                    Oe = ae.propertyIsEnumerable,
                                    Ne = oe.splice,
                                    De = be ? be.isConcatSpreadable : o,
                                    Ve = be ? be.iterator : o,
                                    on = be ? be.toStringTag : o,
                                    pn = function() {
                                        try {
                                            var t = jo(ee, "defineProperty");
                                            return t({}, "", {}), t
                                        } catch (t) {}
                                    }(),
                                    Nn = e.clearTimeout !== Fe.clearTimeout && e.clearTimeout,
                                    Bn = r && r.now !== Fe.Date.now && r.now,
                                    Dn = e.setTimeout !== Fe.setTimeout && e.setTimeout,
                                    Vn = te.ceil,
                                    jn = te.floor,
                                    kn = ee.getOwnPropertySymbols,
                                    Un = ve ? ve.isBuffer : o,
                                    zn = e.isFinite,
                                    Gn = oe.join,
                                    Hn = En(ee.keys, ee),
                                    Wn = te.max,
                                    Yn = te.min,
                                    Xn = r.now,
                                    qn = e.parseInt,
                                    Qn = te.random,
                                    Zn = oe.reverse,
                                    Jn = jo(e, "DataView"),
                                    Kn = jo(e, "Map"),
                                    $n = jo(e, "Promise"),
                                    ti = jo(e, "Set"),
                                    ei = jo(e, "WeakMap"),
                                    ni = jo(ee, "create"),
                                    ii = ei && new ei,
                                    ri = {},
                                    oi = us(Jn),
                                    si = us(Kn),
                                    ai = us($n),
                                    li = us(ti),
                                    ci = us(ei),
                                    hi = be ? be.prototype : o,
                                    ui = hi ? hi.valueOf : o,
                                    di = hi ? hi.toString : o;

                                function pi(t) {
                                    if (Ca(t) && !va(t) && !(t instanceof vi)) {
                                        if (t instanceof gi) return t;
                                        if (he.call(t, "__wrapped__")) return ds(t)
                                    }
                                    return new gi(t)
                                }
                                var fi = function() {
                                    function t() {}
                                    return function(e) {
                                        if (!Ea(e)) return {};
                                        if (Ie) return Ie(e);
                                        t.prototype = e;
                                        var n = new t;
                                        return t.prototype = o, n
                                    }
                                }();

                                function mi() {}

                                function gi(t, e) {
                                    this.__wrapped__ = t, this.__actions__ = [], this.__chain__ = !!e, this.__index__ = 0, this.__values__ = o
                                }

                                function vi(t) {
                                    this.__wrapped__ = t, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = D, this.__views__ = []
                                }

                                function yi(t) {
                                    var e = -1,
                                        n = null == t ? 0 : t.length;
                                    for (this.clear(); ++e < n;) {
                                        var i = t[e];
                                        this.set(i[0], i[1])
                                    }
                                }

                                function xi(t) {
                                    var e = -1,
                                        n = null == t ? 0 : t.length;
                                    for (this.clear(); ++e < n;) {
                                        var i = t[e];
                                        this.set(i[0], i[1])
                                    }
                                }

                                function bi(t) {
                                    var e = -1,
                                        n = null == t ? 0 : t.length;
                                    for (this.clear(); ++e < n;) {
                                        var i = t[e];
                                        this.set(i[0], i[1])
                                    }
                                }

                                function wi(t) {
                                    var e = -1,
                                        n = null == t ? 0 : t.length;
                                    for (this.__data__ = new bi; ++e < n;) this.add(t[e])
                                }

                                function _i(t) {
                                    var e = this.__data__ = new xi(t);
                                    this.size = e.size
                                }

                                function Si(t, e) {
                                    var n = va(t),
                                        i = !n && ga(t),
                                        r = !n && !i && wa(t),
                                        o = !n && !i && !r && Ba(t),
                                        s = n || i || r || o,
                                        a = s ? gn(t.length, ie) : [],
                                        l = a.length;
                                    for (var c in t) !e && !he.call(t, c) || s && ("length" == c || r && ("offset" == c || "parent" == c) || o && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || Yo(c, l)) || a.push(c);
                                    return a
                                }

                                function Mi(t) {
                                    var e = t.length;
                                    return e ? t[wr(0, e - 1)] : o
                                }

                                function Ai(t, e) {
                                    return ls(no(t), Oi(e, 0, t.length))
                                }

                                function Ti(t) {
                                    return ls(no(t))
                                }

                                function Ei(t, e, n) {
                                    (n === o || pa(t[e], n)) && (n !== o || e in t) || Ii(t, e, n)
                                }

                                function Ci(t, e, n) {
                                    var i = t[e];
                                    he.call(t, e) && pa(i, n) && (n !== o || e in t) || Ii(t, e, n)
                                }

                                function Pi(t, e) {
                                    for (var n = t.length; n--;)
                                        if (pa(t[n][0], e)) return n;
                                    return -1
                                }

                                function Li(t, e, n, i) {
                                    return ji(t, (function(t, r, o) {
                                        e(i, t, n(t), o)
                                    })), i
                                }

                                function Ri(t, e) {
                                    return t && io(e, rl(e), t)
                                }

                                function Ii(t, e, n) {
                                    "__proto__" == e && pn ? pn(t, e, {
                                        configurable: !0,
                                        enumerable: !0,
                                        value: n,
                                        writable: !0
                                    }) : t[e] = n
                                }

                                function Fi(t, e) {
                                    for (var n = -1, r = e.length, s = i(r), a = null == t; ++n < r;) s[n] = a ? o : $a(t, e[n]);
                                    return s
                                }

                                function Oi(t, e, n) {
                                    return t == t && (n !== o && (t = t <= n ? t : n), e !== o && (t = t >= e ? t : e)), t
                                }

                                function Ni(t, e, n, i, r, s) {
                                    var a, l = e & d,
                                        c = e & p,
                                        h = e & f;
                                    if (n && (a = r ? n(t, i, r, s) : n(t)), a !== o) return a;
                                    if (!Ea(t)) return t;
                                    var u = va(t);
                                    if (u) {
                                        if (a = function(t) {
                                                var e = t.length,
                                                    n = new t.constructor(e);
                                                return e && "string" == typeof t[0] && he.call(t, "index") && (n.index = t.index, n.input = t.input), n
                                            }(t), !l) return no(t, a)
                                    } else {
                                        var m = zo(t),
                                            g = m == q || m == Q;
                                        if (wa(t)) return Zr(t, l);
                                        if (m == $ || m == U || g && !r) {
                                            if (a = c || g ? {} : Ho(t), !l) return c ? function(t, e) {
                                                return io(t, Uo(t), e)
                                            }(t, function(t, e) {
                                                return t && io(e, ol(e), t)
                                            }(a, t)) : function(t, e) {
                                                return io(t, ko(t), e)
                                            }(t, Ri(a, t))
                                        } else {
                                            if (!Ee[m]) return r ? t : {};
                                            a = function(t, e, n) {
                                                var i, r = t.constructor;
                                                switch (e) {
                                                    case lt:
                                                        return Jr(t);
                                                    case H:
                                                    case W:
                                                        return new r(+t);
                                                    case ct:
                                                        return function(t, e) {
                                                            var n = e ? Jr(t.buffer) : t.buffer;
                                                            return new t.constructor(n, t.byteOffset, t.byteLength)
                                                        }(t, n);
                                                    case ht:
                                                    case ut:
                                                    case dt:
                                                    case pt:
                                                    case ft:
                                                    case mt:
                                                    case gt:
                                                    case vt:
                                                    case yt:
                                                        return Kr(t, n);
                                                    case Z:
                                                        return new r;
                                                    case J:
                                                    case it:
                                                        return new r(t);
                                                    case et:
                                                        return function(t) {
                                                            var e = new t.constructor(t.source, Gt.exec(t));
                                                            return e.lastIndex = t.lastIndex, e
                                                        }(t);
                                                    case nt:
                                                        return new r;
                                                    case rt:
                                                        return i = t, ui ? ee(ui.call(i)) : {}
                                                }
                                            }(t, m, l)
                                        }
                                    }
                                    s || (s = new _i);
                                    var v = s.get(t);
                                    if (v) return v;
                                    s.set(t, a), Fa(t) ? t.forEach((function(i) {
                                        a.add(Ni(i, e, n, i, t, s))
                                    })) : Pa(t) && t.forEach((function(i, r) {
                                        a.set(r, Ni(i, e, n, r, t, s))
                                    }));
                                    var y = u ? o : (h ? c ? Io : Ro : c ? ol : rl)(t);
                                    return Xe(y || t, (function(i, r) {
                                        y && (i = t[r = i]), Ci(a, r, Ni(i, e, n, r, t, s))
                                    })), a
                                }

                                function Bi(t, e, n) {
                                    var i = n.length;
                                    if (null == t) return !i;
                                    for (t = ee(t); i--;) {
                                        var r = n[i],
                                            s = e[r],
                                            a = t[r];
                                        if (a === o && !(r in t) || !s(a)) return !1
                                    }
                                    return !0
                                }

                                function Di(t, e, n) {
                                    if ("function" != typeof t) throw new re(l);
                                    return rs((function() {
                                        t.apply(o, n)
                                    }), e)
                                }

                                function Vi(t, e, n, i) {
                                    var r = -1,
                                        o = Je,
                                        a = !0,
                                        l = t.length,
                                        c = [],
                                        h = e.length;
                                    if (!l) return c;
                                    n && (e = $e(e, vn(n))), i ? (o = Ke, a = !1) : e.length >= s && (o = xn, a = !1, e = new wi(e));
                                    t: for (; ++r < l;) {
                                        var u = t[r],
                                            d = null == n ? u : n(u);
                                        if (u = i || 0 !== u ? u : 0, a && d == d) {
                                            for (var p = h; p--;)
                                                if (e[p] === d) continue t;
                                            c.push(u)
                                        } else o(e, d, i) || c.push(u)
                                    }
                                    return c
                                }
                                pi.templateSettings = {
                                    escape: Tt,
                                    evaluate: Et,
                                    interpolate: Ct,
                                    variable: "",
                                    imports: {
                                        _: pi
                                    }
                                }, pi.prototype = mi.prototype, pi.prototype.constructor = pi, gi.prototype = fi(mi.prototype), gi.prototype.constructor = gi, vi.prototype = fi(mi.prototype), vi.prototype.constructor = vi, yi.prototype.clear = function() {
                                    this.__data__ = ni ? ni(null) : {}, this.size = 0
                                }, yi.prototype.delete = function(t) {
                                    var e = this.has(t) && delete this.__data__[t];
                                    return this.size -= e ? 1 : 0, e
                                }, yi.prototype.get = function(t) {
                                    var e = this.__data__;
                                    if (ni) {
                                        var n = e[t];
                                        return n === c ? o : n
                                    }
                                    return he.call(e, t) ? e[t] : o
                                }, yi.prototype.has = function(t) {
                                    var e = this.__data__;
                                    return ni ? e[t] !== o : he.call(e, t)
                                }, yi.prototype.set = function(t, e) {
                                    var n = this.__data__;
                                    return this.size += this.has(t) ? 0 : 1, n[t] = ni && e === o ? c : e, this
                                }, xi.prototype.clear = function() {
                                    this.__data__ = [], this.size = 0
                                }, xi.prototype.delete = function(t) {
                                    var e = this.__data__,
                                        n = Pi(e, t);
                                    return !(n < 0) && (n == e.length - 1 ? e.pop() : Ne.call(e, n, 1), --this.size, !0)
                                }, xi.prototype.get = function(t) {
                                    var e = this.__data__,
                                        n = Pi(e, t);
                                    return n < 0 ? o : e[n][1]
                                }, xi.prototype.has = function(t) {
                                    return Pi(this.__data__, t) > -1
                                }, xi.prototype.set = function(t, e) {
                                    var n = this.__data__,
                                        i = Pi(n, t);
                                    return i < 0 ? (++this.size, n.push([t, e])) : n[i][1] = e, this
                                }, bi.prototype.clear = function() {
                                    this.size = 0, this.__data__ = {
                                        hash: new yi,
                                        map: new(Kn || xi),
                                        string: new yi
                                    }
                                }, bi.prototype.delete = function(t) {
                                    var e = Do(this, t).delete(t);
                                    return this.size -= e ? 1 : 0, e
                                }, bi.prototype.get = function(t) {
                                    return Do(this, t).get(t)
                                }, bi.prototype.has = function(t) {
                                    return Do(this, t).has(t)
                                }, bi.prototype.set = function(t, e) {
                                    var n = Do(this, t),
                                        i = n.size;
                                    return n.set(t, e), this.size += n.size == i ? 0 : 1, this
                                }, wi.prototype.add = wi.prototype.push = function(t) {
                                    return this.__data__.set(t, c), this
                                }, wi.prototype.has = function(t) {
                                    return this.__data__.has(t)
                                }, _i.prototype.clear = function() {
                                    this.__data__ = new xi, this.size = 0
                                }, _i.prototype.delete = function(t) {
                                    var e = this.__data__,
                                        n = e.delete(t);
                                    return this.size = e.size, n
                                }, _i.prototype.get = function(t) {
                                    return this.__data__.get(t)
                                }, _i.prototype.has = function(t) {
                                    return this.__data__.has(t)
                                }, _i.prototype.set = function(t, e) {
                                    var n = this.__data__;
                                    if (n instanceof xi) {
                                        var i = n.__data__;
                                        if (!Kn || i.length < s - 1) return i.push([t, e]), this.size = ++n.size, this;
                                        n = this.__data__ = new bi(i)
                                    }
                                    return n.set(t, e), this.size = n.size, this
                                };
                                var ji = so(Xi),
                                    ki = so(qi, !0);

                                function Ui(t, e) {
                                    var n = !0;
                                    return ji(t, (function(t, i, r) {
                                        return n = !!e(t, i, r)
                                    })), n
                                }

                                function zi(t, e, n) {
                                    for (var i = -1, r = t.length; ++i < r;) {
                                        var s = t[i],
                                            a = e(s);
                                        if (null != a && (l === o ? a == a && !Na(a) : n(a, l))) var l = a,
                                            c = s
                                    }
                                    return c
                                }

                                function Gi(t, e) {
                                    var n = [];
                                    return ji(t, (function(t, i, r) {
                                        e(t, i, r) && n.push(t)
                                    })), n
                                }

                                function Hi(t, e, n, i, r) {
                                    var o = -1,
                                        s = t.length;
                                    for (n || (n = Wo), r || (r = []); ++o < s;) {
                                        var a = t[o];
                                        e > 0 && n(a) ? e > 1 ? Hi(a, e - 1, n, i, r) : tn(r, a) : i || (r[r.length] = a)
                                    }
                                    return r
                                }
                                var Wi = ao(),
                                    Yi = ao(!0);

                                function Xi(t, e) {
                                    return t && Wi(t, e, rl)
                                }

                                function qi(t, e) {
                                    return t && Yi(t, e, rl)
                                }

                                function Qi(t, e) {
                                    return Ze(e, (function(e) {
                                        return Ma(t[e])
                                    }))
                                }

                                function Zi(t, e) {
                                    for (var n = 0, i = (e = Yr(e, t)).length; null != t && n < i;) t = t[hs(e[n++])];
                                    return n && n == i ? t : o
                                }

                                function Ji(t, e, n) {
                                    var i = e(t);
                                    return va(t) ? i : tn(i, n(t))
                                }

                                function Ki(t) {
                                    return null == t ? t === o ? ot : K : on && on in ee(t) ? function(t) {
                                        var e = he.call(t, on),
                                            n = t[on];
                                        try {
                                            t[on] = o;
                                            var i = !0
                                        } catch (t) {}
                                        var r = pe.call(t);
                                        return i && (e ? t[on] = n : delete t[on]), r
                                    }(t) : function(t) {
                                        return pe.call(t)
                                    }(t)
                                }

                                function $i(t, e) {
                                    return t > e
                                }

                                function tr(t, e) {
                                    return null != t && he.call(t, e)
                                }

                                function er(t, e) {
                                    return null != t && e in ee(t)
                                }

                                function nr(t, e, n) {
                                    for (var r = n ? Ke : Je, s = t[0].length, a = t.length, l = a, c = i(a), h = 1 / 0, u = []; l--;) {
                                        var d = t[l];
                                        l && e && (d = $e(d, vn(e))), h = Yn(d.length, h), c[l] = !n && (e || s >= 120 && d.length >= 120) ? new wi(l && d) : o
                                    }
                                    d = t[0];
                                    var p = -1,
                                        f = c[0];
                                    t: for (; ++p < s && u.length < h;) {
                                        var m = d[p],
                                            g = e ? e(m) : m;
                                        if (m = n || 0 !== m ? m : 0, !(f ? xn(f, g) : r(u, g, n))) {
                                            for (l = a; --l;) {
                                                var v = c[l];
                                                if (!(v ? xn(v, g) : r(t[l], g, n))) continue t
                                            }
                                            f && f.push(g), u.push(m)
                                        }
                                    }
                                    return u
                                }

                                function ir(t, e, n) {
                                    var i = null == (t = es(t, e = Yr(e, t))) ? t : t[hs(Ss(e))];
                                    return null == i ? o : We(i, t, n)
                                }

                                function rr(t) {
                                    return Ca(t) && Ki(t) == U
                                }

                                function or(t, e, n, i, r) {
                                    return t === e || (null == t || null == e || !Ca(t) && !Ca(e) ? t != t && e != e : function(t, e, n, i, r, s) {
                                        var a = va(t),
                                            l = va(e),
                                            c = a ? z : zo(t),
                                            h = l ? z : zo(e),
                                            u = (c = c == U ? $ : c) == $,
                                            d = (h = h == U ? $ : h) == $,
                                            p = c == h;
                                        if (p && wa(t)) {
                                            if (!wa(e)) return !1;
                                            a = !0, u = !1
                                        }
                                        if (p && !u) return s || (s = new _i), a || Ba(t) ? Po(t, e, n, i, r, s) : function(t, e, n, i, r, o, s) {
                                            switch (n) {
                                                case ct:
                                                    if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
                                                    t = t.buffer, e = e.buffer;
                                                case lt:
                                                    return !(t.byteLength != e.byteLength || !o(new _e(t), new _e(e)));
                                                case H:
                                                case W:
                                                case J:
                                                    return pa(+t, +e);
                                                case X:
                                                    return t.name == e.name && t.message == e.message;
                                                case et:
                                                case it:
                                                    return t == e + "";
                                                case Z:
                                                    var a = Tn;
                                                case nt:
                                                    var l = i & m;
                                                    if (a || (a = Pn), t.size != e.size && !l) return !1;
                                                    var c = s.get(t);
                                                    if (c) return c == e;
                                                    i |= g, s.set(t, e);
                                                    var h = Po(a(t), a(e), i, r, o, s);
                                                    return s.delete(t), h;
                                                case rt:
                                                    if (ui) return ui.call(t) == ui.call(e)
                                            }
                                            return !1
                                        }(t, e, c, n, i, r, s);
                                        if (!(n & m)) {
                                            var f = u && he.call(t, "__wrapped__"),
                                                v = d && he.call(e, "__wrapped__");
                                            if (f || v) {
                                                var y = f ? t.value() : t,
                                                    x = v ? e.value() : e;
                                                return s || (s = new _i), r(y, x, n, i, s)
                                            }
                                        }
                                        return !!p && (s || (s = new _i), function(t, e, n, i, r, s) {
                                            var a = n & m,
                                                l = Ro(t),
                                                c = l.length;
                                            if (c != Ro(e).length && !a) return !1;
                                            for (var h = c; h--;) {
                                                var u = l[h];
                                                if (!(a ? u in e : he.call(e, u))) return !1
                                            }
                                            var d = s.get(t);
                                            if (d && s.get(e)) return d == e;
                                            var p = !0;
                                            s.set(t, e), s.set(e, t);
                                            for (var f = a; ++h < c;) {
                                                var g = t[u = l[h]],
                                                    v = e[u];
                                                if (i) var y = a ? i(v, g, u, e, t, s) : i(g, v, u, t, e, s);
                                                if (!(y === o ? g === v || r(g, v, n, i, s) : y)) {
                                                    p = !1;
                                                    break
                                                }
                                                f || (f = "constructor" == u)
                                            }
                                            if (p && !f) {
                                                var x = t.constructor,
                                                    b = e.constructor;
                                                x != b && "constructor" in t && "constructor" in e && !("function" == typeof x && x instanceof x && "function" == typeof b && b instanceof b) && (p = !1)
                                            }
                                            return s.delete(t), s.delete(e), p
                                        }(t, e, n, i, r, s))
                                    }(t, e, n, i, or, r))
                                }

                                function sr(t, e, n, i) {
                                    var r = n.length,
                                        s = r,
                                        a = !i;
                                    if (null == t) return !s;
                                    for (t = ee(t); r--;) {
                                        var l = n[r];
                                        if (a && l[2] ? l[1] !== t[l[0]] : !(l[0] in t)) return !1
                                    }
                                    for (; ++r < s;) {
                                        var c = (l = n[r])[0],
                                            h = t[c],
                                            u = l[1];
                                        if (a && l[2]) {
                                            if (h === o && !(c in t)) return !1
                                        } else {
                                            var d = new _i;
                                            if (i) var p = i(h, u, c, t, e, d);
                                            if (!(p === o ? or(u, h, m | g, i, d) : p)) return !1
                                        }
                                    }
                                    return !0
                                }

                                function ar(t) {
                                    return !(!Ea(t) || (e = t, de && de in e)) && (Ma(t) ? ge : Yt).test(us(t));
                                    var e
                                }

                                function lr(t) {
                                    return "function" == typeof t ? t : null == t ? Ll : "object" == typeof t ? va(t) ? fr(t[0], t[1]) : pr(t) : jl(t)
                                }

                                function cr(t) {
                                    if (!Jo(t)) return Hn(t);
                                    var e = [];
                                    for (var n in ee(t)) he.call(t, n) && "constructor" != n && e.push(n);
                                    return e
                                }

                                function hr(t) {
                                    if (!Ea(t)) return function(t) {
                                        var e = [];
                                        if (null != t)
                                            for (var n in ee(t)) e.push(n);
                                        return e
                                    }(t);
                                    var e = Jo(t),
                                        n = [];
                                    for (var i in t)("constructor" != i || !e && he.call(t, i)) && n.push(i);
                                    return n
                                }

                                function ur(t, e) {
                                    return t < e
                                }

                                function dr(t, e) {
                                    var n = -1,
                                        r = xa(t) ? i(t.length) : [];
                                    return ji(t, (function(t, i, o) {
                                        r[++n] = e(t, i, o)
                                    })), r
                                }

                                function pr(t) {
                                    var e = Vo(t);
                                    return 1 == e.length && e[0][2] ? $o(e[0][0], e[0][1]) : function(n) {
                                        return n === t || sr(n, t, e)
                                    }
                                }

                                function fr(t, e) {
                                    return qo(t) && Ko(e) ? $o(hs(t), e) : function(n) {
                                        var i = $a(n, t);
                                        return i === o && i === e ? tl(n, t) : or(e, i, m | g)
                                    }
                                }

                                function mr(t, e, n, i, r) {
                                    t !== e && Wi(e, (function(s, a) {
                                        if (r || (r = new _i), Ea(s)) ! function(t, e, n, i, r, s, a) {
                                            var l = ns(t, n),
                                                c = ns(e, n),
                                                h = a.get(c);
                                            if (h) Ei(t, n, h);
                                            else {
                                                var u = s ? s(l, c, n + "", t, e, a) : o,
                                                    d = u === o;
                                                if (d) {
                                                    var p = va(c),
                                                        f = !p && wa(c),
                                                        m = !p && !f && Ba(c);
                                                    u = c, p || f || m ? va(l) ? u = l : ba(l) ? u = no(l) : f ? (d = !1, u = Zr(c, !0)) : m ? (d = !1, u = Kr(c, !0)) : u = [] : Ra(c) || ga(c) ? (u = l, ga(l) ? u = Ha(l) : Ea(l) && !Ma(l) || (u = Ho(c))) : d = !1
                                                }
                                                d && (a.set(c, u), r(u, c, i, s, a), a.delete(c)), Ei(t, n, u)
                                            }
                                        }(t, e, a, n, mr, i, r);
                                        else {
                                            var l = i ? i(ns(t, a), s, a + "", t, e, r) : o;
                                            l === o && (l = s), Ei(t, a, l)
                                        }
                                    }), ol)
                                }

                                function gr(t, e) {
                                    var n = t.length;
                                    if (n) return Yo(e += e < 0 ? n : 0, n) ? t[e] : o
                                }

                                function vr(t, e, n) {
                                    var i = -1;
                                    return e = $e(e.length ? e : [Ll], vn(Bo())),
                                        function(t, e) {
                                            var n = t.length;
                                            for (t.sort(e); n--;) t[n] = t[n].value;
                                            return t
                                        }(dr(t, (function(t, n, r) {
                                            return {
                                                criteria: $e(e, (function(e) {
                                                    return e(t)
                                                })),
                                                index: ++i,
                                                value: t
                                            }
                                        })), (function(t, e) {
                                            return function(t, e, n) {
                                                for (var i = -1, r = t.criteria, o = e.criteria, s = r.length, a = n.length; ++i < s;) {
                                                    var l = $r(r[i], o[i]);
                                                    if (l) return i >= a ? l : l * ("desc" == n[i] ? -1 : 1)
                                                }
                                                return t.index - e.index
                                            }(t, e, n)
                                        }))
                                }

                                function yr(t, e, n) {
                                    for (var i = -1, r = e.length, o = {}; ++i < r;) {
                                        var s = e[i],
                                            a = Zi(t, s);
                                        n(a, s) && Tr(o, Yr(s, t), a)
                                    }
                                    return o
                                }

                                function xr(t, e, n, i) {
                                    var r = i ? cn : ln,
                                        o = -1,
                                        s = e.length,
                                        a = t;
                                    for (t === e && (e = no(e)), n && (a = $e(t, vn(n))); ++o < s;)
                                        for (var l = 0, c = e[o], h = n ? n(c) : c;
                                            (l = r(a, h, l, i)) > -1;) a !== t && Ne.call(a, l, 1), Ne.call(t, l, 1);
                                    return t
                                }

                                function br(t, e) {
                                    for (var n = t ? e.length : 0, i = n - 1; n--;) {
                                        var r = e[n];
                                        if (n == i || r !== o) {
                                            var o = r;
                                            Yo(r) ? Ne.call(t, r, 1) : Vr(t, r)
                                        }
                                    }
                                    return t
                                }

                                function wr(t, e) {
                                    return t + jn(Qn() * (e - t + 1))
                                }

                                function _r(t, e) {
                                    var n = "";
                                    if (!t || e < 1 || e > O) return n;
                                    do {
                                        e % 2 && (n += t), (e = jn(e / 2)) && (t += t)
                                    } while (e);
                                    return n
                                }

                                function Sr(t, e) {
                                    return os(ts(t, e, Ll), t + "")
                                }

                                function Mr(t) {
                                    return Mi(pl(t))
                                }

                                function Ar(t, e) {
                                    var n = pl(t);
                                    return ls(n, Oi(e, 0, n.length))
                                }

                                function Tr(t, e, n, i) {
                                    if (!Ea(t)) return t;
                                    for (var r = -1, s = (e = Yr(e, t)).length, a = s - 1, l = t; null != l && ++r < s;) {
                                        var c = hs(e[r]),
                                            h = n;
                                        if (r != a) {
                                            var u = l[c];
                                            (h = i ? i(u, c, l) : o) === o && (h = Ea(u) ? u : Yo(e[r + 1]) ? [] : {})
                                        }
                                        Ci(l, c, h), l = l[c]
                                    }
                                    return t
                                }
                                var Er = ii ? function(t, e) {
                                        return ii.set(t, e), t
                                    } : Ll,
                                    Cr = pn ? function(t, e) {
                                        return pn(t, "toString", {
                                            configurable: !0,
                                            enumerable: !1,
                                            value: El(e),
                                            writable: !0
                                        })
                                    } : Ll;

                                function Pr(t) {
                                    return ls(pl(t))
                                }

                                function Lr(t, e, n) {
                                    var r = -1,
                                        o = t.length;
                                    e < 0 && (e = -e > o ? 0 : o + e), (n = n > o ? o : n) < 0 && (n += o), o = e > n ? 0 : n - e >>> 0, e >>>= 0;
                                    for (var s = i(o); ++r < o;) s[r] = t[r + e];
                                    return s
                                }

                                function Rr(t, e) {
                                    var n;
                                    return ji(t, (function(t, i, r) {
                                        return !(n = e(t, i, r))
                                    })), !!n
                                }

                                function Ir(t, e, n) {
                                    var i = 0,
                                        r = null == t ? i : t.length;
                                    if ("number" == typeof e && e == e && r <= j) {
                                        for (; i < r;) {
                                            var o = i + r >>> 1,
                                                s = t[o];
                                            null !== s && !Na(s) && (n ? s <= e : s < e) ? i = o + 1 : r = o
                                        }
                                        return r
                                    }
                                    return Fr(t, e, Ll, n)
                                }

                                function Fr(t, e, n, i) {
                                    e = n(e);
                                    for (var r = 0, s = null == t ? 0 : t.length, a = e != e, l = null === e, c = Na(e), h = e === o; r < s;) {
                                        var u = jn((r + s) / 2),
                                            d = n(t[u]),
                                            p = d !== o,
                                            f = null === d,
                                            m = d == d,
                                            g = Na(d);
                                        if (a) var v = i || m;
                                        else v = h ? m && (i || p) : l ? m && p && (i || !f) : c ? m && p && !f && (i || !g) : !f && !g && (i ? d <= e : d < e);
                                        v ? r = u + 1 : s = u
                                    }
                                    return Yn(s, V)
                                }

                                function Or(t, e) {
                                    for (var n = -1, i = t.length, r = 0, o = []; ++n < i;) {
                                        var s = t[n],
                                            a = e ? e(s) : s;
                                        if (!n || !pa(a, l)) {
                                            var l = a;
                                            o[r++] = 0 === s ? 0 : s
                                        }
                                    }
                                    return o
                                }

                                function Nr(t) {
                                    return "number" == typeof t ? t : Na(t) ? B : +t
                                }

                                function Br(t) {
                                    if ("string" == typeof t) return t;
                                    if (va(t)) return $e(t, Br) + "";
                                    if (Na(t)) return di ? di.call(t) : "";
                                    var e = t + "";
                                    return "0" == e && 1 / t == -F ? "-0" : e
                                }

                                function Dr(t, e, n) {
                                    var i = -1,
                                        r = Je,
                                        o = t.length,
                                        a = !0,
                                        l = [],
                                        c = l;
                                    if (n) a = !1, r = Ke;
                                    else if (o >= s) {
                                        var h = e ? null : So(t);
                                        if (h) return Pn(h);
                                        a = !1, r = xn, c = new wi
                                    } else c = e ? [] : l;
                                    t: for (; ++i < o;) {
                                        var u = t[i],
                                            d = e ? e(u) : u;
                                        if (u = n || 0 !== u ? u : 0, a && d == d) {
                                            for (var p = c.length; p--;)
                                                if (c[p] === d) continue t;
                                            e && c.push(d), l.push(u)
                                        } else r(c, d, n) || (c !== l && c.push(d), l.push(u))
                                    }
                                    return l
                                }

                                function Vr(t, e) {
                                    return null == (t = es(t, e = Yr(e, t))) || delete t[hs(Ss(e))]
                                }

                                function jr(t, e, n, i) {
                                    return Tr(t, e, n(Zi(t, e)), i)
                                }

                                function kr(t, e, n, i) {
                                    for (var r = t.length, o = i ? r : -1;
                                        (i ? o-- : ++o < r) && e(t[o], o, t););
                                    return n ? Lr(t, i ? 0 : o, i ? o + 1 : r) : Lr(t, i ? o + 1 : 0, i ? r : o)
                                }

                                function Ur(t, e) {
                                    var n = t;
                                    return n instanceof vi && (n = n.value()), en(e, (function(t, e) {
                                        return e.func.apply(e.thisArg, tn([t], e.args))
                                    }), n)
                                }

                                function zr(t, e, n) {
                                    var r = t.length;
                                    if (r < 2) return r ? Dr(t[0]) : [];
                                    for (var o = -1, s = i(r); ++o < r;)
                                        for (var a = t[o], l = -1; ++l < r;) l != o && (s[o] = Vi(s[o] || a, t[l], e, n));
                                    return Dr(Hi(s, 1), e, n)
                                }

                                function Gr(t, e, n) {
                                    for (var i = -1, r = t.length, s = e.length, a = {}; ++i < r;) {
                                        var l = i < s ? e[i] : o;
                                        n(a, t[i], l)
                                    }
                                    return a
                                }

                                function Hr(t) {
                                    return ba(t) ? t : []
                                }

                                function Wr(t) {
                                    return "function" == typeof t ? t : Ll
                                }

                                function Yr(t, e) {
                                    return va(t) ? t : qo(t, e) ? [t] : cs(Wa(t))
                                }
                                var Xr = Sr;

                                function qr(t, e, n) {
                                    var i = t.length;
                                    return n = n === o ? i : n, !e && n >= i ? t : Lr(t, e, n)
                                }
                                var Qr = Nn || function(t) {
                                    return Fe.clearTimeout(t)
                                };

                                function Zr(t, e) {
                                    if (e) return t.slice();
                                    var n = t.length,
                                        i = Ce ? Ce(n) : new t.constructor(n);
                                    return t.copy(i), i
                                }

                                function Jr(t) {
                                    var e = new t.constructor(t.byteLength);
                                    return new _e(e).set(new _e(t)), e
                                }

                                function Kr(t, e) {
                                    var n = e ? Jr(t.buffer) : t.buffer;
                                    return new t.constructor(n, t.byteOffset, t.length)
                                }

                                function $r(t, e) {
                                    if (t !== e) {
                                        var n = t !== o,
                                            i = null === t,
                                            r = t == t,
                                            s = Na(t),
                                            a = e !== o,
                                            l = null === e,
                                            c = e == e,
                                            h = Na(e);
                                        if (!l && !h && !s && t > e || s && a && c && !l && !h || i && a && c || !n && c || !r) return 1;
                                        if (!i && !s && !h && t < e || h && n && r && !i && !s || l && n && r || !a && r || !c) return -1
                                    }
                                    return 0
                                }

                                function to(t, e, n, r) {
                                    for (var o = -1, s = t.length, a = n.length, l = -1, c = e.length, h = Wn(s - a, 0), u = i(c + h), d = !r; ++l < c;) u[l] = e[l];
                                    for (; ++o < a;)(d || o < s) && (u[n[o]] = t[o]);
                                    for (; h--;) u[l++] = t[o++];
                                    return u
                                }

                                function eo(t, e, n, r) {
                                    for (var o = -1, s = t.length, a = -1, l = n.length, c = -1, h = e.length, u = Wn(s - l, 0), d = i(u + h), p = !r; ++o < u;) d[o] = t[o];
                                    for (var f = o; ++c < h;) d[f + c] = e[c];
                                    for (; ++a < l;)(p || o < s) && (d[f + n[a]] = t[o++]);
                                    return d
                                }

                                function no(t, e) {
                                    var n = -1,
                                        r = t.length;
                                    for (e || (e = i(r)); ++n < r;) e[n] = t[n];
                                    return e
                                }

                                function io(t, e, n, i) {
                                    var r = !n;
                                    n || (n = {});
                                    for (var s = -1, a = e.length; ++s < a;) {
                                        var l = e[s],
                                            c = i ? i(n[l], t[l], l, n, t) : o;
                                        c === o && (c = t[l]), r ? Ii(n, l, c) : Ci(n, l, c)
                                    }
                                    return n
                                }

                                function ro(t, e) {
                                    return function(n, i) {
                                        var r = va(n) ? Ye : Li,
                                            o = e ? e() : {};
                                        return r(n, t, Bo(i, 2), o)
                                    }
                                }

                                function oo(t) {
                                    return Sr((function(e, n) {
                                        var i = -1,
                                            r = n.length,
                                            s = r > 1 ? n[r - 1] : o,
                                            a = r > 2 ? n[2] : o;
                                        for (s = t.length > 3 && "function" == typeof s ? (r--, s) : o, a && Xo(n[0], n[1], a) && (s = r < 3 ? o : s, r = 1), e = ee(e); ++i < r;) {
                                            var l = n[i];
                                            l && t(e, l, i, s)
                                        }
                                        return e
                                    }))
                                }

                                function so(t, e) {
                                    return function(n, i) {
                                        if (null == n) return n;
                                        if (!xa(n)) return t(n, i);
                                        for (var r = n.length, o = e ? r : -1, s = ee(n);
                                            (e ? o-- : ++o < r) && !1 !== i(s[o], o, s););
                                        return n
                                    }
                                }

                                function ao(t) {
                                    return function(e, n, i) {
                                        for (var r = -1, o = ee(e), s = i(e), a = s.length; a--;) {
                                            var l = s[t ? a : ++r];
                                            if (!1 === n(o[l], l, o)) break
                                        }
                                        return e
                                    }
                                }

                                function lo(t) {
                                    return function(e) {
                                        var n = An(e = Wa(e)) ? In(e) : o,
                                            i = n ? n[0] : e.charAt(0),
                                            r = n ? qr(n, 1).join("") : e.slice(1);
                                        return i[t]() + r
                                    }
                                }

                                function co(t) {
                                    return function(e) {
                                        return en(Ml(gl(e).replace(ye, "")), t, "")
                                    }
                                }

                                function ho(t) {
                                    return function() {
                                        var e = arguments;
                                        switch (e.length) {
                                            case 0:
                                                return new t;
                                            case 1:
                                                return new t(e[0]);
                                            case 2:
                                                return new t(e[0], e[1]);
                                            case 3:
                                                return new t(e[0], e[1], e[2]);
                                            case 4:
                                                return new t(e[0], e[1], e[2], e[3]);
                                            case 5:
                                                return new t(e[0], e[1], e[2], e[3], e[4]);
                                            case 6:
                                                return new t(e[0], e[1], e[2], e[3], e[4], e[5]);
                                            case 7:
                                                return new t(e[0], e[1], e[2], e[3], e[4], e[5], e[6])
                                        }
                                        var n = fi(t.prototype),
                                            i = t.apply(n, e);
                                        return Ea(i) ? i : n
                                    }
                                }

                                function uo(t) {
                                    return function(e, n, i) {
                                        var r = ee(e);
                                        if (!xa(e)) {
                                            var s = Bo(n, 3);
                                            e = rl(e), n = function(t) {
                                                return s(r[t], t, r)
                                            }
                                        }
                                        var a = t(e, n, i);
                                        return a > -1 ? r[s ? e[a] : a] : o
                                    }
                                }

                                function po(t) {
                                    return Lo((function(e) {
                                        var n = e.length,
                                            i = n,
                                            r = gi.prototype.thru;
                                        for (t && e.reverse(); i--;) {
                                            var s = e[i];
                                            if ("function" != typeof s) throw new re(l);
                                            if (r && !a && "wrapper" == Oo(s)) var a = new gi([], !0)
                                        }
                                        for (i = a ? i : n; ++i < n;) {
                                            var c = Oo(s = e[i]),
                                                h = "wrapper" == c ? Fo(s) : o;
                                            a = h && Qo(h[0]) && h[1] == (M | b | _ | A) && !h[4].length && 1 == h[9] ? a[Oo(h[0])].apply(a, h[3]) : 1 == s.length && Qo(s) ? a[c]() : a.thru(s)
                                        }
                                        return function() {
                                            var t = arguments,
                                                i = t[0];
                                            if (a && 1 == t.length && va(i)) return a.plant(i).value();
                                            for (var r = 0, o = n ? e[r].apply(this, t) : i; ++r < n;) o = e[r].call(this, o);
                                            return o
                                        }
                                    }))
                                }

                                function fo(t, e, n, r, s, a, l, c, h, u) {
                                    var d = e & M,
                                        p = e & v,
                                        f = e & y,
                                        m = e & (b | w),
                                        g = e & T,
                                        x = f ? o : ho(t);
                                    return function v() {
                                        for (var y = arguments.length, b = i(y), w = y; w--;) b[w] = arguments[w];
                                        if (m) var _ = No(v),
                                            S = function(t, e) {
                                                for (var n = t.length, i = 0; n--;) t[n] === e && ++i;
                                                return i
                                            }(b, _);
                                        if (r && (b = to(b, r, s, m)), a && (b = eo(b, a, l, m)), y -= S, m && y < u) {
                                            var M = Cn(b, _);
                                            return wo(t, e, fo, v.placeholder, n, b, M, c, h, u - y)
                                        }
                                        var A = p ? n : this,
                                            T = f ? A[t] : t;
                                        return y = b.length, c ? b = function(t, e) {
                                            for (var n = t.length, i = Yn(e.length, n), r = no(t); i--;) {
                                                var s = e[i];
                                                t[i] = Yo(s, n) ? r[s] : o
                                            }
                                            return t
                                        }(b, c) : g && y > 1 && b.reverse(), d && h < y && (b.length = h), this && this !== Fe && this instanceof v && (T = x || ho(T)), T.apply(A, b)
                                    }
                                }

                                function mo(t, e) {
                                    return function(n, i) {
                                        return function(t, e, n, i) {
                                            return Xi(t, (function(t, r, o) {
                                                e(i, n(t), r, o)
                                            })), i
                                        }(n, t, e(i), {})
                                    }
                                }

                                function go(t, e) {
                                    return function(n, i) {
                                        var r;
                                        if (n === o && i === o) return e;
                                        if (n !== o && (r = n), i !== o) {
                                            if (r === o) return i;
                                            "string" == typeof n || "string" == typeof i ? (n = Br(n), i = Br(i)) : (n = Nr(n), i = Nr(i)), r = t(n, i)
                                        }
                                        return r
                                    }
                                }

                                function vo(t) {
                                    return Lo((function(e) {
                                        return e = $e(e, vn(Bo())), Sr((function(n) {
                                            var i = this;
                                            return t(e, (function(t) {
                                                return We(t, i, n)
                                            }))
                                        }))
                                    }))
                                }

                                function yo(t, e) {
                                    var n = (e = e === o ? " " : Br(e)).length;
                                    if (n < 2) return n ? _r(e, t) : e;
                                    var i = _r(e, Vn(t / Rn(e)));
                                    return An(e) ? qr(In(i), 0, t).join("") : i.slice(0, t)
                                }

                                function xo(t) {
                                    return function(e, n, r) {
                                        return r && "number" != typeof r && Xo(e, n, r) && (n = r = o), e = ka(e), n === o ? (n = e, e = 0) : n = ka(n),
                                            function(t, e, n, r) {
                                                for (var o = -1, s = Wn(Vn((e - t) / (n || 1)), 0), a = i(s); s--;) a[r ? s : ++o] = t, t += n;
                                                return a
                                            }(e, n, r = r === o ? e < n ? 1 : -1 : ka(r), t)
                                    }
                                }

                                function bo(t) {
                                    return function(e, n) {
                                        return "string" == typeof e && "string" == typeof n || (e = Ga(e), n = Ga(n)), t(e, n)
                                    }
                                }

                                function wo(t, e, n, i, r, s, a, l, c, h) {
                                    var u = e & b;
                                    e |= u ? _ : S, (e &= ~(u ? S : _)) & x || (e &= ~(v | y));
                                    var d = [t, e, r, u ? s : o, u ? a : o, u ? o : s, u ? o : a, l, c, h],
                                        p = n.apply(o, d);
                                    return Qo(t) && is(p, d), p.placeholder = i, ss(p, t, e)
                                }

                                function _o(t) {
                                    var e = te[t];
                                    return function(t, n) {
                                        if (t = Ga(t), (n = null == n ? 0 : Yn(Ua(n), 292)) && zn(t)) {
                                            var i = (Wa(t) + "e").split("e");
                                            return +((i = (Wa(e(i[0] + "e" + (+i[1] + n))) + "e").split("e"))[0] + "e" + (+i[1] - n))
                                        }
                                        return e(t)
                                    }
                                }
                                var So = ti && 1 / Pn(new ti([, -0]))[1] == F ? function(t) {
                                    return new ti(t)
                                } : Nl;

                                function Mo(t) {
                                    return function(e) {
                                        var n = zo(e);
                                        return n == Z ? Tn(e) : n == nt ? Ln(e) : function(t, e) {
                                            return $e(e, (function(e) {
                                                return [e, t[e]]
                                            }))
                                        }(e, t(e))
                                    }
                                }

                                function Ao(t, e, n, r, s, a, c, h) {
                                    var d = e & y;
                                    if (!d && "function" != typeof t) throw new re(l);
                                    var p = r ? r.length : 0;
                                    if (p || (e &= ~(_ | S), r = s = o), c = c === o ? c : Wn(Ua(c), 0), h = h === o ? h : Ua(h), p -= s ? s.length : 0, e & S) {
                                        var f = r,
                                            m = s;
                                        r = s = o
                                    }
                                    var g = d ? o : Fo(t),
                                        T = [t, e, n, r, s, f, m, a, c, h];
                                    if (g && function(t, e) {
                                            var n = t[1],
                                                i = e[1],
                                                r = n | i,
                                                o = r < (v | y | M),
                                                s = i == M && n == b || i == M && n == A && t[7].length <= e[8] || i == (M | A) && e[7].length <= e[8] && n == b;
                                            if (!o && !s) return t;
                                            i & v && (t[2] = e[2], r |= n & v ? 0 : x);
                                            var a = e[3];
                                            if (a) {
                                                var l = t[3];
                                                t[3] = l ? to(l, a, e[4]) : a, t[4] = l ? Cn(t[3], u) : e[4]
                                            }(a = e[5]) && (l = t[5], t[5] = l ? eo(l, a, e[6]) : a, t[6] = l ? Cn(t[5], u) : e[6]), (a = e[7]) && (t[7] = a), i & M && (t[8] = null == t[8] ? e[8] : Yn(t[8], e[8])), null == t[9] && (t[9] = e[9]), t[0] = e[0], t[1] = r
                                        }(T, g), t = T[0], e = T[1], n = T[2], r = T[3], s = T[4], !(h = T[9] = T[9] === o ? d ? 0 : t.length : Wn(T[9] - p, 0)) && e & (b | w) && (e &= ~(b | w)), e && e != v) E = e == b || e == w ? function(t, e, n) {
                                        var r = ho(t);
                                        return function s() {
                                            for (var a = arguments.length, l = i(a), c = a, h = No(s); c--;) l[c] = arguments[c];
                                            var u = a < 3 && l[0] !== h && l[a - 1] !== h ? [] : Cn(l, h);
                                            return (a -= u.length) < n ? wo(t, e, fo, s.placeholder, o, l, u, o, o, n - a) : We(this && this !== Fe && this instanceof s ? r : t, this, l)
                                        }
                                    }(t, e, h) : e != _ && e != (v | _) || s.length ? fo.apply(o, T) : function(t, e, n, r) {
                                        var o = e & v,
                                            s = ho(t);
                                        return function e() {
                                            for (var a = -1, l = arguments.length, c = -1, h = r.length, u = i(h + l), d = this && this !== Fe && this instanceof e ? s : t; ++c < h;) u[c] = r[c];
                                            for (; l--;) u[c++] = arguments[++a];
                                            return We(d, o ? n : this, u)
                                        }
                                    }(t, e, n, r);
                                    else var E = function(t, e, n) {
                                        var i = e & v,
                                            r = ho(t);
                                        return function e() {
                                            return (this && this !== Fe && this instanceof e ? r : t).apply(i ? n : this, arguments)
                                        }
                                    }(t, e, n);
                                    return ss((g ? Er : is)(E, T), t, e)
                                }

                                function To(t, e, n, i) {
                                    return t === o || pa(t, ae[n]) && !he.call(i, n) ? e : t
                                }

                                function Eo(t, e, n, i, r, s) {
                                    return Ea(t) && Ea(e) && (s.set(e, t), mr(t, e, o, Eo, s), s.delete(e)), t
                                }

                                function Co(t) {
                                    return Ra(t) ? o : t
                                }

                                function Po(t, e, n, i, r, s) {
                                    var a = n & m,
                                        l = t.length,
                                        c = e.length;
                                    if (l != c && !(a && c > l)) return !1;
                                    var h = s.get(t);
                                    if (h && s.get(e)) return h == e;
                                    var u = -1,
                                        d = !0,
                                        p = n & g ? new wi : o;
                                    for (s.set(t, e), s.set(e, t); ++u < l;) {
                                        var f = t[u],
                                            v = e[u];
                                        if (i) var y = a ? i(v, f, u, e, t, s) : i(f, v, u, t, e, s);
                                        if (y !== o) {
                                            if (y) continue;
                                            d = !1;
                                            break
                                        }
                                        if (p) {
                                            if (!rn(e, (function(t, e) {
                                                    if (!xn(p, e) && (f === t || r(f, t, n, i, s))) return p.push(e)
                                                }))) {
                                                d = !1;
                                                break
                                            }
                                        } else if (f !== v && !r(f, v, n, i, s)) {
                                            d = !1;
                                            break
                                        }
                                    }
                                    return s.delete(t), s.delete(e), d
                                }

                                function Lo(t) {
                                    return os(ts(t, o, ys), t + "")
                                }

                                function Ro(t) {
                                    return Ji(t, rl, ko)
                                }

                                function Io(t) {
                                    return Ji(t, ol, Uo)
                                }
                                var Fo = ii ? function(t) {
                                    return ii.get(t)
                                } : Nl;

                                function Oo(t) {
                                    for (var e = t.name + "", n = ri[e], i = he.call(ri, e) ? n.length : 0; i--;) {
                                        var r = n[i],
                                            o = r.func;
                                        if (null == o || o == t) return r.name
                                    }
                                    return e
                                }

                                function No(t) {
                                    return (he.call(pi, "placeholder") ? pi : t).placeholder
                                }

                                function Bo() {
                                    var t = pi.iteratee || Rl;
                                    return t = t === Rl ? lr : t, arguments.length ? t(arguments[0], arguments[1]) : t
                                }

                                function Do(t, e) {
                                    var n, i, r = t.__data__;
                                    return ("string" == (i = typeof(n = e)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? r["string" == typeof e ? "string" : "hash"] : r.map
                                }

                                function Vo(t) {
                                    for (var e = rl(t), n = e.length; n--;) {
                                        var i = e[n],
                                            r = t[i];
                                        e[n] = [i, r, Ko(r)]
                                    }
                                    return e
                                }

                                function jo(t, e) {
                                    var n = function(t, e) {
                                        return null == t ? o : t[e]
                                    }(t, e);
                                    return ar(n) ? n : o
                                }
                                var ko = kn ? function(t) {
                                        return null == t ? [] : (t = ee(t), Ze(kn(t), (function(e) {
                                            return Oe.call(t, e)
                                        })))
                                    } : zl,
                                    Uo = kn ? function(t) {
                                        for (var e = []; t;) tn(e, ko(t)), t = Re(t);
                                        return e
                                    } : zl,
                                    zo = Ki;

                                function Go(t, e, n) {
                                    for (var i = -1, r = (e = Yr(e, t)).length, o = !1; ++i < r;) {
                                        var s = hs(e[i]);
                                        if (!(o = null != t && n(t, s))) break;
                                        t = t[s]
                                    }
                                    return o || ++i != r ? o : !!(r = null == t ? 0 : t.length) && Ta(r) && Yo(s, r) && (va(t) || ga(t))
                                }

                                function Ho(t) {
                                    return "function" != typeof t.constructor || Jo(t) ? {} : fi(Re(t))
                                }

                                function Wo(t) {
                                    return va(t) || ga(t) || !!(De && t && t[De])
                                }

                                function Yo(t, e) {
                                    var n = typeof t;
                                    return !!(e = null == e ? O : e) && ("number" == n || "symbol" != n && qt.test(t)) && t > -1 && t % 1 == 0 && t < e
                                }

                                function Xo(t, e, n) {
                                    if (!Ea(n)) return !1;
                                    var i = typeof e;
                                    return !!("number" == i ? xa(n) && Yo(e, n.length) : "string" == i && e in n) && pa(n[e], t)
                                }

                                function qo(t, e) {
                                    if (va(t)) return !1;
                                    var n = typeof t;
                                    return !("number" != n && "symbol" != n && "boolean" != n && null != t && !Na(t)) || Lt.test(t) || !Pt.test(t) || null != e && t in ee(e)
                                }

                                function Qo(t) {
                                    var e = Oo(t),
                                        n = pi[e];
                                    if ("function" != typeof n || !(e in vi.prototype)) return !1;
                                    if (t === n) return !0;
                                    var i = Fo(n);
                                    return !!i && t === i[0]
                                }(Jn && zo(new Jn(new ArrayBuffer(1))) != ct || Kn && zo(new Kn) != Z || $n && "[object Promise]" != zo($n.resolve()) || ti && zo(new ti) != nt || ei && zo(new ei) != st) && (zo = function(t) {
                                    var e = Ki(t),
                                        n = e == $ ? t.constructor : o,
                                        i = n ? us(n) : "";
                                    if (i) switch (i) {
                                        case oi:
                                            return ct;
                                        case si:
                                            return Z;
                                        case ai:
                                            return "[object Promise]";
                                        case li:
                                            return nt;
                                        case ci:
                                            return st
                                    }
                                    return e
                                });
                                var Zo = le ? Ma : Gl;

                                function Jo(t) {
                                    var e = t && t.constructor;
                                    return t === ("function" == typeof e && e.prototype || ae)
                                }

                                function Ko(t) {
                                    return t == t && !Ea(t)
                                }

                                function $o(t, e) {
                                    return function(n) {
                                        return null != n && n[t] === e && (e !== o || t in ee(n))
                                    }
                                }

                                function ts(t, e, n) {
                                    return e = Wn(e === o ? t.length - 1 : e, 0),
                                        function() {
                                            for (var r = arguments, o = -1, s = Wn(r.length - e, 0), a = i(s); ++o < s;) a[o] = r[e + o];
                                            o = -1;
                                            for (var l = i(e + 1); ++o < e;) l[o] = r[o];
                                            return l[e] = n(a), We(t, this, l)
                                        }
                                }

                                function es(t, e) {
                                    return e.length < 2 ? t : Zi(t, Lr(e, 0, -1))
                                }

                                function ns(t, e) {
                                    if (("constructor" !== e || "function" != typeof t[e]) && "__proto__" != e) return t[e]
                                }
                                var is = as(Er),
                                    rs = Dn || function(t, e) {
                                        return Fe.setTimeout(t, e)
                                    },
                                    os = as(Cr);

                                function ss(t, e, n) {
                                    var i = e + "";
                                    return os(t, function(t, e) {
                                        var n = e.length;
                                        if (!n) return t;
                                        var i = n - 1;
                                        return e[i] = (n > 1 ? "& " : "") + e[i], e = e.join(n > 2 ? ", " : " "), t.replace(Dt, "{\n/* [wrapped with " + e + "] */\n")
                                    }(i, function(t, e) {
                                        return Xe(k, (function(n) {
                                            var i = "_." + n[0];
                                            e & n[1] && !Je(t, i) && t.push(i)
                                        })), t.sort()
                                    }(function(t) {
                                        var e = t.match(Vt);
                                        return e ? e[1].split(jt) : []
                                    }(i), n)))
                                }

                                function as(t) {
                                    var e = 0,
                                        n = 0;
                                    return function() {
                                        var i = Xn(),
                                            r = L - (i - n);
                                        if (n = i, r > 0) {
                                            if (++e >= P) return arguments[0]
                                        } else e = 0;
                                        return t.apply(o, arguments)
                                    }
                                }

                                function ls(t, e) {
                                    var n = -1,
                                        i = t.length,
                                        r = i - 1;
                                    for (e = e === o ? i : e; ++n < e;) {
                                        var s = wr(n, r),
                                            a = t[s];
                                        t[s] = t[n], t[n] = a
                                    }
                                    return t.length = e, t
                                }
                                var cs = function(t) {
                                    var e = aa(t, (function(t) {
                                            return n.size === h && n.clear(), t
                                        })),
                                        n = e.cache;
                                    return e
                                }((function(t) {
                                    var e = [];
                                    return 46 === t.charCodeAt(0) && e.push(""), t.replace(Rt, (function(t, n, i, r) {
                                        e.push(i ? r.replace(Ut, "$1") : n || t)
                                    })), e
                                }));

                                function hs(t) {
                                    if ("string" == typeof t || Na(t)) return t;
                                    var e = t + "";
                                    return "0" == e && 1 / t == -F ? "-0" : e
                                }

                                function us(t) {
                                    if (null != t) {
                                        try {
                                            return ce.call(t)
                                        } catch (t) {}
                                        try {
                                            return t + ""
                                        } catch (t) {}
                                    }
                                    return ""
                                }

                                function ds(t) {
                                    if (t instanceof vi) return t.clone();
                                    var e = new gi(t.__wrapped__, t.__chain__);
                                    return e.__actions__ = no(t.__actions__), e.__index__ = t.__index__, e.__values__ = t.__values__, e
                                }
                                var ps = Sr((function(t, e) {
                                        return ba(t) ? Vi(t, Hi(e, 1, ba, !0)) : []
                                    })),
                                    fs = Sr((function(t, e) {
                                        var n = Ss(e);
                                        return ba(n) && (n = o), ba(t) ? Vi(t, Hi(e, 1, ba, !0), Bo(n, 2)) : []
                                    })),
                                    ms = Sr((function(t, e) {
                                        var n = Ss(e);
                                        return ba(n) && (n = o), ba(t) ? Vi(t, Hi(e, 1, ba, !0), o, n) : []
                                    }));

                                function gs(t, e, n) {
                                    var i = null == t ? 0 : t.length;
                                    if (!i) return -1;
                                    var r = null == n ? 0 : Ua(n);
                                    return r < 0 && (r = Wn(i + r, 0)), an(t, Bo(e, 3), r)
                                }

                                function vs(t, e, n) {
                                    var i = null == t ? 0 : t.length;
                                    if (!i) return -1;
                                    var r = i - 1;
                                    return n !== o && (r = Ua(n), r = n < 0 ? Wn(i + r, 0) : Yn(r, i - 1)), an(t, Bo(e, 3), r, !0)
                                }

                                function ys(t) {
                                    return null != t && t.length ? Hi(t, 1) : []
                                }

                                function xs(t) {
                                    return t && t.length ? t[0] : o
                                }
                                var bs = Sr((function(t) {
                                        var e = $e(t, Hr);
                                        return e.length && e[0] === t[0] ? nr(e) : []
                                    })),
                                    ws = Sr((function(t) {
                                        var e = Ss(t),
                                            n = $e(t, Hr);
                                        return e === Ss(n) ? e = o : n.pop(), n.length && n[0] === t[0] ? nr(n, Bo(e, 2)) : []
                                    })),
                                    _s = Sr((function(t) {
                                        var e = Ss(t),
                                            n = $e(t, Hr);
                                        return (e = "function" == typeof e ? e : o) && n.pop(), n.length && n[0] === t[0] ? nr(n, o, e) : []
                                    }));

                                function Ss(t) {
                                    var e = null == t ? 0 : t.length;
                                    return e ? t[e - 1] : o
                                }
                                var Ms = Sr(As);

                                function As(t, e) {
                                    return t && t.length && e && e.length ? xr(t, e) : t
                                }
                                var Ts = Lo((function(t, e) {
                                    var n = null == t ? 0 : t.length,
                                        i = Fi(t, e);
                                    return br(t, $e(e, (function(t) {
                                        return Yo(t, n) ? +t : t
                                    })).sort($r)), i
                                }));

                                function Es(t) {
                                    return null == t ? t : Zn.call(t)
                                }
                                var Cs = Sr((function(t) {
                                        return Dr(Hi(t, 1, ba, !0))
                                    })),
                                    Ps = Sr((function(t) {
                                        var e = Ss(t);
                                        return ba(e) && (e = o), Dr(Hi(t, 1, ba, !0), Bo(e, 2))
                                    })),
                                    Ls = Sr((function(t) {
                                        var e = Ss(t);
                                        return e = "function" == typeof e ? e : o, Dr(Hi(t, 1, ba, !0), o, e)
                                    }));

                                function Rs(t) {
                                    if (!t || !t.length) return [];
                                    var e = 0;
                                    return t = Ze(t, (function(t) {
                                        if (ba(t)) return e = Wn(t.length, e), !0
                                    })), gn(e, (function(e) {
                                        return $e(t, dn(e))
                                    }))
                                }

                                function Is(t, e) {
                                    if (!t || !t.length) return [];
                                    var n = Rs(t);
                                    return null == e ? n : $e(n, (function(t) {
                                        return We(e, o, t)
                                    }))
                                }
                                var Fs = Sr((function(t, e) {
                                        return ba(t) ? Vi(t, e) : []
                                    })),
                                    Os = Sr((function(t) {
                                        return zr(Ze(t, ba))
                                    })),
                                    Ns = Sr((function(t) {
                                        var e = Ss(t);
                                        return ba(e) && (e = o), zr(Ze(t, ba), Bo(e, 2))
                                    })),
                                    Bs = Sr((function(t) {
                                        var e = Ss(t);
                                        return e = "function" == typeof e ? e : o, zr(Ze(t, ba), o, e)
                                    })),
                                    Ds = Sr(Rs),
                                    Vs = Sr((function(t) {
                                        var e = t.length,
                                            n = e > 1 ? t[e - 1] : o;
                                        return n = "function" == typeof n ? (t.pop(), n) : o, Is(t, n)
                                    }));

                                function js(t) {
                                    var e = pi(t);
                                    return e.__chain__ = !0, e
                                }

                                function ks(t, e) {
                                    return e(t)
                                }
                                var Us = Lo((function(t) {
                                        var e = t.length,
                                            n = e ? t[0] : 0,
                                            i = this.__wrapped__,
                                            r = function(e) {
                                                return Fi(e, t)
                                            };
                                        return !(e > 1 || this.__actions__.length) && i instanceof vi && Yo(n) ? ((i = i.slice(n, +n + (e ? 1 : 0))).__actions__.push({
                                            func: ks,
                                            args: [r],
                                            thisArg: o
                                        }), new gi(i, this.__chain__).thru((function(t) {
                                            return e && !t.length && t.push(o), t
                                        }))) : this.thru(r)
                                    })),
                                    zs = ro((function(t, e, n) {
                                        he.call(t, n) ? ++t[n] : Ii(t, n, 1)
                                    })),
                                    Gs = uo(gs),
                                    Hs = uo(vs);

                                function Ws(t, e) {
                                    return (va(t) ? Xe : ji)(t, Bo(e, 3))
                                }

                                function Ys(t, e) {
                                    return (va(t) ? qe : ki)(t, Bo(e, 3))
                                }
                                var Xs = ro((function(t, e, n) {
                                        he.call(t, n) ? t[n].push(e) : Ii(t, n, [e])
                                    })),
                                    qs = Sr((function(t, e, n) {
                                        var r = -1,
                                            o = "function" == typeof e,
                                            s = xa(t) ? i(t.length) : [];
                                        return ji(t, (function(t) {
                                            s[++r] = o ? We(e, t, n) : ir(t, e, n)
                                        })), s
                                    })),
                                    Qs = ro((function(t, e, n) {
                                        Ii(t, n, e)
                                    }));

                                function Zs(t, e) {
                                    return (va(t) ? $e : dr)(t, Bo(e, 3))
                                }
                                var Js = ro((function(t, e, n) {
                                        t[n ? 0 : 1].push(e)
                                    }), (function() {
                                        return [
                                            [],
                                            []
                                        ]
                                    })),
                                    Ks = Sr((function(t, e) {
                                        if (null == t) return [];
                                        var n = e.length;
                                        return n > 1 && Xo(t, e[0], e[1]) ? e = [] : n > 2 && Xo(e[0], e[1], e[2]) && (e = [e[0]]), vr(t, Hi(e, 1), [])
                                    })),
                                    $s = Bn || function() {
                                        return Fe.Date.now()
                                    };

                                function ta(t, e, n) {
                                    return e = n ? o : e, e = t && null == e ? t.length : e, Ao(t, M, o, o, o, o, e)
                                }

                                function ea(t, e) {
                                    var n;
                                    if ("function" != typeof e) throw new re(l);
                                    return t = Ua(t),
                                        function() {
                                            return --t > 0 && (n = e.apply(this, arguments)), t <= 1 && (e = o), n
                                        }
                                }
                                var na = Sr((function(t, e, n) {
                                        var i = v;
                                        if (n.length) {
                                            var r = Cn(n, No(na));
                                            i |= _
                                        }
                                        return Ao(t, i, e, n, r)
                                    })),
                                    ia = Sr((function(t, e, n) {
                                        var i = v | y;
                                        if (n.length) {
                                            var r = Cn(n, No(ia));
                                            i |= _
                                        }
                                        return Ao(e, i, t, n, r)
                                    }));

                                function ra(t, e, n) {
                                    var i, r, s, a, c, h, u = 0,
                                        d = !1,
                                        p = !1,
                                        f = !0;
                                    if ("function" != typeof t) throw new re(l);

                                    function m(e) {
                                        var n = i,
                                            s = r;
                                        return i = r = o, u = e, a = t.apply(s, n)
                                    }

                                    function g(t) {
                                        var n = t - h;
                                        return h === o || n >= e || n < 0 || p && t - u >= s
                                    }

                                    function v() {
                                        var t = $s();
                                        if (g(t)) return y(t);
                                        c = rs(v, function(t) {
                                            var n = e - (t - h);
                                            return p ? Yn(n, s - (t - u)) : n
                                        }(t))
                                    }

                                    function y(t) {
                                        return c = o, f && i ? m(t) : (i = r = o, a)
                                    }

                                    function x() {
                                        var t = $s(),
                                            n = g(t);
                                        if (i = arguments, r = this, h = t, n) {
                                            if (c === o) return function(t) {
                                                return u = t, c = rs(v, e), d ? m(t) : a
                                            }(h);
                                            if (p) return Qr(c), c = rs(v, e), m(h)
                                        }
                                        return c === o && (c = rs(v, e)), a
                                    }
                                    return e = Ga(e) || 0, Ea(n) && (d = !!n.leading, s = (p = "maxWait" in n) ? Wn(Ga(n.maxWait) || 0, e) : s, f = "trailing" in n ? !!n.trailing : f), x.cancel = function() {
                                        c !== o && Qr(c), u = 0, i = h = r = c = o
                                    }, x.flush = function() {
                                        return c === o ? a : y($s())
                                    }, x
                                }
                                var oa = Sr((function(t, e) {
                                        return Di(t, 1, e)
                                    })),
                                    sa = Sr((function(t, e, n) {
                                        return Di(t, Ga(e) || 0, n)
                                    }));

                                function aa(t, e) {
                                    if ("function" != typeof t || null != e && "function" != typeof e) throw new re(l);
                                    var n = function() {
                                        var i = arguments,
                                            r = e ? e.apply(this, i) : i[0],
                                            o = n.cache;
                                        if (o.has(r)) return o.get(r);
                                        var s = t.apply(this, i);
                                        return n.cache = o.set(r, s) || o, s
                                    };
                                    return n.cache = new(aa.Cache || bi), n
                                }

                                function la(t) {
                                    if ("function" != typeof t) throw new re(l);
                                    return function() {
                                        var e = arguments;
                                        switch (e.length) {
                                            case 0:
                                                return !t.call(this);
                                            case 1:
                                                return !t.call(this, e[0]);
                                            case 2:
                                                return !t.call(this, e[0], e[1]);
                                            case 3:
                                                return !t.call(this, e[0], e[1], e[2])
                                        }
                                        return !t.apply(this, e)
                                    }
                                }
                                aa.Cache = bi;
                                var ca = Xr((function(t, e) {
                                        var n = (e = 1 == e.length && va(e[0]) ? $e(e[0], vn(Bo())) : $e(Hi(e, 1), vn(Bo()))).length;
                                        return Sr((function(i) {
                                            for (var r = -1, o = Yn(i.length, n); ++r < o;) i[r] = e[r].call(this, i[r]);
                                            return We(t, this, i)
                                        }))
                                    })),
                                    ha = Sr((function(t, e) {
                                        var n = Cn(e, No(ha));
                                        return Ao(t, _, o, e, n)
                                    })),
                                    ua = Sr((function(t, e) {
                                        var n = Cn(e, No(ua));
                                        return Ao(t, S, o, e, n)
                                    })),
                                    da = Lo((function(t, e) {
                                        return Ao(t, A, o, o, o, e)
                                    }));

                                function pa(t, e) {
                                    return t === e || t != t && e != e
                                }
                                var fa = bo($i),
                                    ma = bo((function(t, e) {
                                        return t >= e
                                    })),
                                    ga = rr(function() {
                                        return arguments
                                    }()) ? rr : function(t) {
                                        return Ca(t) && he.call(t, "callee") && !Oe.call(t, "callee")
                                    },
                                    va = i.isArray,
                                    ya = je ? vn(je) : function(t) {
                                        return Ca(t) && Ki(t) == lt
                                    };

                                function xa(t) {
                                    return null != t && Ta(t.length) && !Ma(t)
                                }

                                function ba(t) {
                                    return Ca(t) && xa(t)
                                }
                                var wa = Un || Gl,
                                    _a = ke ? vn(ke) : function(t) {
                                        return Ca(t) && Ki(t) == W
                                    };

                                function Sa(t) {
                                    if (!Ca(t)) return !1;
                                    var e = Ki(t);
                                    return e == X || e == Y || "string" == typeof t.message && "string" == typeof t.name && !Ra(t)
                                }

                                function Ma(t) {
                                    if (!Ea(t)) return !1;
                                    var e = Ki(t);
                                    return e == q || e == Q || e == G || e == tt
                                }

                                function Aa(t) {
                                    return "number" == typeof t && t == Ua(t)
                                }

                                function Ta(t) {
                                    return "number" == typeof t && t > -1 && t % 1 == 0 && t <= O
                                }

                                function Ea(t) {
                                    var e = typeof t;
                                    return null != t && ("object" == e || "function" == e)
                                }

                                function Ca(t) {
                                    return null != t && "object" == typeof t
                                }
                                var Pa = Ue ? vn(Ue) : function(t) {
                                    return Ca(t) && zo(t) == Z
                                };

                                function La(t) {
                                    return "number" == typeof t || Ca(t) && Ki(t) == J
                                }

                                function Ra(t) {
                                    if (!Ca(t) || Ki(t) != $) return !1;
                                    var e = Re(t);
                                    if (null === e) return !0;
                                    var n = he.call(e, "constructor") && e.constructor;
                                    return "function" == typeof n && n instanceof n && ce.call(n) == fe
                                }
                                var Ia = ze ? vn(ze) : function(t) {
                                        return Ca(t) && Ki(t) == et
                                    },
                                    Fa = Ge ? vn(Ge) : function(t) {
                                        return Ca(t) && zo(t) == nt
                                    };

                                function Oa(t) {
                                    return "string" == typeof t || !va(t) && Ca(t) && Ki(t) == it
                                }

                                function Na(t) {
                                    return "symbol" == typeof t || Ca(t) && Ki(t) == rt
                                }
                                var Ba = He ? vn(He) : function(t) {
                                        return Ca(t) && Ta(t.length) && !!Te[Ki(t)]
                                    },
                                    Da = bo(ur),
                                    Va = bo((function(t, e) {
                                        return t <= e
                                    }));

                                function ja(t) {
                                    if (!t) return [];
                                    if (xa(t)) return Oa(t) ? In(t) : no(t);
                                    if (Ve && t[Ve]) return function(t) {
                                        for (var e, n = []; !(e = t.next()).done;) n.push(e.value);
                                        return n
                                    }(t[Ve]());
                                    var e = zo(t);
                                    return (e == Z ? Tn : e == nt ? Pn : pl)(t)
                                }

                                function ka(t) {
                                    return t ? (t = Ga(t)) === F || t === -F ? (t < 0 ? -1 : 1) * N : t == t ? t : 0 : 0 === t ? t : 0
                                }

                                function Ua(t) {
                                    var e = ka(t),
                                        n = e % 1;
                                    return e == e ? n ? e - n : e : 0
                                }

                                function za(t) {
                                    return t ? Oi(Ua(t), 0, D) : 0
                                }

                                function Ga(t) {
                                    if ("number" == typeof t) return t;
                                    if (Na(t)) return B;
                                    if (Ea(t)) {
                                        var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                                        t = Ea(e) ? e + "" : e
                                    }
                                    if ("string" != typeof t) return 0 === t ? t : +t;
                                    t = t.replace(Ot, "");
                                    var n = Wt.test(t);
                                    return n || Xt.test(t) ? Le(t.slice(2), n ? 2 : 8) : Ht.test(t) ? B : +t
                                }

                                function Ha(t) {
                                    return io(t, ol(t))
                                }

                                function Wa(t) {
                                    return null == t ? "" : Br(t)
                                }
                                var Ya = oo((function(t, e) {
                                        if (Jo(e) || xa(e)) io(e, rl(e), t);
                                        else
                                            for (var n in e) he.call(e, n) && Ci(t, n, e[n])
                                    })),
                                    Xa = oo((function(t, e) {
                                        io(e, ol(e), t)
                                    })),
                                    qa = oo((function(t, e, n, i) {
                                        io(e, ol(e), t, i)
                                    })),
                                    Qa = oo((function(t, e, n, i) {
                                        io(e, rl(e), t, i)
                                    })),
                                    Za = Lo(Fi),
                                    Ja = Sr((function(t, e) {
                                        t = ee(t);
                                        var n = -1,
                                            i = e.length,
                                            r = i > 2 ? e[2] : o;
                                        for (r && Xo(e[0], e[1], r) && (i = 1); ++n < i;)
                                            for (var s = e[n], a = ol(s), l = -1, c = a.length; ++l < c;) {
                                                var h = a[l],
                                                    u = t[h];
                                                (u === o || pa(u, ae[h]) && !he.call(t, h)) && (t[h] = s[h])
                                            }
                                        return t
                                    })),
                                    Ka = Sr((function(t) {
                                        return t.push(o, Eo), We(al, o, t)
                                    }));

                                function $a(t, e, n) {
                                    var i = null == t ? o : Zi(t, e);
                                    return i === o ? n : i
                                }

                                function tl(t, e) {
                                    return null != t && Go(t, e, er)
                                }
                                var el = mo((function(t, e, n) {
                                        null != e && "function" != typeof e.toString && (e = pe.call(e)), t[e] = n
                                    }), El(Ll)),
                                    nl = mo((function(t, e, n) {
                                        null != e && "function" != typeof e.toString && (e = pe.call(e)), he.call(t, e) ? t[e].push(n) : t[e] = [n]
                                    }), Bo),
                                    il = Sr(ir);

                                function rl(t) {
                                    return xa(t) ? Si(t) : cr(t)
                                }

                                function ol(t) {
                                    return xa(t) ? Si(t, !0) : hr(t)
                                }
                                var sl = oo((function(t, e, n) {
                                        mr(t, e, n)
                                    })),
                                    al = oo((function(t, e, n, i) {
                                        mr(t, e, n, i)
                                    })),
                                    ll = Lo((function(t, e) {
                                        var n = {};
                                        if (null == t) return n;
                                        var i = !1;
                                        e = $e(e, (function(e) {
                                            return e = Yr(e, t), i || (i = e.length > 1), e
                                        })), io(t, Io(t), n), i && (n = Ni(n, d | p | f, Co));
                                        for (var r = e.length; r--;) Vr(n, e[r]);
                                        return n
                                    })),
                                    cl = Lo((function(t, e) {
                                        return null == t ? {} : function(t, e) {
                                            return yr(t, e, (function(e, n) {
                                                return tl(t, n)
                                            }))
                                        }(t, e)
                                    }));

                                function hl(t, e) {
                                    if (null == t) return {};
                                    var n = $e(Io(t), (function(t) {
                                        return [t]
                                    }));
                                    return e = Bo(e), yr(t, n, (function(t, n) {
                                        return e(t, n[0])
                                    }))
                                }
                                var ul = Mo(rl),
                                    dl = Mo(ol);

                                function pl(t) {
                                    return null == t ? [] : yn(t, rl(t))
                                }
                                var fl = co((function(t, e, n) {
                                    return e = e.toLowerCase(), t + (n ? ml(e) : e)
                                }));

                                function ml(t) {
                                    return Sl(Wa(t).toLowerCase())
                                }

                                function gl(t) {
                                    return (t = Wa(t)) && t.replace(Qt, _n).replace(xe, "")
                                }
                                var vl = co((function(t, e, n) {
                                        return t + (n ? "-" : "") + e.toLowerCase()
                                    })),
                                    yl = co((function(t, e, n) {
                                        return t + (n ? " " : "") + e.toLowerCase()
                                    })),
                                    xl = lo("toLowerCase"),
                                    bl = co((function(t, e, n) {
                                        return t + (n ? "_" : "") + e.toLowerCase()
                                    })),
                                    wl = co((function(t, e, n) {
                                        return t + (n ? " " : "") + Sl(e)
                                    })),
                                    _l = co((function(t, e, n) {
                                        return t + (n ? " " : "") + e.toUpperCase()
                                    })),
                                    Sl = lo("toUpperCase");

                                function Ml(t, e, n) {
                                    return t = Wa(t), (e = n ? o : e) === o ? function(t) {
                                        return Se.test(t)
                                    }(t) ? function(t) {
                                        return t.match(we) || []
                                    }(t) : function(t) {
                                        return t.match(kt) || []
                                    }(t) : t.match(e) || []
                                }
                                var Al = Sr((function(t, e) {
                                        try {
                                            return We(t, o, e)
                                        } catch (t) {
                                            return Sa(t) ? t : new Kt(t)
                                        }
                                    })),
                                    Tl = Lo((function(t, e) {
                                        return Xe(e, (function(e) {
                                            e = hs(e), Ii(t, e, na(t[e], t))
                                        })), t
                                    }));

                                function El(t) {
                                    return function() {
                                        return t
                                    }
                                }
                                var Cl = po(),
                                    Pl = po(!0);

                                function Ll(t) {
                                    return t
                                }

                                function Rl(t) {
                                    return lr("function" == typeof t ? t : Ni(t, d))
                                }
                                var Il = Sr((function(t, e) {
                                        return function(n) {
                                            return ir(n, t, e)
                                        }
                                    })),
                                    Fl = Sr((function(t, e) {
                                        return function(n) {
                                            return ir(t, n, e)
                                        }
                                    }));

                                function Ol(t, e, n) {
                                    var i = rl(e),
                                        r = Qi(e, i);
                                    null != n || Ea(e) && (r.length || !i.length) || (n = e, e = t, t = this, r = Qi(e, rl(e)));
                                    var o = !(Ea(n) && "chain" in n && !n.chain),
                                        s = Ma(t);
                                    return Xe(r, (function(n) {
                                        var i = e[n];
                                        t[n] = i, s && (t.prototype[n] = function() {
                                            var e = this.__chain__;
                                            if (o || e) {
                                                var n = t(this.__wrapped__);
                                                return (n.__actions__ = no(this.__actions__)).push({
                                                    func: i,
                                                    args: arguments,
                                                    thisArg: t
                                                }), n.__chain__ = e, n
                                            }
                                            return i.apply(t, tn([this.value()], arguments))
                                        })
                                    })), t
                                }

                                function Nl() {}
                                var Bl = vo($e),
                                    Dl = vo(Qe),
                                    Vl = vo(rn);

                                function jl(t) {
                                    return qo(t) ? dn(hs(t)) : function(t) {
                                        return function(e) {
                                            return Zi(e, t)
                                        }
                                    }(t)
                                }
                                var kl = xo(),
                                    Ul = xo(!0);

                                function zl() {
                                    return []
                                }

                                function Gl() {
                                    return !1
                                }
                                var Hl, Wl = go((function(t, e) {
                                        return t + e
                                    }), 0),
                                    Yl = _o("ceil"),
                                    Xl = go((function(t, e) {
                                        return t / e
                                    }), 1),
                                    ql = _o("floor"),
                                    Ql = go((function(t, e) {
                                        return t * e
                                    }), 1),
                                    Zl = _o("round"),
                                    Jl = go((function(t, e) {
                                        return t - e
                                    }), 0);
                                return pi.after = function(t, e) {
                                    if ("function" != typeof e) throw new re(l);
                                    return t = Ua(t),
                                        function() {
                                            if (--t < 1) return e.apply(this, arguments)
                                        }
                                }, pi.ary = ta, pi.assign = Ya, pi.assignIn = Xa, pi.assignInWith = qa, pi.assignWith = Qa, pi.at = Za, pi.before = ea, pi.bind = na, pi.bindAll = Tl, pi.bindKey = ia, pi.castArray = function() {
                                    if (!arguments.length) return [];
                                    var t = arguments[0];
                                    return va(t) ? t : [t]
                                }, pi.chain = js, pi.chunk = function(t, e, n) {
                                    e = (n ? Xo(t, e, n) : e === o) ? 1 : Wn(Ua(e), 0);
                                    var r = null == t ? 0 : t.length;
                                    if (!r || e < 1) return [];
                                    for (var s = 0, a = 0, l = i(Vn(r / e)); s < r;) l[a++] = Lr(t, s, s += e);
                                    return l
                                }, pi.compact = function(t) {
                                    for (var e = -1, n = null == t ? 0 : t.length, i = 0, r = []; ++e < n;) {
                                        var o = t[e];
                                        o && (r[i++] = o)
                                    }
                                    return r
                                }, pi.concat = function() {
                                    var t = arguments.length;
                                    if (!t) return [];
                                    for (var e = i(t - 1), n = arguments[0], r = t; r--;) e[r - 1] = arguments[r];
                                    return tn(va(n) ? no(n) : [n], Hi(e, 1))
                                }, pi.cond = function(t) {
                                    var e = null == t ? 0 : t.length,
                                        n = Bo();
                                    return t = e ? $e(t, (function(t) {
                                        if ("function" != typeof t[1]) throw new re(l);
                                        return [n(t[0]), t[1]]
                                    })) : [], Sr((function(n) {
                                        for (var i = -1; ++i < e;) {
                                            var r = t[i];
                                            if (We(r[0], this, n)) return We(r[1], this, n)
                                        }
                                    }))
                                }, pi.conforms = function(t) {
                                    return function(t) {
                                        var e = rl(t);
                                        return function(n) {
                                            return Bi(n, t, e)
                                        }
                                    }(Ni(t, d))
                                }, pi.constant = El, pi.countBy = zs, pi.create = function(t, e) {
                                    var n = fi(t);
                                    return null == e ? n : Ri(n, e)
                                }, pi.curry = function t(e, n, i) {
                                    var r = Ao(e, b, o, o, o, o, o, n = i ? o : n);
                                    return r.placeholder = t.placeholder, r
                                }, pi.curryRight = function t(e, n, i) {
                                    var r = Ao(e, w, o, o, o, o, o, n = i ? o : n);
                                    return r.placeholder = t.placeholder, r
                                }, pi.debounce = ra, pi.defaults = Ja, pi.defaultsDeep = Ka, pi.defer = oa, pi.delay = sa, pi.difference = ps, pi.differenceBy = fs, pi.differenceWith = ms, pi.drop = function(t, e, n) {
                                    var i = null == t ? 0 : t.length;
                                    return i ? Lr(t, (e = n || e === o ? 1 : Ua(e)) < 0 ? 0 : e, i) : []
                                }, pi.dropRight = function(t, e, n) {
                                    var i = null == t ? 0 : t.length;
                                    return i ? Lr(t, 0, (e = i - (e = n || e === o ? 1 : Ua(e))) < 0 ? 0 : e) : []
                                }, pi.dropRightWhile = function(t, e) {
                                    return t && t.length ? kr(t, Bo(e, 3), !0, !0) : []
                                }, pi.dropWhile = function(t, e) {
                                    return t && t.length ? kr(t, Bo(e, 3), !0) : []
                                }, pi.fill = function(t, e, n, i) {
                                    var r = null == t ? 0 : t.length;
                                    return r ? (n && "number" != typeof n && Xo(t, e, n) && (n = 0, i = r), function(t, e, n, i) {
                                        var r = t.length;
                                        for ((n = Ua(n)) < 0 && (n = -n > r ? 0 : r + n), (i = i === o || i > r ? r : Ua(i)) < 0 && (i += r), i = n > i ? 0 : za(i); n < i;) t[n++] = e;
                                        return t
                                    }(t, e, n, i)) : []
                                }, pi.filter = function(t, e) {
                                    return (va(t) ? Ze : Gi)(t, Bo(e, 3))
                                }, pi.flatMap = function(t, e) {
                                    return Hi(Zs(t, e), 1)
                                }, pi.flatMapDeep = function(t, e) {
                                    return Hi(Zs(t, e), F)
                                }, pi.flatMapDepth = function(t, e, n) {
                                    return n = n === o ? 1 : Ua(n), Hi(Zs(t, e), n)
                                }, pi.flatten = ys, pi.flattenDeep = function(t) {
                                    return null != t && t.length ? Hi(t, F) : []
                                }, pi.flattenDepth = function(t, e) {
                                    return null != t && t.length ? Hi(t, e = e === o ? 1 : Ua(e)) : []
                                }, pi.flip = function(t) {
                                    return Ao(t, T)
                                }, pi.flow = Cl, pi.flowRight = Pl, pi.fromPairs = function(t) {
                                    for (var e = -1, n = null == t ? 0 : t.length, i = {}; ++e < n;) {
                                        var r = t[e];
                                        i[r[0]] = r[1]
                                    }
                                    return i
                                }, pi.functions = function(t) {
                                    return null == t ? [] : Qi(t, rl(t))
                                }, pi.functionsIn = function(t) {
                                    return null == t ? [] : Qi(t, ol(t))
                                }, pi.groupBy = Xs, pi.initial = function(t) {
                                    return null != t && t.length ? Lr(t, 0, -1) : []
                                }, pi.intersection = bs, pi.intersectionBy = ws, pi.intersectionWith = _s, pi.invert = el, pi.invertBy = nl, pi.invokeMap = qs, pi.iteratee = Rl, pi.keyBy = Qs, pi.keys = rl, pi.keysIn = ol, pi.map = Zs, pi.mapKeys = function(t, e) {
                                    var n = {};
                                    return e = Bo(e, 3), Xi(t, (function(t, i, r) {
                                        Ii(n, e(t, i, r), t)
                                    })), n
                                }, pi.mapValues = function(t, e) {
                                    var n = {};
                                    return e = Bo(e, 3), Xi(t, (function(t, i, r) {
                                        Ii(n, i, e(t, i, r))
                                    })), n
                                }, pi.matches = function(t) {
                                    return pr(Ni(t, d))
                                }, pi.matchesProperty = function(t, e) {
                                    return fr(t, Ni(e, d))
                                }, pi.memoize = aa, pi.merge = sl, pi.mergeWith = al, pi.method = Il, pi.methodOf = Fl, pi.mixin = Ol, pi.negate = la, pi.nthArg = function(t) {
                                    return t = Ua(t), Sr((function(e) {
                                        return gr(e, t)
                                    }))
                                }, pi.omit = ll, pi.omitBy = function(t, e) {
                                    return hl(t, la(Bo(e)))
                                }, pi.once = function(t) {
                                    return ea(2, t)
                                }, pi.orderBy = function(t, e, n, i) {
                                    return null == t ? [] : (va(e) || (e = null == e ? [] : [e]), va(n = i ? o : n) || (n = null == n ? [] : [n]), vr(t, e, n))
                                }, pi.over = Bl, pi.overArgs = ca, pi.overEvery = Dl, pi.overSome = Vl, pi.partial = ha, pi.partialRight = ua, pi.partition = Js, pi.pick = cl, pi.pickBy = hl, pi.property = jl, pi.propertyOf = function(t) {
                                    return function(e) {
                                        return null == t ? o : Zi(t, e)
                                    }
                                }, pi.pull = Ms, pi.pullAll = As, pi.pullAllBy = function(t, e, n) {
                                    return t && t.length && e && e.length ? xr(t, e, Bo(n, 2)) : t
                                }, pi.pullAllWith = function(t, e, n) {
                                    return t && t.length && e && e.length ? xr(t, e, o, n) : t
                                }, pi.pullAt = Ts, pi.range = kl, pi.rangeRight = Ul, pi.rearg = da, pi.reject = function(t, e) {
                                    return (va(t) ? Ze : Gi)(t, la(Bo(e, 3)))
                                }, pi.remove = function(t, e) {
                                    var n = [];
                                    if (!t || !t.length) return n;
                                    var i = -1,
                                        r = [],
                                        o = t.length;
                                    for (e = Bo(e, 3); ++i < o;) {
                                        var s = t[i];
                                        e(s, i, t) && (n.push(s), r.push(i))
                                    }
                                    return br(t, r), n
                                }, pi.rest = function(t, e) {
                                    if ("function" != typeof t) throw new re(l);
                                    return Sr(t, e = e === o ? e : Ua(e))
                                }, pi.reverse = Es, pi.sampleSize = function(t, e, n) {
                                    return e = (n ? Xo(t, e, n) : e === o) ? 1 : Ua(e), (va(t) ? Ai : Ar)(t, e)
                                }, pi.set = function(t, e, n) {
                                    return null == t ? t : Tr(t, e, n)
                                }, pi.setWith = function(t, e, n, i) {
                                    return i = "function" == typeof i ? i : o, null == t ? t : Tr(t, e, n, i)
                                }, pi.shuffle = function(t) {
                                    return (va(t) ? Ti : Pr)(t)
                                }, pi.slice = function(t, e, n) {
                                    var i = null == t ? 0 : t.length;
                                    return i ? (n && "number" != typeof n && Xo(t, e, n) ? (e = 0, n = i) : (e = null == e ? 0 : Ua(e), n = n === o ? i : Ua(n)), Lr(t, e, n)) : []
                                }, pi.sortBy = Ks, pi.sortedUniq = function(t) {
                                    return t && t.length ? Or(t) : []
                                }, pi.sortedUniqBy = function(t, e) {
                                    return t && t.length ? Or(t, Bo(e, 2)) : []
                                }, pi.split = function(t, e, n) {
                                    return n && "number" != typeof n && Xo(t, e, n) && (e = n = o), (n = n === o ? D : n >>> 0) ? (t = Wa(t)) && ("string" == typeof e || null != e && !Ia(e)) && !(e = Br(e)) && An(t) ? qr(In(t), 0, n) : t.split(e, n) : []
                                }, pi.spread = function(t, e) {
                                    if ("function" != typeof t) throw new re(l);
                                    return e = null == e ? 0 : Wn(Ua(e), 0), Sr((function(n) {
                                        var i = n[e],
                                            r = qr(n, 0, e);
                                        return i && tn(r, i), We(t, this, r)
                                    }))
                                }, pi.tail = function(t) {
                                    var e = null == t ? 0 : t.length;
                                    return e ? Lr(t, 1, e) : []
                                }, pi.take = function(t, e, n) {
                                    return t && t.length ? Lr(t, 0, (e = n || e === o ? 1 : Ua(e)) < 0 ? 0 : e) : []
                                }, pi.takeRight = function(t, e, n) {
                                    var i = null == t ? 0 : t.length;
                                    return i ? Lr(t, (e = i - (e = n || e === o ? 1 : Ua(e))) < 0 ? 0 : e, i) : []
                                }, pi.takeRightWhile = function(t, e) {
                                    return t && t.length ? kr(t, Bo(e, 3), !1, !0) : []
                                }, pi.takeWhile = function(t, e) {
                                    return t && t.length ? kr(t, Bo(e, 3)) : []
                                }, pi.tap = function(t, e) {
                                    return e(t), t
                                }, pi.throttle = function(t, e, n) {
                                    var i = !0,
                                        r = !0;
                                    if ("function" != typeof t) throw new re(l);
                                    return Ea(n) && (i = "leading" in n ? !!n.leading : i, r = "trailing" in n ? !!n.trailing : r), ra(t, e, {
                                        leading: i,
                                        maxWait: e,
                                        trailing: r
                                    })
                                }, pi.thru = ks, pi.toArray = ja, pi.toPairs = ul, pi.toPairsIn = dl, pi.toPath = function(t) {
                                    return va(t) ? $e(t, hs) : Na(t) ? [t] : no(cs(Wa(t)))
                                }, pi.toPlainObject = Ha, pi.transform = function(t, e, n) {
                                    var i = va(t),
                                        r = i || wa(t) || Ba(t);
                                    if (e = Bo(e, 4), null == n) {
                                        var o = t && t.constructor;
                                        n = r ? i ? new o : [] : Ea(t) && Ma(o) ? fi(Re(t)) : {}
                                    }
                                    return (r ? Xe : Xi)(t, (function(t, i, r) {
                                        return e(n, t, i, r)
                                    })), n
                                }, pi.unary = function(t) {
                                    return ta(t, 1)
                                }, pi.union = Cs, pi.unionBy = Ps, pi.unionWith = Ls, pi.uniq = function(t) {
                                    return t && t.length ? Dr(t) : []
                                }, pi.uniqBy = function(t, e) {
                                    return t && t.length ? Dr(t, Bo(e, 2)) : []
                                }, pi.uniqWith = function(t, e) {
                                    return e = "function" == typeof e ? e : o, t && t.length ? Dr(t, o, e) : []
                                }, pi.unset = function(t, e) {
                                    return null == t || Vr(t, e)
                                }, pi.unzip = Rs, pi.unzipWith = Is, pi.update = function(t, e, n) {
                                    return null == t ? t : jr(t, e, Wr(n))
                                }, pi.updateWith = function(t, e, n, i) {
                                    return i = "function" == typeof i ? i : o, null == t ? t : jr(t, e, Wr(n), i)
                                }, pi.values = pl, pi.valuesIn = function(t) {
                                    return null == t ? [] : yn(t, ol(t))
                                }, pi.without = Fs, pi.words = Ml, pi.wrap = function(t, e) {
                                    return ha(Wr(e), t)
                                }, pi.xor = Os, pi.xorBy = Ns, pi.xorWith = Bs, pi.zip = Ds, pi.zipObject = function(t, e) {
                                    return Gr(t || [], e || [], Ci)
                                }, pi.zipObjectDeep = function(t, e) {
                                    return Gr(t || [], e || [], Tr)
                                }, pi.zipWith = Vs, pi.entries = ul, pi.entriesIn = dl, pi.extend = Xa, pi.extendWith = qa, Ol(pi, pi), pi.add = Wl, pi.attempt = Al, pi.camelCase = fl, pi.capitalize = ml, pi.ceil = Yl, pi.clamp = function(t, e, n) {
                                    return n === o && (n = e, e = o), n !== o && (n = (n = Ga(n)) == n ? n : 0), e !== o && (e = (e = Ga(e)) == e ? e : 0), Oi(Ga(t), e, n)
                                }, pi.clone = function(t) {
                                    return Ni(t, f)
                                }, pi.cloneDeep = function(t) {
                                    return Ni(t, d | f)
                                }, pi.cloneDeepWith = function(t, e) {
                                    return Ni(t, d | f, e = "function" == typeof e ? e : o)
                                }, pi.cloneWith = function(t, e) {
                                    return Ni(t, f, e = "function" == typeof e ? e : o)
                                }, pi.conformsTo = function(t, e) {
                                    return null == e || Bi(t, e, rl(e))
                                }, pi.deburr = gl, pi.defaultTo = function(t, e) {
                                    return null == t || t != t ? e : t
                                }, pi.divide = Xl, pi.endsWith = function(t, e, n) {
                                    t = Wa(t), e = Br(e);
                                    var i = t.length,
                                        r = n = n === o ? i : Oi(Ua(n), 0, i);
                                    return (n -= e.length) >= 0 && t.slice(n, r) == e
                                }, pi.eq = pa, pi.escape = function(t) {
                                    return (t = Wa(t)) && At.test(t) ? t.replace(St, Sn) : t
                                }, pi.escapeRegExp = function(t) {
                                    return (t = Wa(t)) && Ft.test(t) ? t.replace(It, "\\$&") : t
                                }, pi.every = function(t, e, n) {
                                    var i = va(t) ? Qe : Ui;
                                    return n && Xo(t, e, n) && (e = o), i(t, Bo(e, 3))
                                }, pi.find = Gs, pi.findIndex = gs, pi.findKey = function(t, e) {
                                    return sn(t, Bo(e, 3), Xi)
                                }, pi.findLast = Hs, pi.findLastIndex = vs, pi.findLastKey = function(t, e) {
                                    return sn(t, Bo(e, 3), qi)
                                }, pi.floor = ql, pi.forEach = Ws, pi.forEachRight = Ys, pi.forIn = function(t, e) {
                                    return null == t ? t : Wi(t, Bo(e, 3), ol)
                                }, pi.forInRight = function(t, e) {
                                    return null == t ? t : Yi(t, Bo(e, 3), ol)
                                }, pi.forOwn = function(t, e) {
                                    return t && Xi(t, Bo(e, 3))
                                }, pi.forOwnRight = function(t, e) {
                                    return t && qi(t, Bo(e, 3))
                                }, pi.get = $a, pi.gt = fa, pi.gte = ma, pi.has = function(t, e) {
                                    return null != t && Go(t, e, tr)
                                }, pi.hasIn = tl, pi.head = xs, pi.identity = Ll, pi.includes = function(t, e, n, i) {
                                    t = xa(t) ? t : pl(t), n = n && !i ? Ua(n) : 0;
                                    var r = t.length;
                                    return n < 0 && (n = Wn(r + n, 0)), Oa(t) ? n <= r && t.indexOf(e, n) > -1 : !!r && ln(t, e, n) > -1
                                }, pi.indexOf = function(t, e, n) {
                                    var i = null == t ? 0 : t.length;
                                    if (!i) return -1;
                                    var r = null == n ? 0 : Ua(n);
                                    return r < 0 && (r = Wn(i + r, 0)), ln(t, e, r)
                                }, pi.inRange = function(t, e, n) {
                                    return e = ka(e), n === o ? (n = e, e = 0) : n = ka(n),
                                        function(t, e, n) {
                                            return t >= Yn(e, n) && t < Wn(e, n)
                                        }(t = Ga(t), e, n)
                                }, pi.invoke = il, pi.isArguments = ga, pi.isArray = va, pi.isArrayBuffer = ya, pi.isArrayLike = xa, pi.isArrayLikeObject = ba, pi.isBoolean = function(t) {
                                    return !0 === t || !1 === t || Ca(t) && Ki(t) == H
                                }, pi.isBuffer = wa, pi.isDate = _a, pi.isElement = function(t) {
                                    return Ca(t) && 1 === t.nodeType && !Ra(t)
                                }, pi.isEmpty = function(t) {
                                    if (null == t) return !0;
                                    if (xa(t) && (va(t) || "string" == typeof t || "function" == typeof t.splice || wa(t) || Ba(t) || ga(t))) return !t.length;
                                    var e = zo(t);
                                    if (e == Z || e == nt) return !t.size;
                                    if (Jo(t)) return !cr(t).length;
                                    for (var n in t)
                                        if (he.call(t, n)) return !1;
                                    return !0
                                }, pi.isEqual = function(t, e) {
                                    return or(t, e)
                                }, pi.isEqualWith = function(t, e, n) {
                                    var i = (n = "function" == typeof n ? n : o) ? n(t, e) : o;
                                    return i === o ? or(t, e, o, n) : !!i
                                }, pi.isError = Sa, pi.isFinite = function(t) {
                                    return "number" == typeof t && zn(t)
                                }, pi.isFunction = Ma, pi.isInteger = Aa, pi.isLength = Ta, pi.isMap = Pa, pi.isMatch = function(t, e) {
                                    return t === e || sr(t, e, Vo(e))
                                }, pi.isMatchWith = function(t, e, n) {
                                    return n = "function" == typeof n ? n : o, sr(t, e, Vo(e), n)
                                }, pi.isNaN = function(t) {
                                    return La(t) && t != +t
                                }, pi.isNative = function(t) {
                                    if (Zo(t)) throw new Kt(a);
                                    return ar(t)
                                }, pi.isNil = function(t) {
                                    return null == t
                                }, pi.isNull = function(t) {
                                    return null === t
                                }, pi.isNumber = La, pi.isObject = Ea, pi.isObjectLike = Ca, pi.isPlainObject = Ra, pi.isRegExp = Ia, pi.isSafeInteger = function(t) {
                                    return Aa(t) && t >= -O && t <= O
                                }, pi.isSet = Fa, pi.isString = Oa, pi.isSymbol = Na, pi.isTypedArray = Ba, pi.isUndefined = function(t) {
                                    return t === o
                                }, pi.isWeakMap = function(t) {
                                    return Ca(t) && zo(t) == st
                                }, pi.isWeakSet = function(t) {
                                    return Ca(t) && Ki(t) == at
                                }, pi.join = function(t, e) {
                                    return null == t ? "" : Gn.call(t, e)
                                }, pi.kebabCase = vl, pi.last = Ss, pi.lastIndexOf = function(t, e, n) {
                                    var i = null == t ? 0 : t.length;
                                    if (!i) return -1;
                                    var r = i;
                                    return n !== o && (r = (r = Ua(n)) < 0 ? Wn(i + r, 0) : Yn(r, i - 1)), e == e ? function(t, e, n) {
                                        for (var i = n + 1; i--;)
                                            if (t[i] === e) return i;
                                        return i
                                    }(t, e, r) : an(t, hn, r, !0)
                                }, pi.lowerCase = yl, pi.lowerFirst = xl, pi.lt = Da, pi.lte = Va, pi.max = function(t) {
                                    return t && t.length ? zi(t, Ll, $i) : o
                                }, pi.maxBy = function(t, e) {
                                    return t && t.length ? zi(t, Bo(e, 2), $i) : o
                                }, pi.mean = function(t) {
                                    return un(t, Ll)
                                }, pi.meanBy = function(t, e) {
                                    return un(t, Bo(e, 2))
                                }, pi.min = function(t) {
                                    return t && t.length ? zi(t, Ll, ur) : o
                                }, pi.minBy = function(t, e) {
                                    return t && t.length ? zi(t, Bo(e, 2), ur) : o
                                }, pi.stubArray = zl, pi.stubFalse = Gl, pi.stubObject = function() {
                                    return {}
                                }, pi.stubString = function() {
                                    return ""
                                }, pi.stubTrue = function() {
                                    return !0
                                }, pi.multiply = Ql, pi.nth = function(t, e) {
                                    return t && t.length ? gr(t, Ua(e)) : o
                                }, pi.noConflict = function() {
                                    return Fe._ === this && (Fe._ = me), this
                                }, pi.noop = Nl, pi.now = $s, pi.pad = function(t, e, n) {
                                    t = Wa(t);
                                    var i = (e = Ua(e)) ? Rn(t) : 0;
                                    if (!e || i >= e) return t;
                                    var r = (e - i) / 2;
                                    return yo(jn(r), n) + t + yo(Vn(r), n)
                                }, pi.padEnd = function(t, e, n) {
                                    t = Wa(t);
                                    var i = (e = Ua(e)) ? Rn(t) : 0;
                                    return e && i < e ? t + yo(e - i, n) : t
                                }, pi.padStart = function(t, e, n) {
                                    t = Wa(t);
                                    var i = (e = Ua(e)) ? Rn(t) : 0;
                                    return e && i < e ? yo(e - i, n) + t : t
                                }, pi.parseInt = function(t, e, n) {
                                    return n || null == e ? e = 0 : e && (e = +e), qn(Wa(t).replace(Nt, ""), e || 0)
                                }, pi.random = function(t, e, n) {
                                    if (n && "boolean" != typeof n && Xo(t, e, n) && (e = n = o), n === o && ("boolean" == typeof e ? (n = e, e = o) : "boolean" == typeof t && (n = t, t = o)), t === o && e === o ? (t = 0, e = 1) : (t = ka(t), e === o ? (e = t, t = 0) : e = ka(e)), t > e) {
                                        var i = t;
                                        t = e, e = i
                                    }
                                    if (n || t % 1 || e % 1) {
                                        var r = Qn();
                                        return Yn(t + r * (e - t + Pe("1e-" + ((r + "").length - 1))), e)
                                    }
                                    return wr(t, e)
                                }, pi.reduce = function(t, e, n) {
                                    var i = va(t) ? en : fn,
                                        r = arguments.length < 3;
                                    return i(t, Bo(e, 4), n, r, ji)
                                }, pi.reduceRight = function(t, e, n) {
                                    var i = va(t) ? nn : fn,
                                        r = arguments.length < 3;
                                    return i(t, Bo(e, 4), n, r, ki)
                                }, pi.repeat = function(t, e, n) {
                                    return e = (n ? Xo(t, e, n) : e === o) ? 1 : Ua(e), _r(Wa(t), e)
                                }, pi.replace = function() {
                                    var t = arguments,
                                        e = Wa(t[0]);
                                    return t.length < 3 ? e : e.replace(t[1], t[2])
                                }, pi.result = function(t, e, n) {
                                    var i = -1,
                                        r = (e = Yr(e, t)).length;
                                    for (r || (r = 1, t = o); ++i < r;) {
                                        var s = null == t ? o : t[hs(e[i])];
                                        s === o && (i = r, s = n), t = Ma(s) ? s.call(t) : s
                                    }
                                    return t
                                }, pi.round = Zl, pi.runInContext = t, pi.sample = function(t) {
                                    return (va(t) ? Mi : Mr)(t)
                                }, pi.size = function(t) {
                                    if (null == t) return 0;
                                    if (xa(t)) return Oa(t) ? Rn(t) : t.length;
                                    var e = zo(t);
                                    return e == Z || e == nt ? t.size : cr(t).length
                                }, pi.snakeCase = bl, pi.some = function(t, e, n) {
                                    var i = va(t) ? rn : Rr;
                                    return n && Xo(t, e, n) && (e = o), i(t, Bo(e, 3))
                                }, pi.sortedIndex = function(t, e) {
                                    return Ir(t, e)
                                }, pi.sortedIndexBy = function(t, e, n) {
                                    return Fr(t, e, Bo(n, 2))
                                }, pi.sortedIndexOf = function(t, e) {
                                    var n = null == t ? 0 : t.length;
                                    if (n) {
                                        var i = Ir(t, e);
                                        if (i < n && pa(t[i], e)) return i
                                    }
                                    return -1
                                }, pi.sortedLastIndex = function(t, e) {
                                    return Ir(t, e, !0)
                                }, pi.sortedLastIndexBy = function(t, e, n) {
                                    return Fr(t, e, Bo(n, 2), !0)
                                }, pi.sortedLastIndexOf = function(t, e) {
                                    if (null != t && t.length) {
                                        var n = Ir(t, e, !0) - 1;
                                        if (pa(t[n], e)) return n
                                    }
                                    return -1
                                }, pi.startCase = wl, pi.startsWith = function(t, e, n) {
                                    return t = Wa(t), n = null == n ? 0 : Oi(Ua(n), 0, t.length), e = Br(e), t.slice(n, n + e.length) == e
                                }, pi.subtract = Jl, pi.sum = function(t) {
                                    return t && t.length ? mn(t, Ll) : 0
                                }, pi.sumBy = function(t, e) {
                                    return t && t.length ? mn(t, Bo(e, 2)) : 0
                                }, pi.template = function(t, e, n) {
                                    var i = pi.templateSettings;
                                    n && Xo(t, e, n) && (e = o), t = Wa(t), e = qa({}, e, i, To);
                                    var r, s, a = qa({}, e.imports, i.imports, To),
                                        l = rl(a),
                                        c = yn(a, l),
                                        h = 0,
                                        u = e.interpolate || Zt,
                                        d = "__p += '",
                                        p = ne((e.escape || Zt).source + "|" + u.source + "|" + (u === Ct ? zt : Zt).source + "|" + (e.evaluate || Zt).source + "|$", "g"),
                                        f = "//# sourceURL=" + (he.call(e, "sourceURL") ? (e.sourceURL + "").replace(/[\r\n]/g, " ") : "lodash.templateSources[" + ++Ae + "]") + "\n";
                                    t.replace(p, (function(e, n, i, o, a, l) {
                                        return i || (i = o), d += t.slice(h, l).replace(Jt, Mn), n && (r = !0, d += "' +\n__e(" + n + ") +\n'"), a && (s = !0, d += "';\n" + a + ";\n__p += '"), i && (d += "' +\n((__t = (" + i + ")) == null ? '' : __t) +\n'"), h = l + e.length, e
                                    })), d += "';\n";
                                    var m = he.call(e, "variable") && e.variable;
                                    m || (d = "with (obj) {\n" + d + "\n}\n"), d = (s ? d.replace(xt, "") : d).replace(bt, "$1").replace(wt, "$1;"), d = "function(" + (m || "obj") + ") {\n" + (m ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (r ? ", __e = _.escape" : "") + (s ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + d + "return __p\n}";
                                    var g = Al((function() {
                                        return $t(l, f + "return " + d).apply(o, c)
                                    }));
                                    if (g.source = d, Sa(g)) throw g;
                                    return g
                                }, pi.times = function(t, e) {
                                    if ((t = Ua(t)) < 1 || t > O) return [];
                                    var n = D,
                                        i = Yn(t, D);
                                    e = Bo(e), t -= D;
                                    for (var r = gn(i, e); ++n < t;) e(n);
                                    return r
                                }, pi.toFinite = ka, pi.toInteger = Ua, pi.toLength = za, pi.toLower = function(t) {
                                    return Wa(t).toLowerCase()
                                }, pi.toNumber = Ga, pi.toSafeInteger = function(t) {
                                    return t ? Oi(Ua(t), -O, O) : 0 === t ? t : 0
                                }, pi.toString = Wa, pi.toUpper = function(t) {
                                    return Wa(t).toUpperCase()
                                }, pi.trim = function(t, e, n) {
                                    if ((t = Wa(t)) && (n || e === o)) return t.replace(Ot, "");
                                    if (!t || !(e = Br(e))) return t;
                                    var i = In(t),
                                        r = In(e);
                                    return qr(i, bn(i, r), wn(i, r) + 1).join("")
                                }, pi.trimEnd = function(t, e, n) {
                                    if ((t = Wa(t)) && (n || e === o)) return t.replace(Bt, "");
                                    if (!t || !(e = Br(e))) return t;
                                    var i = In(t);
                                    return qr(i, 0, wn(i, In(e)) + 1).join("")
                                }, pi.trimStart = function(t, e, n) {
                                    if ((t = Wa(t)) && (n || e === o)) return t.replace(Nt, "");
                                    if (!t || !(e = Br(e))) return t;
                                    var i = In(t);
                                    return qr(i, bn(i, In(e))).join("")
                                }, pi.truncate = function(t, e) {
                                    var n = E,
                                        i = C;
                                    if (Ea(e)) {
                                        var r = "separator" in e ? e.separator : r;
                                        n = "length" in e ? Ua(e.length) : n, i = "omission" in e ? Br(e.omission) : i
                                    }
                                    var s = (t = Wa(t)).length;
                                    if (An(t)) {
                                        var a = In(t);
                                        s = a.length
                                    }
                                    if (n >= s) return t;
                                    var l = n - Rn(i);
                                    if (l < 1) return i;
                                    var c = a ? qr(a, 0, l).join("") : t.slice(0, l);
                                    if (r === o) return c + i;
                                    if (a && (l += c.length - l), Ia(r)) {
                                        if (t.slice(l).search(r)) {
                                            var h, u = c;
                                            for (r.global || (r = ne(r.source, Wa(Gt.exec(r)) + "g")), r.lastIndex = 0; h = r.exec(u);) var d = h.index;
                                            c = c.slice(0, d === o ? l : d)
                                        }
                                    } else if (t.indexOf(Br(r), l) != l) {
                                        var p = c.lastIndexOf(r);
                                        p > -1 && (c = c.slice(0, p))
                                    }
                                    return c + i
                                }, pi.unescape = function(t) {
                                    return (t = Wa(t)) && Mt.test(t) ? t.replace(_t, Fn) : t
                                }, pi.uniqueId = function(t) {
                                    var e = ++ue;
                                    return Wa(t) + e
                                }, pi.upperCase = _l, pi.upperFirst = Sl, pi.each = Ws, pi.eachRight = Ys, pi.first = xs, Ol(pi, (Hl = {}, Xi(pi, (function(t, e) {
                                    he.call(pi.prototype, e) || (Hl[e] = t)
                                })), Hl), {
                                    chain: !1
                                }), pi.VERSION = "4.17.15", Xe(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], (function(t) {
                                    pi[t].placeholder = pi
                                })), Xe(["drop", "take"], (function(t, e) {
                                    vi.prototype[t] = function(n) {
                                        n = n === o ? 1 : Wn(Ua(n), 0);
                                        var i = this.__filtered__ && !e ? new vi(this) : this.clone();
                                        return i.__filtered__ ? i.__takeCount__ = Yn(n, i.__takeCount__) : i.__views__.push({
                                            size: Yn(n, D),
                                            type: t + (i.__dir__ < 0 ? "Right" : "")
                                        }), i
                                    }, vi.prototype[t + "Right"] = function(e) {
                                        return this.reverse()[t](e).reverse()
                                    }
                                })), Xe(["filter", "map", "takeWhile"], (function(t, e) {
                                    var n = e + 1,
                                        i = n == R || 3 == n;
                                    vi.prototype[t] = function(t) {
                                        var e = this.clone();
                                        return e.__iteratees__.push({
                                            iteratee: Bo(t, 3),
                                            type: n
                                        }), e.__filtered__ = e.__filtered__ || i, e
                                    }
                                })), Xe(["head", "last"], (function(t, e) {
                                    var n = "take" + (e ? "Right" : "");
                                    vi.prototype[t] = function() {
                                        return this[n](1).value()[0]
                                    }
                                })), Xe(["initial", "tail"], (function(t, e) {
                                    var n = "drop" + (e ? "" : "Right");
                                    vi.prototype[t] = function() {
                                        return this.__filtered__ ? new vi(this) : this[n](1)
                                    }
                                })), vi.prototype.compact = function() {
                                    return this.filter(Ll)
                                }, vi.prototype.find = function(t) {
                                    return this.filter(t).head()
                                }, vi.prototype.findLast = function(t) {
                                    return this.reverse().find(t)
                                }, vi.prototype.invokeMap = Sr((function(t, e) {
                                    return "function" == typeof t ? new vi(this) : this.map((function(n) {
                                        return ir(n, t, e)
                                    }))
                                })), vi.prototype.reject = function(t) {
                                    return this.filter(la(Bo(t)))
                                }, vi.prototype.slice = function(t, e) {
                                    t = Ua(t);
                                    var n = this;
                                    return n.__filtered__ && (t > 0 || e < 0) ? new vi(n) : (t < 0 ? n = n.takeRight(-t) : t && (n = n.drop(t)), e !== o && (n = (e = Ua(e)) < 0 ? n.dropRight(-e) : n.take(e - t)), n)
                                }, vi.prototype.takeRightWhile = function(t) {
                                    return this.reverse().takeWhile(t).reverse()
                                }, vi.prototype.toArray = function() {
                                    return this.take(D)
                                }, Xi(vi.prototype, (function(t, e) {
                                    var n = /^(?:filter|find|map|reject)|While$/.test(e),
                                        i = /^(?:head|last)$/.test(e),
                                        r = pi[i ? "take" + ("last" == e ? "Right" : "") : e],
                                        s = i || /^find/.test(e);
                                    r && (pi.prototype[e] = function() {
                                        var e = this.__wrapped__,
                                            a = i ? [1] : arguments,
                                            l = e instanceof vi,
                                            c = a[0],
                                            h = l || va(e),
                                            u = function(t) {
                                                var e = r.apply(pi, tn([t], a));
                                                return i && d ? e[0] : e
                                            };
                                        h && n && "function" == typeof c && 1 != c.length && (l = h = !1);
                                        var d = this.__chain__,
                                            p = !!this.__actions__.length,
                                            f = s && !d,
                                            m = l && !p;
                                        if (!s && h) {
                                            e = m ? e : new vi(this);
                                            var g = t.apply(e, a);
                                            return g.__actions__.push({
                                                func: ks,
                                                args: [u],
                                                thisArg: o
                                            }), new gi(g, d)
                                        }
                                        return f && m ? t.apply(this, a) : (g = this.thru(u), f ? i ? g.value()[0] : g.value() : g)
                                    })
                                })), Xe(["pop", "push", "shift", "sort", "splice", "unshift"], (function(t) {
                                    var e = oe[t],
                                        n = /^(?:push|sort|unshift)$/.test(t) ? "tap" : "thru",
                                        i = /^(?:pop|shift)$/.test(t);
                                    pi.prototype[t] = function() {
                                        var t = arguments;
                                        if (i && !this.__chain__) {
                                            var r = this.value();
                                            return e.apply(va(r) ? r : [], t)
                                        }
                                        return this[n]((function(n) {
                                            return e.apply(va(n) ? n : [], t)
                                        }))
                                    }
                                })), Xi(vi.prototype, (function(t, e) {
                                    var n = pi[e];
                                    if (n) {
                                        var i = n.name + "";
                                        he.call(ri, i) || (ri[i] = []), ri[i].push({
                                            name: e,
                                            func: n
                                        })
                                    }
                                })), ri[fo(o, y).name] = [{
                                    name: "wrapper",
                                    func: o
                                }], vi.prototype.clone = function() {
                                    var t = new vi(this.__wrapped__);
                                    return t.__actions__ = no(this.__actions__), t.__dir__ = this.__dir__, t.__filtered__ = this.__filtered__, t.__iteratees__ = no(this.__iteratees__), t.__takeCount__ = this.__takeCount__, t.__views__ = no(this.__views__), t
                                }, vi.prototype.reverse = function() {
                                    if (this.__filtered__) {
                                        var t = new vi(this);
                                        t.__dir__ = -1, t.__filtered__ = !0
                                    } else(t = this.clone()).__dir__ *= -1;
                                    return t
                                }, vi.prototype.value = function() {
                                    var t = this.__wrapped__.value(),
                                        e = this.__dir__,
                                        n = va(t),
                                        i = e < 0,
                                        r = n ? t.length : 0,
                                        o = function(t, e, n) {
                                            for (var i = -1, r = n.length; ++i < r;) {
                                                var o = n[i],
                                                    s = o.size;
                                                switch (o.type) {
                                                    case "drop":
                                                        t += s;
                                                        break;
                                                    case "dropRight":
                                                        e -= s;
                                                        break;
                                                    case "take":
                                                        e = Yn(e, t + s);
                                                        break;
                                                    case "takeRight":
                                                        t = Wn(t, e - s)
                                                }
                                            }
                                            return {
                                                start: t,
                                                end: e
                                            }
                                        }(0, r, this.__views__),
                                        s = o.start,
                                        a = o.end,
                                        l = a - s,
                                        c = i ? a : s - 1,
                                        h = this.__iteratees__,
                                        u = h.length,
                                        d = 0,
                                        p = Yn(l, this.__takeCount__);
                                    if (!n || !i && r == l && p == l) return Ur(t, this.__actions__);
                                    var f = [];
                                    t: for (; l-- && d < p;) {
                                        for (var m = -1, g = t[c += e]; ++m < u;) {
                                            var v = h[m],
                                                y = v.iteratee,
                                                x = v.type,
                                                b = y(g);
                                            if (x == I) g = b;
                                            else if (!b) {
                                                if (x == R) continue t;
                                                break t
                                            }
                                        }
                                        f[d++] = g
                                    }
                                    return f
                                }, pi.prototype.at = Us, pi.prototype.chain = function() {
                                    return js(this)
                                }, pi.prototype.commit = function() {
                                    return new gi(this.value(), this.__chain__)
                                }, pi.prototype.next = function() {
                                    this.__values__ === o && (this.__values__ = ja(this.value()));
                                    var t = this.__index__ >= this.__values__.length;
                                    return {
                                        done: t,
                                        value: t ? o : this.__values__[this.__index__++]
                                    }
                                }, pi.prototype.plant = function(t) {
                                    for (var e, n = this; n instanceof mi;) {
                                        var i = ds(n);
                                        i.__index__ = 0, i.__values__ = o, e ? r.__wrapped__ = i : e = i;
                                        var r = i;
                                        n = n.__wrapped__
                                    }
                                    return r.__wrapped__ = t, e
                                }, pi.prototype.reverse = function() {
                                    var t = this.__wrapped__;
                                    if (t instanceof vi) {
                                        var e = t;
                                        return this.__actions__.length && (e = new vi(this)), (e = e.reverse()).__actions__.push({
                                            func: ks,
                                            args: [Es],
                                            thisArg: o
                                        }), new gi(e, this.__chain__)
                                    }
                                    return this.thru(Es)
                                }, pi.prototype.toJSON = pi.prototype.valueOf = pi.prototype.value = function() {
                                    return Ur(this.__wrapped__, this.__actions__)
                                }, pi.prototype.first = pi.prototype.head, Ve && (pi.prototype[Ve] = function() {
                                    return this
                                }), pi
                            }();
                        Fe._ = On, (r = function() {
                            return On
                        }.call(e, n, e, i)) === o || (i.exports = r)
                    }).call(this)
                }).call(this, n(44), n(45)(t))
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2),
                    r = n(30);
                class o extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.character.velocitySimulator.damping = .6, this.character.velocitySimulator.mass = 10, this.character.setArcadeVelocityTarget(0), this.character.setAnimation("idle", .1)
                    }
                    update(t) {
                        super.update(t), this.fallInAir()
                    }
                    onInputChange() {
                        super.onInputChange(), this.character.actions.jump.justPressed && this.character.setState(new i.JumpIdle(this.character)), this.character.actions.dance.justPressed && this.character.setState(new r.Dance(this.character)), this.anyDirection() && (this.character.velocity.length() > .5 ? this.character.setState(new i.Walk(this.character)) : this.setAppropriateStartWalkState())
                    }
                }
                e.Idle = o
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                        value: !0
                    }),
                    function(t) {
                        t.Left = "left", t.Right = "right"
                    }(e.Side || (e.Side = {}))
            }, function(t, e, n) {
                "use strict";
                n.r(e), n.d(e, "Face3", (function() {
                    return c
                })), n.d(e, "Geometry", (function() {
                    return a
                }));
                var i = n(0);
                const r = new i.Matrix4,
                    o = new i.Object3D,
                    s = new i.Vector3;
                class a extends i.EventDispatcher {
                    constructor() {
                        super(), this.uuid = i.MathUtils.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                            []
                        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
                    }
                    applyMatrix4(t) {
                        const e = (new i.Matrix3).getNormalMatrix(t);
                        for (let n = 0, i = this.vertices.length; n < i; n++) this.vertices[n].applyMatrix4(t);
                        for (let n = 0, i = this.faces.length; n < i; n++) {
                            const t = this.faces[n];
                            t.normal.applyMatrix3(e).normalize();
                            for (let n = 0, i = t.vertexNormals.length; n < i; n++) t.vertexNormals[n].applyMatrix3(e).normalize()
                        }
                        return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                    }
                    rotateX(t) {
                        return r.makeRotationX(t), this.applyMatrix4(r), this
                    }
                    rotateY(t) {
                        return r.makeRotationY(t), this.applyMatrix4(r), this
                    }
                    rotateZ(t) {
                        return r.makeRotationZ(t), this.applyMatrix4(r), this
                    }
                    translate(t, e, n) {
                        return r.makeTranslation(t, e, n), this.applyMatrix4(r), this
                    }
                    scale(t, e, n) {
                        return r.makeScale(t, e, n), this.applyMatrix4(r), this
                    }
                    lookAt(t) {
                        return o.lookAt(t), o.updateMatrix(), this.applyMatrix4(o.matrix), this
                    }
                    fromBufferGeometry(t) {
                        const e = this,
                            n = null !== t.index ? t.index : void 0,
                            r = t.attributes;
                        if (void 0 === r.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                        const o = r.position,
                            s = r.normal,
                            a = r.color,
                            l = r.uv,
                            h = r.uv2;
                        void 0 !== h && (this.faceVertexUvs[1] = []);
                        for (let c = 0; c < o.count; c++) e.vertices.push((new i.Vector3).fromBufferAttribute(o, c)), void 0 !== a && e.colors.push((new i.Color).fromBufferAttribute(a, c));

                        function u(t, n, r, o) {
                            const u = void 0 === a ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[r].clone()],
                                d = void 0 === s ? [] : [(new i.Vector3).fromBufferAttribute(s, t), (new i.Vector3).fromBufferAttribute(s, n), (new i.Vector3).fromBufferAttribute(s, r)],
                                p = new c(t, n, r, d, u, o);
                            e.faces.push(p), void 0 !== l && e.faceVertexUvs[0].push([(new i.Vector2).fromBufferAttribute(l, t), (new i.Vector2).fromBufferAttribute(l, n), (new i.Vector2).fromBufferAttribute(l, r)]), void 0 !== h && e.faceVertexUvs[1].push([(new i.Vector2).fromBufferAttribute(h, t), (new i.Vector2).fromBufferAttribute(h, n), (new i.Vector2).fromBufferAttribute(h, r)])
                        }
                        const d = t.groups;
                        if (d.length > 0)
                            for (let i = 0; i < d.length; i++) {
                                const t = d[i],
                                    e = t.start;
                                for (let i = e, r = e + t.count; i < r; i += 3) void 0 !== n ? u(n.getX(i), n.getX(i + 1), n.getX(i + 2), t.materialIndex) : u(i, i + 1, i + 2, t.materialIndex)
                            } else if (void 0 !== n)
                                for (let i = 0; i < n.count; i += 3) u(n.getX(i), n.getX(i + 1), n.getX(i + 2));
                            else
                                for (let i = 0; i < o.count; i += 3) u(i, i + 1, i + 2);
                        return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                    }
                    center() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(s).negate(), this.translate(s.x, s.y, s.z), this
                    }
                    normalize() {
                        this.computeBoundingSphere();
                        const t = this.boundingSphere.center,
                            e = this.boundingSphere.radius,
                            n = 0 === e ? 1 : 1 / e,
                            r = new i.Matrix4;
                        return r.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(r), this
                    }
                    computeFaceNormals() {
                        const t = new i.Vector3,
                            e = new i.Vector3;
                        for (let n = 0, i = this.faces.length; n < i; n++) {
                            const i = this.faces[n],
                                r = this.vertices[i.a],
                                o = this.vertices[i.b],
                                s = this.vertices[i.c];
                            t.subVectors(s, o), e.subVectors(r, o), t.cross(e), t.normalize(), i.normal.copy(t)
                        }
                    }
                    computeVertexNormals() {
                        let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                        const e = new Array(this.vertices.length);
                        for (let n = 0, r = this.vertices.length; n < r; n++) e[n] = new i.Vector3;
                        if (t) {
                            const t = new i.Vector3,
                                n = new i.Vector3;
                            for (let i = 0, r = this.faces.length; i < r; i++) {
                                const r = this.faces[i],
                                    o = this.vertices[r.a],
                                    s = this.vertices[r.b],
                                    a = this.vertices[r.c];
                                t.subVectors(a, s), n.subVectors(o, s), t.cross(n), e[r.a].add(t), e[r.b].add(t), e[r.c].add(t)
                            }
                        } else {
                            this.computeFaceNormals();
                            for (let t = 0, n = this.faces.length; t < n; t++) {
                                const n = this.faces[t];
                                e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal)
                            }
                        }
                        for (let n = 0, i = this.vertices.length; n < i; n++) e[n].normalize();
                        for (let n = 0, i = this.faces.length; n < i; n++) {
                            const t = this.faces[n],
                                i = t.vertexNormals;
                            3 === i.length ? (i[0].copy(e[t.a]), i[1].copy(e[t.b]), i[2].copy(e[t.c])) : (i[0] = e[t.a].clone(), i[1] = e[t.b].clone(), i[2] = e[t.c].clone())
                        }
                        this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                    }
                    computeFlatVertexNormals() {
                        this.computeFaceNormals();
                        for (let t = 0, e = this.faces.length; t < e; t++) {
                            const e = this.faces[t],
                                n = e.vertexNormals;
                            3 === n.length ? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal)) : (n[0] = e.normal.clone(), n[1] = e.normal.clone(), n[2] = e.normal.clone())
                        }
                        this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                    }
                    computeMorphNormals() {
                        for (let e = 0, n = this.faces.length; e < n; e++) {
                            const t = this.faces[e];
                            t.__originalFaceNormal ? t.__originalFaceNormal.copy(t.normal) : t.__originalFaceNormal = t.normal.clone(), t.__originalVertexNormals || (t.__originalVertexNormals = []);
                            for (let e = 0, n = t.vertexNormals.length; e < n; e++) t.__originalVertexNormals[e] ? t.__originalVertexNormals[e].copy(t.vertexNormals[e]) : t.__originalVertexNormals[e] = t.vertexNormals[e].clone()
                        }
                        const t = new a;
                        t.faces = this.faces;
                        for (let e = 0, n = this.morphTargets.length; e < n; e++) {
                            if (!this.morphNormals[e]) {
                                this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                                const t = this.morphNormals[e].faceNormals,
                                    n = this.morphNormals[e].vertexNormals;
                                for (let e = 0, r = this.faces.length; e < r; e++) {
                                    const e = new i.Vector3,
                                        r = {
                                            a: new i.Vector3,
                                            b: new i.Vector3,
                                            c: new i.Vector3
                                        };
                                    t.push(e), n.push(r)
                                }
                            }
                            const n = this.morphNormals[e];
                            t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals();
                            for (let t = 0, e = this.faces.length; t < e; t++) {
                                const e = this.faces[t],
                                    i = n.faceNormals[t],
                                    r = n.vertexNormals[t];
                                i.copy(e.normal), r.a.copy(e.vertexNormals[0]), r.b.copy(e.vertexNormals[1]), r.c.copy(e.vertexNormals[2])
                            }
                        }
                        for (let e = 0, n = this.faces.length; e < n; e++) {
                            const t = this.faces[e];
                            t.normal = t.__originalFaceNormal, t.vertexNormals = t.__originalVertexNormals
                        }
                    }
                    computeBoundingBox() {
                        null === this.boundingBox && (this.boundingBox = new i.Box3), this.boundingBox.setFromPoints(this.vertices)
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere && (this.boundingSphere = new i.Sphere), this.boundingSphere.setFromPoints(this.vertices)
                    }
                    merge(t, e) {
                        let n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        if (!t || !t.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
                        const o = this.vertices.length,
                            s = this.vertices,
                            a = t.vertices,
                            l = this.faces,
                            h = t.faces,
                            u = this.colors,
                            d = t.colors;
                        void 0 !== e && (n = (new i.Matrix3).getNormalMatrix(e));
                        for (let i = 0, c = a.length; i < c; i++) {
                            const t = a[i].clone();
                            void 0 !== e && t.applyMatrix4(e), s.push(t)
                        }
                        for (let i = 0, c = d.length; i < c; i++) u.push(d[i].clone());
                        for (let i = 0, p = h.length; i < p; i++) {
                            const t = h[i];
                            let e, s;
                            const a = t.vertexNormals,
                                u = t.vertexColors,
                                d = new c(t.a + o, t.b + o, t.c + o);
                            d.normal.copy(t.normal), void 0 !== n && d.normal.applyMatrix3(n).normalize();
                            for (let i = 0, r = a.length; i < r; i++) e = a[i].clone(), void 0 !== n && e.applyMatrix3(n).normalize(), d.vertexNormals.push(e);
                            d.color.copy(t.color);
                            for (let n = 0, i = u.length; n < i; n++) s = u[n], d.vertexColors.push(s.clone());
                            d.materialIndex = t.materialIndex + r, l.push(d)
                        }
                        for (let i = 0, c = t.faceVertexUvs.length; i < c; i++) {
                            const e = t.faceVertexUvs[i];
                            void 0 === this.faceVertexUvs[i] && (this.faceVertexUvs[i] = []);
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t],
                                    r = [];
                                for (let t = 0, e = n.length; t < e; t++) r.push(n[t].clone());
                                this.faceVertexUvs[i].push(r)
                            }
                        }
                    }
                    mergeMesh(t) {
                        t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
                    }
                    mergeVertices() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 4;
                        const e = {},
                            n = [],
                            i = [],
                            r = Math.pow(10, t);
                        for (let a = 0, l = this.vertices.length; a < l; a++) {
                            const t = this.vertices[a],
                                o = Math.round(t.x * r) + "_" + Math.round(t.y * r) + "_" + Math.round(t.z * r);
                            void 0 === e[o] ? (e[o] = a, n.push(this.vertices[a]), i[a] = n.length - 1) : i[a] = i[e[o]]
                        }
                        const o = [];
                        for (let a = 0, l = this.faces.length; a < l; a++) {
                            const t = this.faces[a];
                            t.a = i[t.a], t.b = i[t.b], t.c = i[t.c];
                            const e = [t.a, t.b, t.c];
                            for (let n = 0; n < 3; n++)
                                if (e[n] === e[(n + 1) % 3]) {
                                    o.push(a);
                                    break
                                }
                        }
                        for (let a = o.length - 1; a >= 0; a--) {
                            const t = o[a];
                            this.faces.splice(t, 1);
                            for (let e = 0, n = this.faceVertexUvs.length; e < n; e++) this.faceVertexUvs[e].splice(t, 1)
                        }
                        const s = this.vertices.length - n.length;
                        return this.vertices = n, s
                    }
                    setFromPoints(t) {
                        this.vertices = [];
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            this.vertices.push(new i.Vector3(n.x, n.y, n.z || 0))
                        }
                        return this
                    }
                    sortFacesByMaterialIndex() {
                        const t = this.faces,
                            e = t.length;
                        for (let s = 0; s < e; s++) t[s]._id = s;
                        t.sort((function(t, e) {
                            return t.materialIndex - e.materialIndex
                        }));
                        const n = this.faceVertexUvs[0],
                            i = this.faceVertexUvs[1];
                        let r, o;
                        n && n.length === e && (r = []), i && i.length === e && (o = []);
                        for (let s = 0; s < e; s++) {
                            const e = t[s]._id;
                            r && r.push(n[e]), o && o.push(i[e])
                        }
                        r && (this.faceVertexUvs[0] = r), o && (this.faceVertexUvs[1] = o)
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.5,
                                type: "Geometry",
                                generator: "Geometry.toJSON"
                            }
                        };
                        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                            const e = this.parameters;
                            for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                            return t
                        }
                        const e = [];
                        for (let p = 0; p < this.vertices.length; p++) {
                            const t = this.vertices[p];
                            e.push(t.x, t.y, t.z)
                        }
                        const n = [],
                            i = [],
                            r = {},
                            o = [],
                            s = {},
                            a = [],
                            l = {};
                        for (let p = 0; p < this.faces.length; p++) {
                            const t = this.faces[p],
                                e = !0,
                                i = !1,
                                r = void 0 !== this.faceVertexUvs[0][p],
                                o = t.normal.length() > 0,
                                s = t.vertexNormals.length > 0,
                                a = 1 !== t.color.r || 1 !== t.color.g || 1 !== t.color.b,
                                l = t.vertexColors.length > 0;
                            let f = 0;
                            if (f = c(f, 0, 0), f = c(f, 1, e), f = c(f, 2, i), f = c(f, 3, r), f = c(f, 4, o), f = c(f, 5, s), f = c(f, 6, a), f = c(f, 7, l), n.push(f), n.push(t.a, t.b, t.c), n.push(t.materialIndex), r) {
                                const t = this.faceVertexUvs[0][p];
                                n.push(d(t[0]), d(t[1]), d(t[2]))
                            }
                            if (o && n.push(h(t.normal)), s) {
                                const e = t.vertexNormals;
                                n.push(h(e[0]), h(e[1]), h(e[2]))
                            }
                            if (a && n.push(u(t.color)), l) {
                                const e = t.vertexColors;
                                n.push(u(e[0]), u(e[1]), u(e[2]))
                            }
                        }

                        function c(t, e, n) {
                            return n ? t | 1 << e : t & ~(1 << e)
                        }

                        function h(t) {
                            const e = t.x.toString() + t.y.toString() + t.z.toString();
                            return void 0 !== r[e] || (r[e] = i.length / 3, i.push(t.x, t.y, t.z)), r[e]
                        }

                        function u(t) {
                            const e = t.r.toString() + t.g.toString() + t.b.toString();
                            return void 0 !== s[e] || (s[e] = o.length, o.push(t.getHex())), s[e]
                        }

                        function d(t) {
                            const e = t.x.toString() + t.y.toString();
                            return void 0 !== l[e] || (l[e] = a.length / 2, a.push(t.x, t.y)), l[e]
                        }
                        return t.data = {}, t.data.vertices = e, t.data.normals = i, o.length > 0 && (t.data.colors = o), a.length > 0 && (t.data.uvs = [a]), t.data.faces = n, t
                    }
                    clone() {
                        return (new a).copy(this)
                    }
                    copy(t) {
                        this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                            []
                        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                        const e = t.vertices;
                        for (let u = 0, d = e.length; u < d; u++) this.vertices.push(e[u].clone());
                        const n = t.colors;
                        for (let u = 0, d = n.length; u < d; u++) this.colors.push(n[u].clone());
                        const i = t.faces;
                        for (let u = 0, d = i.length; u < d; u++) this.faces.push(i[u].clone());
                        for (let u = 0, d = t.faceVertexUvs.length; u < d; u++) {
                            const e = t.faceVertexUvs[u];
                            void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t],
                                    i = [];
                                for (let t = 0, e = n.length; t < e; t++) {
                                    const e = n[t];
                                    i.push(e.clone())
                                }
                                this.faceVertexUvs[u].push(i)
                            }
                        }
                        const r = t.morphTargets;
                        for (let u = 0, d = r.length; u < d; u++) {
                            const t = {};
                            if (t.name = r[u].name, void 0 !== r[u].vertices) {
                                t.vertices = [];
                                for (let e = 0, n = r[u].vertices.length; e < n; e++) t.vertices.push(r[u].vertices[e].clone())
                            }
                            if (void 0 !== r[u].normals) {
                                t.normals = [];
                                for (let e = 0, n = r[u].normals.length; e < n; e++) t.normals.push(r[u].normals[e].clone())
                            }
                            this.morphTargets.push(t)
                        }
                        const o = t.morphNormals;
                        for (let u = 0, d = o.length; u < d; u++) {
                            const t = {};
                            if (void 0 !== o[u].vertexNormals) {
                                t.vertexNormals = [];
                                for (let e = 0, n = o[u].vertexNormals.length; e < n; e++) {
                                    const n = o[u].vertexNormals[e],
                                        i = {};
                                    i.a = n.a.clone(), i.b = n.b.clone(), i.c = n.c.clone(), t.vertexNormals.push(i)
                                }
                            }
                            if (void 0 !== o[u].faceNormals) {
                                t.faceNormals = [];
                                for (let e = 0, n = o[u].faceNormals.length; e < n; e++) t.faceNormals.push(o[u].faceNormals[e].clone())
                            }
                            this.morphNormals.push(t)
                        }
                        const s = t.skinWeights;
                        for (let u = 0, d = s.length; u < d; u++) this.skinWeights.push(s[u].clone());
                        const a = t.skinIndices;
                        for (let u = 0, d = a.length; u < d; u++) this.skinIndices.push(a[u].clone());
                        const l = t.lineDistances;
                        for (let u = 0, d = l.length; u < d; u++) this.lineDistances.push(l[u]);
                        const c = t.boundingBox;
                        null !== c && (this.boundingBox = c.clone());
                        const h = t.boundingSphere;
                        return null !== h && (this.boundingSphere = h.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                    }
                    toBufferGeometry() {
                        const t = (new l).fromGeometry(this),
                            e = new i.BufferGeometry,
                            n = new Float32Array(3 * t.vertices.length);
                        if (e.setAttribute("position", new i.BufferAttribute(n, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                            const n = new Float32Array(3 * t.normals.length);
                            e.setAttribute("normal", new i.BufferAttribute(n, 3).copyVector3sArray(t.normals))
                        }
                        if (t.colors.length > 0) {
                            const n = new Float32Array(3 * t.colors.length);
                            e.setAttribute("color", new i.BufferAttribute(n, 3).copyColorsArray(t.colors))
                        }
                        if (t.uvs.length > 0) {
                            const n = new Float32Array(2 * t.uvs.length);
                            e.setAttribute("uv", new i.BufferAttribute(n, 2).copyVector2sArray(t.uvs))
                        }
                        if (t.uvs2.length > 0) {
                            const n = new Float32Array(2 * t.uvs2.length);
                            e.setAttribute("uv2", new i.BufferAttribute(n, 2).copyVector2sArray(t.uvs2))
                        }
                        e.groups = t.groups;
                        for (const r in t.morphTargets) {
                            const n = [],
                                o = t.morphTargets[r];
                            for (let t = 0, e = o.length; t < e; t++) {
                                const e = o[t],
                                    r = new i.Float32BufferAttribute(3 * e.data.length, 3);
                                r.name = e.name, n.push(r.copyVector3sArray(e.data))
                            }
                            e.morphAttributes[r] = n
                        }
                        if (t.skinIndices.length > 0) {
                            const n = new i.Float32BufferAttribute(4 * t.skinIndices.length, 4);
                            e.setAttribute("skinIndex", n.copyVector4sArray(t.skinIndices))
                        }
                        if (t.skinWeights.length > 0) {
                            const n = new i.Float32BufferAttribute(4 * t.skinWeights.length, 4);
                            e.setAttribute("skinWeight", n.copyVector4sArray(t.skinWeights))
                        }
                        return null !== t.boundingSphere && (e.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (e.boundingBox = t.boundingBox.clone()), e
                    }
                    computeTangents() {
                        console.error("THREE.Geometry: .computeTangents() has been removed.")
                    }
                    computeLineDistances() {
                        console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                    }
                    applyMatrix(t) {
                        return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    static createBufferGeometryFromObject(t) {
                        let e = new i.BufferGeometry;
                        const n = t.geometry;
                        if (t.isPoints || t.isLine) {
                            const t = new i.Float32BufferAttribute(3 * n.vertices.length, 3),
                                r = new i.Float32BufferAttribute(3 * n.colors.length, 3);
                            if (e.setAttribute("position", t.copyVector3sArray(n.vertices)), e.setAttribute("color", r.copyColorsArray(n.colors)), n.lineDistances && n.lineDistances.length === n.vertices.length) {
                                const t = new i.Float32BufferAttribute(n.lineDistances.length, 1);
                                e.setAttribute("lineDistance", t.copyArray(n.lineDistances))
                            }
                            null !== n.boundingSphere && (e.boundingSphere = n.boundingSphere.clone()), null !== n.boundingBox && (e.boundingBox = n.boundingBox.clone())
                        } else t.isMesh && (e = n.toBufferGeometry());
                        return e
                    }
                }
                a.prototype.isGeometry = !0;
                class l {
                    constructor() {
                        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
                    }
                    computeGroups(t) {
                        const e = [];
                        let n, i, r;
                        const o = t.faces;
                        for (i = 0; i < o.length; i++) {
                            const t = o[i];
                            t.materialIndex !== r && (r = t.materialIndex, void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), n = {
                                start: 3 * i,
                                materialIndex: r
                            })
                        }
                        void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), this.groups = e
                    }
                    fromGeometry(t) {
                        const e = t.faces,
                            n = t.vertices,
                            r = t.faceVertexUvs,
                            o = r[0] && r[0].length > 0,
                            s = r[1] && r[1].length > 0,
                            a = t.morphTargets,
                            l = a.length;
                        let c;
                        if (l > 0) {
                            c = [];
                            for (let t = 0; t < l; t++) c[t] = {
                                name: a[t].name,
                                data: []
                            };
                            this.morphTargets.position = c
                        }
                        const h = t.morphNormals,
                            u = h.length;
                        let d;
                        if (u > 0) {
                            d = [];
                            for (let t = 0; t < u; t++) d[t] = {
                                name: h[t].name,
                                data: []
                            };
                            this.morphTargets.normal = d
                        }
                        const p = t.skinIndices,
                            f = t.skinWeights,
                            m = p.length === n.length,
                            g = f.length === n.length;
                        n.length > 0 && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                        for (let v = 0; v < e.length; v++) {
                            const t = e[v];
                            this.vertices.push(n[t.a], n[t.b], n[t.c]);
                            const y = t.vertexNormals;
                            if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                            else {
                                const e = t.normal;
                                this.normals.push(e, e, e)
                            }
                            const x = t.vertexColors;
                            if (3 === x.length) this.colors.push(x[0], x[1], x[2]);
                            else {
                                const e = t.color;
                                this.colors.push(e, e, e)
                            }
                            if (!0 === o) {
                                const t = r[0][v];
                                void 0 !== t ? this.uvs.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", v), this.uvs.push(new i.Vector2, new i.Vector2, new i.Vector2))
                            }
                            if (!0 === s) {
                                const t = r[1][v];
                                void 0 !== t ? this.uvs2.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", v), this.uvs2.push(new i.Vector2, new i.Vector2, new i.Vector2))
                            }
                            for (let e = 0; e < l; e++) {
                                const n = a[e].vertices;
                                c[e].data.push(n[t.a], n[t.b], n[t.c])
                            }
                            for (let e = 0; e < u; e++) {
                                const t = h[e].vertexNormals[v];
                                d[e].data.push(t.a, t.b, t.c)
                            }
                            m && this.skinIndices.push(p[t.a], p[t.b], p[t.c]), g && this.skinWeights.push(f[t.a], f[t.b], f[t.c])
                        }
                        return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                    }
                }
                class c {
                    constructor(t, e, n, r, o) {
                        let s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
                        this.a = t, this.b = e, this.c = n, this.normal = r && r.isVector3 ? r : new i.Vector3, this.vertexNormals = Array.isArray(r) ? r : [], this.color = o && o.isColor ? o : new i.Color, this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = s
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                        for (let e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                        for (let e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                        return this
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(0),
                    r = n(1),
                    o = n(6),
                    s = n(24),
                    a = n(25),
                    l = n(26),
                    c = n(3),
                    h = n(11);
                class u extends i.Object3D {
                    constructor(t, e) {
                        super(), this.actions = {}, this.seats = [], this.wheels = [], this.materials = [], this.firstPerson = !1, void 0 === e && (e = {}), e.chassisConnectionPointLocal = new r.Vec3, e.axleLocal = new r.Vec3(-1, 0, 0), e.directionLocal = new r.Vec3(0, -1, 0);
                        let n = new r.Material("Mat");
                        n.friction = .01, this.collision = new r.Body({
                            mass: 50
                        }), this.collision.material = n, this.readVehicleData(t), this.modelContainer = new i.Group, this.add(this.modelContainer), this.modelContainer.add(t.scene), this.rayCastVehicle = new r.RaycastVehicle({
                            chassisBody: this.collision,
                            indexUpAxis: 1,
                            indexRightAxis: 0,
                            indexForwardAxis: 2
                        }), this.wheels.forEach((t => {
                            e.chassisConnectionPointLocal.set(t.position.x, t.position.y + .2, t.position.z);
                            const n = this.rayCastVehicle.addWheel(e);
                            t.rayCastWheelInfoIndex = n
                        })), this.help = new i.AxesHelper(2)
                    }
                    update(t) {
                        this.help.position.copy(c.threeVector(this.collision.interpolatedPosition)), this.help.quaternion.copy(c.threeQuat(this.collision.interpolatedQuaternion)), this.position.set(this.collision.interpolatedPosition.x, this.collision.interpolatedPosition.y, this.collision.interpolatedPosition.z), this.quaternion.set(this.collision.interpolatedQuaternion.x, this.collision.interpolatedQuaternion.y, this.collision.interpolatedQuaternion.z, this.collision.interpolatedQuaternion.w), this.seats.forEach((e => {
                            e.update(t)
                        }));
                        for (let e = 0; e < this.rayCastVehicle.wheelInfos.length; e++) {
                            this.rayCastVehicle.updateWheelTransform(e);
                            let t = this.rayCastVehicle.wheelInfos[e].worldTransform,
                                n = this.wheels[e].wheelObject;
                            n.position.copy(c.threeVector(t.position)), n.quaternion.copy(c.threeQuat(t.quaternion));
                            let i = new r.Vec3;
                            this.rayCastVehicle.getVehicleAxisWorld(this.rayCastVehicle.indexUpAxis, i)
                        }
                    }
                    onInputChange() {
                        this.actions.exitVehicle.justPressed && void 0 !== this.controllingCharacter && this.controllingCharacter.charState.canLeaveVehicles && (this.controllingCharacter.modelContainer.visible = !0, this.controllingCharacter.exitVehicle())
                    }
                    resetControls() {
                        for (const t in this.actions) this.actions.hasOwnProperty(t) && this.triggerAction(t, !1)
                    }
                    allowSleep(t) {
                        this.collision.allowSleep = t, !1 === t && this.collision.wakeUp()
                    }
                    handleKeyboardEvent(t, e, n) {
                        if ("KeyC" === e && !0 === n && !0 === t.shiftKey) this.resetControls(), this.world.cameraOperator.characterCaller = this.controllingCharacter, this.world.inputManager.setInputReceiver(this.world.cameraOperator);
                        else if ("KeyC" === e) this.firstPerson = !0, this.world.cameraOperator.setRadius(0, !0), this.controllingCharacter.modelContainer.visible = !1;
                        else
                            for (const i in this.actions)
                                if (this.actions.hasOwnProperty(i)) {
                                    const t = this.actions[i];
                                    o.includes(t.eventCodes, e) && this.triggerAction(i, n)
                                }
                    }
                    triggerAction(t, e) {
                        let n = this.actions[t];
                        n.isPressed !== e && (n.isPressed = e, n.justPressed = !1, n.justReleased = !1, e ? n.justPressed = !0 : n.justReleased = !0, this.onInputChange(), n.justPressed = !1, n.justReleased = !1)
                    }
                    handleMouseButton(t, e, n) {}
                    handleMouseMove(t, e, n) {
                        this.world.cameraOperator.move(e, n)
                    }
                    handleMouseWheel(t, e) {
                        this.world.scrollTheTimeScale(e)
                    }
                    inputReceiverInit() {
                        this.collision.allowSleep = !1, this.world.cameraOperator.setRadius(3)
                    }
                    inputReceiverUpdate(t) {
                        if (this.firstPerson) {
                            let t = (new i.Vector3).copy(this.camera.position);
                            t.applyQuaternion(this.quaternion), this.world.cameraOperator.target.copy(t.add(this.position))
                        } else this.world.cameraOperator.target.set(this.position.x, this.position.y + .5, this.position.z)
                    }
                    getMountPoint(t) {
                        return this.seats[0].entryPoint.position
                    }
                    setPosition(t, e, n) {
                        this.collision.position.x = t, this.collision.position.y = e, this.collision.position.z = n
                    }
                    setSteeringValue(t) {
                        this.wheels.forEach((e => {
                            e.steering && this.rayCastVehicle.setSteeringValue(t, e.rayCastWheelInfoIndex)
                        }))
                    }
                    applyEngineForce(t) {
                        this.wheels.forEach((e => {
                            this.drive !== e.drive && "awd" !== this.drive || this.rayCastVehicle.applyEngineForce(t, e.rayCastWheelInfoIndex)
                        }))
                    }
                    setBrake(t, e) {
                        this.wheels.forEach((n => {
                            void 0 !== e && e !== n.drive || this.rayCastVehicle.setBrake(t, n.rayCastWheelInfoIndex)
                        }))
                    }
                    addToWorld(t) {
                        o.includes(t.vehicles, this) ? console.warn("Adding character to a world in which it already exists.") : void 0 === this.rayCastVehicle ? console.error("Trying to create vehicle without raycastVehicleComponent") : (this.world = t, t.vehicles.push(this), t.graphicsWorld.add(this), this.rayCastVehicle.addToWorld(t.physicsWorld), this.wheels.forEach((t => {
                            this.world.graphicsWorld.attach(t.wheelObject)
                        })))
                    }
                    removeFromWorld(t) {
                        o.includes(t.vehicles, this) ? (this.world = void 0, o.pull(t.vehicles, this), t.graphicsWorld.remove(this), t.physicsWorld.remove(this.collision)) : console.warn("Removing character from a world in which it isn't present.")
                    }
                    readVehicleData(t) {
                        t.scene.traverse((e => {
                            if (e.isMesh && (c.setupMeshProperties(e), void 0 !== e.material && this.materials.push(e.material)), e.hasOwnProperty("userData") && e.userData.hasOwnProperty("data")) {
                                if ("seat" === e.userData.data) {
                                    let n = new s.VehicleSeat(e);
                                    n.vehicle = this, e.userData.hasOwnProperty("door_object") && (n.door = new l.VehicleDoor(t.scene.getObjectByName(e.userData.door_object))), e.userData.hasOwnProperty("door_side") ? n.doorSide = e.userData.door_side : console.error("Seat object " + e + " has no doorSide property."), e.userData.hasOwnProperty("entry_point") ? n.entryPoint = t.scene.getObjectByName(e.userData.entry_point) : console.error("Seat object " + e + " has no entry point reference property."), e.userData.hasOwnProperty("seat_type") ? n.type = e.userData.seat_type : console.error("Seat object " + e + " has no seat type property."), this.seats.push(n)
                                }
                                if ("camera" === e.userData.data && (this.camera = e), "wheel" === e.userData.data) {
                                    let t = new a.Wheel(e);
                                    t.position = e.position, e.userData.hasOwnProperty("steering") && (t.steering = "true" === e.userData.steering), e.userData.hasOwnProperty("drive") && (t.drive = e.userData.drive), this.wheels.push(t)
                                }
                                if ("collision" === e.userData.data)
                                    if ("box" === e.userData.shape) {
                                        e.visible = !1;
                                        let t = new r.Box(new r.Vec3(e.scale.x, e.scale.y, e.scale.z));
                                        t.collisionFilterMask = ~h.CollisionGroups.TrimeshColliders, this.collision.addShape(t, new r.Vec3(e.position.x, e.position.y, e.position.z))
                                    } else if ("sphere" === e.userData.shape) {
                                    e.visible = !1;
                                    let t = new r.Sphere(e.scale.x);
                                    t.collisionFilterGroup = h.CollisionGroups.TrimeshColliders, this.collision.addShape(t, new r.Vec3(e.position.x, e.position.y, e.position.z))
                                }
                                "navmesh" === e.userData.data && (e.visible = !1)
                            }
                        })), 0 === this.collision.shapes.length && console.warn("Vehicle " + typeof this + " has no collision data."), 0 === this.seats.length && console.warn("Vehicle " + typeof this + " has no seats.")
                    }
                }
                e.Vehicle = u
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                        value: !0
                    }),
                    function(t) {
                        t[t.Default = 1] = "Default", t[t.Characters = 2] = "Characters", t[t.TrimeshColliders = 4] = "TrimeshColliders"
                    }(e.CollisionGroups || (e.CollisionGroups = {}))
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.SimulatorBase = class {
                    constructor(t, e, n) {
                        this.mass = e, this.damping = n, this.frameTime = 1 / t, this.offset = 0
                    }
                    setFPS(t) {
                        this.frameTime = 1 / t
                    }
                    lastFrame() {
                        return this.cache[this.cache.length - 1]
                    }
                    generateFrames(t) {
                        let e = this.offset + t,
                            n = Math.floor(e / this.frameTime);
                        if (this.offset = e % this.frameTime, n > 0) {
                            for (let t = 0; t < n; t++) this.cache.push(this.getFrame(t + 1 === n));
                            this.cache = this.cache.slice(-2)
                        }
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(0),
                    r = n(6);
                class o extends i.Object3D {
                    constructor(t, e) {
                        super(), this.isObject = !0, this.model = t, this.physics = e
                    }
                    update(t) {
                        void 0 !== this.physics.visual && (this.physics.visual.position.copy(this.position), this.physics.visual.quaternion.copy(this.quaternion)), void 0 !== this.model && (this.model.position.copy(this.position), this.model.quaternion.copy(this.quaternion))
                    }
                    setModel(t) {
                        this.model = t
                    }
                    setModelFromPhysicsShape() {
                        this.model = this.physics.getVisualModel({
                            visible: !0,
                            wireframe: !1
                        })
                    }
                    setPhysics(t) {
                        this.physics = t
                    }
                    addToWorld(t) {
                        r.includes(t.objects, this) ? console.warn("Adding object to a world in which it already exists.") : (t.objects.push(this), void 0 !== this.physics.physical && t.physicsWorld.addBody(this.physics.physical), void 0 !== this.physics.visual && t.graphicsWorld.add(this.physics.visual), void 0 !== this.model && t.graphicsWorld.add(this.model))
                    }
                    removeFromWorld(t) {
                        r.includes(t.objects, this) ? (r.pull(t.objects, this), void 0 !== this.physics.physical && t.physicsWorld.remove(this.physics.physical), void 0 !== this.physics.visual && t.graphicsWorld.remove(this.physics.visual), void 0 !== this.model && t.graphicsWorld.remove(this.model)) : console.warn("Removing object from a world in which it isn't present.")
                    }
                }
                e.SBObject = o
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.character.setAnimation("driving", .1)
                    }
                    update(t) {
                        super.update(t)
                    }
                }
                e.Sitting = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.default = {
                    uniforms: {
                        tDiffuse: {
                            value: null
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "\tvUv = uv;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "\tvec4 texel = texture2D( tDiffuse, vUv );", "\tgl_FragColor = opacity * texel;", "}"].join("\n")
                }
            }, function(t, e, n) {
                "use strict";
                t.exports = function(t) {
                    var e = [];
                    return e.toString = function() {
                        return this.map((function(e) {
                            var n = function(t, e) {
                                var n, i, r, o = t[1] || "",
                                    s = t[3];
                                if (!s) return o;
                                if (e && "function" == typeof btoa) {
                                    var a = (n = s, i = btoa(unescape(encodeURIComponent(JSON.stringify(n)))), r = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(i), "/*# ".concat(r, " */")),
                                        l = s.sources.map((function(t) {
                                            return "/*# sourceURL=".concat(s.sourceRoot).concat(t, " */")
                                        }));
                                    return [o].concat(l).concat([a]).join("\n")
                                }
                                return [o].join("\n")
                            }(e, t);
                            return e[2] ? "@media ".concat(e[2], " {").concat(n, "}") : n
                        })).join("")
                    }, e.i = function(t, n) {
                        "string" == typeof t && (t = [
                            [null, t, ""]
                        ]);
                        for (var i = 0; i < t.length; i++) {
                            var r = [].concat(t[i]);
                            n && (r[2] ? r[2] = "".concat(n, " and ").concat(r[2]) : r[2] = n), e.push(r)
                        }
                    }, e
                }
            }, function(t, e, n) {
                "use strict";
                var i, r = {},
                    o = function() {
                        return void 0 === i && (i = Boolean(window && document && document.all && !window.atob)), i
                    },
                    s = function() {
                        var t = {};
                        return function(e) {
                            if (void 0 === t[e]) {
                                var n = document.querySelector(e);
                                if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement) try {
                                    n = n.contentDocument.head
                                } catch (t) {
                                    n = null
                                }
                                t[e] = n
                            }
                            return t[e]
                        }
                    }();

                function a(t, e) {
                    for (var n = [], i = {}, r = 0; r < t.length; r++) {
                        var o = t[r],
                            s = e.base ? o[0] + e.base : o[0],
                            a = {
                                css: o[1],
                                media: o[2],
                                sourceMap: o[3]
                            };
                        i[s] ? i[s].parts.push(a) : n.push(i[s] = {
                            id: s,
                            parts: [a]
                        })
                    }
                    return n
                }

                function l(t, e) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n],
                            o = r[i.id],
                            s = 0;
                        if (o) {
                            for (o.refs++; s < o.parts.length; s++) o.parts[s](i.parts[s]);
                            for (; s < i.parts.length; s++) o.parts.push(g(i.parts[s], e))
                        } else {
                            for (var a = []; s < i.parts.length; s++) a.push(g(i.parts[s], e));
                            r[i.id] = {
                                id: i.id,
                                refs: 1,
                                parts: a
                            }
                        }
                    }
                }

                function c(t) {
                    var e = document.createElement("style");
                    if (void 0 === t.attributes.nonce) {
                        var i = n.nc;
                        i && (t.attributes.nonce = i)
                    }
                    if (Object.keys(t.attributes).forEach((function(n) {
                            e.setAttribute(n, t.attributes[n])
                        })), "function" == typeof t.insert) t.insert(e);
                    else {
                        var r = s(t.insert || "head");
                        if (!r) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                        r.appendChild(e)
                    }
                    return e
                }
                var h, u = (h = [], function(t, e) {
                    return h[t] = e, h.filter(Boolean).join("\n")
                });

                function d(t, e, n, i) {
                    var r = n ? "" : i.css;
                    if (t.styleSheet) t.styleSheet.cssText = u(e, r);
                    else {
                        var o = document.createTextNode(r),
                            s = t.childNodes;
                        s[e] && t.removeChild(s[e]), s.length ? t.insertBefore(o, s[e]) : t.appendChild(o)
                    }
                }

                function p(t, e, n) {
                    var i = n.css,
                        r = n.media,
                        o = n.sourceMap;
                    if (r && t.setAttribute("media", r), o && btoa && (i += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o)))), " */")), t.styleSheet) t.styleSheet.cssText = i;
                    else {
                        for (; t.firstChild;) t.removeChild(t.firstChild);
                        t.appendChild(document.createTextNode(i))
                    }
                }
                var f = null,
                    m = 0;

                function g(t, e) {
                    var n, i, r;
                    if (e.singleton) {
                        var o = m++;
                        n = f || (f = c(e)), i = d.bind(null, n, o, !1), r = d.bind(null, n, o, !0)
                    } else n = c(e), i = p.bind(null, n, e), r = function() {
                        ! function(t) {
                            if (null === t.parentNode) return !1;
                            t.parentNode.removeChild(t)
                        }(n)
                    };
                    return i(t),
                        function(e) {
                            if (e) {
                                if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap) return;
                                i(t = e)
                            } else r()
                        }
                }
                t.exports = function(t, e) {
                    (e = e || {}).attributes = "object" == typeof e.attributes ? e.attributes : {}, e.singleton || "boolean" == typeof e.singleton || (e.singleton = o());
                    var n = a(t, e);
                    return l(n, e),
                        function(t) {
                            for (var i = [], o = 0; o < n.length; o++) {
                                var s = n[o],
                                    c = r[s.id];
                                c && (c.refs--, i.push(c))
                            }
                            t && l(a(t, e), e);
                            for (var h = 0; h < i.length; h++) {
                                var u = i[h];
                                if (0 === u.refs) {
                                    for (var d = 0; d < u.parts.length; d++) u.parts[d]();
                                    delete r[u.id]
                                }
                            }
                        }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(0),
                    r = n(3);
                e.FollowTarget = class {
                    constructor(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1.3;
                        this.target = t, this.stopDistance = e
                    }
                    setTarget(t) {
                        this.target = t
                    }
                    update(t) {
                        if (void 0 !== this.character.controlledObject) {
                            let t = new i.Vector3,
                                e = new i.Vector3;
                            this.character.getWorldPosition(t), this.target.getWorldPosition(e);
                            let n = (new i.Vector3).subVectors(e, t);
                            n.length() > this.stopDistance ? this.isTargetReached = !1 : this.isTargetReached = !0;
                            let o = new i.Vector3(0, 0, 1).applyQuaternion(this.character.controlledObject.quaternion);
                            n.normalize();
                            let s = r.getSignedAngleBetweenVectors(o, n);
                            if (o.dot(n) < 0 ? (this.character.controlledObject.triggerAction("reverse", !0), this.character.controlledObject.triggerAction("throttle", !1)) : (this.character.controlledObject.triggerAction("throttle", !0), this.character.controlledObject.triggerAction("reverse", !1)), Math.abs(s) > .3) {
                                let t = o.dot(r.threeVector(this.character.controlledObject.collision.velocity));
                                o.dot(n) > 0 || t > 0 ? s > 0 ? (this.character.controlledObject.triggerAction("left", !0), this.character.controlledObject.triggerAction("right", !1)) : (this.character.controlledObject.triggerAction("right", !0), this.character.controlledObject.triggerAction("left", !1)) : s > 0 ? (this.character.controlledObject.triggerAction("right", !0), this.character.controlledObject.triggerAction("left", !1)) : (this.character.controlledObject.triggerAction("left", !0), this.character.controlledObject.triggerAction("right", !1))
                            } else this.character.controlledObject.triggerAction("left", !1), this.character.controlledObject.triggerAction("right", !1)
                        } else {
                            let t = (new i.Vector3).subVectors(this.target.position, this.character.position);
                            this.character.setViewVector(t), t.length() > this.stopDistance ? (this.isTargetReached = !1, this.character.triggerAction("up", !0)) : (this.isTargetReached = !0, this.character.triggerAction("up", !1), this.character.setOrientation(t))
                        }
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.SimulationFrame = class {
                    constructor(t, e) {
                        this.position = t, this.velocity = e
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(1),
                    r = n(0),
                    o = n(3);
                e.BoxPhysics = class {
                    constructor(t) {
                        let e = {
                            mass: 0,
                            position: new r.Vector3,
                            size: new r.Vector3(.3, .3, .3),
                            friction: .3
                        };
                        t = o.setDefaults(t, e), this.options = t, t.position = new i.Vec3(t.position.x, t.position.y, t.position.z), t.size = new i.Vec3(t.size.x, t.size.y, t.size.z);
                        let n = new i.Material("boxMat");
                        n.friction = t.friction;
                        let s = new i.Box(t.size),
                            a = new i.Body({
                                mass: t.mass,
                                position: t.position,
                                shape: s
                            });
                        a.material = n, this.physical = a, this.visual = this.getVisualModel({
                            visible: !1,
                            wireframe: !0
                        })
                    }
                    getVisualModel(t) {
                        t = o.setDefaults(t, {
                            visible: !0,
                            wireframe: !0
                        });
                        let e = new r.BoxGeometry(2 * this.options.size.x, 2 * this.options.size.y, 2 * this.options.size.z),
                            n = new r.MeshLambertMaterial({
                                color: 13421772,
                                wireframe: t.wireframe
                            }),
                            i = new r.Mesh(e, n);
                        return i.visible = t.visible, t.wireframe || (i.castShadow = !0, i.receiveShadow = !0), i
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(1),
                    r = n(0),
                    o = n(3);
                e.CapsulePhysics = class {
                    constructor(t) {
                        let e = {
                            mass: 0,
                            position: new i.Vec3,
                            height: .5,
                            radius: .3,
                            segments: 8,
                            friction: .3
                        };
                        t = o.setDefaults(t, e), this.options = t;
                        let n = new i.Material("capsuleMat");
                        n.friction = t.friction;
                        let r = new i.Body({
                                mass: t.mass,
                                position: t.position
                            }),
                            s = new i.Sphere(t.radius);
                        r.material = n, r.addShape(s, new i.Vec3(0, 0, 0)), r.addShape(s, new i.Vec3(0, t.height / 2, 0)), r.addShape(s, new i.Vec3(0, -t.height / 2, 0)), this.physical = r, this.visual = this.getVisualModel({
                            visible: !1,
                            wireframe: !0
                        })
                    }
                    getVisualModel(t) {
                        t = o.setDefaults(t, {
                            visible: !0,
                            wireframe: !0
                        }), new r.MeshLambertMaterial({
                            color: 13421772,
                            wireframe: t.wireframe
                        }), o.createCapsuleGeometry(this.options.radius, this.options.height, this.options.segments);
                        let e = new r.Mesh;
                        return e.visible = t.visible, t.wireframe || (e.castShadow = !0, e.receiveShadow = !0), e
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(1),
                    r = n(0),
                    o = n(9),
                    s = n(3),
                    a = n(93);
                e.TrimeshPhysics = class {
                    constructor(t, e) {
                        this.mesh = t.clone();
                        let n = {
                            mass: 0,
                            position: t.position,
                            friction: .3
                        };
                        e = s.setDefaults(e, n), this.options = e;
                        let r = new i.Material("triMat");
                        r.friction = e.friction, this.mesh.geometry.isBufferGeometry && (this.mesh.geometry = (new o.Geometry).fromBufferGeometry(this.mesh.geometry));
                        let l = a.threeToCannon(this.mesh, {
                                type: a.threeToCannon.Type.MESH
                            }),
                            c = new i.Body({
                                mass: e.mass,
                                position: e.position,
                                shape: l
                            });
                        c.material = r, this.physical = c, this.visual = this.getVisualModel({
                            visible: !1,
                            wireframe: !0
                        })
                    }
                    getVisualModel(t) {
                        t = s.setDefaults(t, {
                            visible: !0,
                            wireframe: !0
                        });
                        let e = new r.MeshLambertMaterial({
                                color: 13421772,
                                wireframe: t.wireframe
                            }),
                            n = this.mesh.clone();
                        return n.material = e, n.visible = t.visible, t.wireframe || (n.castShadow = !0, n.receiveShadow = !0), n
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(1),
                    r = n(10),
                    o = n(5),
                    s = n(27),
                    a = n(0),
                    l = n(3);
                class c extends r.Vehicle {
                    constructor(t) {
                        super(t, {
                            radius: .12,
                            suspensionStiffness: 150,
                            suspensionRestLength: .25,
                            dampingRelaxation: 5,
                            dampingCompression: 5,
                            directionLocal: new i.Vec3(0, -1, 0),
                            axleLocal: new i.Vec3(-1, 0, 0),
                            chassisConnectionPointLocal: new i.Vec3
                        }), this.elevators = [], this.enginePower = 0, this.lastDrag = 0, this.readAirplaneData(t), this.collision.preStep = t => {
                            this.physicsPreStep(t, this)
                        }, this.actions = {
                            throttle: new o.KeyBinding("KeyW"),
                            brake: new o.KeyBinding("KeyS"),
                            wheelBrake: new o.KeyBinding("Space"),
                            pitchUp: new o.KeyBinding("ArrowDown"),
                            pitchDown: new o.KeyBinding("ArrowUp"),
                            yawLeft: new o.KeyBinding("KeyQ"),
                            yawRight: new o.KeyBinding("KeyE"),
                            rollLeft: new o.KeyBinding("ArrowLeft", "KeyA"),
                            rollRight: new o.KeyBinding("ArrowRight", "KeyD"),
                            exitVehicle: new o.KeyBinding("KeyF")
                        }, this.steeringSimulator = new s.SpringSimulator(60, 10, .6), this.aileronSimulator = new s.SpringSimulator(60, 5, .6), this.elevatorSimulator = new s.SpringSimulator(60, 7, .6), this.rudderSimulator = new s.SpringSimulator(60, 10, .6)
                    }
                    update(t) {
                        super.update(t), void 0 !== this.controllingCharacter ? (this.enginePower < 1 && (this.enginePower += .4 * t), this.enginePower > 1 && (this.enginePower = 1)) : (this.enginePower > 0 && (this.enginePower -= .12 * t), this.enginePower < 0 && (this.enginePower = 0)), this.rotor.rotateX(this.enginePower * t * 60), this.rayCastVehicle.numWheelsOnGround > 0 ? !this.actions.yawLeft.isPressed && !this.actions.rollLeft.isPressed || this.actions.yawRight.isPressed || this.actions.rollRight.isPressed ? !this.actions.yawRight.isPressed && !this.actions.rollRight.isPressed || this.actions.yawLeft.isPressed || this.actions.rollLeft.isPressed ? this.steeringSimulator.target = 0 : this.steeringSimulator.target = -.8 : this.steeringSimulator.target = .8 : this.steeringSimulator.target = 0, this.steeringSimulator.simulate(t), this.setSteeringValue(this.steeringSimulator.position), this.actions.rollLeft.isPressed && !this.actions.rollRight.isPressed ? this.aileronSimulator.target = .7 : !this.actions.rollLeft.isPressed && this.actions.rollRight.isPressed ? this.aileronSimulator.target = -.7 : this.aileronSimulator.target = 0, this.actions.pitchUp.isPressed && !this.actions.pitchDown.isPressed ? this.elevatorSimulator.target = .7 : !this.actions.pitchUp.isPressed && this.actions.pitchDown.isPressed ? this.elevatorSimulator.target = -.7 : this.elevatorSimulator.target = 0, this.actions.yawLeft.isPressed && !this.actions.yawRight.isPressed ? this.rudderSimulator.target = .7 : !this.actions.yawLeft.isPressed && this.actions.yawRight.isPressed ? this.rudderSimulator.target = -.7 : this.rudderSimulator.target = 0, this.aileronSimulator.simulate(t), this.elevatorSimulator.simulate(t), this.rudderSimulator.simulate(t), this.leftAileron.rotation.y = this.aileronSimulator.position, this.rightAileron.rotation.y = -this.aileronSimulator.position, this.elevators.forEach((t => {
                            t.rotation.y = this.elevatorSimulator.position
                        })), this.rudder.rotation.y = this.rudderSimulator.position
                    }
                    physicsPreStep(t, e) {
                        let n = new a.Quaternion(t.quaternion.x, t.quaternion.y, t.quaternion.z, t.quaternion.w),
                            r = new a.Vector3(1, 0, 0).applyQuaternion(n),
                            o = new a.Vector3(0, 1, 0).applyQuaternion(n),
                            s = new a.Vector3(0, 0, 1).applyQuaternion(n);
                        const c = (new i.Vec3).copy(this.collision.velocity);
                        let h = t.velocity.length();
                        const u = c.dot(l.cannonVector(s));
                        let d = u / 10;
                        d = a.MathUtils.clamp(d, 0, 1);
                        let p = (u - 7) / 3;
                        p = a.MathUtils.clamp(p, 0, 1), this.collision.mass = 50 * (1 - .8 * p);
                        let f = t.velocity.clone();
                        f.normalize();
                        let m = (new a.Quaternion).setFromUnitVectors(s, l.threeVector(f));
                        m.x *= .3, m.y *= .3, m.z *= .3, m.w *= .3;
                        let g = (new a.Euler).setFromQuaternion(m),
                            v = a.MathUtils.clamp(h - 1, 0, 1);
                        v *= this.rayCastVehicle.numWheelsOnGround > 0 && u < 0 ? 0 : 1;
                        let y = this.actions.throttle.isPressed && u > 0 ? 0 : 1;
                        t.angularVelocity.x += g.x * v * y, t.angularVelocity.y += g.y * v, t.angularVelocity.z += g.z * v * y, e.actions.pitchUp.isPressed && (t.angularVelocity.x -= .05 * r.x * d * this.enginePower, t.angularVelocity.y -= .05 * r.y * d * this.enginePower, t.angularVelocity.z -= .05 * r.z * d * this.enginePower), e.actions.pitchDown.isPressed && (t.angularVelocity.x += .05 * r.x * d * this.enginePower, t.angularVelocity.y += .05 * r.y * d * this.enginePower, t.angularVelocity.z += .05 * r.z * d * this.enginePower), e.actions.yawLeft.isPressed && (t.angularVelocity.x += .02 * o.x * d * this.enginePower, t.angularVelocity.y += .02 * o.y * d * this.enginePower, t.angularVelocity.z += .02 * o.z * d * this.enginePower), e.actions.yawRight.isPressed && (t.angularVelocity.x -= .02 * o.x * d * this.enginePower, t.angularVelocity.y -= .02 * o.y * d * this.enginePower, t.angularVelocity.z -= .02 * o.z * d * this.enginePower), e.actions.rollLeft.isPressed && (t.angularVelocity.x -= .05 * s.x * d * this.enginePower, t.angularVelocity.y -= .05 * s.y * d * this.enginePower, t.angularVelocity.z -= .05 * s.z * d * this.enginePower), e.actions.rollRight.isPressed && (t.angularVelocity.x += .05 * s.x * d * this.enginePower, t.angularVelocity.y += .05 * s.y * d * this.enginePower, t.angularVelocity.z += .05 * s.z * d * this.enginePower);
                        let x = .02;
                        e.actions.throttle.isPressed && !e.actions.brake.isPressed ? x = .05 : !e.actions.throttle.isPressed && e.actions.brake.isPressed ? x = -.05 : this.rayCastVehicle.numWheelsOnGround > 0 && (x = 0), t.velocity.x += (h * this.lastDrag + x) * s.x * this.enginePower, t.velocity.y += (h * this.lastDrag + x) * s.y * this.enginePower, t.velocity.z += (h * this.lastDrag + x) * s.z * this.enginePower;
                        let b = t.velocity.length();
                        const w = .005 * Math.pow(b, 1);
                        t.velocity.x -= t.velocity.x * w, t.velocity.y -= t.velocity.y * w, t.velocity.z -= t.velocity.z * w, this.lastDrag = w;
                        let _ = .01 * Math.pow(b, 1);
                        _ = a.MathUtils.clamp(_, 0, .1), t.velocity.x += o.x * _, t.velocity.y += o.y * _, t.velocity.z += o.z * _, t.angularVelocity.x = a.MathUtils.lerp(t.angularVelocity.x, .98 * t.angularVelocity.x, d), t.angularVelocity.y = a.MathUtils.lerp(t.angularVelocity.y, .98 * t.angularVelocity.y, d), t.angularVelocity.z = a.MathUtils.lerp(t.angularVelocity.z, .98 * t.angularVelocity.z, d)
                    }
                    onInputChange() {
                        super.onInputChange(), this.actions.wheelBrake.justPressed && this.setBrake(1e3), this.actions.wheelBrake.justReleased && this.setBrake(0)
                    }
                    readAirplaneData(t) {
                        t.scene.traverse((t => {
                            t.hasOwnProperty("userData") && t.userData.hasOwnProperty("data") && ("rotor" === t.userData.data && (this.rotor = t), "rudder" === t.userData.data && (this.rudder = t), "elevator" === t.userData.data && this.elevators.push(t), "aileron" === t.userData.data && t.userData.hasOwnProperty("side") && ("left" === t.userData.side ? this.leftAileron = t : "right" === t.userData.side && (this.rightAileron = t)))
                        }))
                    }
                    inputReceiverInit() {
                        super.inputReceiverInit(), this.world.updateControls([{
                            keys: ["W"],
                            desc: "Increase rotor RPM"
                        }, {
                            keys: ["S"],
                            desc: "Decrease rotor RPM"
                        }, {
                            keys: ["\u2191", "\u2193"],
                            desc: "Elevators"
                        }, {
                            keys: ["\u2190", "\u2192", "or", "A", "D"],
                            desc: "Ailerons"
                        }, {
                            keys: ["Q", "E"],
                            desc: "Rudder / Steering"
                        }, {
                            keys: ["Space"],
                            desc: "Brake"
                        }, {
                            keys: ["F"],
                            desc: "Exit vehicle"
                        }])
                    }
                }
                e.Airplane = c
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.VehicleSeat = class {
                    constructor(t) {
                        this.seatPoint = t
                    }
                    update(t) {
                        void 0 !== this.door && this.door.update(t)
                    }
                    isDoorOpen() {
                        return void 0 === this.door || this.door.isOpen()
                    }
                    openDoor() {
                        void 0 !== this.door && this.door.open()
                    }
                    closeDoor() {
                        void 0 !== this.door && this.door.close()
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.Wheel = class {
                    constructor(t) {
                        this.steering = !1, this.wheelObject = t
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(0);
                e.VehicleDoor = class {
                    constructor(t) {
                        this.rotation = 0, this.targetRotation = 0, this.rotationSpeed = 5, this.doorObject = t
                    }
                    update(t) {
                        this.rotation < this.targetRotation ? (this.rotation += t * this.rotationSpeed, this.rotation > this.targetRotation && (this.rotation = this.targetRotation)) : this.rotation > this.targetRotation && (this.rotation -= t * this.rotationSpeed, this.rotation < this.targetRotation && (this.rotation = this.targetRotation));
                        let e = Math.sin(this.rotation * Math.PI * .5) * -Math.PI * .45;
                        this.doorObject.setRotationFromEuler(new i.Euler(0, e, 0))
                    }
                    open() {
                        this.targetRotation = 1
                    }
                    close() {
                        this.targetRotation = 0
                    }
                    isOpen() {
                        return this.rotation > .5
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(0),
                    r = n(12),
                    o = n(19),
                    s = n(3);
                class a extends r.SimulatorBase {
                    constructor(t, e, n) {
                        let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                        super(t, e, n), this.position = i, this.velocity = r, this.target = 0, this.cache = [];
                        for (let s = 0; s < 2; s++) this.cache.push(new o.SimulationFrame(i, r))
                    }
                    simulate(t) {
                        this.generateFrames(t), this.position = i.MathUtils.lerp(this.cache[0].position, this.cache[1].position, this.offset / this.frameTime), this.velocity = i.MathUtils.lerp(this.cache[0].velocity, this.cache[1].velocity, this.offset / this.frameTime)
                    }
                    getFrame(t) {
                        return s.spring(this.lastFrame().position, this.target, this.lastFrame().velocity, this.mass, this.damping)
                    }
                }
                e.SpringSimulator = a
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(1),
                    r = n(10),
                    o = n(5),
                    s = n(0),
                    a = n(3),
                    l = n(27);
                class c extends r.Vehicle {
                    constructor(t) {
                        super(t, {
                            radius: .25,
                            suspensionStiffness: 20,
                            suspensionRestLength: .35,
                            frictionSlip: .8,
                            dampingRelaxation: 2,
                            dampingCompression: 2,
                            rollInfluence: .9
                        }), this.drive = "awd", this.gear = 1, this.timeToShift = .2, this.readCarData(t), this.collision.preStep = t => {
                            this.physicsPreStep(t, this)
                        }, this.actions = {
                            throttle: new o.KeyBinding("KeyW"),
                            reverse: new o.KeyBinding("KeyS"),
                            brake: new o.KeyBinding("Space"),
                            left: new o.KeyBinding("KeyA"),
                            right: new o.KeyBinding("KeyD"),
                            exitVehicle: new o.KeyBinding("KeyF")
                        }, this.steeringSimulator = new l.SpringSimulator(60, 10, .6)
                    }
                    update(t) {
                        super.update(t);
                        let e = new s.Quaternion(this.collision.quaternion.x, this.collision.quaternion.y, this.collision.quaternion.z, this.collision.quaternion.w),
                            n = new s.Vector3(0, 0, 1).applyQuaternion(e);
                        const r = {
                                R: -4,
                                0: 0,
                                1: 5,
                                2: 9,
                                3: 13,
                                4: 17,
                                5: 22
                            },
                            o = (new i.Vec3).copy(this.collision.velocity),
                            l = o.dot(a.cannonVector(n));
                        o.normalize();
                        let c = a.getSignedAngleBetweenVectors(a.threeVector(o), n);
                        if (this.shiftTimer > 0) this.shiftTimer -= t, this.shiftTimer < 0 && (this.shiftTimer = 0);
                        else if (this.actions.reverse.isPressed) {
                            const t = (r.R - l) / Math.abs(r.R),
                                e = 500 / this.gear * Math.pow(Math.abs(t), 1);
                            this.applyEngineForce(e)
                        } else {
                            const t = (r[this.gear] - l) / (r[this.gear] - r[this.gear - 1]);
                            if (t < .1 && this.gear < 5) this.shiftUp();
                            else if (this.gear > 1 && t > 1.2) this.shiftDown();
                            else if (this.actions.throttle.isPressed) {
                                const e = 500 / this.gear * Math.pow(t, 1);
                                this.applyEngineForce(-e)
                            }
                        }
                        let h = s.MathUtils.clamp(.3 * l, 1, Number.MAX_VALUE);
                        if (this.actions.right.isPressed) {
                            let t = Math.min(-.8 / h, -c);
                            this.steeringSimulator.target = s.MathUtils.clamp(t, -.8, .8)
                        } else if (this.actions.left.isPressed) {
                            let t = Math.max(.8 / h, -c);
                            this.steeringSimulator.target = s.MathUtils.clamp(t, -.8, .8)
                        } else this.steeringSimulator.target = 0;
                        this.steeringSimulator.simulate(t), this.setSteeringValue(this.steeringSimulator.position), this.steeringWheel.rotation.z = 2 * -this.steeringSimulator.position, this.rayCastVehicle.numWheelsOnGround < 3 && Math.abs(this.collision.velocity.length()) < .1 && this.collision.quaternion.copy(this.collision.initQuaternion)
                    }
                    shiftUp() {
                        this.gear++, this.shiftTimer = this.timeToShift, this.applyEngineForce(0)
                    }
                    shiftDown() {
                        this.gear--, this.shiftTimer = this.timeToShift, this.applyEngineForce(0)
                    }
                    physicsPreStep(t, e) {
                        let n = new s.Quaternion(t.quaternion.x, t.quaternion.y, t.quaternion.z, t.quaternion.w);
                        new s.Vector3(0, 0, 1).applyQuaternion(n), this.rayCastVehicle.numWheelsOnGround
                    }
                    onInputChange() {
                        super.onInputChange(), (this.actions.throttle.justReleased || this.actions.reverse.justReleased) && this.applyEngineForce(0), this.actions.brake.justPressed && this.setBrake(1e6, "rwd"), this.actions.brake.justReleased && this.setBrake(0, "rwd")
                    }
                    inputReceiverInit() {
                        super.inputReceiverInit(), this.world.updateControls([{
                            keys: ["W"],
                            desc: "Throttle"
                        }, {
                            keys: ["S"],
                            desc: "Brake / Reverse"
                        }, {
                            keys: ["A", "D"],
                            desc: "Steering"
                        }, {
                            keys: ["Space"],
                            desc: "Handbrake"
                        }, {
                            keys: ["F"],
                            desc: "Exit vehicle"
                        }])
                    }
                    readCarData(t) {
                        t.scene.traverse((t => {
                            t.hasOwnProperty("userData") && t.userData.hasOwnProperty("data") && "steering_wheel" === t.userData.data && (this.steeringWheel = t)
                        }))
                    }
                }
                e.Car = c
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(1),
                    r = n(3),
                    o = n(10),
                    s = n(5),
                    a = n(0);
                class l extends o.Vehicle {
                    constructor(t) {
                        super(t), this.rotors = [], this.enginePower = 0, this.readHelicopterData(t), this.collision.preStep = t => {
                            this.physicsPreStep(t, this)
                        }, this.actions = {
                            ascend: new s.KeyBinding("KeyW"),
                            descend: new s.KeyBinding("KeyS"),
                            pitchUp: new s.KeyBinding("ArrowDown"),
                            pitchDown: new s.KeyBinding("ArrowUp"),
                            yawLeft: new s.KeyBinding("KeyQ"),
                            yawRight: new s.KeyBinding("KeyE"),
                            rollLeft: new s.KeyBinding("ArrowLeft", "KeyA"),
                            rollRight: new s.KeyBinding("ArrowRight", "KeyD"),
                            exitVehicle: new s.KeyBinding("KeyF")
                        }
                    }
                    update(t) {
                        super.update(t), void 0 !== this.controllingCharacter ? (this.enginePower < 1 && (this.enginePower += .2 * t), this.enginePower > 1 && (this.enginePower = 1)) : (this.enginePower > 0 && (this.enginePower -= .06 * t), this.enginePower < 0 && (this.enginePower = 0)), this.rotors.forEach((e => {
                            e.rotateX(this.enginePower * t * 30)
                        }))
                    }
                    physicsPreStep(t, e) {
                        let n = new a.Quaternion(t.quaternion.x, t.quaternion.y, t.quaternion.z, t.quaternion.w),
                            o = new a.Vector3(1, 0, 0).applyQuaternion(n),
                            s = new a.Vector3(0, 1, 0),
                            l = new a.Vector3(0, 1, 0).applyQuaternion(n),
                            c = new a.Vector3(0, 0, 1).applyQuaternion(n);
                        e.actions.ascend.isPressed && (t.velocity.x += .15 * l.x * this.enginePower, t.velocity.y += .15 * l.y * this.enginePower, t.velocity.z += .15 * l.z * this.enginePower), e.actions.descend.isPressed && (t.velocity.x -= .15 * l.x * this.enginePower, t.velocity.y -= .15 * l.y * this.enginePower, t.velocity.z -= .15 * l.z * this.enginePower);
                        let h = e.world.physicsWorld.gravity,
                            u = new i.Vec3(-h.x, -h.y, -h.z).length();
                        u *= e.world.physicsFrameTime, u *= .98;
                        let d = s.dot(l);
                        u *= Math.sqrt(a.MathUtils.clamp(d, 0, 1));
                        let p = r.threeVector(t.velocity);
                        p.x *= l.x, p.y *= l.y, p.z *= l.z, p.multiplyScalar(-.01);
                        let f = l.clone();
                        if (f.multiplyScalar(u), f.multiplyScalar(Math.pow(e.enginePower, 3)), f.add(p), t.velocity.x += f.x, t.velocity.y += f.y, t.velocity.z += f.z, t.velocity.x *= .99, t.velocity.z *= .99, void 0 !== this.controllingCharacter) {
                            let e = (new a.Quaternion).setFromUnitVectors(l, s);
                            e.x *= .3, e.y *= .3, e.z *= .3, e.w *= .3;
                            let n = (new a.Euler).setFromQuaternion(e);
                            t.angularVelocity.x += n.x, t.angularVelocity.y += n.y, t.angularVelocity.z += n.z
                        }
                        e.actions.pitchUp.isPressed && (t.angularVelocity.x -= .1 * o.x * this.enginePower, t.angularVelocity.y -= .1 * o.y * this.enginePower, t.angularVelocity.z -= .1 * o.z * this.enginePower), e.actions.pitchDown.isPressed && (t.angularVelocity.x += .1 * o.x * this.enginePower, t.angularVelocity.y += .1 * o.y * this.enginePower, t.angularVelocity.z += .1 * o.z * this.enginePower), e.actions.yawLeft.isPressed && (t.angularVelocity.x += .1 * l.x * this.enginePower, t.angularVelocity.y += .1 * l.y * this.enginePower, t.angularVelocity.z += .1 * l.z * this.enginePower), e.actions.yawRight.isPressed && (t.angularVelocity.x -= .1 * l.x * this.enginePower, t.angularVelocity.y -= .1 * l.y * this.enginePower, t.angularVelocity.z -= .1 * l.z * this.enginePower), e.actions.rollLeft.isPressed && (t.angularVelocity.x -= .1 * c.x * this.enginePower, t.angularVelocity.y -= .1 * c.y * this.enginePower, t.angularVelocity.z -= .1 * c.z * this.enginePower), e.actions.rollRight.isPressed && (t.angularVelocity.x += .1 * c.x * this.enginePower, t.angularVelocity.y += .1 * c.y * this.enginePower, t.angularVelocity.z += .1 * c.z * this.enginePower), t.angularVelocity.x *= .97, t.angularVelocity.y *= .97, t.angularVelocity.z *= .97
                    }
                    readHelicopterData(t) {
                        t.scene.traverse((t => {
                            t.hasOwnProperty("userData") && t.userData.hasOwnProperty("data") && "rotor" === t.userData.data && this.rotors.push(t)
                        }))
                    }
                    inputReceiverInit() {
                        super.inputReceiverInit(), this.world.updateControls([{
                            keys: ["W"],
                            desc: "Ascend"
                        }, {
                            keys: ["S"],
                            desc: "Descend"
                        }, {
                            keys: ["\u2191", "\u2193"],
                            desc: "Pitch"
                        }, {
                            keys: ["\u2190", "\u2192", "or", "A", "D"],
                            desc: "Roll"
                        }, {
                            keys: ["Q", "E"],
                            desc: "Yaw"
                        }, {
                            keys: ["F"],
                            desc: "Exit vehicle"
                        }])
                    }
                }
                e.Helicopter = l
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.isDancing = !1, this.character.velocitySimulator.damping = .6, this.character.velocitySimulator.mass = 10, this.character.setArcadeVelocityTarget(0), this.character.setAnimation("Dance", .1), this.isDancing = !0
                    }
                    update(t) {
                        super.update(t), this.fallInAir()
                    }
                    onInputChange() {
                        super.onInputChange(), this.character.actions.jump.justPressed && this.character.setState(new i.JumpIdle(this.character)), this.anyDirection() && !this.character.actions.dance.justPressed && (this.character.velocity.length() > .5 ? this.character.setState(new i.Walk(this.character)) : this.setAppropriateStartWalkState())
                    }
                }
                e.Dance = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(0),
                    r = n(1),
                    o = n(6),
                    s = n(3),
                    a = n(5),
                    l = n(13),
                    c = n(68),
                    h = n(70),
                    u = n(7),
                    d = n(21),
                    p = n(32),
                    f = n(72),
                    m = n(74),
                    g = n(14),
                    v = n(11),
                    y = n(0),
                    x = n(75),
                    b = n(33);
                class w extends i.Object3D {
                    constructor(t, e) {
                        super(), this.isCharacter = !0, this.height = 0, this.materials = [], this.acceleration = new i.Vector3, this.velocity = new i.Vector3, this.arcadeVelocityInfluence = new i.Vector3, this.velocityTarget = new i.Vector3, this.arcadeVelocityIsAdditive = !1, this.defaultVelocitySimulatorDamping = .8, this.defaultVelocitySimulatorMass = 50, this.moveSpeed = 4, this.angularVelocity = 0, this.orientation = new i.Vector3(0, 0, 1), this.orientationTarget = new i.Vector3(0, 0, 1), this.defaultRotationSimulatorDamping = .5, this.defaultRotationSimulatorMass = 6, this.rayResult = new r.RaycastResult, this.rayHasHit = !1, this.rayCastLength = .6, this.raySafeOffset = .03, this.wantsToJump = !1, this.initJumpSpeed = -1, this.groundImpactData = new s.GroundImpactData, this.jumpInitialLift = 6, this.jumpNuanceFallAcceleration = .2, this.jumpNuanceRiseDeceleration = .15, this.jumpNuanceFallVelocityMax = -10, this.isRunningTowardsVehicle = !1, this.physicsEnabled = !0, this.serverPosition = new i.Vector3(0, 0, 0), this.isFlaggedForReset = !1, this.namePlatePositionY = 0, this.videoSessionId = "", this.bodyColor = {
                            r: 1,
                            g: 1,
                            b: 1
                        }, this.faceString = "", this.joystickEnabled = !1, this.joystickAngle = 0, this.isServerDriven = !1, this.sendCharAnimationStateCommand = null, this.previousAction = null, this.isServerDriven = e || !1, this.readCharacterData(t), this.setAnimations(t.animations), this.help1 = new i.AxesHelper(1), this.help2 = new i.AxesHelper(2), this.help3 = new i.AxesHelper(3), this.tiltContainer = new i.Group, this.add(this.tiltContainer), this.modelContainer = new i.Group, this.modelContainer.position.y = -.57, this.tiltContainer.add(this.modelContainer), this.modelContainer.add(t.scene), this.model = t.scene, this.mixer = new i.AnimationMixer(t.scene), this.setupNameplate(), this.velocitySimulator = new c.VectorSpringSimulator(60, this.defaultVelocitySimulatorMass, this.defaultVelocitySimulatorDamping), this.rotationSimulator = new h.RelativeSpringSimulator(60, this.defaultRotationSimulatorMass, this.defaultRotationSimulatorDamping), this.viewVector = new i.Vector3, this.actions = {
                            up: new a.KeyBinding("KeyW"),
                            down: new a.KeyBinding("KeyS"),
                            left: new a.KeyBinding("KeyA"),
                            right: new a.KeyBinding("KeyD"),
                            run: new a.KeyBinding("ShiftLeft"),
                            jump: new a.KeyBinding("Space"),
                            use: new a.KeyBinding("KeyE"),
                            enter: new a.KeyBinding("KeyZ"),
                            primary: new a.KeyBinding("Mouse0"),
                            secondary: new a.KeyBinding("Mouse1"),
                            hideChar: new a.KeyBinding("KeyV"),
                            chat: new a.KeyBinding("Enter"),
                            dance: new a.KeyBinding("KeyF")
                        };
                        let n = new d.CapsulePhysics({
                            mass: 1,
                            position: new r.Vec3,
                            height: .5,
                            radius: .25,
                            segments: 8,
                            friction: 0
                        });
                        n.physical.shapes.forEach((t => {
                            t.collisionFilterMask = ~v.CollisionGroups.TrimeshColliders
                        })), n.physical.allowSleep = !1, this.characterCapsule = new l.SBObject, this.characterCapsule.setPhysics(n), this.characterCapsule.physics.physical.collisionFilterGroup = 2, this.characterCapsule.physics.physical.fixedRotation = !0, this.characterCapsule.physics.physical.updateMassProperties();
                        const o = new i.BoxGeometry(.1, .1, .1),
                            p = new i.MeshLambertMaterial({
                                color: 16711680
                            });
                        this.raycastBox = new i.Mesh(o, p), this.raycastBox.visible = !1, this.characterCapsule.physics.physical.preStep = t => {
                            this.physicsPreStep(t, this)
                        }, this.characterCapsule.physics.physical.postStep = t => {
                            this.physicsPostStep(t, this)
                        }, this.isServerDriven ? this.physicsEnabled = !1 : this.setState(new u.Idle(this))
                    }
                    removeHat() {
                        this.hat && b.disposeObject(this.hat), this.nameObject.position.y = this.namePlatePositionY
                    }
                    changeHat(t) {
                        this.removeHat();
                        let e = x.find((e => e.id === t));
                        e && this.world && this.world.loadingManager.loadGLTF(e.url, (t => {
                            this.model.traverse((n => {
                                "hat_placeholder" === n.name && (this.hat = t.scene, n.add(t.scene), t.scene.scale.multiplyScalar(e.scaleFactor), t.scene.position.x += e.positionOffset.x, t.scene.position.y += e.positionOffset.y, t.scene.position.z += e.positionOffset.z, this.nameObject.position.y = this.nameObject.position.y + .5)
                            }))
                        }))
                    }
                    setupNameplate() {
                        let t = document.createElement("canvas");
                        t.width = 256, t.height = 256, this.namePlateContext = t.getContext("2d");
                        let e = new y.CanvasTexture(t);
                        this.nameTexture = e;
                        var n = new i.SpriteMaterial({
                                map: e,
                                transparent: !0,
                                depthWrite: !1
                            }),
                            r = new i.Sprite(n);
                        r.renderOrder = 1, this.nameObject = r, this.modelContainer.add(r), r.position.y += 1.2, r.position.z += .2, this.namePlatePositionY = r.position.y
                    }
                    changeName(t) {
                        if (!this.namePlateContext || !this.nameTexture) return;
                        let e = this.namePlateContext;
                        e.clearRect(0, 0, 256, 256), e.fillStyle = "white", e.font = "20px Roboto", e.textAlign = "center", e.textBaseline = "middle", e.fillText(t, 128, 150), this.nameTexture.needsUpdate = !0
                    }
                    changeCharacterColor(t, e, n) {
                        this.bodyColor = {
                            r: t,
                            g: e,
                            b: n
                        }, this.applyCharacterColor()
                    }
                    applyCharacterColor() {
                        this.baseMaterial && this.baseMaterial.color.setRGB(this.bodyColor.r, this.bodyColor.g, this.bodyColor.b)
                    }
                    changeCharacterFace(t, e) {
                        console.log("changeCharacterFace", t, e), this.lastFaceUsed = t, this.lastFaceColorUsed = e, this.model.traverse((n => {
                            if (n.material && "Face" === n.material.name) {
                                let i = this.faceCanvas;
                                i || (this.faceCanvas = document.createElement("canvas"), i = this.faceCanvas), i.width = 256, i.height = 256;
                                let r = i.getContext("2d");
                                if (!r) return;
                                r.fillStyle = "rgb(".concat(Math.floor(255 * e.r), ", ").concat(Math.floor(255 * e.g), ", ").concat(Math.floor(255 * e.b), ")"), r.fillRect(0, 0, 256, 256), r.font = "180px Georgia", r.textAlign = "center", r.textBaseline = "middle", r.fillText(t, 128, 150);
                                let o = new y.CanvasTexture(i);
                                console.log("texture", o), n.material.map = o
                            }
                        }))
                    }
                    changeCharacterSkin(t) {
                        this.world.loadingManager.loadGLTF(t, (t => {
                            this.loadGLTF(t)
                        }))
                    }
                    loadGLTF(t) {
                        b.disposeObject(this.model), this.materials = [], this.model = null, this.readCharacterData(t), this.setAnimations(t.animations), this.model = t.scene, this.modelContainer.add(this.model), this.mixer = new i.AnimationMixer(t.scene), this.setState(new u.Idle(this)), this.changeCharacterFace(this.lastFaceUsed, this.lastFaceColorUsed)
                    }
                    setAudioChatElement(t) {
                        this.audioChatElement = t
                    }
                    setVideoTexture(t) {
                        let e = () => {
                            let e = new y.VideoTexture(t),
                                n = t.videoWidth / t.videoHeight;
                            this.videoSprite && this.nameObject.remove(this.videoSprite);
                            const r = new i.SpriteMaterial({
                                    map: e,
                                    transparent: !0
                                }),
                                o = new i.Sprite(r);
                            this.videoSprite = o, this.nameObject.add(this.videoSprite), this.videoSprite.visible = !0, this.videoSprite.material.depthTest = !1, this.videoSprite.renderOrder = 1, this.videoSprite.position.x = 0, this.videoSprite.position.y = .25, this.videoSprite.position.z = 0, this.videoSprite.scale.multiplyScalar(.5), this.videoSprite.scale.x *= n
                        };
                        t.videoHeight > 0 ? e() : t.onplay = () => {
                            e()
                        }
                    }
                    setVideoTextureFromMap() {
                        if (this.videoSessionId && this.world) {
                            let t = this.world.videoMap.get(this.videoSessionId);
                            t && this.setVideoTexture(t)
                        }
                    }
                    setAnimations(t) {
                        this.animations = t
                    }
                    setArcadeVelocityInfluence(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t;
                        this.arcadeVelocityInfluence.set(t, e, n)
                    }
                    setViewVector(t) {
                        this.viewVector.copy(t).normalize()
                    }
                    setState(t) {
                        this.charState = t, this.charState.onInputChange()
                    }
                    setPosition(t, e, n) {
                        this.physicsEnabled ? (this.characterCapsule.physics.physical.position = new r.Vec3(t, e, n), this.characterCapsule.physics.physical.interpolatedPosition = new r.Vec3(t, e, n)) : (this.position.x = t, this.position.y = e, this.position.z = n)
                    }
                    resetVelocity() {
                        this.velocity.x = 0, this.velocity.y = 0, this.velocity.z = 0, this.characterCapsule.physics.physical.velocity.x = 0, this.characterCapsule.physics.physical.velocity.y = 0, this.characterCapsule.physics.physical.velocity.z = 0, this.velocitySimulator.init()
                    }
                    setArcadeVelocityTarget(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        this.velocityTarget.z = t, this.velocityTarget.x = e, this.velocityTarget.y = n
                    }
                    setOrientation(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            n = (new i.Vector3).copy(t).setY(0).normalize();
                        this.orientationTarget.copy(n), e && this.orientation.copy(n)
                    }
                    resetOrientation() {
                        const t = this.matrix.elements;
                        let e = new i.Vector3(t[8], t[9], t[10]);
                        this.setOrientation(e, !0)
                    }
                    setBehaviour(t) {
                        t.character = this, this.behaviour = t
                    }
                    setPhysicsEnabled(t) {
                        this.physicsEnabled = t, !0 === t ? this.world.physicsWorld.addBody(this.characterCapsule.physics.physical) : this.world.physicsWorld.remove(this.characterCapsule.physics.physical)
                    }
                    readCharacterData(t) {
                        t.scene.traverse((t => {
                            t.isMesh && (void 0 !== t.material && this.materials.push(t.material), "Boxman" === t.material.name && (this.baseMaterial = t.material, this.applyCharacterColor()))
                        }))
                    }
                    handleKeyboardEvent(t, e, n) {
                        if (void 0 !== this.controlledObject) this.controlledObject.handleKeyboardEvent(t, e, n);
                        else if ("KeyC" === e && !0 === n && !0 === t.shiftKey);
                        else
                            for (const i in this.actions)
                                if (this.actions.hasOwnProperty(i)) {
                                    const t = this.actions[i];
                                    o.includes(t.eventCodes, e) && this.triggerAction(i, n)
                                }
                    }
                    handleMouseButton(t, e, n) {
                        if (void 0 !== this.controlledObject) this.controlledObject.handleMouseButton(t, e, n);
                        else
                            for (const i in this.actions)
                                if (this.actions.hasOwnProperty(i)) {
                                    const t = this.actions[i];
                                    o.includes(t.eventCodes, e) && this.triggerAction(i, n)
                                }
                    }
                    handleMouseMove(t, e, n) {
                        void 0 !== this.controlledObject ? this.controlledObject.handleMouseMove(t, e, n) : this.world.cameraOperator.move(e, n)
                    }
                    handleMouseWheel(t, e) {
                        void 0 !== this.controlledObject ? this.controlledObject.handleMouseWheel(t, e) : this.world.scrollTheTimeScale(e)
                    }
                    getActionMap() {
                        return {
                            up: this.actions.up.isPressed,
                            left: this.actions.left.isPressed,
                            right: this.actions.right.isPressed,
                            down: this.actions.down.isPressed,
                            run: this.actions.run.isPressed,
                            jump: this.actions.jump.isPressed,
                            dance: this.actions.dance.isPressed
                        }
                    }
                    triggerAction(t, e) {
                        let n = this.actions[t];
                        n.isPressed !== e && (n.isPressed = e, n.justPressed = !1, n.justReleased = !1, e ? n.justPressed = !0 : n.justReleased = !0, this.processDJ3DAction(), this.charState.onInputChange(), n.justPressed = !1, n.justReleased = !1)
                    }
                    processDJ3DAction() {
                        if (this.actions.hideChar.justReleased && (this.modelContainer.visible = !this.modelContainer.visible), this.actions.chat.justReleased) {
                            let t = document.getElementById("chatInput");
                            t && t.focus()
                        }
                    }
                    takeControl() {
                        void 0 !== this.world ? this.world.inputManager.setInputReceiver(this) : console.warn("Attempting to take control of a character that doesn't belong to a world.")
                    }
                    resetControls() {
                        for (const t in this.actions) this.actions.hasOwnProperty(t) && this.triggerAction(t, !1)
                    }
                    update(t) {
                        if (void 0 !== this.behaviour && this.behaviour.update(t), !0 === this.isRunningTowardsVehicle) {
                            let t = new i.Vector3;
                            this.targetSeat.entryPoint.getWorldPosition(t);
                            let e = (new i.Vector3).subVectors(t, this.position);
                            this.setOrientation(e);
                            let n = e.y;
                            e.y = 0, this.charState.canEnterVehicles && e.length() < .2 && n < 2 && this.enterVehicle(this.targetSeat)
                        }
                        if (void 0 !== this.charState && this.charState.update(t), this.physicsEnabled && this.springMovement(t), this.physicsEnabled && this.springRotation(t), this.physicsEnabled && this.rotateModel(), void 0 !== this.mixer && this.mixer.update(t), this.physicsEnabled) this.position.set(this.characterCapsule.physics.physical.interpolatedPosition.x, this.characterCapsule.physics.physical.interpolatedPosition.y, this.characterCapsule.physics.physical.interpolatedPosition.z);
                        else {
                            let t = new i.Vector3;
                            this.getWorldPosition(t), this.characterCapsule.physics.physical.position.copy(s.cannonVector(t)), this.characterCapsule.physics.physical.interpolatedPosition.copy(s.cannonVector(t))
                        }
                        this.help1.position.copy(this.position), this.help1.quaternion.copy(this.quaternion), this.modelContainer.getWorldPosition(this.help2.position), this.modelContainer.getWorldQuaternion(this.help2.quaternion), this.tiltContainer.getWorldPosition(this.help3.position), this.tiltContainer.getWorldQuaternion(this.help3.quaternion)
                    }
                    inputReceiverInit() {
                        void 0 === this.controlledObject ? (this.world.cameraOperator.setRadius(4, !0), this.world.cameraOperator.followMode = !1) : this.controlledObject.inputReceiverInit()
                    }
                    inputReceiverUpdate(t) {
                        if (void 0 !== this.controlledObject) this.controlledObject.inputReceiverUpdate(t);
                        else {
                            this.viewVector = (new i.Vector3).subVectors(this.position, this.world.camera.position);
                            let t = new i.Vector3;
                            this.getWorldPosition(t), this.getWorldPosition(this.world.cameraOperator.target)
                        }
                    }
                    setAnimation(t, e) {
                        if (!this.isServerDriven && this.sendCharAnimationStateCommand && this.sendCharAnimationStateCommand(t, e), void 0 !== this.mixer) {
                            let n = i.AnimationClip.findByName(this.animations, t);
                            if (!n) return;
                            let r = this.mixer.clipAction(n);
                            return this.previousAction && (this.previousAction.paused = !0, this.previousAction.crossFadeTo(r, e, !1)), this.previousAction = r, r.reset().play(), r._clip.duration
                        }
                    }
                    springMovement(t) {
                        this.velocitySimulator.target.copy(this.velocityTarget), this.velocitySimulator.simulate(t), this.velocity.copy(this.velocitySimulator.position), this.acceleration.copy(this.velocitySimulator.velocity)
                    }
                    springRotation(t) {
                        let e = s.getSignedAngleBetweenVectors(this.orientation, this.orientationTarget);
                        this.rotationSimulator.target = e, this.rotationSimulator.simulate(t);
                        let n = this.rotationSimulator.position;
                        this.orientation.applyAxisAngle(new i.Vector3(0, 1, 0), n), this.angularVelocity = this.rotationSimulator.velocity
                    }
                    enableJoystick() {
                        this.joystickEnabled = !0
                    }
                    disableJoystick() {
                        this.joystickEnabled = !1
                    }
                    sendJoystickAngle(t) {
                        this.joystickAngle = t
                    }
                    getLocalMovementDirection() {
                        if (this.joystickEnabled) return new i.Vector3(-Math.cos(this.joystickAngle), 0, Math.sin(this.joystickAngle)).normalize();
                        const t = this.actions.right.isPressed ? -1 : 0,
                            e = this.actions.left.isPressed ? 1 : 0,
                            n = this.actions.up.isPressed ? 1 : 0,
                            r = this.actions.down.isPressed ? -1 : 0;
                        return new i.Vector3(t + e, 0, n + r).normalize()
                    }
                    getCameraRelativeMovementVector() {
                        const t = this.getLocalMovementDirection(),
                            e = new i.Vector3(this.viewVector.x, 0, this.viewVector.z).normalize();
                        return s.appplyVectorMatrixXZ(e, t)
                    }
                    setCameraRelativeOrientationTarget() {
                        if (!1 === this.isRunningTowardsVehicle) {
                            let t = this.getCameraRelativeMovementVector();
                            0 === t.x && 0 === t.y && 0 === t.z ? this.setOrientation(this.orientation) : this.setOrientation(t)
                        }
                    }
                    rotateModel() {
                        this.lookAt(this.position.x + this.orientation.x, this.position.y + this.orientation.y, this.position.z + this.orientation.z), this.tiltContainer.rotation.z = 2.3 * -this.angularVelocity * this.velocity.length(), this.tiltContainer.position.setY(Math.cos(Math.abs(2.3 * this.angularVelocity * this.velocity.length())) / 2 - .5)
                    }
                    jump() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1;
                        this.wantsToJump = !0, this.initJumpSpeed = t
                    }
                    findVehicleToEnter() {
                        let t, e = Number.POSITIVE_INFINITY;
                        this.world.vehicles.forEach((n => {
                            let r = (new i.Vector3).subVectors(this.position, n.position).lengthSq();
                            r < 10 && r < e && (t = n)
                        })), void 0 !== t ? (this.isRunningTowardsVehicle = !0, this.targetSeat = t.seats[0], this.triggerAction("up", !0)) : console.error("World has no vehicles")
                    }
                    enterVehicle(t) {
                        this.resetControls(), t.isDoorOpen() ? this.setState(new p.EnteringVehicle(this, this.targetSeat)) : this.setState(new m.OpenVehicleDoor(this, t)), this.isRunningTowardsVehicle = !1, this.targetSeat = void 0
                    }
                    teleportToVehicle(t, e) {
                        this.resetVelocity(), this.rotateModel(), this.setPhysicsEnabled(!1), t.attach(this), this.setPosition(e.seatPoint.position.x, e.seatPoint.position.y + .6, e.seatPoint.position.z), this.quaternion.copy(e.seatPoint.quaternion), this.setState(new g.Sitting(this))
                    }
                    startControllingVehicle(t, e) {
                        this.controlledObject = t, this.controlledObject.allowSleep(!1), t.inputReceiverInit(), this.controlledObjectSeat = e, t.controllingCharacter = this
                    }
                    exitVehicle() {
                        this.setState(new f.ExitingVehicle(this, this.controlledObject, this.controlledObjectSeat)), this.controlledObject.allowSleep(!0), this.controlledObject.controllingCharacter = void 0, this.controlledObject.resetControls(), this.controlledObject = void 0, this.inputReceiverInit()
                    }
                    physicsPreStep(t, e) {
                        const n = new r.Vec3(t.position.x, t.position.y, t.position.z),
                            i = new r.Vec3(t.position.x, t.position.y - e.rayCastLength - e.raySafeOffset, t.position.z),
                            o = {
                                collisionFilterMask: v.CollisionGroups.Default,
                                skipBackfaces: !0
                            };
                        e.rayHasHit = e.world.physicsWorld.raycastClosest(n, i, o, e.rayResult), e.rayHasHit ? e.raycastBox.visible && (e.raycastBox.position.x = e.rayResult.hitPointWorld.x, e.raycastBox.position.y = e.rayResult.hitPointWorld.y, e.raycastBox.position.z = e.rayResult.hitPointWorld.z) : e.raycastBox.visible && e.raycastBox.position.set(t.position.x, t.position.y - e.rayCastLength - e.raySafeOffset, t.position.z)
                    }
                    physicsPostStep(t, e) {
                        let n = new i.Vector3(t.velocity.x, t.velocity.y, t.velocity.z),
                            r = (new i.Vector3).copy(e.velocity).multiplyScalar(e.moveSpeed);
                        r = s.appplyVectorMatrixXZ(e.orientation, r);
                        let o = new i.Vector3;
                        if (e.arcadeVelocityIsAdditive) {
                            o.copy(n);
                            let t = s.appplyVectorMatrixXZ(e.orientation, e.velocityTarget),
                                a = (new i.Vector3).copy(r).multiply(e.arcadeVelocityInfluence);
                            (Math.abs(n.x) < Math.abs(t.x * e.moveSpeed) || s.haveDifferentSigns(n.x, r.x)) && (o.x += a.x), (Math.abs(n.y) < Math.abs(t.y * e.moveSpeed) || s.haveDifferentSigns(n.y, r.y)) && (o.y += a.y), (Math.abs(n.z) < Math.abs(t.z * e.moveSpeed) || s.haveDifferentSigns(n.z, r.z)) && (o.z += a.z)
                        } else o = new i.Vector3(i.MathUtils.lerp(n.x, r.x, e.arcadeVelocityInfluence.x), i.MathUtils.lerp(n.y, r.y, e.arcadeVelocityInfluence.y), i.MathUtils.lerp(n.z, r.z, e.arcadeVelocityInfluence.z));
                        if (e.rayHasHit) {
                            o.y = 0;
                            let n = new i.Vector3(0, 1, 0),
                                r = new i.Vector3(e.rayResult.hitNormalWorld.x, e.rayResult.hitNormalWorld.y, e.rayResult.hitNormalWorld.z),
                                s = (new i.Quaternion).setFromUnitVectors(n, r),
                                a = (new i.Matrix4).makeRotationFromQuaternion(s);
                            o.applyMatrix4(a), t.velocity.x = o.x, t.velocity.y = o.y, t.velocity.z = o.z, t.position.y = e.rayResult.hitPointWorld.y + e.rayCastLength + o.y / e.world.physicsFrameRate
                        } else t.velocity.x = o.x, t.velocity.y = o.y, t.velocity.z = o.z, e.groundImpactData.velocity.x = t.velocity.x, e.groundImpactData.velocity.y = t.velocity.y, e.groundImpactData.velocity.z = t.velocity.z;
                        e.wantsToJump && (e.initJumpSpeed > -1 && (t.velocity.y = 0, t.velocity.lengthSquared() < Math.pow(e.initJumpSpeed, 2) && (t.velocity.normalize(), t.velocity.mult(e.initJumpSpeed, t.velocity))), t.velocity.y += this.jumpInitialLift, t.position.y += 2 * e.raySafeOffset, e.wantsToJump = !1), t.velocity.y < 0 && t.velocity.y > this.jumpNuanceFallVelocityMax && (t.velocity.y -= this.jumpNuanceFallAcceleration), t.velocity.y > 0 && !this.actions.jump.isPressed && (t.velocity.y -= this.jumpNuanceRiseDeceleration)
                    }
                    addToWorld(t) {
                        o.includes(t.characters, this) ? console.warn("Adding character to a world in which it already exists.") : (this.world = t, t.characters.push(this), t.physicsWorld.addBody(this.characterCapsule.physics.physical), t.graphicsWorld.add(this), t.graphicsWorld.add(this.characterCapsule.physics.visual), t.graphicsWorld.add(this.raycastBox), t.objects.push(this.characterCapsule))
                    }
                    removeFromWorld(t) {
                        o.includes(t.characters, this) ? (this.world = void 0, o.pull(t.characters, this), t.physicsWorld.remove(this.characterCapsule.physics.physical), t.graphicsWorld.remove(this), t.graphicsWorld.remove(this.characterCapsule.physics.visual), t.graphicsWorld.remove(this.raycastBox), this.proximityLine && t.graphicsWorld.remove(this.proximityLine), o.pull(t.objects, this.characterCapsule), this.faceCanvas && this.faceCanvas.remove()) : console.warn("Removing character from a world in which it isn't present.")
                    }
                }
                e.Character = w
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2),
                    r = n(0),
                    o = n(14),
                    s = n(8),
                    a = n(71);
                class l extends i.CharacterStateBase {
                    constructor(t, e) {
                        super(t), this.startPosition = new r.Vector3, this.endPosition = new r.Vector3, this.startRotation = new r.Quaternion, this.endRotation = new r.Quaternion, this.canFindVehiclesToEnter = !1, this.vehicle = e.vehicle, this.seat = e, this.animationLength = 1, e.doorSide === s.Side.Left ? this.animationLength = this.character.setAnimation("sit_down_right", .1) : e.doorSide === s.Side.Right && (this.animationLength = this.character.setAnimation("sit_down_left", .1)), this.character.resetVelocity(), this.character.rotateModel(), this.character.setPhysicsEnabled(!1), this.seat.vehicle.attach(this.character), this.startPosition.copy(this.character.position), this.endPosition.copy(e.seatPoint.position), this.endPosition.y += .6, this.startRotation.copy(this.character.quaternion), this.endRotation.copy(this.seat.seatPoint.quaternion)
                    }
                    update(t) {
                        super.update(t), this.timer > this.animationLength - t && (this.character.setPosition(this.endPosition.x, this.endPosition.y, this.endPosition.z), this.character.startControllingVehicle(this.vehicle, this.seat), this.anyDirection() || void 0 === this.seat.door ? this.character.setState(new o.Sitting(this.character)) : this.character.setState(new a.CloseVehicleDoorInside(this.character, this.seat)));
                        let e = this.timer / this.animationLength,
                            n = 1 - (.5 * Math.cos(e * Math.PI) + .5),
                            i = (new r.Vector3).lerpVectors(this.startPosition, this.endPosition, n);
                        this.character.setPosition(i.x, i.y, i.z)
                    }
                }
                e.EnteringVehicle = l
            }, function(t, e, n) {
                "use strict";

                function i(t) {
                    return "geometry" in t && "material" in t
                }

                function r(t) {
                    if (!i(t)) return;
                    const e = [].concat(t.material);
                    for (const n of e) n.dispose()
                }

                function o(t) {
                    let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                        n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                        o = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
                    t && (i(t) && (t.geometry && n && t.geometry.dispose(), o && r(t)), e && Promise.resolve().then((() => {
                        t.parent && t.parent.remove(t)
                    })))
                }
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.isRenderItem = i, e.disposeMaterial = r, e.disposeObject = o, e.disposeObjectTree = function(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    t.traverse((t => {
                        o(t, e.removeFromParent, e.destroyGeometry, e.destroyMaterial)
                    }))
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var i, r = function() {
                        function t(t, e) {
                            for (var n = 0; n < e.length; n++) {
                                var i = e[n];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                            }
                        }
                        return function(e, n, i) {
                            return n && t(e.prototype, n), i && t(e, i), e
                        }
                    }(),
                    o = function(t) {
                        if (t && t.__esModule) return t;
                        var e = {};
                        if (null != t)
                            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                        return e.default = t, e
                    }(n(0)),
                    s = (i = n(4)) && i.__esModule ? i : {
                        default: i
                    },
                    a = function(t) {
                        function e(t, n) {
                            ! function(t, e) {
                                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                            }(this, e);
                            var i = function(t, e) {
                                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !e || "object" != typeof e && "function" != typeof e ? t : e
                            }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                            return i.textureID = void 0 !== n ? n : "tDiffuse", t instanceof o.ShaderMaterial ? (i.uniforms = t.uniforms, i.material = t) : t && (i.uniforms = o.UniformsUtils.clone(t.uniforms), i.material = new o.ShaderMaterial({
                                defines: Object.assign({}, t.defines),
                                uniforms: i.uniforms,
                                vertexShader: t.vertexShader,
                                fragmentShader: t.fragmentShader
                            })), i.fsQuad = new s.default.FullScreenQuad(i.material), i
                        }
                        return function(t, e) {
                            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                            t.prototype = Object.create(e && e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                        }(e, t), r(e, [{
                            key: "render",
                            value: function(t, e, n) {
                                this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
                            }
                        }]), e
                    }(s.default);
                e.default = a
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var i, r = function() {
                        function t(t, e) {
                            for (var n = 0; n < e.length; n++) {
                                var i = e[n];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                            }
                        }
                        return function(e, n, i) {
                            return n && t(e.prototype, n), i && t(e, i), e
                        }
                    }(),
                    o = function(t) {
                        function e(t, n) {
                            ! function(t, e) {
                                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                            }(this, e);
                            var i = function(t, e) {
                                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !e || "object" != typeof e && "function" != typeof e ? t : e
                            }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                            return i.scene = t, i.camera = n, i.clear = !0, i.needsSwap = !1, i.inverse = !1, i
                        }
                        return function(t, e) {
                            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                            t.prototype = Object.create(e && e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                        }(e, t), r(e, [{
                            key: "render",
                            value: function(t, e, n) {
                                var i = t.context,
                                    r = t.state;
                                r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0);
                                var o = void 0,
                                    s = void 0;
                                this.inverse ? (o = 0, s = 1) : (o = 1, s = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE), r.buffers.stencil.setFunc(i.ALWAYS, o, 4294967295), r.buffers.stencil.setClear(s), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP)
                            }
                        }]), e
                    }(((i = n(4)) && i.__esModule ? i : {
                        default: i
                    }).default);
                e.default = o
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var i, r = function() {
                        function t(t, e) {
                            for (var n = 0; n < e.length; n++) {
                                var i = e[n];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                            }
                        }
                        return function(e, n, i) {
                            return n && t(e.prototype, n), i && t(e, i), e
                        }
                    }(),
                    o = function(t) {
                        function e() {
                            ! function(t, e) {
                                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                            }(this, e);
                            var t = function(t, e) {
                                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !e || "object" != typeof e && "function" != typeof e ? t : e
                            }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                            return t.needsSwap = !1, t
                        }
                        return function(t, e) {
                            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                            t.prototype = Object.create(e && e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                        }(e, t), r(e, [{
                            key: "render",
                            value: function(t) {
                                t.state.buffers.stencil.setTest(!1)
                            }
                        }]), e
                    }(((i = n(4)) && i.__esModule ? i : {
                        default: i
                    }).default);
                e.default = o
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(38),
                    r = n(92);
                e.LoadingManager = class {
                    constructor(t) {
                        this.firstLoad = !0, this.loadingTracker = [], this.world = t, this.gltfLoader = new i.GLTFLoader
                    }
                    loadGLTF(t, e) {
                        let n = this.addLoadingEntry(t);
                        this.gltfLoader.load(t, (t => {
                            e(t), this.doneLoading(n)
                        }), (t => {
                            t.lengthComputable && (n.progress = t.loaded / t.total)
                        }), (t => {
                            console.error(t)
                        }))
                    }
                    addLoadingEntry(t) {
                        let e = new r.LoadingTrackerEntry(t);
                        return this.loadingTracker.push(e), e
                    }
                    doneLoading(t) {
                        t.finished = !0, t.progress = 1, this.isLoadingDone() && void 0 !== this.onFinishedCallback && this.onFinishedCallback()
                    }
                    getLoadingPercentage() {
                        let t = !0,
                            e = 0,
                            n = 0;
                        for (const i of this.loadingTracker) e++, n += i.progress, i.finished || (t = !1);
                        return n / e * 100
                    }
                    isLoadingDone() {
                        for (const t of this.loadingTracker)
                            if (!t.finished) return !1;
                        return !0
                    }
                }
            }, function(t, e, n) {
                "use strict";
                n.r(e), n.d(e, "GLTFLoader", (function() {
                    return r
                }));
                var i = n(0);
                class r extends i.Loader {
                    constructor(t) {
                        super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(t) {
                            return new c(t)
                        })), this.register((function(t) {
                            return new u(t)
                        })), this.register((function(t) {
                            return new d(t)
                        })), this.register((function(t) {
                            return new h(t)
                        })), this.register((function(t) {
                            return new a(t)
                        })), this.register((function(t) {
                            return new p(t)
                        }))
                    }
                    load(t, e, n, r) {
                        const o = this;
                        let s;
                        s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : i.LoaderUtils.extractUrlBase(t), this.manager.itemStart(t);
                        const a = function(e) {
                                r ? r(e) : console.error(e), o.manager.itemError(t), o.manager.itemEnd(t)
                            },
                            l = new i.FileLoader(this.manager);
                        l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(t, (function(n) {
                            try {
                                o.parse(n, s, (function(n) {
                                    e(n), o.manager.itemEnd(t)
                                }), a)
                            } catch (t) {
                                a(t)
                            }
                        }), n, a)
                    }
                    setDRACOLoader(t) {
                        return this.dracoLoader = t, this
                    }
                    setDDSLoader() {
                        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
                    }
                    setKTX2Loader(t) {
                        return this.ktx2Loader = t, this
                    }
                    setMeshoptDecoder(t) {
                        return this.meshoptDecoder = t, this
                    }
                    register(t) {
                        return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
                    }
                    unregister(t) {
                        return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this
                    }
                    parse(t, e, n, r) {
                        let o;
                        const a = {},
                            c = {};
                        if ("string" == typeof t) o = t;
                        else if (i.LoaderUtils.decodeText(new Uint8Array(t, 0, 4)) === f) {
                            try {
                                a[s.KHR_BINARY_GLTF] = new v(t)
                            } catch (t) {
                                return void(r && r(t))
                            }
                            o = a[s.KHR_BINARY_GLTF].content
                        } else o = i.LoaderUtils.decodeText(new Uint8Array(t));
                        const h = JSON.parse(o);
                        if (void 0 === h.asset || h.asset.version[0] < 2) return void(r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                        const u = new k(h, {
                            path: e || this.resourcePath || "",
                            crossOrigin: this.crossOrigin,
                            requestHeader: this.requestHeader,
                            manager: this.manager,
                            ktx2Loader: this.ktx2Loader,
                            meshoptDecoder: this.meshoptDecoder
                        });
                        u.fileLoader.setRequestHeader(this.requestHeader);
                        for (let i = 0; i < this.pluginCallbacks.length; i++) {
                            const t = this.pluginCallbacks[i](u);
                            c[t.name] = t, a[t.name] = !0
                        }
                        if (h.extensionsUsed)
                            for (let i = 0; i < h.extensionsUsed.length; ++i) {
                                const t = h.extensionsUsed[i],
                                    e = h.extensionsRequired || [];
                                switch (t) {
                                    case s.KHR_MATERIALS_UNLIT:
                                        a[t] = new l;
                                        break;
                                    case s.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                        a[t] = new w;
                                        break;
                                    case s.KHR_DRACO_MESH_COMPRESSION:
                                        a[t] = new y(h, this.dracoLoader);
                                        break;
                                    case s.KHR_TEXTURE_TRANSFORM:
                                        a[t] = new x;
                                        break;
                                    case s.KHR_MESH_QUANTIZATION:
                                        a[t] = new _;
                                        break;
                                    default:
                                        e.indexOf(t) >= 0 && void 0 === c[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                                }
                            }
                        u.setExtensions(a), u.setPlugins(c), u.parse(n, r)
                    }
                }

                function o() {
                    let t = {};
                    return {
                        get: function(e) {
                            return t[e]
                        },
                        add: function(e, n) {
                            t[e] = n
                        },
                        remove: function(e) {
                            delete t[e]
                        },
                        removeAll: function() {
                            t = {}
                        }
                    }
                }
                const s = {
                    KHR_BINARY_GLTF: "KHR_binary_glTF",
                    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
                    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                    EXT_TEXTURE_WEBP: "EXT_texture_webp",
                    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
                };
                class a {
                    constructor(t) {
                        this.parser = t, this.name = s.KHR_LIGHTS_PUNCTUAL, this.cache = {
                            refs: {},
                            uses: {}
                        }
                    }
                    _markDefs() {
                        const t = this.parser,
                            e = this.parser.json.nodes || [];
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = e[n];
                            i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && t._addNodeRef(this.cache, i.extensions[this.name].light)
                        }
                    }
                    _loadLight(t) {
                        const e = this.parser,
                            n = "light:" + t;
                        let r = e.cache.get(n);
                        if (r) return r;
                        const o = e.json,
                            s = ((o.extensions && o.extensions[this.name] || {}).lights || [])[t];
                        let a;
                        const l = new i.Color(16777215);
                        void 0 !== s.color && l.fromArray(s.color);
                        const c = void 0 !== s.range ? s.range : 0;
                        switch (s.type) {
                            case "directional":
                                a = new i.DirectionalLight(l), a.target.position.set(0, 0, -1), a.add(a.target);
                                break;
                            case "point":
                                a = new i.PointLight(l), a.distance = c;
                                break;
                            case "spot":
                                a = new i.SpotLight(l), a.distance = c, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, a.angle = s.spot.outerConeAngle, a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
                                break;
                            default:
                                throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
                        }
                        return a.position.set(0, 0, 0), a.decay = 2, void 0 !== s.intensity && (a.intensity = s.intensity), a.name = e.createUniqueName(s.name || "light_" + t), r = Promise.resolve(a), e.cache.add(n, r), r
                    }
                    createNodeAttachment(t) {
                        const e = this,
                            n = this.parser,
                            i = n.json.nodes[t],
                            r = (i.extensions && i.extensions[this.name] || {}).light;
                        return void 0 === r ? null : this._loadLight(r).then((function(t) {
                            return n._getNodeRef(e.cache, r, t)
                        }))
                    }
                }
                class l {
                    constructor() {
                        this.name = s.KHR_MATERIALS_UNLIT
                    }
                    getMaterialType() {
                        return i.MeshBasicMaterial
                    }
                    extendParams(t, e, n) {
                        const r = [];
                        t.color = new i.Color(1, 1, 1), t.opacity = 1;
                        const o = e.pbrMetallicRoughness;
                        if (o) {
                            if (Array.isArray(o.baseColorFactor)) {
                                const e = o.baseColorFactor;
                                t.color.fromArray(e), t.opacity = e[3]
                            }
                            void 0 !== o.baseColorTexture && r.push(n.assignTexture(t, "map", o.baseColorTexture))
                        }
                        return Promise.all(r)
                    }
                }
                class c {
                    constructor(t) {
                        this.parser = t, this.name = s.KHR_MATERIALS_CLEARCOAT
                    }
                    getMaterialType(t) {
                        const e = this.parser.json.materials[t];
                        return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null
                    }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            r = n.json.materials[t];
                        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                        const o = [],
                            s = r.extensions[this.name];
                        if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && o.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && o.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (o.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) {
                            const t = s.clearcoatNormalTexture.scale;
                            e.clearcoatNormalScale = new i.Vector2(t, -t)
                        }
                        return Promise.all(o)
                    }
                }
                class h {
                    constructor(t) {
                        this.parser = t, this.name = s.KHR_MATERIALS_TRANSMISSION
                    }
                    getMaterialType(t) {
                        const e = this.parser.json.materials[t];
                        return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null
                    }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            i = n.json.materials[t];
                        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                        const r = [],
                            o = i.extensions[this.name];
                        return void 0 !== o.transmissionFactor && (e.transmission = o.transmissionFactor), void 0 !== o.transmissionTexture && r.push(n.assignTexture(e, "transmissionMap", o.transmissionTexture)), Promise.all(r)
                    }
                }
                class u {
                    constructor(t) {
                        this.parser = t, this.name = s.KHR_TEXTURE_BASISU
                    }
                    loadTexture(t) {
                        const e = this.parser,
                            n = e.json,
                            i = n.textures[t];
                        if (!i.extensions || !i.extensions[this.name]) return null;
                        const r = i.extensions[this.name],
                            o = n.images[r.source],
                            s = e.options.ktx2Loader;
                        if (!s) {
                            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                            return null
                        }
                        return e.loadTextureImage(t, o, s)
                    }
                }
                class d {
                    constructor(t) {
                        this.parser = t, this.name = s.EXT_TEXTURE_WEBP, this.isSupported = null
                    }
                    loadTexture(t) {
                        const e = this.name,
                            n = this.parser,
                            i = n.json,
                            r = i.textures[t];
                        if (!r.extensions || !r.extensions[e]) return null;
                        const o = r.extensions[e],
                            s = i.images[o.source];
                        let a = n.textureLoader;
                        if (s.uri) {
                            const t = n.options.manager.getHandler(s.uri);
                            null !== t && (a = t)
                        }
                        return this.detectSupport().then((function(r) {
                            if (r) return n.loadTextureImage(t, s, a);
                            if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                            return n.loadTexture(t)
                        }))
                    }
                    detectSupport() {
                        return this.isSupported || (this.isSupported = new Promise((function(t) {
                            const e = new Image;
                            e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() {
                                t(1 === e.height)
                            }
                        }))), this.isSupported
                    }
                }
                class p {
                    constructor(t) {
                        this.name = s.EXT_MESHOPT_COMPRESSION, this.parser = t
                    }
                    loadBufferView(t) {
                        const e = this.parser.json,
                            n = e.bufferViews[t];
                        if (n.extensions && n.extensions[this.name]) {
                            const t = n.extensions[this.name],
                                i = this.parser.getDependency("buffer", t.buffer),
                                r = this.parser.options.meshoptDecoder;
                            if (!r || !r.supported) {
                                if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                                return null
                            }
                            return Promise.all([i, r.ready]).then((function(e) {
                                const n = t.byteOffset || 0,
                                    i = t.byteLength || 0,
                                    o = t.count,
                                    s = t.byteStride,
                                    a = new ArrayBuffer(o * s),
                                    l = new Uint8Array(e[0], n, i);
                                return r.decodeGltfBuffer(new Uint8Array(a), o, s, l, t.mode, t.filter), a
                            }))
                        }
                        return null
                    }
                }
                const f = "glTF",
                    m = 12,
                    g = {
                        JSON: 1313821514,
                        BIN: 5130562
                    };
                class v {
                    constructor(t) {
                        this.name = s.KHR_BINARY_GLTF, this.content = null, this.body = null;
                        const e = new DataView(t, 0, m);
                        if (this.header = {
                                magic: i.LoaderUtils.decodeText(new Uint8Array(t.slice(0, 4))),
                                version: e.getUint32(4, !0),
                                length: e.getUint32(8, !0)
                            }, this.header.magic !== f) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                        const n = this.header.length - m,
                            r = new DataView(t, m);
                        let o = 0;
                        for (; o < n;) {
                            const e = r.getUint32(o, !0);
                            o += 4;
                            const n = r.getUint32(o, !0);
                            if (o += 4, n === g.JSON) {
                                const n = new Uint8Array(t, m + o, e);
                                this.content = i.LoaderUtils.decodeText(n)
                            } else if (n === g.BIN) {
                                const n = m + o;
                                this.body = t.slice(n, n + e)
                            }
                            o += e
                        }
                        if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
                    }
                }
                class y {
                    constructor(t, e) {
                        if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                        this.name = s.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
                    }
                    decodePrimitive(t, e) {
                        const n = this.json,
                            i = this.dracoLoader,
                            r = t.extensions[this.name].bufferView,
                            o = t.extensions[this.name].attributes,
                            s = {},
                            a = {},
                            l = {};
                        for (const c in o) {
                            const t = P[c] || c.toLowerCase();
                            s[t] = o[c]
                        }
                        for (const c in t.attributes) {
                            const e = P[c] || c.toLowerCase();
                            if (void 0 !== o[c]) {
                                const i = n.accessors[t.attributes[c]],
                                    r = A[i.componentType];
                                l[e] = r, a[e] = !0 === i.normalized
                            }
                        }
                        return e.getDependency("bufferView", r).then((function(t) {
                            return new Promise((function(e) {
                                i.decodeDracoFile(t, (function(t) {
                                    for (const e in t.attributes) {
                                        const n = t.attributes[e],
                                            i = a[e];
                                        void 0 !== i && (n.normalized = i)
                                    }
                                    e(t)
                                }), s, l)
                            }))
                        }))
                    }
                }
                class x {
                    constructor() {
                        this.name = s.KHR_TEXTURE_TRANSFORM
                    }
                    extendTexture(t, e) {
                        return void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t
                    }
                }
                class b extends i.MeshStandardMaterial {
                    constructor(t) {
                        super(), this.isGLTFSpecularGlossinessMaterial = !0;
                        const e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                            n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                            r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                            o = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                            s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                            a = {
                                specular: {
                                    value: (new i.Color).setHex(16777215)
                                },
                                glossiness: {
                                    value: 1
                                },
                                specularMap: {
                                    value: null
                                },
                                glossinessMap: {
                                    value: null
                                }
                            };
                        this._extraUniforms = a, this.onBeforeCompile = function(t) {
                            for (const e in a) t.uniforms[e] = a[e];
                            t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", o).replace("#include <lights_physical_fragment>", s)
                        }, Object.defineProperties(this, {
                            specular: {
                                get: function() {
                                    return a.specular.value
                                },
                                set: function(t) {
                                    a.specular.value = t
                                }
                            },
                            specularMap: {
                                get: function() {
                                    return a.specularMap.value
                                },
                                set: function(t) {
                                    a.specularMap.value = t, t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                                }
                            },
                            glossiness: {
                                get: function() {
                                    return a.glossiness.value
                                },
                                set: function(t) {
                                    a.glossiness.value = t
                                }
                            },
                            glossinessMap: {
                                get: function() {
                                    return a.glossinessMap.value
                                },
                                set: function(t) {
                                    a.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                                }
                            }
                        }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
                    }
                }
                class w {
                    constructor() {
                        this.name = s.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
                    }
                    getMaterialType() {
                        return b
                    }
                    extendParams(t, e, n) {
                        const r = e.extensions[this.name];
                        t.color = new i.Color(1, 1, 1), t.opacity = 1;
                        const o = [];
                        if (Array.isArray(r.diffuseFactor)) {
                            const e = r.diffuseFactor;
                            t.color.fromArray(e), t.opacity = e[3]
                        }
                        if (void 0 !== r.diffuseTexture && o.push(n.assignTexture(t, "map", r.diffuseTexture)), t.emissive = new i.Color(0, 0, 0), t.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, t.specular = new i.Color(1, 1, 1), Array.isArray(r.specularFactor) && t.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) {
                            const e = r.specularGlossinessTexture;
                            o.push(n.assignTexture(t, "glossinessMap", e)), o.push(n.assignTexture(t, "specularMap", e))
                        }
                        return Promise.all(o)
                    }
                    createMaterial(t) {
                        const e = new b(t);
                        return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = 1, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = i.TangentSpaceNormalMap, t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e.refractionRatio = .98, e
                    }
                }
                class _ {
                    constructor() {
                        this.name = s.KHR_MESH_QUANTIZATION
                    }
                }
                class S extends i.Interpolant {
                    constructor(t, e, n, i) {
                        super(t, e, n, i)
                    }
                    copySampleValue_(t) {
                        const e = this.resultBuffer,
                            n = this.sampleValues,
                            i = this.valueSize,
                            r = t * i * 3 + i;
                        for (let o = 0; o !== i; o++) e[o] = n[r + o];
                        return e
                    }
                }
                S.prototype.beforeStart_ = S.prototype.copySampleValue_, S.prototype.afterEnd_ = S.prototype.copySampleValue_, S.prototype.interpolate_ = function(t, e, n, i) {
                    const r = this.resultBuffer,
                        o = this.sampleValues,
                        s = this.valueSize,
                        a = 2 * s,
                        l = 3 * s,
                        c = i - e,
                        h = (n - e) / c,
                        u = h * h,
                        d = u * h,
                        p = t * l,
                        f = p - l,
                        m = -2 * d + 3 * u,
                        g = d - u,
                        v = 1 - m,
                        y = g - u + h;
                    for (let x = 0; x !== s; x++) {
                        const t = o[f + x + s],
                            e = o[f + x + a] * c,
                            n = o[p + x + s],
                            i = o[p + x] * c;
                        r[x] = v * t + y * e + m * n + g * i
                    }
                    return r
                };
                const M = {
                        FLOAT: 5126,
                        FLOAT_MAT3: 35675,
                        FLOAT_MAT4: 35676,
                        FLOAT_VEC2: 35664,
                        FLOAT_VEC3: 35665,
                        FLOAT_VEC4: 35666,
                        LINEAR: 9729,
                        REPEAT: 10497,
                        SAMPLER_2D: 35678,
                        POINTS: 0,
                        LINES: 1,
                        LINE_LOOP: 2,
                        LINE_STRIP: 3,
                        TRIANGLES: 4,
                        TRIANGLE_STRIP: 5,
                        TRIANGLE_FAN: 6,
                        UNSIGNED_BYTE: 5121,
                        UNSIGNED_SHORT: 5123
                    },
                    A = {
                        5120: Int8Array,
                        5121: Uint8Array,
                        5122: Int16Array,
                        5123: Uint16Array,
                        5125: Uint32Array,
                        5126: Float32Array
                    },
                    T = {
                        9728: i.NearestFilter,
                        9729: i.LinearFilter,
                        9984: i.NearestMipmapNearestFilter,
                        9985: i.LinearMipmapNearestFilter,
                        9986: i.NearestMipmapLinearFilter,
                        9987: i.LinearMipmapLinearFilter
                    },
                    E = {
                        33071: i.ClampToEdgeWrapping,
                        33648: i.MirroredRepeatWrapping,
                        10497: i.RepeatWrapping
                    },
                    C = {
                        SCALAR: 1,
                        VEC2: 2,
                        VEC3: 3,
                        VEC4: 4,
                        MAT2: 4,
                        MAT3: 9,
                        MAT4: 16
                    },
                    P = {
                        POSITION: "position",
                        NORMAL: "normal",
                        TANGENT: "tangent",
                        TEXCOORD_0: "uv",
                        TEXCOORD_1: "uv2",
                        COLOR_0: "color",
                        WEIGHTS_0: "skinWeight",
                        JOINTS_0: "skinIndex"
                    },
                    L = {
                        scale: "scale",
                        translation: "position",
                        rotation: "quaternion",
                        weights: "morphTargetInfluences"
                    },
                    R = {
                        CUBICSPLINE: void 0,
                        LINEAR: i.InterpolateLinear,
                        STEP: i.InterpolateDiscrete
                    },
                    I = {
                        OPAQUE: "OPAQUE",
                        MASK: "MASK",
                        BLEND: "BLEND"
                    };

                function F(t, e) {
                    return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                }

                function O(t, e, n) {
                    for (const i in n.extensions) void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = n.extensions[i])
                }

                function N(t, e) {
                    void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
                }

                function B(t, e) {
                    if (t.updateMorphTargets(), void 0 !== e.weights)
                        for (let n = 0, i = e.weights.length; n < i; n++) t.morphTargetInfluences[n] = e.weights[n];
                    if (e.extras && Array.isArray(e.extras.targetNames)) {
                        const n = e.extras.targetNames;
                        if (t.morphTargetInfluences.length === n.length) {
                            t.morphTargetDictionary = {};
                            for (let e = 0, i = n.length; e < i; e++) t.morphTargetDictionary[n[e]] = e
                        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                    }
                }

                function D(t) {
                    const e = t.extensions && t.extensions[s.KHR_DRACO_MESH_COMPRESSION];
                    let n;
                    return n = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + V(e.attributes) : t.indices + ":" + V(t.attributes) + ":" + t.mode, n
                }

                function V(t) {
                    let e = "";
                    const n = Object.keys(t).sort();
                    for (let i = 0, r = n.length; i < r; i++) e += n[i] + ":" + t[n[i]] + ";";
                    return e
                }

                function j(t) {
                    switch (t) {
                        case Int8Array:
                            return 1 / 127;
                        case Uint8Array:
                            return 1 / 255;
                        case Int16Array:
                            return 1 / 32767;
                        case Uint16Array:
                            return 1 / 65535;
                        default:
                            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                    }
                }
                class k {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new o, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                            refs: {},
                            uses: {}
                        }, this.cameraCache = {
                            refs: {},
                            uses: {}
                        }, this.lightCache = {
                            refs: {},
                            uses: {}
                        }, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new i.ImageBitmapLoader(this.options.manager) : this.textureLoader = new i.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new i.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                    }
                    setExtensions(t) {
                        this.extensions = t
                    }
                    setPlugins(t) {
                        this.plugins = t
                    }
                    parse(t, e) {
                        const n = this,
                            i = this.json,
                            r = this.extensions;
                        this.cache.removeAll(), this._invokeAll((function(t) {
                            return t._markDefs && t._markDefs()
                        })), Promise.all(this._invokeAll((function(t) {
                            return t.beforeRoot && t.beforeRoot()
                        }))).then((function() {
                            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                        })).then((function(e) {
                            const o = {
                                scene: e[0][i.scene || 0],
                                scenes: e[0],
                                animations: e[1],
                                cameras: e[2],
                                asset: i.asset,
                                parser: n,
                                userData: {}
                            };
                            O(r, o, i), N(o, i), Promise.all(n._invokeAll((function(t) {
                                return t.afterRoot && t.afterRoot(o)
                            }))).then((function() {
                                t(o)
                            }))
                        })).catch(e)
                    }
                    _markDefs() {
                        const t = this.json.nodes || [],
                            e = this.json.skins || [],
                            n = this.json.meshes || [];
                        for (let i = 0, r = e.length; i < r; i++) {
                            const n = e[i].joints;
                            for (let e = 0, i = n.length; e < i; e++) t[n[e]].isBone = !0
                        }
                        for (let i = 0, r = t.length; i < r; i++) {
                            const e = t[i];
                            void 0 !== e.mesh && (this._addNodeRef(this.meshCache, e.mesh), void 0 !== e.skin && (n[e.mesh].isSkinnedMesh = !0)), void 0 !== e.camera && this._addNodeRef(this.cameraCache, e.camera)
                        }
                    }
                    _addNodeRef(t, e) {
                        void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
                    }
                    _getNodeRef(t, e, n) {
                        if (t.refs[e] <= 1) return n;
                        const i = n.clone();
                        return i.name += "_instance_" + t.uses[e]++, i
                    }
                    _invokeOne(t) {
                        const e = Object.values(this.plugins);
                        e.push(this);
                        for (let n = 0; n < e.length; n++) {
                            const i = t(e[n]);
                            if (i) return i
                        }
                        return null
                    }
                    _invokeAll(t) {
                        const e = Object.values(this.plugins);
                        e.unshift(this);
                        const n = [];
                        for (let i = 0; i < e.length; i++) {
                            const r = t(e[i]);
                            r && n.push(r)
                        }
                        return n
                    }
                    getDependency(t, e) {
                        const n = t + ":" + e;
                        let i = this.cache.get(n);
                        if (!i) {
                            switch (t) {
                                case "scene":
                                    i = this.loadScene(e);
                                    break;
                                case "node":
                                    i = this.loadNode(e);
                                    break;
                                case "mesh":
                                    i = this._invokeOne((function(t) {
                                        return t.loadMesh && t.loadMesh(e)
                                    }));
                                    break;
                                case "accessor":
                                    i = this.loadAccessor(e);
                                    break;
                                case "bufferView":
                                    i = this._invokeOne((function(t) {
                                        return t.loadBufferView && t.loadBufferView(e)
                                    }));
                                    break;
                                case "buffer":
                                    i = this.loadBuffer(e);
                                    break;
                                case "material":
                                    i = this._invokeOne((function(t) {
                                        return t.loadMaterial && t.loadMaterial(e)
                                    }));
                                    break;
                                case "texture":
                                    i = this._invokeOne((function(t) {
                                        return t.loadTexture && t.loadTexture(e)
                                    }));
                                    break;
                                case "skin":
                                    i = this.loadSkin(e);
                                    break;
                                case "animation":
                                    i = this.loadAnimation(e);
                                    break;
                                case "camera":
                                    i = this.loadCamera(e);
                                    break;
                                default:
                                    throw new Error("Unknown type: " + t)
                            }
                            this.cache.add(n, i)
                        }
                        return i
                    }
                    getDependencies(t) {
                        let e = this.cache.get(t);
                        if (!e) {
                            const n = this,
                                i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                            e = Promise.all(i.map((function(e, i) {
                                return n.getDependency(t, i)
                            }))), this.cache.add(t, e)
                        }
                        return e
                    }
                    loadBuffer(t) {
                        const e = this.json.buffers[t],
                            n = this.fileLoader;
                        if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                        if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[s.KHR_BINARY_GLTF].body);
                        const i = this.options;
                        return new Promise((function(t, r) {
                            n.load(F(e.uri, i.path), t, void 0, (function() {
                                r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                            }))
                        }))
                    }
                    loadBufferView(t) {
                        const e = this.json.bufferViews[t];
                        return this.getDependency("buffer", e.buffer).then((function(t) {
                            const n = e.byteLength || 0,
                                i = e.byteOffset || 0;
                            return t.slice(i, i + n)
                        }))
                    }
                    loadAccessor(t) {
                        const e = this,
                            n = this.json,
                            r = this.json.accessors[t];
                        if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null);
                        const o = [];
                        return void 0 !== r.bufferView ? o.push(this.getDependency("bufferView", r.bufferView)) : o.push(null), void 0 !== r.sparse && (o.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), o.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(o).then((function(t) {
                            const o = t[0],
                                s = C[r.type],
                                a = A[r.componentType],
                                l = a.BYTES_PER_ELEMENT,
                                c = l * s,
                                h = r.byteOffset || 0,
                                u = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
                                d = !0 === r.normalized;
                            let p, f;
                            if (u && u !== c) {
                                const t = Math.floor(h / u),
                                    n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + t + ":" + r.count;
                                let c = e.cache.get(n);
                                c || (p = new a(o, t * u, r.count * u / l), c = new i.InterleavedBuffer(p, u / l), e.cache.add(n, c)), f = new i.InterleavedBufferAttribute(c, s, h % u / l, d)
                            } else p = null === o ? new a(r.count * s) : new a(o, h, r.count * s), f = new i.BufferAttribute(p, s, d);
                            if (void 0 !== r.sparse) {
                                const e = C.SCALAR,
                                    n = A[r.sparse.indices.componentType],
                                    l = r.sparse.indices.byteOffset || 0,
                                    c = r.sparse.values.byteOffset || 0,
                                    h = new n(t[1], l, r.sparse.count * e),
                                    u = new a(t[2], c, r.sparse.count * s);
                                null !== o && (f = new i.BufferAttribute(f.array.slice(), f.itemSize, f.normalized));
                                for (let t = 0, i = h.length; t < i; t++) {
                                    const e = h[t];
                                    if (f.setX(e, u[t * s]), s >= 2 && f.setY(e, u[t * s + 1]), s >= 3 && f.setZ(e, u[t * s + 2]), s >= 4 && f.setW(e, u[t * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                                }
                            }
                            return f
                        }))
                    }
                    loadTexture(t) {
                        const e = this.json,
                            n = this.options,
                            i = e.textures[t],
                            r = e.images[i.source];
                        let o = this.textureLoader;
                        if (r.uri) {
                            const t = n.manager.getHandler(r.uri);
                            null !== t && (o = t)
                        }
                        return this.loadTextureImage(t, r, o)
                    }
                    loadTextureImage(t, e, n) {
                        const r = this,
                            o = this.json,
                            s = this.options,
                            a = o.textures[t],
                            l = (e.uri || e.bufferView) + ":" + a.sampler;
                        if (this.textureCache[l]) return this.textureCache[l];
                        const c = self.URL || self.webkitURL;
                        let h = e.uri || "",
                            u = !1,
                            d = !0;
                        const p = h.search(/\.jpe?g($|\?)/i) > 0 || 0 === h.search(/^data\:image\/jpeg/);
                        if (("image/jpeg" === e.mimeType || p) && (d = !1), void 0 !== e.bufferView) h = r.getDependency("bufferView", e.bufferView).then((function(t) {
                            if ("image/png" === e.mimeType) {
                                const e = new DataView(t, 25, 1).getUint8(0, !1);
                                d = 6 === e || 4 === e || 3 === e
                            }
                            u = !0;
                            const n = new Blob([t], {
                                type: e.mimeType
                            });
                            return h = c.createObjectURL(n), h
                        }));
                        else if (void 0 === e.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
                        const f = Promise.resolve(h).then((function(t) {
                            return new Promise((function(e, r) {
                                let o = e;
                                !0 === n.isImageBitmapLoader && (o = function(t) {
                                    e(new i.CanvasTexture(t))
                                }), n.load(F(t, s.path), o, void 0, r)
                            }))
                        })).then((function(e) {
                            !0 === u && c.revokeObjectURL(h), e.flipY = !1, a.name && (e.name = a.name), d || (e.format = i.RGBFormat);
                            const n = (o.samplers || {})[a.sampler] || {};
                            return e.magFilter = T[n.magFilter] || i.LinearFilter, e.minFilter = T[n.minFilter] || i.LinearMipmapLinearFilter, e.wrapS = E[n.wrapS] || i.RepeatWrapping, e.wrapT = E[n.wrapT] || i.RepeatWrapping, r.associations.set(e, {
                                type: "textures",
                                index: t
                            }), e
                        }));
                        return this.textureCache[l] = f, f
                    }
                    assignTexture(t, e, n) {
                        const i = this;
                        return this.getDependency("texture", n.index).then((function(r) {
                            if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."), i.extensions[s.KHR_TEXTURE_TRANSFORM]) {
                                const t = void 0 !== n.extensions ? n.extensions[s.KHR_TEXTURE_TRANSFORM] : void 0;
                                if (t) {
                                    const e = i.associations.get(r);
                                    r = i.extensions[s.KHR_TEXTURE_TRANSFORM].extendTexture(r, t), i.associations.set(r, e)
                                }
                            }
                            t[e] = r
                        }))
                    }
                    assignFinalMaterial(t) {
                        const e = t.geometry;
                        let n = t.material;
                        const r = void 0 !== e.attributes.tangent,
                            o = void 0 !== e.attributes.color,
                            s = void 0 === e.attributes.normal,
                            a = Object.keys(e.morphAttributes).length > 0,
                            l = a && void 0 !== e.morphAttributes.normal;
                        if (t.isPoints) {
                            const t = "PointsMaterial:" + n.uuid;
                            let e = this.cache.get(t);
                            e || (e = new i.PointsMaterial, i.Material.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, e.sizeAttenuation = !1, this.cache.add(t, e)), n = e
                        } else if (t.isLine) {
                            const t = "LineBasicMaterial:" + n.uuid;
                            let e = this.cache.get(t);
                            e || (e = new i.LineBasicMaterial, i.Material.prototype.copy.call(e, n), e.color.copy(n.color), this.cache.add(t, e)), n = e
                        }
                        if (r || o || s || a) {
                            let t = "ClonedMaterial:" + n.uuid + ":";
                            n.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"), r && (t += "vertex-tangents:"), o && (t += "vertex-colors:"), s && (t += "flat-shading:"), a && (t += "morph-targets:"), l && (t += "morph-normals:");
                            let e = this.cache.get(t);
                            e || (e = n.clone(), o && (e.vertexColors = !0), s && (e.flatShading = !0), a && (e.morphTargets = !0), l && (e.morphNormals = !0), r && (e.vertexTangents = !0, e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)), this.cache.add(t, e), this.associations.set(e, this.associations.get(n))), n = e
                        }
                        n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), t.material = n
                    }
                    getMaterialType() {
                        return i.MeshStandardMaterial
                    }
                    loadMaterial(t) {
                        const e = this,
                            n = this.json,
                            r = this.extensions,
                            o = n.materials[t];
                        let a;
                        const l = {},
                            c = o.extensions || {},
                            h = [];
                        if (c[s.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                            const t = r[s.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                            a = t.getMaterialType(), h.push(t.extendParams(l, o, e))
                        } else if (c[s.KHR_MATERIALS_UNLIT]) {
                            const t = r[s.KHR_MATERIALS_UNLIT];
                            a = t.getMaterialType(), h.push(t.extendParams(l, o, e))
                        } else {
                            const n = o.pbrMetallicRoughness || {};
                            if (l.color = new i.Color(1, 1, 1), l.opacity = 1, Array.isArray(n.baseColorFactor)) {
                                const t = n.baseColorFactor;
                                l.color.fromArray(t), l.opacity = t[3]
                            }
                            void 0 !== n.baseColorTexture && h.push(e.assignTexture(l, "map", n.baseColorTexture)), l.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, l.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (h.push(e.assignTexture(l, "metalnessMap", n.metallicRoughnessTexture)), h.push(e.assignTexture(l, "roughnessMap", n.metallicRoughnessTexture))), a = this._invokeOne((function(e) {
                                return e.getMaterialType && e.getMaterialType(t)
                            })), h.push(Promise.all(this._invokeAll((function(e) {
                                return e.extendMaterialParams && e.extendMaterialParams(t, l)
                            }))))
                        }!0 === o.doubleSided && (l.side = i.DoubleSide);
                        const u = o.alphaMode || I.OPAQUE;
                        return u === I.BLEND ? (l.transparent = !0, l.depthWrite = !1) : (l.transparent = !1, u === I.MASK && (l.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : .5)), void 0 !== o.normalTexture && a !== i.MeshBasicMaterial && (h.push(e.assignTexture(l, "normalMap", o.normalTexture)), l.normalScale = new i.Vector2(1, -1), void 0 !== o.normalTexture.scale && l.normalScale.set(o.normalTexture.scale, -o.normalTexture.scale)), void 0 !== o.occlusionTexture && a !== i.MeshBasicMaterial && (h.push(e.assignTexture(l, "aoMap", o.occlusionTexture)), void 0 !== o.occlusionTexture.strength && (l.aoMapIntensity = o.occlusionTexture.strength)), void 0 !== o.emissiveFactor && a !== i.MeshBasicMaterial && (l.emissive = (new i.Color).fromArray(o.emissiveFactor)), void 0 !== o.emissiveTexture && a !== i.MeshBasicMaterial && h.push(e.assignTexture(l, "emissiveMap", o.emissiveTexture)), Promise.all(h).then((function() {
                            let n;
                            return n = a === b ? r[s.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(l) : new a(l), o.name && (n.name = o.name), n.map && (n.map.encoding = i.sRGBEncoding), n.emissiveMap && (n.emissiveMap.encoding = i.sRGBEncoding), N(n, o), e.associations.set(n, {
                                type: "materials",
                                index: t
                            }), o.extensions && O(r, n, o), n
                        }))
                    }
                    createUniqueName(t) {
                        const e = i.PropertyBinding.sanitizeNodeName(t || "");
                        let n = e;
                        for (let i = 1; this.nodeNamesUsed[n]; ++i) n = e + "_" + i;
                        return this.nodeNamesUsed[n] = !0, n
                    }
                    loadGeometries(t) {
                        const e = this,
                            n = this.extensions,
                            r = this.primitiveCache;

                        function o(t) {
                            return n[s.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) {
                                return z(n, t, e)
                            }))
                        }
                        const a = [];
                        for (let l = 0, c = t.length; l < c; l++) {
                            const n = t[l],
                                c = D(n),
                                h = r[c];
                            if (h) a.push(h.promise);
                            else {
                                let t;
                                t = n.extensions && n.extensions[s.KHR_DRACO_MESH_COMPRESSION] ? o(n) : z(new i.BufferGeometry, n, e), r[c] = {
                                    primitive: n,
                                    promise: t
                                }, a.push(t)
                            }
                        }
                        return Promise.all(a)
                    }
                    loadMesh(t) {
                        const e = this,
                            n = this.json,
                            r = this.extensions,
                            o = n.meshes[t],
                            s = o.primitives,
                            a = [];
                        for (let c = 0, h = s.length; c < h; c++) {
                            const t = void 0 === s[c].material ? (void 0 === (l = this.cache).DefaultMaterial && (l.DefaultMaterial = new i.MeshStandardMaterial({
                                color: 16777215,
                                emissive: 0,
                                metalness: 1,
                                roughness: 1,
                                transparent: !1,
                                depthTest: !0,
                                side: i.FrontSide
                            })), l.DefaultMaterial) : this.getDependency("material", s[c].material);
                            a.push(t)
                        }
                        var l;
                        return a.push(e.loadGeometries(s)), Promise.all(a).then((function(n) {
                            const a = n.slice(0, n.length - 1),
                                l = n[n.length - 1],
                                c = [];
                            for (let u = 0, d = l.length; u < d; u++) {
                                const n = l[u],
                                    h = s[u];
                                let d;
                                const p = a[u];
                                if (h.mode === M.TRIANGLES || h.mode === M.TRIANGLE_STRIP || h.mode === M.TRIANGLE_FAN || void 0 === h.mode) d = !0 === o.isSkinnedMesh ? new i.SkinnedMesh(n, p) : new i.Mesh(n, p), !0 !== d.isSkinnedMesh || d.geometry.attributes.skinWeight.normalized || d.normalizeSkinWeights(), h.mode === M.TRIANGLE_STRIP ? d.geometry = G(d.geometry, i.TriangleStripDrawMode) : h.mode === M.TRIANGLE_FAN && (d.geometry = G(d.geometry, i.TriangleFanDrawMode));
                                else if (h.mode === M.LINES) d = new i.LineSegments(n, p);
                                else if (h.mode === M.LINE_STRIP) d = new i.Line(n, p);
                                else if (h.mode === M.LINE_LOOP) d = new i.LineLoop(n, p);
                                else {
                                    if (h.mode !== M.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                                    d = new i.Points(n, p)
                                }
                                Object.keys(d.geometry.morphAttributes).length > 0 && B(d, o), d.name = e.createUniqueName(o.name || "mesh_" + t), N(d, o), h.extensions && O(r, d, h), e.assignFinalMaterial(d), c.push(d)
                            }
                            if (1 === c.length) return c[0];
                            const h = new i.Group;
                            for (let t = 0, e = c.length; t < e; t++) h.add(c[t]);
                            return h
                        }))
                    }
                    loadCamera(t) {
                        let e;
                        const n = this.json.cameras[t],
                            r = n[n.type];
                        if (r) return "perspective" === n.type ? e = new i.PerspectiveCamera(i.MathUtils.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (e = new i.OrthographicCamera(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (e.name = this.createUniqueName(n.name)), N(e, n), Promise.resolve(e);
                        console.warn("THREE.GLTFLoader: Missing camera parameters.")
                    }
                    loadSkin(t) {
                        const e = this.json.skins[t],
                            n = {
                                joints: e.joints
                            };
                        return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function(t) {
                            return n.inverseBindMatrices = t, n
                        }))
                    }
                    loadAnimation(t) {
                        const e = this.json.animations[t],
                            n = [],
                            r = [],
                            o = [],
                            s = [],
                            a = [];
                        for (let i = 0, l = e.channels.length; i < l; i++) {
                            const t = e.channels[i],
                                l = e.samplers[t.sampler],
                                c = t.target,
                                h = void 0 !== c.node ? c.node : c.id,
                                u = void 0 !== e.parameters ? e.parameters[l.input] : l.input,
                                d = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
                            n.push(this.getDependency("node", h)), r.push(this.getDependency("accessor", u)), o.push(this.getDependency("accessor", d)), s.push(l), a.push(c)
                        }
                        return Promise.all([Promise.all(n), Promise.all(r), Promise.all(o), Promise.all(s), Promise.all(a)]).then((function(n) {
                            const r = n[0],
                                o = n[1],
                                s = n[2],
                                a = n[3],
                                l = n[4],
                                c = [];
                            for (let t = 0, e = r.length; t < e; t++) {
                                const e = r[t],
                                    n = o[t],
                                    h = s[t],
                                    u = a[t],
                                    d = l[t];
                                if (void 0 === e) continue;
                                let p;
                                switch (e.updateMatrix(), e.matrixAutoUpdate = !0, L[d.path]) {
                                    case L.weights:
                                        p = i.NumberKeyframeTrack;
                                        break;
                                    case L.rotation:
                                        p = i.QuaternionKeyframeTrack;
                                        break;
                                    case L.position:
                                    case L.scale:
                                    default:
                                        p = i.VectorKeyframeTrack
                                }
                                const f = e.name ? e.name : e.uuid,
                                    m = void 0 !== u.interpolation ? R[u.interpolation] : i.InterpolateLinear,
                                    g = [];
                                L[d.path] === L.weights ? e.traverse((function(t) {
                                    !0 === t.isMesh && t.morphTargetInfluences && g.push(t.name ? t.name : t.uuid)
                                })) : g.push(f);
                                let v = h.array;
                                if (h.normalized) {
                                    const t = j(v.constructor),
                                        e = new Float32Array(v.length);
                                    for (let n = 0, i = v.length; n < i; n++) e[n] = v[n] * t;
                                    v = e
                                }
                                for (let t = 0, i = g.length; t < i; t++) {
                                    const e = new p(g[t] + "." + L[d.path], n.array, v, m);
                                    "CUBICSPLINE" === u.interpolation && (e.createInterpolant = function(t) {
                                        return new S(this.times, this.values, this.getValueSize() / 3, t)
                                    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), c.push(e)
                                }
                            }
                            const h = e.name ? e.name : "animation_" + t;
                            return new i.AnimationClip(h, void 0, c)
                        }))
                    }
                    createNodeMesh(t) {
                        const e = this.json,
                            n = this,
                            i = e.nodes[t];
                        return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(t) {
                            const e = n._getNodeRef(n.meshCache, i.mesh, t);
                            return void 0 !== i.weights && e.traverse((function(t) {
                                if (t.isMesh)
                                    for (let e = 0, n = i.weights.length; e < n; e++) t.morphTargetInfluences[e] = i.weights[e]
                            })), e
                        }))
                    }
                    loadNode(t) {
                        const e = this.json,
                            n = this.extensions,
                            r = this,
                            o = e.nodes[t],
                            s = o.name ? r.createUniqueName(o.name) : "";
                        return function() {
                            const e = [],
                                n = r._invokeOne((function(e) {
                                    return e.createNodeMesh && e.createNodeMesh(t)
                                }));
                            return n && e.push(n), void 0 !== o.camera && e.push(r.getDependency("camera", o.camera).then((function(t) {
                                return r._getNodeRef(r.cameraCache, o.camera, t)
                            }))), r._invokeAll((function(e) {
                                return e.createNodeAttachment && e.createNodeAttachment(t)
                            })).forEach((function(t) {
                                e.push(t)
                            })), Promise.all(e)
                        }().then((function(e) {
                            let a;
                            if (a = !0 === o.isBone ? new i.Bone : e.length > 1 ? new i.Group : 1 === e.length ? e[0] : new i.Object3D, a !== e[0])
                                for (let t = 0, n = e.length; t < n; t++) a.add(e[t]);
                            if (o.name && (a.userData.name = o.name, a.name = s), N(a, o), o.extensions && O(n, a, o), void 0 !== o.matrix) {
                                const t = new i.Matrix4;
                                t.fromArray(o.matrix), a.applyMatrix4(t)
                            } else void 0 !== o.translation && a.position.fromArray(o.translation), void 0 !== o.rotation && a.quaternion.fromArray(o.rotation), void 0 !== o.scale && a.scale.fromArray(o.scale);
                            return r.associations.set(a, {
                                type: "nodes",
                                index: t
                            }), a
                        }))
                    }
                    loadScene(t) {
                        const e = this.json,
                            n = this.extensions,
                            r = this.json.scenes[t],
                            o = this,
                            s = new i.Group;
                        r.name && (s.name = o.createUniqueName(r.name)), N(s, r), r.extensions && O(n, s, r);
                        const a = r.nodes || [],
                            l = [];
                        for (let i = 0, c = a.length; i < c; i++) l.push(U(a[i], s, e, o));
                        return Promise.all(l).then((function() {
                            return s
                        }))
                    }
                }

                function U(t, e, n, r) {
                    const o = n.nodes[t];
                    return r.getDependency("node", t).then((function(t) {
                        if (void 0 === o.skin) return t;
                        let e;
                        return r.getDependency("skin", o.skin).then((function(t) {
                            e = t;
                            const n = [];
                            for (let i = 0, o = e.joints.length; i < o; i++) n.push(r.getDependency("node", e.joints[i]));
                            return Promise.all(n)
                        })).then((function(n) {
                            return t.traverse((function(t) {
                                if (!t.isMesh) return;
                                const r = [],
                                    o = [];
                                for (let s = 0, a = n.length; s < a; s++) {
                                    const t = n[s];
                                    if (t) {
                                        r.push(t);
                                        const n = new i.Matrix4;
                                        void 0 !== e.inverseBindMatrices && n.fromArray(e.inverseBindMatrices.array, 16 * s), o.push(n)
                                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[s])
                                }
                                t.bind(new i.Skeleton(r, o), t.matrixWorld)
                            })), t
                        }))
                    })).then((function(t) {
                        e.add(t);
                        const i = [];
                        if (o.children) {
                            const e = o.children;
                            for (let o = 0, s = e.length; o < s; o++) {
                                const s = e[o];
                                i.push(U(s, t, n, r))
                            }
                        }
                        return Promise.all(i)
                    }))
                }

                function z(t, e, n) {
                    const r = e.attributes,
                        o = [];

                    function s(e, i) {
                        return n.getDependency("accessor", e).then((function(e) {
                            t.setAttribute(i, e)
                        }))
                    }
                    for (const i in r) {
                        const e = P[i] || i.toLowerCase();
                        e in t.attributes || o.push(s(r[i], e))
                    }
                    if (void 0 !== e.indices && !t.index) {
                        const i = n.getDependency("accessor", e.indices).then((function(e) {
                            t.setIndex(e)
                        }));
                        o.push(i)
                    }
                    return N(t, e),
                        function(t, e, n) {
                            const r = e.attributes,
                                o = new i.Box3;
                            if (void 0 === r.POSITION) return; {
                                const t = n.json.accessors[r.POSITION],
                                    e = t.min,
                                    s = t.max;
                                if (void 0 === e || void 0 === s) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                                if (o.set(new i.Vector3(e[0], e[1], e[2]), new i.Vector3(s[0], s[1], s[2])), t.normalized) {
                                    const e = j(A[t.componentType]);
                                    o.min.multiplyScalar(e), o.max.multiplyScalar(e)
                                }
                            }
                            const s = e.targets;
                            if (void 0 !== s) {
                                const t = new i.Vector3,
                                    e = new i.Vector3;
                                for (let i = 0, r = s.length; i < r; i++) {
                                    const r = s[i];
                                    if (void 0 !== r.POSITION) {
                                        const i = n.json.accessors[r.POSITION],
                                            o = i.min,
                                            s = i.max;
                                        if (void 0 !== o && void 0 !== s) {
                                            if (e.setX(Math.max(Math.abs(o[0]), Math.abs(s[0]))), e.setY(Math.max(Math.abs(o[1]), Math.abs(s[1]))), e.setZ(Math.max(Math.abs(o[2]), Math.abs(s[2]))), i.normalized) {
                                                const t = j(A[i.componentType]);
                                                e.multiplyScalar(t)
                                            }
                                            t.max(e)
                                        } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                    }
                                }
                                o.expandByVector(t)
                            }
                            t.boundingBox = o;
                            const a = new i.Sphere;
                            o.getCenter(a.center), a.radius = o.min.distanceTo(o.max) / 2, t.boundingSphere = a
                        }(t, e, n), Promise.all(o).then((function() {
                            return void 0 !== e.targets ? function(t, e, n) {
                                let i = !1,
                                    r = !1;
                                for (let a = 0, l = e.length; a < l; a++) {
                                    const t = e[a];
                                    if (void 0 !== t.POSITION && (i = !0), void 0 !== t.NORMAL && (r = !0), i && r) break
                                }
                                if (!i && !r) return Promise.resolve(t);
                                const o = [],
                                    s = [];
                                for (let a = 0, l = e.length; a < l; a++) {
                                    const l = e[a];
                                    if (i) {
                                        const e = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : t.attributes.position;
                                        o.push(e)
                                    }
                                    if (r) {
                                        const e = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : t.attributes.normal;
                                        s.push(e)
                                    }
                                }
                                return Promise.all([Promise.all(o), Promise.all(s)]).then((function(e) {
                                    const n = e[0],
                                        o = e[1];
                                    return i && (t.morphAttributes.position = n), r && (t.morphAttributes.normal = o), t.morphTargetsRelative = !0, t
                                }))
                            }(t, e.targets, n) : t
                        }))
                }

                function G(t, e) {
                    let n = t.getIndex();
                    if (null === n) {
                        const e = [],
                            i = t.getAttribute("position");
                        if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
                        for (let t = 0; t < i.count; t++) e.push(t);
                        t.setIndex(e), n = t.getIndex()
                    }
                    const r = n.count - 2,
                        o = [];
                    if (e === i.TriangleFanDrawMode)
                        for (let i = 1; i <= r; i++) o.push(n.getX(0)), o.push(n.getX(i)), o.push(n.getX(i + 1));
                    else
                        for (let i = 0; i < r; i++) i % 2 == 0 ? (o.push(n.getX(i)), o.push(n.getX(i + 1)), o.push(n.getX(i + 2))) : (o.push(n.getX(i + 2)), o.push(n.getX(i + 1)), o.push(n.getX(i)));
                    o.length / 3 !== r && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                    const s = t.clone();
                    return s.setIndex(o), s
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), n(40), n(42);
                const i = n(0),
                    r = n(1),
                    o = n(18),
                    s = n(46),
                    a = n(47);
                e.CharacterAI = {
                    FollowTarget: o.FollowTarget,
                    FollowPath: s.FollowPath,
                    RandomBehaviour: a.RandomBehaviour
                };
                const l = n(20),
                    c = n(21),
                    h = n(48),
                    u = n(49),
                    d = n(22);
                e.ObjectPhysics = {
                    BoxPhysics: l.BoxPhysics,
                    CapsulePhysics: c.CapsulePhysics,
                    ConvexPhysics: h.ConvexPhysics,
                    SpherePhysics: u.SpherePhysics,
                    TrimeshPhysics: d.TrimeshPhysics
                };
                var p = n(23);
                e.Airplane = p.Airplane;
                var f = n(28);
                e.Car = f.Car;
                var m = n(29);
                e.Helicopter = m.Helicopter;
                var g = n(25);
                e.Wheel = g.Wheel;
                var v = n(24);
                e.VehicleSeat = v.VehicleSeat;
                var y = n(26);
                e.VehicleDoor = y.VehicleDoor;
                const x = n(2);
                e.CharacterStates = x;
                var b = n(31);
                e.Character = b.Character;
                var w = n(5);
                e.KeyBinding = w.KeyBinding;
                var _ = n(13);
                e.SBObject = _.SBObject;
                var S = n(76);
                e.World = S.World, e.THREE = i, e.CANNON = r;
                var M = n(38);
                e.GLTFLoader = M.GLTFLoader;
                var A = n(37);
                e.LoadingManager = A.LoadingManager
            }, function(t, e, n) {
                var i = n(41);
                "string" == typeof(i = i.__esModule ? i.default : i) && (i = [
                    [t.i, i, ""]
                ]);
                var r = {
                    insert: "head",
                    singleton: !1
                };
                n(17)(i, r), i.locals && (t.exports = i.locals)
            }, function(t, e, n) {
                (e = n(16)(!1)).push([t.i, ".dg ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    clear: both\n}\n\n.dg.ac {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 0;\n    z-index: 0\n}\n\n.dg:not(.ac) .main {\n    overflow: hidden\n}\n\n.dg.main {\n    -webkit-transition: opacity .1s linear;\n    -o-transition: opacity .1s linear;\n    -moz-transition: opacity .1s linear;\n    transition: opacity .1s linear\n}\n\n.dg.main.taller-than-window {\n    overflow-y: auto\n}\n\n.dg.main.taller-than-window .close-button {\n    opacity: 1;\n    margin-top: -1px;\n    border-top: 1px solid #2c2c2c\n}\n\n.dg.main ul.closed .close-button {\n    opacity: 1 !important\n}\n\n.dg.main:hover .close-button,\n.dg.main .close-button.drag {\n    opacity: 1\n}\n\n.dg.main .close-button {\n    -webkit-transition: opacity .1s linear;\n    -o-transition: opacity .1s linear;\n    -moz-transition: opacity .1s linear;\n    transition: opacity .1s linear;\n    border: 0;\n    line-height: 19px;\n    height: 20px;\n    cursor: pointer;\n    text-align: center;\n    background-color: #000\n}\n\n.dg.main .close-button.close-top {\n    position: relative\n}\n\n.dg.main .close-button.close-bottom {\n    position: absolute\n}\n\n.dg.main .close-button:hover {\n    background-color: #111\n}\n\n.dg.a {\n    float: right;\n    margin-top: 15px;\n    margin-right: 15px;\n    overflow-y: visible\n}\n\n.dg.a.has-save>ul.close-top {\n    margin-top: 0\n}\n\n.dg.a.has-save>ul.close-bottom {\n    margin-top: 27px\n}\n\n.dg.a.has-save>ul.closed {\n    margin-top: 0\n}\n\n.dg.a .save-row {\n    top: 0;\n    z-index: 1002\n}\n\n.dg.a .save-row.close-top {\n    position: relative\n}\n\n.dg.a .save-row.close-bottom {\n    position: fixed\n}\n\n.dg li {\n    -webkit-transition: height .1s ease-out;\n    -o-transition: height .1s ease-out;\n    -moz-transition: height .1s ease-out;\n    transition: height .1s ease-out;\n    -webkit-transition: overflow .1s linear;\n    -o-transition: overflow .1s linear;\n    -moz-transition: overflow .1s linear;\n    transition: overflow .1s linear\n}\n\n.dg li:not(.folder) {\n    cursor: auto;\n    height: 27px;\n    line-height: 27px;\n    padding: 0 4px 0 5px\n}\n\n.dg li.folder {\n    padding: 0;\n    border-left: 4px solid transparent\n}\n\n.dg li.title {\n    cursor: pointer;\n    margin-left: -4px\n}\n\n.dg .closed li:not(.title),\n.dg .closed ul li,\n.dg .closed ul li>* {\n    height: 0;\n    overflow: hidden;\n    border: 0\n}\n\n.dg .cr {\n    clear: both;\n    padding-left: 3px;\n    height: 27px;\n    overflow: hidden\n}\n\n.dg .property-name {\n    cursor: default;\n    float: left;\n    clear: left;\n    width: 40%;\n    overflow: hidden;\n    text-overflow: ellipsis\n}\n\n.dg .c {\n    float: left;\n    width: 60%;\n    position: relative\n}\n\n.dg .c input[type=text] {\n    border: 0;\n    margin-top: 4px;\n    padding: 3px;\n    width: 100%;\n    float: right\n}\n\n.dg .has-slider input[type=text] {\n    width: 30%;\n    margin-left: 0\n}\n\n.dg .slider {\n    float: left;\n    width: 66%;\n    margin-left: -5px;\n    margin-right: 0;\n    height: 19px;\n    margin-top: 4px\n}\n\n.dg .slider-fg {\n    height: 100%\n}\n\n.dg .c input[type=checkbox] {\n    margin-top: 7px\n}\n\n.dg .c select {\n    margin-top: 5px\n}\n\n.dg .cr.function,\n.dg .cr.function .property-name,\n.dg .cr.function *,\n.dg .cr.boolean,\n.dg .cr.boolean * {\n    cursor: pointer\n}\n\n.dg .cr.color {\n    overflow: visible\n}\n\n.dg .selector {\n    display: none;\n    position: absolute;\n    margin-left: -9px;\n    margin-top: 23px;\n    z-index: 10\n}\n\n.dg .c:hover .selector,\n.dg .selector.drag {\n    display: block\n}\n\n.dg li.save-row {\n    padding: 0\n}\n\n.dg li.save-row .button {\n    display: inline-block;\n    padding: 0px 6px\n}\n\n.dg.dialogue {\n    background-color: #222;\n    width: 460px;\n    padding: 15px;\n    font-size: 13px;\n    line-height: 15px\n}\n\n#dg-new-constructor {\n    padding: 10px;\n    color: #222;\n    font-family: Monaco, monospace;\n    font-size: 10px;\n    border: 0;\n    resize: none;\n    box-shadow: inset 1px 1px 1px #888;\n    word-wrap: break-word;\n    margin: 12px 0;\n    display: block;\n    width: 440px;\n    overflow-y: scroll;\n    height: 100px;\n    position: relative\n}\n\n#dg-local-explain {\n    display: none;\n    font-size: 11px;\n    line-height: 17px;\n    border-radius: 3px;\n    background-color: #333;\n    padding: 8px;\n    margin-top: 10px\n}\n\n#dg-local-explain code {\n    font-size: 10px\n}\n\n#dat-gui-save-locally {\n    display: none\n}\n\n.dg {\n    color: #eee;\n    font: 11px 'Lucida Grande', sans-serif;\n    text-shadow: 0 -1px 0 #111\n}\n\n.dg.main::-webkit-scrollbar {\n    width: 5px;\n    background: #1a1a1a\n}\n\n.dg.main::-webkit-scrollbar-corner {\n    height: 0;\n    display: none\n}\n\n.dg.main::-webkit-scrollbar-thumb {\n    border-radius: 5px;\n    background: #676767\n}\n\n.dg li:not(.folder) {\n    background: #1a1a1a;\n    border-bottom: 1px solid #2c2c2c\n}\n\n.dg li.save-row {\n    line-height: 25px;\n    background: #dad5cb;\n    border: 0\n}\n\n.dg li.save-row select {\n    margin-left: 5px;\n    width: 108px\n}\n\n.dg li.save-row .button {\n    margin-left: 5px;\n    margin-top: 1px;\n    border-radius: 2px;\n    font-size: 9px;\n    line-height: 7px;\n    padding: 4px 4px 5px 4px;\n    background: #c5bdad;\n    color: #fff;\n    text-shadow: 0 1px 0 #b0a58f;\n    box-shadow: 0 -1px 0 #b0a58f;\n    cursor: pointer\n}\n\n.dg li.save-row .button.gears {\n    background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;\n    height: 7px;\n    width: 8px\n}\n\n.dg li.save-row .button:hover {\n    background-color: #bab19e;\n    box-shadow: 0 -1px 0 #b0a58f\n}\n\n.dg li.folder {\n    border-bottom: 0\n}\n\n.dg li.title {\n    padding-left: 16px;\n    background: #000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\n    cursor: pointer;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2)\n}\n\n.dg .closed li.title {\n    background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)\n}\n\n.dg .cr.boolean {\n    border-left: 3px solid #806787\n}\n\n.dg .cr.color {\n    border-left: 3px solid\n}\n\n.dg .cr.function {\n    border-left: 3px solid #e61d5f\n}\n\n.dg .cr.number {\n    border-left: 3px solid #2FA1D6\n}\n\n.dg .cr.number input[type=text] {\n    color: #2FA1D6\n}\n\n.dg .cr.string {\n    border-left: 3px solid #1ed36f\n}\n\n.dg .cr.string input[type=text] {\n    color: #1ed36f\n}\n\n.dg .cr.function:hover,\n.dg .cr.boolean:hover {\n    background: #111\n}\n\n.dg .c input[type=text] {\n    background: #303030;\n    outline: none\n}\n\n.dg .c input[type=text]:hover {\n    background: #3c3c3c\n}\n\n.dg .c input[type=text]:focus {\n    background: #494949;\n    color: #fff\n}\n\n.dg .c .slider {\n    background: #303030;\n    cursor: ew-resize\n}\n\n.dg .c .slider-fg {\n    background: #2FA1D6;\n    max-width: 100%\n}\n\n.dg .c .slider:hover {\n    background: #3c3c3c\n}\n\n.dg .c .slider:hover .slider-fg {\n    background: #44abda\n}", ""]), t.exports = e
            }, function(t, e, n) {
                var i = n(43);
                "string" == typeof(i = i.__esModule ? i.default : i) && (i = [
                    [t.i, i, ""]
                ]);
                var r = {
                    insert: "head",
                    singleton: !1
                };
                n(17)(i, r), i.locals && (t.exports = i.locals)
            }, function(t, e, n) {
                (e = n(16)(!1)).push([t.i, '#canvas {\n  width: 100%;\n  height: 100%;\n\n  transition: filter 3s ease;\n}\n\n.statsBox {\n  height: 48px;\n  opacity: 0.9;\n  z-index: 5;\n  cursor: cell;\n}\n\n.statsBox,\n.dg.ac .dg.main.a .dg .title {\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3);\n}\n\n.dg.ac {\n  top: 48px;\n  user-select: none;\n  display: none;\n}\n\n.dg.ac .close-button.close-bottom {\n  display: none;\n}\n\n/* .info-column{\n    height: 100vh;\n    position: absolute;\n    display: flex;\n    justify-content: center;\n    flex-direction: column;\n} */\n\n.info-box {\n  display: flex;\n  flex-direction: column;\n}\n\n.info-card {\n  z-index: 3;\n  color: #fff;\n  border-radius: 3px;\n  text-shadow: 1px 1px 1px #000, 0px 1px 3px #000;\n  background: #0000;\n  overflow: hidden;\n  top: 80px;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: flex-start;\n  margin: 10px;\n  font-family: "Cutive Mono", monospace;\n  user-select: none;\n  pointer-events: none;\n  transition: all 0.3s ease;\n  overflow: visible;\n}\n\n.info-title {\n  font-weight: bold;\n  font-size: 18px;\n  margin-bottom: 8px;\n}\n\n.info-row {\n  margin-bottom: 10px;\n  display: flex;\n  align-items: center;\n}\n\n.info-card .keyboard {\n  position: absolute;\n  left: 12px;\n  top: 8px;\n  height: 30px;\n}\n\n.info-card .mouse {\n  max-height: 34px;\n  margin: -2px 0px;\n}\n\n.info-card .key {\n  text-shadow: none;\n  font-weight: bold;\n  display: inline-block;\n  font-family: "Cutive Mono", monospace;\n  padding: 2px 5px;\n  margin-right: 2px;\n  min-width: 10px;\n  text-align: center;\n  margin-left: 2px;\n  background: #eff0f2;\n  box-shadow: inset 0 0 25px #e8e8e8, 0 1px 0 #c3c3c3, 0 2px 0 #c9c9c9,\n    0 2px 3px #000;\n  color: #111;\n  border-radius: 2px;\n  font-size: 14px;\n}\n\n.ctrl-desc {\n  margin-left: 5px;\n}\n\n.controls-card .menu-arrow {\n  position: absolute;\n  right: 8px;\n  height: 24px;\n  top: 14px;\n  transition: all 0.2s ease;\n  transform: rotate(180deg);\n}\n\n#loader {\n  z-index: 6;\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  /* background: rgba(0,0,0,0.5); */\n  display: flex;\n  justify-content: flex-start;\n  align-items: flex-end;\n  padding: 20px;\n  font-size: 30px;\n  font-family: "Averia Sans Libre", cursive;\n  color: white;\n  text-shadow: 0px 1px 1px black, 0px 0px 4px black;\n}\n\n#debug-menu {\n  position: absolute;\n}\n', ""]), t.exports = e
            }, function(t, e) {
                var n;
                n = function() {
                    return this
                }();
                try {
                    n = n || new Function("return this")()
                } catch (t) {
                    "object" == typeof window && (n = window)
                }
                t.exports = n
            }, function(t, e) {
                t.exports = function(t) {
                    return t.webpackPolyfill || (t.deprecate = function() {}, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, "loaded", {
                        enumerable: !0,
                        get: function() {
                            return t.l
                        }
                    }), Object.defineProperty(t, "id", {
                        enumerable: !0,
                        get: function() {
                            return t.i
                        }
                    }), t.webpackPolyfill = 1), t
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(18),
                    r = n(0);
                class o extends i.FollowTarget {
                    constructor(t, e) {
                        super(t.object, 0), this.reverse = !1, this.nodeRadius = e, this.targetNode = t
                    }
                    update(t) {
                        super.update(t);
                        let e = new r.Vector3,
                            n = new r.Vector3;
                        this.character.getWorldPosition(e), this.target.getWorldPosition(n), (new r.Vector3).subVectors(n, e).length() < this.nodeRadius && (this.reverse ? (super.setTarget(this.targetNode.previousNode.object), this.targetNode = this.targetNode.previousNode) : (super.setTarget(this.targetNode.nextNode.object), this.targetNode = this.targetNode.nextNode))
                    }
                }
                e.FollowPath = o
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(0);
                e.RandomBehaviour = class {
                    constructor() {
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 100;
                        this.randomFrequency = t
                    }
                    update(t) {
                        let e = Math.floor(Math.random() * this.randomFrequency),
                            n = Math.random() > .5;
                        0 === e ? (this.character.setViewVector(new i.Vector3(Math.random() - .5, Math.random() - .5, Math.random() - .5)), this.character.triggerAction("up", !0), this.character.charState.update(t), this.character.triggerAction("up", !1)) : 1 === e ? this.character.triggerAction("up", n) : 2 === e ? this.character.triggerAction("run", n) : 3 === e && this.character.triggerAction("jump", n)
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(1),
                    r = n(0),
                    o = n(3),
                    s = n(9);
                e.ConvexPhysics = class {
                    constructor(t, e) {
                        this.mesh = t.clone();
                        let n = {
                            mass: 0,
                            position: t.position,
                            friction: .3
                        };
                        e = o.setDefaults(e, n), this.options = e;
                        let r = new i.Material("convMat");
                        r.friction = e.friction, this.mesh.geometry.isBufferGeometry && (this.mesh.geometry = (new s.Geometry).fromBufferGeometry(this.mesh.geometry));
                        let a = this.mesh.geometry.vertices.map((t => new i.Vec3(t.x, t.y, t.z))),
                            l = this.mesh.geometry.faces.map((t => [t.a, t.b, t.c])),
                            c = new i.ConvexPolyhedron(a, l),
                            h = new i.Body({
                                mass: e.mass,
                                position: e.position,
                                shape: c
                            });
                        h.material = r, this.physical = h, this.visual = this.getVisualModel({
                            visible: !1,
                            wireframe: !0
                        })
                    }
                    getVisualModel(t) {
                        t = o.setDefaults(t, {
                            visible: !0,
                            wireframe: !0
                        });
                        let e = new r.MeshLambertMaterial({
                                color: 13421772,
                                wireframe: t.wireframe
                            }),
                            n = this.mesh.clone();
                        return n.material = e, n.visible = t.visible, t.wireframe || (n.castShadow = !0, n.receiveShadow = !0), n
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(1),
                    r = n(0),
                    o = n(3);
                e.SpherePhysics = class {
                    constructor(t) {
                        let e = {
                            mass: 0,
                            position: new i.Vec3,
                            radius: .3,
                            friction: .3
                        };
                        t = o.setDefaults(t, e), this.options = t;
                        let n = new i.Material("sphereMat");
                        n.friction = t.friction;
                        let r = new i.Sphere(t.radius),
                            s = new i.Body({
                                mass: t.mass,
                                position: t.position,
                                shape: r
                            });
                        s.material = n, this.physical = s, this.visual = this.getVisualModel({
                            visible: !1,
                            wireframe: !0
                        })
                    }
                    getVisualModel(t) {
                        t = o.setDefaults(t, {
                            visible: !0,
                            wireframe: !0
                        });
                        let e = new r.SphereGeometry(this.options.radius),
                            n = new r.MeshLambertMaterial({
                                color: 13421772,
                                wireframe: t.wireframe
                            }),
                            i = new r.Mesh(e, n);
                        return i.visible = t.visible, t.wireframe || (i.castShadow = !0, i.receiveShadow = !0), i
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(3),
                    r = n(2),
                    o = -12;
                e.CharacterStateBase = class {
                    constructor(t) {
                        this.character = t, this.character.velocitySimulator.damping = this.character.defaultVelocitySimulatorDamping, this.character.velocitySimulator.mass = this.character.defaultVelocitySimulatorMass, this.character.rotationSimulator.damping = this.character.defaultRotationSimulatorDamping, this.character.rotationSimulator.mass = this.character.defaultRotationSimulatorMass, this.character.arcadeVelocityIsAdditive = !1, this.character.setArcadeVelocityInfluence(1, 0, 1), this.canFindVehiclesToEnter = !0, this.canEnterVehicles = !1, this.canLeaveVehicles = !0, this.timer = 0
                    }
                    update(t) {
                        this.timer += t
                    }
                    onInputChange() {}
                    noDirection() {
                        return !(this.character.actions.up.isPressed || this.character.actions.down.isPressed || this.character.actions.left.isPressed || this.character.actions.right.isPressed)
                    }
                    anyDirection() {
                        return this.character.actions.up.isPressed || this.character.actions.down.isPressed || this.character.actions.left.isPressed || this.character.actions.right.isPressed
                    }
                    fallInAir() {
                        this.character.rayHasHit || this.character.setState(new r.Falling(this.character))
                    }
                    animationEnded(t) {
                        return void 0 === this.character.mixer || (void 0 === this.animationLength ? (console.error(this.constructor.name + "Error: Set this.animationLength in state constructor!"), !1) : this.timer > this.animationLength - t)
                    }
                    setAppropriateDropState() {
                        this.character.groundImpactData.velocity.y < o ? this.character.setState(new r.DropRolling(this.character)) : this.anyDirection() ? this.character.groundImpactData.velocity.y < -2 ? this.character.setState(new r.DropRunning(this.character)) : this.character.actions.run.isPressed ? this.character.setState(new r.Sprint(this.character)) : this.character.setState(new r.Walk(this.character)) : this.character.setState(new r.DropIdle(this.character))
                    }
                    setAppropriateStartWalkState() {
                        let t = Math.PI,
                            e = i.getSignedAngleBetweenVectors(this.character.orientation, this.character.getCameraRelativeMovementVector());
                        e > .8 * t ? this.character.setState(new r.StartWalkBackLeft(this.character)) : e < .8 * -t ? this.character.setState(new r.StartWalkBackRight(this.character)) : e > .3 * t ? this.character.setState(new r.StartWalkLeft(this.character)) : e < .3 * -t ? this.character.setState(new r.StartWalkRight(this.character)) : this.character.setState(new r.StartWalkForward(this.character))
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.character.velocitySimulator.damping = .5, this.character.velocitySimulator.mass = 7, this.character.setArcadeVelocityTarget(0), this.animationLength = this.character.setAnimation("drop_idle", .1), this.anyDirection() && this.character.setState(new i.StartWalkForward(t))
                    }
                    update(t) {
                        super.update(t), this.character.setCameraRelativeOrientationTarget(), this.animationEnded(t) && this.character.setState(new i.Idle(this.character)), this.fallInAir()
                    }
                    onInputChange() {
                        super.onInputChange(), this.character.actions.jump.justPressed && this.character.setState(new i.JumpIdle(this.character)), this.anyDirection() && this.character.setState(new i.StartWalkForward(this.character))
                    }
                }
                e.DropIdle = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.character.velocitySimulator.mass = 1, this.character.velocitySimulator.damping = .6, this.character.setArcadeVelocityTarget(.8), this.animationLength = this.character.setAnimation("drop_running_roll", .03)
                    }
                    update(t) {
                        super.update(t), this.character.setCameraRelativeOrientationTarget(), this.animationEnded(t) && (this.anyDirection() ? this.character.setState(new i.Walk(this.character)) : this.character.setState(new i.EndWalk(this.character)))
                    }
                }
                e.DropRolling = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.character.setArcadeVelocityTarget(.8), this.animationLength = this.character.setAnimation("drop_running", .1)
                    }
                    update(t) {
                        super.update(t), this.character.setCameraRelativeOrientationTarget(), this.animationEnded(t) && this.character.setState(new i.Walk(this.character))
                    }
                    onInputChange() {
                        super.onInputChange(), this.noDirection() && this.character.setState(new i.EndWalk(this.character)), this.anyDirection() && this.character.actions.run.justPressed && this.character.setState(new i.Sprint(this.character)), this.character.actions.jump.justPressed && this.character.setState(new i.JumpRunning(this.character))
                    }
                }
                e.DropRunning = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.character.setArcadeVelocityTarget(0), this.animationLength = t.setAnimation("stop", .1)
                    }
                    update(t) {
                        super.update(t), this.animationEnded(t) && this.character.setState(new i.Idle(this.character)), this.fallInAir()
                    }
                    onInputChange() {
                        super.onInputChange(), this.character.actions.jump.justPressed && this.character.setState(new i.JumpIdle(this.character)), this.anyDirection() && (this.character.actions.run.isPressed ? this.character.setState(new i.Sprint(this.character)) : this.character.velocity.length() > .5 ? this.character.setState(new i.Walk(this.character)) : this.setAppropriateStartWalkState())
                    }
                }
                e.EndWalk = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.character.velocitySimulator.mass = 100, this.character.rotationSimulator.damping = .3, this.character.arcadeVelocityIsAdditive = !0, this.character.setArcadeVelocityInfluence(.05, 0, .05), this.character.setAnimation("falling", .3)
                    }
                    update(t) {
                        super.update(t), this.character.setCameraRelativeOrientationTarget(), this.character.arcadeVelocityIsAdditive = !0, this.character.setArcadeVelocityTarget(this.anyDirection() ? .25 : 0), this.character.rayHasHit && this.setAppropriateDropState()
                    }
                }
                e.Falling = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.character.rotationSimulator.mass = 30, this.character.rotationSimulator.damping = .6, this.character.velocitySimulator.damping = .6, this.character.velocitySimulator.mass = 10, this.character.setArcadeVelocityTarget(0), this.animationLength = this.character.setAnimation("rotate_left", .1)
                    }
                    update(t) {
                        super.update(t), this.animationEnded(t) && this.character.setState(new i.Idle(this.character)), this.fallInAir()
                    }
                    onInputChange() {
                        super.onInputChange(), this.character.actions.jump.justPressed && this.character.setState(new i.JumpIdle(this.character)), this.anyDirection() && (this.character.velocity.length() > .5 ? this.character.setState(new i.Walk(this.character)) : this.setAppropriateStartWalkState())
                    }
                }
                e.IdleRotateLeft = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.character.rotationSimulator.mass = 30, this.character.rotationSimulator.damping = .6, this.character.velocitySimulator.damping = .6, this.character.velocitySimulator.mass = 10, this.character.setArcadeVelocityTarget(0), this.animationLength = this.character.setAnimation("rotate_right", .1)
                    }
                    update(t) {
                        super.update(t), this.animationEnded(t) && this.character.setState(new i.Idle(this.character)), this.fallInAir()
                    }
                    onInputChange() {
                        super.onInputChange(), this.character.actions.jump.justPressed && this.character.setState(new i.JumpIdle(this.character)), this.anyDirection() && (this.character.velocity.length() > .5 ? this.character.setState(new i.Walk(this.character)) : this.setAppropriateStartWalkState())
                    }
                }
                e.IdleRotateRight = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2),
                    r = 0;
                class o extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.character.velocitySimulator.mass = 50, this.character.setArcadeVelocityTarget(0), this.animationLength = this.character.setAnimation("jump_idle", .1), this.alreadyJumped = !1
                    }
                    update(t) {
                        super.update(t), this.alreadyJumped && (this.character.setCameraRelativeOrientationTarget(), this.character.arcadeVelocityIsAdditive = !0, this.character.setArcadeVelocityTarget(this.anyDirection() ? .8 : 0)), this.timer > r && !this.alreadyJumped ? (this.character.jump(), this.alreadyJumped = !0, this.character.velocitySimulator.mass = 100, this.character.rotationSimulator.damping = .3, this.character.setArcadeVelocityInfluence(.3, 0, .3)) : this.timer > .3 && this.character.rayHasHit ? this.setAppropriateDropState() : this.timer > this.animationLength - t && this.character.setState(new i.Falling(this.character))
                    }
                }
                e.JumpIdle = o
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2),
                    r = 0;
                class o extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.character.velocitySimulator.mass = 100, this.animationLength = this.character.setAnimation("jump_running", .03), this.alreadyJumped = !1
                    }
                    update(t) {
                        super.update(t), this.character.setCameraRelativeOrientationTarget(), this.alreadyJumped && (this.character.arcadeVelocityIsAdditive = !0, this.character.setArcadeVelocityTarget(this.anyDirection() ? .25 : 0)), this.timer > r && !this.alreadyJumped ? (this.character.jump(4), this.alreadyJumped = !0, this.character.rotationSimulator.damping = .3, this.character.arcadeVelocityIsAdditive = !0, this.character.setArcadeVelocityInfluence(.05, 0, .05)) : this.timer > .24 && this.character.rayHasHit ? this.setAppropriateDropState() : this.timer > this.animationLength - t && this.character.setState(new i.Falling(this.character))
                    }
                }
                e.JumpRunning = o
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.canEnterVehicles = !0, this.character.velocitySimulator.mass = 10, this.character.rotationSimulator.damping = .8, this.character.rotationSimulator.mass = 50, this.character.setArcadeVelocityTarget(1.4), this.character.setAnimation("sprint", .1)
                    }
                    update(t) {
                        super.update(t), this.character.setCameraRelativeOrientationTarget(), this.fallInAir()
                    }
                    onInputChange() {
                        super.onInputChange(), this.character.actions.run.isPressed || this.character.setState(new i.Walk(this.character)), this.character.actions.jump.justPressed && this.character.setState(new i.JumpRunning(this.character)), this.noDirection() && this.character.setState(new i.EndWalk(this.character))
                    }
                }
                e.Sprint = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(3),
                    r = n(2);
                class o extends r.CharacterStateBase {
                    constructor(t) {
                        super(t), this.canEnterVehicles = !0, this.character.rotationSimulator.mass = 20, this.character.rotationSimulator.damping = .7, this.character.setArcadeVelocityTarget(.8)
                    }
                    update(t) {
                        super.update(t), this.animationEnded(t) && this.character.setState(new r.Walk(this.character)), this.character.setCameraRelativeOrientationTarget(), this.fallInAir()
                    }
                    onInputChange() {
                        if (super.onInputChange(), this.character.actions.jump.justPressed && this.character.setState(new r.JumpRunning(this.character)), this.noDirection())
                            if (this.timer < .1) {
                                let t = i.getSignedAngleBetweenVectors(this.character.orientation, this.character.orientationTarget);
                                t > .4 * Math.PI ? this.character.setState(new r.IdleRotateLeft(this.character)) : t < .4 * -Math.PI ? this.character.setState(new r.IdleRotateRight(this.character)) : this.character.setState(new r.Idle(this.character))
                            } else this.character.setState(new r.Idle(this.character));
                        this.character.actions.run.justPressed && this.character.setState(new r.Sprint(this.character))
                    }
                }
                e.StartWalkBase = o
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.StartWalkBase {
                    constructor(t) {
                        super(t), this.animationLength = t.setAnimation("start_back_left", .1)
                    }
                }
                e.StartWalkBackLeft = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.StartWalkBase {
                    constructor(t) {
                        super(t), this.animationLength = t.setAnimation("start_back_right", .1)
                    }
                }
                e.StartWalkBackRight = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.StartWalkBase {
                    constructor(t) {
                        super(t), this.animationLength = t.setAnimation("start_forward", .1)
                    }
                }
                e.StartWalkForward = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.StartWalkBase {
                    constructor(t) {
                        super(t), this.animationLength = t.setAnimation("start_left", .1)
                    }
                }
                e.StartWalkLeft = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.StartWalkBase {
                    constructor(t) {
                        super(t), this.animationLength = t.setAnimation("start_right", .1)
                    }
                }
                e.StartWalkRight = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2);
                class r extends i.CharacterStateBase {
                    constructor(t) {
                        super(t), this.canEnterVehicles = !0, this.character.setArcadeVelocityTarget(.8), this.character.setAnimation("run", .1)
                    }
                    update(t) {
                        super.update(t), this.character.setCameraRelativeOrientationTarget(), this.fallInAir()
                    }
                    onInputChange() {
                        super.onInputChange(), this.noDirection() && this.character.setState(new i.EndWalk(this.character)), this.character.actions.dance.justPressed && this.character.setState(new i.Dance(this.character)), this.character.actions.run.isPressed && this.character.setState(new i.Sprint(this.character)), this.character.actions.run.justPressed && this.character.setState(new i.Sprint(this.character)), this.character.actions.jump.justPressed && this.character.setState(new i.JumpRunning(this.character)), this.noDirection() && (this.character.velocity.length() > 1 ? this.character.setState(new i.EndWalk(this.character)) : this.character.setState(new i.Idle(this.character)))
                    }
                }
                e.Walk = r
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(0),
                    r = n(12),
                    o = n(69),
                    s = n(3);
                class a extends r.SimulatorBase {
                    constructor(t, e, n) {
                        super(t, e, n), this.init()
                    }
                    init() {
                        this.position = new i.Vector3, this.velocity = new i.Vector3, this.target = new i.Vector3, this.cache = [];
                        for (let t = 0; t < 2; t++) this.cache.push(new o.SimulationFrameVector(new i.Vector3, new i.Vector3))
                    }
                    simulate(t) {
                        this.generateFrames(t), this.position.lerpVectors(this.cache[0].position, this.cache[1].position, this.offset / this.frameTime), this.velocity.lerpVectors(this.cache[0].velocity, this.cache[1].velocity, this.offset / this.frameTime)
                    }
                    getFrame(t) {
                        let e = new o.SimulationFrameVector(this.lastFrame().position.clone(), this.lastFrame().velocity.clone());
                        return s.springV(e.position, this.target, e.velocity, this.mass, this.damping), e
                    }
                }
                e.VectorSpringSimulator = a
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.SimulationFrameVector = class {
                    constructor(t, e) {
                        this.position = t, this.velocity = e
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(0),
                    r = n(12),
                    o = n(3);
                class s extends r.SimulatorBase {
                    constructor(t, e, n) {
                        let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                        super(t, e, n), this.position = i, this.velocity = r, this.target = 0, this.lastLerp = 0, this.cache = [];
                        for (let o = 0; o < 2; o++) this.cache.push({
                            position: i,
                            velocity: r
                        })
                    }
                    simulate(t) {
                        this.generateFrames(t);
                        let e = i.MathUtils.lerp(0, this.cache[1].position, this.offset / this.frameTime);
                        this.position = e - this.lastLerp, this.lastLerp = e, this.velocity = i.MathUtils.lerp(this.cache[0].velocity, this.cache[1].velocity, this.offset / this.frameTime)
                    }
                    getFrame(t) {
                        let e = Object.assign({}, this.lastFrame());
                        return t && (e.position = 0, this.lastLerp = this.lastLerp - this.lastFrame().position), o.spring(e.position, this.target, e.velocity, this.mass, this.damping)
                    }
                }
                e.RelativeSpringSimulator = s
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2),
                    r = n(8),
                    o = n(14);
                class s extends i.CharacterStateBase {
                    constructor(t, e) {
                        super(t), this.seat = e, this.canFindVehiclesToEnter = !1, this.canLeaveVehicles = !1, e.doorSide === r.Side.Left ? this.animationLength = this.character.setAnimation("close_door_sitting_left", .1) : e.doorSide === r.Side.Right && (this.animationLength = this.character.setAnimation("close_door_sitting_right", .1))
                    }
                    update(t) {
                        super.update(t), this.timer > .3 && this.seat.closeDoor(), this.timer > this.animationLength - t && this.character.setState(new o.Sitting(this.character))
                    }
                }
                e.CloseVehicleDoorInside = s
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2),
                    r = n(8),
                    o = n(0),
                    s = n(7),
                    a = n(73);
                class l extends i.CharacterStateBase {
                    constructor(t, e, n) {
                        super(t), this.startPosition = new o.Vector3, this.endPosition = new o.Vector3, this.startRotation = new o.Quaternion, this.endRotation = new o.Quaternion, this.canFindVehiclesToEnter = !1, this.vehicle = e, this.seat = n, this.seat.openDoor(), this.startPosition.copy(this.character.position), this.endPosition.copy(n.entryPoint.position), this.endPosition.y += .6, this.startRotation.copy(this.character.quaternion), this.endRotation.copy(n.entryPoint.quaternion), n.doorSide === r.Side.Left ? this.animationLength = this.character.setAnimation("stand_up_left", .1) : n.doorSide === r.Side.Right && (this.animationLength = this.character.setAnimation("stand_up_right", .1))
                    }
                    update(t) {
                        if (super.update(t), this.timer > this.animationLength - t) this.character.controlledObject = void 0, this.character.controlledObjectSeat = void 0, this.vehicle.controllingCharacter = void 0, this.character.world.graphicsWorld.attach(this.character), this.character.resetVelocity(), this.character.resetOrientation(), this.character.setPhysicsEnabled(!0), this.anyDirection() || void 0 === this.seat.door ? this.character.setState(new s.Idle(this.character)) : this.character.setState(new a.CloseVehicleDoorOutside(this.character, this.seat));
                        else {
                            let t = this.timer / this.animationLength,
                                e = 1 - (.5 * Math.cos(t * Math.PI) + .5),
                                n = (new o.Vector3).lerpVectors(this.startPosition, this.endPosition, e);
                            this.character.setPosition(n.x, n.y, n.z)
                        }
                    }
                }
                e.ExitingVehicle = l
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2),
                    r = n(8),
                    o = n(7);
                class s extends i.CharacterStateBase {
                    constructor(t, e) {
                        super(t), this.seat = e, this.canFindVehiclesToEnter = !1, e.doorSide === r.Side.Left ? this.animationLength = this.character.setAnimation("close_door_standing_right", .1) : e.doorSide === r.Side.Right && (this.animationLength = this.character.setAnimation("close_door_standing_left", .1))
                    }
                    update(t) {
                        super.update(t), this.timer > .3 && this.seat.closeDoor(), this.timer > this.animationLength - t && this.character.setState(new o.Idle(this.character))
                    }
                }
                e.CloseVehicleDoorOutside = s
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(2),
                    r = n(8),
                    o = n(7),
                    s = n(32),
                    a = n(0);
                class l extends i.CharacterStateBase {
                    constructor(t, e) {
                        super(t), this.canFindVehiclesToEnter = !1, this.seat = e, e.doorSide === r.Side.Left ? this.animationLength = this.character.setAnimation("open_door_standing_right", .1) : e.doorSide === r.Side.Right && (this.animationLength = this.character.setAnimation("open_door_standing_left", .1)), this.character.resetVelocity()
                    }
                    update(t) {
                        super.update(t);
                        const e = this.seat.entryPoint.matrixWorld.elements;
                        let n = new a.Vector3(e[8], e[9], e[10]);
                        this.character.setOrientation(n), this.timer > .3 && this.seat.openDoor(), this.timer > this.animationLength - t && (this.anyDirection() ? this.character.setState(new o.Idle(this.character)) : this.character.setState(new s.EnteringVehicle(this.character, this.seat)))
                    }
                }
                e.OpenVehicleDoor = l
            }, function(t) {
                t.exports = JSON.parse('[{"id":"crown_red","name":"Crown","url":"build/assets/hats/crown_red.glb","scaleFactor":0.7,"positionOffset":{"x":0,"y":0.03,"z":0}},{"id":"santa","name":"Crown","url":"build/assets/hats/santa.glb","scaleFactor":0.5,"positionOffset":{"x":0,"y":0,"z":0}}]')
            }, function(t, e, n) {
                "use strict";
                var i = this && this.__awaiter || function(t, e, n, i) {
                    return new(n || (n = Promise))((function(r, o) {
                        function s(t) {
                            try {
                                l(i.next(t))
                            } catch (t) {
                                o(t)
                            }
                        }

                        function a(t) {
                            try {
                                l(i.throw(t))
                            } catch (t) {
                                o(t)
                            }
                        }

                        function l(t) {
                            var e;
                            t.done ? r(t.value) : (e = t.value, e instanceof n ? e : new n((function(t) {
                                t(e)
                            }))).then(s, a)
                        }
                        l((i = i.apply(t, e || [])).next())
                    }))
                };
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const r = n(0),
                    o = n(1),
                    s = n(77),
                    a = n(78),
                    l = n(79),
                    c = n(85),
                    h = n(86),
                    u = n(87),
                    d = n(88),
                    p = n(89),
                    f = n(13),
                    m = n(31),
                    g = n(20),
                    v = n(3),
                    y = n(22),
                    x = n(90),
                    b = n(11),
                    w = n(37),
                    _ = n(28),
                    S = n(23),
                    M = n(29),
                    A = n(0),
                    T = n(33);
                e.World = class {
                    constructor(t) {
                        this.paths = {}, this.customUpdates = [], this.videoMap = new Map, this.audioMap = new Map, this.quality = .5, this.isProximityChatEnabled = !1, this.raycastObjects = [], this.defaultSkinGlbUrl = "build/assets/boxman.glb";
                        const e = this;
                        t && t.initialCharacterSkinURL && (this.defaultSkinGlbUrl = t.initialCharacterSkinURL), h.Detector.webgl || h.Detector.addGetWebGLMessage(), this.loadingManager = new w.LoadingManager(this), this.renderer = new r.WebGLRenderer({
                            alpha: !0
                        }), this.renderer.outputEncoding = r.GammaEncoding, this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(Math.floor(window.innerWidth * this.quality), Math.floor(window.innerHeight * this.quality)), document.body.appendChild(this.renderer.domElement), this.renderer.domElement.id = "canvas", this.renderer.domElement.style.position = "absolute", this.renderer.domElement.style.zIndex = "1", this.renderer.domElement.style.top = "0", this.renderer.domElement.style.width = "100%", this.renderer.domElement.style.height = "100%", window.addEventListener("resize", (function() {
                            e.camera.aspect = window.innerWidth / window.innerHeight, e.camera.updateProjectionMatrix();
                            let t = Math.floor(window.innerWidth * e.quality),
                                n = Math.floor(window.innerHeight * e.quality);
                            e.renderer.setSize(t, n, !1), c.uniforms.resolution.value.set(1 / (t * u), 1 / (n * u)), e.composer.setSize(t * u, n * u)
                        }), !1), this.graphicsWorld = new r.Scene, this.camera = new r.PerspectiveCamera(45, window.innerWidth / window.innerHeight, .1, 610);
                        let n = new r.AmbientLight(9415106);
                        this.graphicsWorld.add(n);
                        var i = new r.DirectionalLight(16777215, .1);
                        this.graphicsWorld.add(i);
                        let c = new l.ShaderPass(a.FXAAShader),
                            u = void 0 !== window.devicePixelRatio ? window.devicePixelRatio : 1;
                        c.uniforms.resolution.value.set(1 / (window.innerWidth * u), 1 / (window.innerHeight * u)), this.composer = new l.default(this.renderer), this.composer.addPass(new l.RenderPass(this.graphicsWorld, this.camera)), this.physicsWorld = new o.World, this.physicsWorld.gravity.set(0, -9.81, 0), this.physicsWorld.broadphase = new o.SAPBroadphase(this.physicsWorld), this.physicsWorld.solver.iterations = 10, this.physicsWorld.allowSleep = !0, this.parallelPairs = [], this.physicsFrameRate = 60, this.physicsFrameTime = 1 / this.physicsFrameRate, this.physicsMaxPrediction = this.physicsFrameRate, this.clock = new r.Clock, this.renderDelta = 0, this.logicDelta = 0, this.sinceLastFrame = 0, this.justRendered = !1, this.params = {
                            Pointer_Lock: !0,
                            Mouse_Sensitivity: .3,
                            FPS_Limit: 60,
                            Time_Scale: 1,
                            Shadows: !1,
                            FXAA: !1,
                            Draw_Physics: !1,
                            RayCast_Debug: !1,
                            Phi: 60,
                            Theta: 225
                        }, this.getGUI(e).open(), this.timeScaleTarget = 1, this.balls = [], this.objects = [], this.characters = [], this.vehicles = [], this.cameraOperator = new s.CameraOperator(this, this.camera, this.params.Mouse_Sensitivity), this.inputManager = new p.InputManager(this, this.renderer.domElement), this.render(this)
                    }
                    update(t, e) {
                        this.updatePhysics(t), this.updateProximityChatVolumes(), this.objects.forEach((e => {
                            e.update(t)
                        })), this.characters.forEach((e => {
                            e.update(t), e.updateMatrixWorld()
                        })), this.vehicles.forEach((e => {
                            e.update(t)
                        })), this.inputManager.update(t), this.params.Time_Scale = r.MathUtils.lerp(this.params.Time_Scale, this.timeScaleTarget, .2), this.cameraOperator.update(), void 0 !== this.waterMat && (this.waterMat.uniforms.cameraPos.value.copy(this.camera.position), this.waterMat.uniforms.lightDir.value.copy((new r.Vector3).copy(this.sky.sun.position).normalize()), this.waterMat.uniforms.iGlobalTime.value += t), void 0 !== this.grassMat && (this.grassMat.uniforms.time.value += t, this.characters.length > 0 && this.grassMat.uniforms.playerPos.value.copy(this.characters[0].position)), this.physicsWorld.bodies.forEach((t => {
                            t.sleepState, t.sleepState, t.sleepState
                        }))
                    }
                    updatePhysics(t) {
                        this.physicsWorld.step(this.physicsFrameTime, t, this.physicsMaxPrediction), this.objects.forEach((t => {
                            void 0 !== t.physics.physical && (t.physics.physical.position.y < -5 && (t.physics.physical.position.x = 1.13, t.physics.physical.position.y = 5, t.physics.physical.position.z = -2.2, t.physics.physical.interpolatedPosition.x = 1.13, t.physics.physical.interpolatedPosition.y = 5, t.physics.physical.interpolatedPosition.z = -2.2), t.position.copy(v.threeVector(t.physics.physical.position)), t.quaternion.copy(v.threeQuat(t.physics.physical.quaternion)))
                        }))
                    }
                    render(t) {
                        this.requestDelta = this.clock.getDelta(), requestAnimationFrame((() => {
                            t.render(t)
                        }));
                        let e = this.requestDelta + this.renderDelta + this.logicDelta,
                            n = e * this.params.Time_Scale;
                        if (n = Math.min(n, 1 / 30), t.update(n, e), t.customUpdate) {
                            t.customUpdate(n);
                            for (let e = 0; e < t.customUpdates.length; e++) t.customUpdates[e](n)
                        }
                        this.logicDelta = this.clock.getDelta(), this.sinceLastFrame += this.requestDelta + this.renderDelta + this.logicDelta, this.sinceLastFrame %= 1 / 60, this.stats && (this.stats.end(), this.stats.begin()), this.params.FXAA ? this.composer.render() : this.renderer.render(this.graphicsWorld, this.camera), this.renderDelta = this.clock.getDelta()
                    }
                    updateGraphicsQuality(t) {
                        t <= 0 || t > 1 || (this.renderer.setSize(Math.floor(window.innerWidth * t), Math.floor(window.innerHeight * t), !1), this.quality = t)
                    }
                    updateProximityChatVolumes() {
                        if (!this.activeCharacter || !this.isProximityChatEnabled) return;
                        let t = this.activeCharacter.characterCapsule.physics.physical.position;
                        this.characters.forEach((e => {
                            if (e === this.activeCharacter) return;
                            let n = e.characterCapsule.physics.physical.position.distanceTo(t);
                            if (e.audioChatElement) {
                                let t = 1,
                                    s = 3,
                                    a = 8;
                                if (n < s && (t = 1), n > s && n < a && (t = 1 - (n - s) / (a - s)), n > 8 && (t = 0, e.proximityLine && (e.proximityLine.visible = !1)), t > 0) {
                                    if (!e.proximityLine) {
                                        const t = [];
                                        t.push(this.activeCharacter.position), t.push(e.characterCapsule.position);
                                        var i = (new A.BufferGeometry).setFromPoints(t);
                                        let n = new r.LineBasicMaterial({
                                            color: 16777215
                                        });
                                        n.transparent = !0;
                                        const o = new r.Line(i, n);
                                        this.graphicsWorld.add(o), e.proximityLine = o, e.lineMaterial = n
                                    }
                                    var o = e.proximityLine.geometry.attributes.position.array;
                                    o[0] = this.activeCharacter.position.x, o[1] = this.activeCharacter.position.y, o[2] = this.activeCharacter.position.z, o[3] = e.characterCapsule.position.x, o[4] = e.characterCapsule.position.y, o[5] = e.characterCapsule.position.z, e.proximityLine.geometry.attributes.position.needsUpdate = !0, e.proximityLine.visible = !0, e.lineMaterial.opacity = t, e.proximityLine.geometry.computeBoundingBox(), e.proximityLine.geometry.computeBoundingSphere()
                                }
                                t < 0 && (t = 0), t > 1 && (t = 1), e.audioChatElement.volume = t
                            }
                        }))
                    }
                    add(t) {
                        t.addToWorld(this)
                    }
                    remove(t) {
                        t.removeFromWorld(this)
                    }
                    loadScene(t) {
                        this.lastGltf && (T.disposeObjectTree(this.lastGltf), this.balls = [], this.objects = [], this.characters = [], this.vehicles = [], this.raycastObjects = [], this.physicsWorld = new o.World, this.physicsWorld.gravity.set(0, -9.81, 0), this.physicsWorld.broadphase = new o.SAPBroadphase(this.physicsWorld), this.physicsWorld.solver.iterations = 10, this.physicsWorld.allowSleep = !0), this.lastGltf = t.scene, t.scene.traverse((t => {
                            if (t.hasOwnProperty("userData")) {
                                if ("Mesh" === t.type && (v.setupMeshProperties(t), "ocean" === t.material.name)) {
                                    let e = r.UniformsUtils.clone(c.WaterShader.uniforms);
                                    e.iResolution.value.x = window.innerWidth, e.iResolution.value.y = window.innerHeight, t.material = new r.ShaderMaterial({
                                        uniforms: e,
                                        fragmentShader: c.WaterShader.fragmentShader,
                                        vertexShader: c.WaterShader.vertexShader
                                    }), t.material.transparent = !0, this.waterMat = t.material
                                }
                                let e = new A.MeshBasicMaterial({
                                    wireframe: !0,
                                    color: "#000000"
                                });
                                if (t.userData.hasOwnProperty("data")) {
                                    if ("physics" === t.userData.data && t.userData.hasOwnProperty("type")) {
                                        if ("box" === t.userData.type || "box_visible" === t.userData.type) {
                                            let e = new g.BoxPhysics({
                                                size: new r.Vector3(t.scale.x, t.scale.y, t.scale.z)
                                            });
                                            e.physical.position.copy(v.cannonVector(t.position)), e.physical.quaternion.copy(v.cannonQuat(t.quaternion)), e.physical.computeAABB(), e.physical.shapes.forEach((t => {
                                                t.collisionFilterMask = ~b.CollisionGroups.TrimeshColliders
                                            }));
                                            let n = new f.SBObject;
                                            n.setPhysics(e), this.add(n)
                                        } else if ("trimesh" === t.userData.type) {
                                            let e = new y.TrimeshPhysics(t, {}),
                                                n = new f.SBObject;
                                            n.setPhysics(e), this.add(n)
                                        }
                                        "box_visible" !== t.userData.type ? t.visible = !1 : (t.material = e, t.userData.wire_color && t.material.color.set(t.userData.wire_color))
                                    }
                                    if ("pathNode" === t.userData.data) {
                                        let e = t.userData.path;
                                        this.paths.hasOwnProperty(e) || (this.paths[e] = new x.Path), this.paths[e].addNode(t)
                                    }
                                    "spawn" === t.userData.data && ("car" === t.userData.type ? this.loadingManager.loadGLTF("build/assets/car.glb", (e => {
                                        let n = new _.Car(e);
                                        n.setPosition(t.position.x, t.position.y + 1, t.position.z), n.collision.quaternion.copy(v.cannonQuat(t.quaternion)), this.add(n)
                                    })) : "airplane" === t.userData.type ? this.loadingManager.loadGLTF("build/assets/airplane.glb", (e => {
                                        let n = new S.Airplane(e);
                                        n.setPosition(t.position.x, t.position.y + 1, t.position.z), n.collision.quaternion.copy(v.cannonQuat(t.quaternion)), this.add(n)
                                    })) : "heli" === t.userData.type ? this.loadingManager.loadGLTF("build/assets/heli.glb", (e => {
                                        let n = new M.Helicopter(e);
                                        n.setPosition(t.position.x, t.position.y + 1, t.position.z), n.collision.quaternion.copy(v.cannonQuat(t.quaternion)), this.add(n)
                                    })) : "player" === t.userData.type && this.loadingManager.loadGLTF(this.defaultSkinGlbUrl, (e => {
                                        e.scene.traverse((t => {
                                            t.frustumCulled = !1
                                        }));
                                        let n = new m.Character(e);
                                        n.setPosition(t.position.x, t.position.y, t.position.z), this.add(n), n.setOrientation(new r.Vector3(0, 0, 1), !0), n.takeControl(), this.activeCharacter = n, this.onCharacterLoaded()
                                    })))
                                }
                                t.userData.hasOwnProperty("raycast") && (this.raycastObjects.push(t), t.visible = !0, t.material && (t.material.visible = !1))
                            }
                        }));
                        for (const e in this.paths) this.paths.hasOwnProperty(e) && this.paths[e].connectNodes();
                        this.graphicsWorld.add(t.scene)
                    }
                    loadStats(t) {
                        this.stats = u.Stats();
                        let e = t.getElementsByClassName("statsBox");
                        if (e.length > 1)
                            for (let n = 0; n < e.length; n++)
                                for (; e.length > 0;) e[0].parentNode.removeChild(e[0]);
                        t.appendChild(this.stats.dom)
                    }
                    addBots(t) {
                        return i(this, void 0, void 0, (function*() {
                            for (let e = 0; e < t; e++) this.addBot()
                        }))
                    }
                    addBot() {
                        this.loadingManager.loadGLTF("build/assets/boxman.glb", (t => {
                            t.scene.traverse((t => {
                                t.frustumCulled = !1
                            }));
                            let e = new m.Character(t);
                            e.setPosition(this.activeCharacter.position.x, this.activeCharacter.position.y + 4, this.activeCharacter.position.z - 5 * Math.random()), this.add(e), e.setOrientation(new r.Vector3(0, 0, 1), !0)
                        }))
                    }
                    addFloor() {
                        let t = new f.SBObject,
                            e = new g.BoxPhysics({
                                size: new r.Vector3(100, 1, 100)
                            });
                        t.setPhysics(e), t.setModelFromPhysicsShape(), this.add(t);
                        let n = new f.SBObject,
                            i = new g.BoxPhysics({
                                size: new r.Vector3(10, 1, 10)
                            });
                        i.physical.position.z = 10, i.physical.quaternion.setFromEuler(-.3, 0, 0), i.physical.computeAABB(), n.setPhysics(i), n.setModelFromPhysicsShape(), this.add(n);
                        let o = new r.GridHelper(100, 50, 4473924, 11184810);
                        o.position.y = 1.01, this.graphicsWorld.add(o)
                    }
                    scrollTheTimeScale(t) {}
                    updateControls(t) {
                        let e = "";
                        e += '<div class="info-title">Controls:</div>', t.forEach((t => {
                            e += '<div class="info-row">', t.keys.forEach((t => {
                                e += "+" === t || "and" === t || "or" === t || "&" === t ? "&nbsp;" + t + "&nbsp;" : '<span class="key">' + t + "</span>"
                            })), e += '<span class="ctrl-desc">' + t.desc + "</span></div>"
                        })), document.getElementById("controls-menu").innerHTML = e
                    }
                    getGUI(t) {
                        return new d.GUI
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(0),
                    r = n(5),
                    o = n(6);
                e.CameraOperator = class {
                    constructor(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .8 * n;
                        this.radius = 1, this.targetRadius = 1, this.upVelocity = 0, this.forwardVelocity = 0, this.rightVelocity = 0, this.followMode = !1, this.desiredDistance = 0, this.wasCameraObstructed = !1, this.world = t, this.camera = e, this.target = new i.Vector3, this.sensitivity = new i.Vector2(n, o), this.movementSpeed = .06, this.radius = 3, this.theta = 0, this.phi = 90, this.onMouseDownPosition = new i.Vector2, this.onMouseDownTheta = this.theta, this.onMouseDownPhi = this.phi, this.raycaster = new i.Raycaster, this.rayDirection = new i.Vector3, this.raycastDesiredPosition = new i.Vector3, this.mouseDesiredPosition = new i.Vector3, this.actions = {
                            forward: new r.KeyBinding("KeyW"),
                            back: new r.KeyBinding("KeyS"),
                            left: new r.KeyBinding("KeyA"),
                            right: new r.KeyBinding("KeyD"),
                            up: new r.KeyBinding("KeyE"),
                            down: new r.KeyBinding("KeyQ"),
                            fast: new r.KeyBinding("ShiftLeft")
                        }
                    }
                    setSensitivity(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t;
                        this.sensitivity = new i.Vector2(t, e)
                    }
                    setRadius(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        this.targetRadius = Math.max(.001, t), !0 === e && (this.radius = t)
                    }
                    move(t, e) {
                        this.theta -= t * (this.sensitivity.x / 2), this.theta %= 360, this.phi += e * (this.sensitivity.y / 2), this.phi = Math.min(85, Math.max(-85, this.phi))
                    }
                    update() {
                        if (!0 === this.followMode) {
                            this.camera.position.y = i.MathUtils.clamp(this.camera.position.y, this.target.y, Number.POSITIVE_INFINITY), this.camera.lookAt(this.target);
                            let t = this.target.clone().add((new i.Vector3).subVectors(this.camera.position, this.target).normalize().multiplyScalar(this.targetRadius));
                            this.camera.position.x = t.x, this.camera.position.y = t.y, this.camera.position.z = t.z
                        } else {
                            this.radius = i.MathUtils.lerp(this.radius, this.targetRadius, .1), this.mouseDesiredPosition.x = this.target.x + this.radius * Math.sin(this.theta * Math.PI / 180) * Math.cos(this.phi * Math.PI / 180), this.mouseDesiredPosition.y = this.target.y + this.radius * Math.sin(Math.max(this.phi, 0) * Math.PI / 180), this.mouseDesiredPosition.z = this.target.z + this.radius * Math.cos(this.theta * Math.PI / 180) * Math.cos(this.phi * Math.PI / 180), this.desiredDistance = this.mouseDesiredPosition.distanceTo(this.target), this.rayDirection.subVectors(this.mouseDesiredPosition, this.target), this.rayDirection.normalize(), this.raycaster.set(this.target, this.rayDirection);
                            const t = this.raycaster.intersectObjects(this.world.raycastObjects);
                            let e = !1;
                            for (let n = 0; n < t.length; n++) {
                                let i = t[n];
                                i.distance < this.desiredDistance && i.distance < this.radius && (e = !0, this.wasCameraObstructed = !0, this.raycastDesiredPosition.copy(t[n].point));
                                break
                            }
                            e ? this.camera.position.copy(this.raycastDesiredPosition) : this.camera.position.copy(this.mouseDesiredPosition), this.camera.updateMatrix(), this.camera.lookAt(this.target.x, this.target.y + .3, this.target.z)
                        }
                    }
                    handleKeyboardEvent(t, e, n) {
                        if ("KeyC" === e && !0 === n && !0 === t.shiftKey);
                        else
                            for (const i in this.actions)
                                if (this.actions.hasOwnProperty(i)) {
                                    const t = this.actions[i];
                                    o.includes(t.eventCodes, e) && (t.isPressed = n)
                                }
                    }
                    handleMouseWheel(t, e) {
                        this.world.scrollTheTimeScale(e)
                    }
                    handleMouseButton(t, e, n) {
                        for (const i in this.actions)
                            if (this.actions.hasOwnProperty(i)) {
                                const t = this.actions[i];
                                o.includes(t.eventCodes, e) && (t.isPressed = n)
                            }
                    }
                    handleMouseMove(t, e, n) {
                        this.move(e, n)
                    }
                    inputReceiverInit() {
                        this.target.copy(this.camera.position), this.setRadius(0, !0)
                    }
                    inputReceiverUpdate(t) {
                        let e = this.movementSpeed * (this.actions.fast.isPressed ? 600 : 60);
                        const n = this.world.cameraOperator.camera.matrix.elements;
                        let r = new i.Vector3(n[4], n[5], n[6]),
                            o = new i.Vector3(-n[8], -n[9], -n[10]),
                            s = new i.Vector3(n[0], n[1], n[2]);
                        this.upVelocity = i.MathUtils.lerp(this.upVelocity, +this.actions.up.isPressed - +this.actions.down.isPressed, .3), this.forwardVelocity = i.MathUtils.lerp(this.forwardVelocity, +this.actions.forward.isPressed - +this.actions.back.isPressed, .3), this.rightVelocity = i.MathUtils.lerp(this.rightVelocity, +this.actions.right.isPressed - +this.actions.left.isPressed, .3), this.world.cameraOperator.target.add(r.multiplyScalar(e * t * this.upVelocity)), this.world.cameraOperator.target.add(o.multiplyScalar(e * t * this.forwardVelocity)), this.world.cameraOperator.target.add(s.multiplyScalar(e * t * this.rightVelocity))
                    }
                }
            }, function(t, e, n) {
                "use strict";
                n.r(e), n.d(e, "FXAAShader", (function() {
                    return i
                }));
                let i = {
                    uniforms: {
                        tDiffuse: {
                            value: null
                        },
                        resolution: {
                            value: new(n(0).Vector2)(1 / 1024, 1 / 512)
                        }
                    },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["precision highp float;", "", "uniform sampler2D tDiffuse;", "", "uniform vec2 resolution;", "", "varying vec2 vUv;", "", "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)", "", "//----------------------------------------------------------------------------------", "// File:        es3-kepler\\FXAA\\assets\\shaders/FXAA_DefaultES.frag", "// SDK Version: v3.00", "// Email:       gameworks@nvidia.com", "// Site:        http://developer.nvidia.com/", "//", "// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.", "//", "// Redistribution and use in source and binary forms, with or without", "// modification, are permitted provided that the following conditions", "// are met:", "//  * Redistributions of source code must retain the above copyright", "//    notice, this list of conditions and the following disclaimer.", "//  * Redistributions in binary form must reproduce the above copyright", "//    notice, this list of conditions and the following disclaimer in the", "//    documentation and/or other materials provided with the distribution.", "//  * Neither the name of NVIDIA CORPORATION nor the names of its", "//    contributors may be used to endorse or promote products derived", "//    from this software without specific prior written permission.", "//", "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY", "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR", "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,", "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,", "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR", "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY", "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT", "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE", "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", "//", "//----------------------------------------------------------------------------------", "", "#define FXAA_PC 1", "#define FXAA_GLSL_100 1", "#define FXAA_QUALITY_PRESET 12", "", "#define FXAA_GREEN_AS_LUMA 1", "", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_PC_CONSOLE", "    //", "    // The console algorithm for PC is included", "    // for developers targeting really low spec machines.", "    // Likely better to just run FXAA_PC, and use a really low preset.", "    //", "    #define FXAA_PC_CONSOLE 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_120", "    #define FXAA_GLSL_120 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_130", "    #define FXAA_GLSL_130 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_3", "    #define FXAA_HLSL_3 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_4", "    #define FXAA_HLSL_4 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_5", "    #define FXAA_HLSL_5 0", "#endif", "/*==========================================================================*/", "#ifndef FXAA_GREEN_AS_LUMA", "    //", "    // For those using non-linear color,", "    // and either not able to get luma in alpha, or not wanting to,", "    // this enables FXAA to run using green as a proxy for luma.", "    // So with this enabled, no need to pack luma in alpha.", "    //", "    // This will turn off AA on anything which lacks some amount of green.", "    // Pure red and blue or combination of only R and B, will get no AA.", "    //", "    // Might want to lower the settings for both,", "    //    fxaaConsoleEdgeThresholdMin", "    //    fxaaQualityEdgeThresholdMin", "    // In order to insure AA does not get turned off on colors", "    // which contain a minor amount of green.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_GREEN_AS_LUMA 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_EARLY_EXIT", "    //", "    // Controls algorithm's early exit path.", "    // On PS3 turning this ON adds 2 cycles to the shader.", "    // On 360 turning this OFF adds 10ths of a millisecond to the shader.", "    // Turning this off on console will result in a more blurry image.", "    // So this defaults to on.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_EARLY_EXIT 1", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_DISCARD", "    //", "    // Only valid for PC OpenGL currently.", "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.", "    //", "    // 1 = Use discard on pixels which don't need AA.", "    //     For APIs which enable concurrent TEX+ROP from same surface.", "    // 0 = Return unchanged color on pixels which don't need AA.", "    //", "    #define FXAA_DISCARD 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_FAST_PIXEL_OFFSET", "    //", "    // Used for GLSL 120 only.", "    //", "    // 1 = GL API supports fast pixel offsets", "    // 0 = do not use fast pixel offsets", "    //", "    #ifdef GL_EXT_gpu_shader4", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifndef FXAA_FAST_PIXEL_OFFSET", "        #define FXAA_FAST_PIXEL_OFFSET 0", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GATHER4_ALPHA", "    //", "    // 1 = API supports gather4 on alpha channel.", "    // 0 = API does not support gather4 on alpha channel.", "    //", "    #if (FXAA_HLSL_5 == 1)", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifndef FXAA_GATHER4_ALPHA", "        #define FXAA_GATHER4_ALPHA 0", "    #endif", "#endif", "", "", "/*============================================================================", "                        FXAA QUALITY - TUNING KNOBS", "------------------------------------------------------------------------------", "NOTE the other tuning knobs are now in the shader function inputs!", "============================================================================*/", "#ifndef FXAA_QUALITY_PRESET", "    //", "    // Choose the quality preset.", "    // This needs to be compiled into the shader as it effects code.", "    // Best option to include multiple presets is to", "    // in each shader define the preset, then include this file.", "    //", "    // OPTIONS", "    // -----------------------------------------------------------------------", "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)", "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)", "    // 39       - no dither, very expensive", "    //", "    // NOTES", "    // -----------------------------------------------------------------------", "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)", "    // 13 = about same speed as FXAA 3.9 and better than 12", "    // 23 = closest to FXAA 3.9 visually and performance wise", "    //  _ = the lowest digit is directly related to performance", "    // _  = the highest digit is directly related to style", "    //", "    #define FXAA_QUALITY_PRESET 12", "#endif", "", "", "/*============================================================================", "", "                           FXAA QUALITY - PRESETS", "", "============================================================================*/", "", "/*============================================================================", "                     FXAA QUALITY - MEDIUM DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 10)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 3.0", "    #define FXAA_QUALITY_P2 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 11)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 3.0", "    #define FXAA_QUALITY_P3 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 12)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 4.0", "    #define FXAA_QUALITY_P4 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 13)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 4.0", "    #define FXAA_QUALITY_P5 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 14)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 4.0", "    #define FXAA_QUALITY_P6 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 15)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 12.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - LOW DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 20)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 2.0", "    #define FXAA_QUALITY_P2 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 21)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 22)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 23)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 24)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 3.0", "    #define FXAA_QUALITY_P6 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 25)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 26)", "    #define FXAA_QUALITY_PS 9", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 4.0", "    #define FXAA_QUALITY_P8 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 27)", "    #define FXAA_QUALITY_PS 10", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 4.0", "    #define FXAA_QUALITY_P9 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 28)", "    #define FXAA_QUALITY_PS 11", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 4.0", "    #define FXAA_QUALITY_P10 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 29)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - EXTREME QUALITY", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 39)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.0", "    #define FXAA_QUALITY_P2 1.0", "    #define FXAA_QUALITY_P3 1.0", "    #define FXAA_QUALITY_P4 1.0", "    #define FXAA_QUALITY_P5 1.5", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "", "", "/*============================================================================", "", "                                API PORTING", "", "============================================================================*/", "#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)", "    #define FxaaBool bool", "    #define FxaaDiscard discard", "    #define FxaaFloat float", "    #define FxaaFloat2 vec2", "    #define FxaaFloat3 vec3", "    #define FxaaFloat4 vec4", "    #define FxaaHalf float", "    #define FxaaHalf2 vec2", "    #define FxaaHalf3 vec3", "    #define FxaaHalf4 vec4", "    #define FxaaInt2 ivec2", "    #define FxaaSat(x) clamp(x, 0.0, 1.0)", "    #define FxaaTex sampler2D", "#else", "    #define FxaaBool bool", "    #define FxaaDiscard clip(-1)", "    #define FxaaFloat float", "    #define FxaaFloat2 float2", "    #define FxaaFloat3 float3", "    #define FxaaFloat4 float4", "    #define FxaaHalf half", "    #define FxaaHalf2 half2", "    #define FxaaHalf3 half3", "    #define FxaaHalf4 half4", "    #define FxaaSat(x) saturate(x)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_100 == 1)", "  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)", "  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_120 == 1)", "    // Requires,", "    //  #version 120", "    // And at least,", "    //  #extension GL_EXT_gpu_shader4 : enable", "    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)", "    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)", "    #if (FXAA_FAST_PIXEL_OFFSET == 1)", "        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)", "    #else", "        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)", "    #endif", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_130 == 1)", '    // Requires "#version 130" or better', "    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_3 == 1)", "    #define FxaaInt2 float2", "    #define FxaaTex sampler2D", "    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))", "    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_4 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_5 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)", "    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)", "    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)", "    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)", "#endif", "", "", "/*============================================================================", "                   GREEN AS LUMA OPTION SUPPORT FUNCTION", "============================================================================*/", "#if (FXAA_GREEN_AS_LUMA == 0)", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }", "#else", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }", "#endif", "", "", "", "", "/*============================================================================", "", "                             FXAA3 QUALITY - PC", "", "============================================================================*/", "#if (FXAA_PC == 1)", "/*--------------------------------------------------------------------------*/", "FxaaFloat4 FxaaPixelShader(", "    //", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy} = center of pixel", "    FxaaFloat2 pos,", "    //", "    // Used only for FXAA Console, and not used on the 360 version.", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy_} = upper left of pixel", "    // {_zw} = lower right of pixel", "    FxaaFloat4 fxaaConsolePosPos,", "    //", "    // Input color texture.", "    // {rgb_} = color in linear or perceptual color space", "    // if (FXAA_GREEN_AS_LUMA == 0)", "    //     {__a} = luma in perceptual color space (not linear)", "    FxaaTex tex,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", '    // For everything but 360, just use the same input here as for "tex".', "    // For 360, same texture, just alias with a 2nd sampler.", "    // This sampler needs to have an exponent bias of -1.", "    FxaaTex fxaaConsole360TexExpBiasNegOne,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", '    // For everything but 360, just use the same input here as for "tex".', "    // For 360, same texture, just alias with a 3nd sampler.", "    // This sampler needs to have an exponent bias of -2.", "    FxaaTex fxaaConsole360TexExpBiasNegTwo,", "    //", "    // Only used on FXAA Quality.", "    // This must be from a constant/uniform.", "    // {x_} = 1.0/screenWidthInPixels", "    // {_y} = 1.0/screenHeightInPixels", "    FxaaFloat2 fxaaQualityRcpFrame,", "    //", "    // Only used on FXAA Console.", "    // This must be from a constant/uniform.", "    // This effects sub-pixel AA quality and inversely sharpness.", "    //   Where N ranges between,", "    //     N = 0.50 (default)", "    //     N = 0.33 (sharper)", "    // {x__} = -N/screenWidthInPixels", "    // {_y_} = -N/screenHeightInPixels", "    // {_z_} =  N/screenWidthInPixels", "    // {__w} =  N/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt,", "    //", "    // Only used on FXAA Console.", "    // Not used on 360, but used on PS3 and PC.", "    // This must be from a constant/uniform.", "    // {x__} = -2.0/screenWidthInPixels", "    // {_y_} = -2.0/screenHeightInPixels", "    // {_z_} =  2.0/screenWidthInPixels", "    // {__w} =  2.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt2,", "    //", "    // Only used on FXAA Console.", "    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.", "    // This must be from a constant/uniform.", "    // {x__} =  8.0/screenWidthInPixels", "    // {_y_} =  8.0/screenHeightInPixels", "    // {_z_} = -4.0/screenWidthInPixels", "    // {__w} = -4.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsole360RcpFrameOpt2,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_SUBPIX define.", "    // It is here now to allow easier tuning.", "    // Choose the amount of sub-pixel aliasing removal.", "    // This can effect sharpness.", "    //   1.00 - upper limit (softer)", "    //   0.75 - default amount of filtering", "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)", "    //   0.25 - almost off", "    //   0.00 - completely off", "    FxaaFloat fxaaQualitySubpix,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // The minimum amount of local contrast required to apply algorithm.", "    //   0.333 - too little (faster)", "    //   0.250 - low quality", "    //   0.166 - default", "    //   0.125 - high quality", "    //   0.063 - overkill (slower)", "    FxaaFloat fxaaQualityEdgeThreshold,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    //   0.0833 - upper limit (default, the start of visible unfiltered edges)", "    //   0.0625 - high quality (faster)", "    //   0.0312 - visible limit (slower)", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaQualityEdgeThresholdMin,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only three safe values here: 2 and 4 and 8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // For all other platforms can be a non-power of two.", "    //   8.0 is sharper (default!!!)", "    //   4.0 is softer", "    //   2.0 is really soft (good only for vector graphics inputs)", "    FxaaFloat fxaaConsoleEdgeSharpness,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only two safe values here: 1/4 and 1/8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // The console setting has a different mapping than the quality setting.", "    // Other platforms can use other values.", "    //   0.125 leaves less aliasing, but is softer (default!!!)", "    //   0.25 leaves more aliasing, and is sharper", "    FxaaFloat fxaaConsoleEdgeThreshold,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    // The console setting has a different mapping than the quality setting.", "    // This only applies when FXAA_EARLY_EXIT is 1.", "    // This does not apply to PS3,", "    // PS3 was simplified to avoid more shader instructions.", "    //   0.06 - faster but more aliasing in darks", "    //   0.05 - default", "    //   0.04 - slower and less aliasing in darks", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaConsoleEdgeThresholdMin,", "    //", "    // Extra constants for 360 FXAA Console only.", "    // Use zeros or anything else for other platforms.", "    // These must be in physical constant registers and NOT immedates.", "    // Immedates will result in compiler un-optimizing.", "    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)", "    FxaaFloat4 fxaaConsole360ConstDir", ") {", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posM;", "    posM.x = pos.x;", "    posM.y = pos.y;", "    #if (FXAA_GATHER4_ALPHA == 1)", "        #if (FXAA_DISCARD == 0)", "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "            #if (FXAA_GREEN_AS_LUMA == 0)", "                #define lumaM rgbyM.w", "            #else", "                #define lumaM rgbyM.y", "            #endif", "        #endif", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));", "        #else", "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));", "        #endif", "        #if (FXAA_DISCARD == 1)", "            #define lumaM luma4A.w", "        #endif", "        #define lumaE luma4A.z", "        #define lumaS luma4A.x", "        #define lumaSE luma4A.y", "        #define lumaNW luma4B.w", "        #define lumaN luma4B.z", "        #define lumaW luma4B.x", "    #else", "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            #define lumaM rgbyM.w", "        #else", "            #define lumaM rgbyM.y", "        #endif", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));", "        #endif", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat maxSM = max(lumaS, lumaM);", "    FxaaFloat minSM = min(lumaS, lumaM);", "    FxaaFloat maxESM = max(lumaE, maxSM);", "    FxaaFloat minESM = min(lumaE, minSM);", "    FxaaFloat maxWN = max(lumaN, lumaW);", "    FxaaFloat minWN = min(lumaN, lumaW);", "    FxaaFloat rangeMax = max(maxWN, maxESM);", "    FxaaFloat rangeMin = min(minWN, minESM);", "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;", "    FxaaFloat range = rangeMax - rangeMin;", "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);", "    FxaaBool earlyExit = range < rangeMaxClamped;", "/*--------------------------------------------------------------------------*/", "    if(earlyExit)", "        #if (FXAA_DISCARD == 1)", "            FxaaDiscard;", "        #else", "            return rgbyM;", "        #endif", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_GATHER4_ALPHA == 0)", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "        #endif", "    #else", "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));", "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNS = lumaN + lumaS;", "    FxaaFloat lumaWE = lumaW + lumaE;", "    FxaaFloat subpixRcpRange = 1.0/range;", "    FxaaFloat subpixNSWE = lumaNS + lumaWE;", "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;", "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNESE = lumaNE + lumaSE;", "    FxaaFloat lumaNWNE = lumaNW + lumaNE;", "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;", "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNWSW = lumaNW + lumaSW;", "    FxaaFloat lumaSWSE = lumaSW + lumaSE;", "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);", "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);", "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;", "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;", "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;", "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;", "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;", "    FxaaBool horzSpan = edgeHorz >= edgeVert;", "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;", "/*--------------------------------------------------------------------------*/", "    if(!horzSpan) lumaN = lumaW;", "    if(!horzSpan) lumaS = lumaE;", "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;", "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat gradientN = lumaN - lumaM;", "    FxaaFloat gradientS = lumaS - lumaM;", "    FxaaFloat lumaNN = lumaN + lumaM;", "    FxaaFloat lumaSS = lumaS + lumaM;", "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);", "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));", "    if(pairN) lengthSign = -lengthSign;", "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posB;", "    posB.x = posM.x;", "    posB.y = posM.y;", "    FxaaFloat2 offNP;", "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;", "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;", "    if(!horzSpan) posB.x += lengthSign * 0.5;", "    if( horzSpan) posB.y += lengthSign * 0.5;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posN;", "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;", "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat2 posP;", "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;", "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;", "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));", "    FxaaFloat subpixE = subpixC * subpixC;", "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));", "/*--------------------------------------------------------------------------*/", "    if(!pairN) lumaNN = lumaSS;", "    FxaaFloat gradientScaled = gradient * 1.0/4.0;", "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;", "    FxaaFloat subpixF = subpixD * subpixE;", "    FxaaBool lumaMLTZero = lumaMM < 0.0;", "/*--------------------------------------------------------------------------*/", "    lumaEndN -= lumaNN * 0.5;", "    lumaEndP -= lumaNN * 0.5;", "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;", "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;", "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;", "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;", "    FxaaBool doneNP = (!doneN) || (!doneP);", "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;", "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;", "/*--------------------------------------------------------------------------*/", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 3)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 4)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 5)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 6)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;", "/*--------------------------------------------------------------------------*/", "                        #if (FXAA_QUALITY_PS > 7)", "                        if(doneNP) {", "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                            doneN = abs(lumaEndN) >= gradientScaled;", "                            doneP = abs(lumaEndP) >= gradientScaled;", "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;", "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;", "                            doneNP = (!doneN) || (!doneP);", "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;", "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_QUALITY_PS > 8)", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 9)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 10)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 11)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 12)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "    #endif", "/*--------------------------------------------------------------------------*/", "                        }", "                        #endif", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "/*--------------------------------------------------------------------------*/", "    FxaaFloat dstN = posM.x - posN.x;", "    FxaaFloat dstP = posP.x - posM.x;", "    if(!horzSpan) dstN = posM.y - posN.y;", "    if(!horzSpan) dstP = posP.y - posM.y;", "/*--------------------------------------------------------------------------*/", "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;", "    FxaaFloat spanLength = (dstP + dstN);", "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;", "    FxaaFloat spanLengthRcp = 1.0/spanLength;", "/*--------------------------------------------------------------------------*/", "    FxaaBool directionN = dstN < dstP;", "    FxaaFloat dst = min(dstN, dstP);", "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;", "    FxaaFloat subpixG = subpixF * subpixF;", "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;", "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;", "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);", "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;", "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;", "    #if (FXAA_DISCARD == 1)", "        return FxaaTexTop(tex, posM);", "    #else", "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);", "    #endif", "}", "/*==========================================================================*/", "#endif", "", "void main() {", "  gl_FragColor = FxaaPixelShader(", "    vUv,", "    vec4(0.0),", "    tDiffuse,", "    tDiffuse,", "    tDiffuse,", "    resolution,", "    vec4(0.0),", "    vec4(0.0),", "    vec4(0.0),", "    0.75,", "    0.166,", "    0.0833,", "    0.0,", "    0.0,", "    0.0,", "    vec4(0.0)", "  );", "", "  // TODO avoid querying texture twice for same texel", "  gl_FragColor.a = texture2D(tDiffuse, vUv).a;", "}"].join("\n")
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var i = n(15);
                Object.defineProperty(e, "CopyShader", {
                    enumerable: !0,
                    get: function() {
                        return p(i).default
                    }
                });
                var r = n(4);
                Object.defineProperty(e, "Pass", {
                    enumerable: !0,
                    get: function() {
                        return p(r).default
                    }
                });
                var o = n(34);
                Object.defineProperty(e, "ShaderPass", {
                    enumerable: !0,
                    get: function() {
                        return p(o).default
                    }
                });
                var s = n(80);
                Object.defineProperty(e, "RenderingPass", {
                    enumerable: !0,
                    get: function() {
                        return p(s).default
                    }
                });
                var a = n(81);
                Object.defineProperty(e, "TexturePass", {
                    enumerable: !0,
                    get: function() {
                        return p(a).default
                    }
                });
                var l = n(82);
                Object.defineProperty(e, "RenderPass", {
                    enumerable: !0,
                    get: function() {
                        return p(l).default
                    }
                });
                var c = n(35);
                Object.defineProperty(e, "MaskPass", {
                    enumerable: !0,
                    get: function() {
                        return p(c).default
                    }
                });
                var h = n(36);
                Object.defineProperty(e, "ClearMaskPass", {
                    enumerable: !0,
                    get: function() {
                        return p(h).default
                    }
                });
                var u = n(83);
                Object.defineProperty(e, "ClearPass", {
                    enumerable: !0,
                    get: function() {
                        return p(u).default
                    }
                });
                var d = n(84);

                function p(t) {
                    return t && t.__esModule ? t : {
                        default: t
                    }
                }
                Object.defineProperty(e, "default", {
                    enumerable: !0,
                    get: function() {
                        return p(d).default
                    }
                })
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var i, r = function(t) {
                        if (t && t.__esModule) return t;
                        var e = {};
                        if (null != t)
                            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                        return e.default = t, e
                    }(n(0)),
                    o = function(t) {
                        function e() {
                            ! function(t, e) {
                                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                            }(this, e);
                            var t = function(t, e) {
                                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !e || "object" != typeof e && "function" != typeof e ? t : e
                            }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                            return t.camera = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1), t.scene = new r.Scene, t.quad = new r.Mesh(new r.PlaneBufferGeometry(2, 2), null), t.quad.frustumCulled = !1, t.scene.add(t.quad), t
                        }
                        return function(t, e) {
                            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                            t.prototype = Object.create(e && e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                        }(e, t), e
                    }(((i = n(4)) && i.__esModule ? i : {
                        default: i
                    }).default);
                e.default = o
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var i = function() {
                        function t(t, e) {
                            for (var n = 0; n < e.length; n++) {
                                var i = e[n];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                            }
                        }
                        return function(e, n, i) {
                            return n && t(e.prototype, n), i && t(e, i), e
                        }
                    }(),
                    r = function(t) {
                        if (t && t.__esModule) return t;
                        var e = {};
                        if (null != t)
                            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                        return e.default = t, e
                    }(n(0)),
                    o = a(n(4)),
                    s = a(n(15));

                function a(t) {
                    return t && t.__esModule ? t : {
                        default: t
                    }
                }
                var l = function(t) {
                    function e(t, n) {
                        ! function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, e);
                        var i = function(t, e) {
                                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !e || "object" != typeof e && "function" != typeof e ? t : e
                            }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this)),
                            a = s.default;
                        return i.map = t, i.opacity = void 0 !== n ? n : 1, i.uniforms = r.UniformsUtils.clone(a.uniforms), i.material = new r.ShaderMaterial({
                            uniforms: i.uniforms,
                            vertexShader: a.vertexShader,
                            fragmentShader: a.fragmentShader,
                            depthTest: !1,
                            depthWrite: !1
                        }), i.needsSwap = !1, i.fsQuad = new o.default.FullScreenQuad(null), i
                    }
                    return function(t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                        t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                    }(e, t), i(e, [{
                        key: "render",
                        value: function(t, e, n) {
                            var i = t,
                                r = i.autoClear;
                            i.autoClear = !1, this.fsQuad.material = this.material, this.uniforms.opacity.value = this.opacity, this.uniforms.tDiffuse.value = this.map, this.material.transparent = this.opacity < 1, i.setRenderTarget(this.renderToScreen ? null : n), this.clear && i.clear(), this.fsQuad.render(i), i.autoClear = r
                        }
                    }]), e
                }(o.default);
                e.default = l
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var i, r = function() {
                        function t(t, e) {
                            for (var n = 0; n < e.length; n++) {
                                var i = e[n];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                            }
                        }
                        return function(e, n, i) {
                            return n && t(e.prototype, n), i && t(e, i), e
                        }
                    }(),
                    o = function(t) {
                        function e(t, n, i, r, o) {
                            ! function(t, e) {
                                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                            }(this, e);
                            var s = function(t, e) {
                                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !e || "object" != typeof e && "function" != typeof e ? t : e
                            }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                            return s.scene = t, s.camera = n, s.overrideMaterial = i, s.clearColor = r, s.clearAlpha = void 0 !== o ? o : 0, s.clear = !0, s.clearDepth = !1, s.needsSwap = !1, s
                        }
                        return function(t, e) {
                            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                            t.prototype = Object.create(e && e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                        }(e, t), r(e, [{
                            key: "render",
                            value: function(t, e, n) {
                                var i = t,
                                    r = i.autoClear;
                                i.autoClear = !1, this.scene.overrideMaterial = this.overrideMaterial;
                                var o = void 0,
                                    s = void 0;
                                this.clearColor && (o = i.getClearColor().getHex(), s = i.getClearAlpha(), i.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && i.clearDepth(), i.setRenderTarget(this.renderToScreen ? null : n), this.clear && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), i.render(this.scene, this.camera), this.clearColor && i.setClearColor(o, s), this.scene.overrideMaterial = null, i.autoClear = r
                            }
                        }]), e
                    }(((i = n(4)) && i.__esModule ? i : {
                        default: i
                    }).default);
                e.default = o
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var i, r = function() {
                        function t(t, e) {
                            for (var n = 0; n < e.length; n++) {
                                var i = e[n];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                            }
                        }
                        return function(e, n, i) {
                            return n && t(e.prototype, n), i && t(e, i), e
                        }
                    }(),
                    o = function(t) {
                        function e(t, n) {
                            ! function(t, e) {
                                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                            }(this, e);
                            var i = function(t, e) {
                                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !e || "object" != typeof e && "function" != typeof e ? t : e
                            }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                            return i.needsSwap = !1, i.clearColor = void 0 !== t ? t : 0, i.clearAlpha = void 0 !== n ? n : 0, i
                        }
                        return function(t, e) {
                            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                            t.prototype = Object.create(e && e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                        }(e, t), r(e, [{
                            key: "render",
                            value: function(t, e, n) {
                                var i = void 0,
                                    r = void 0;
                                this.clearColor && (i = t.getClearColor().getHex(), r = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), t.setRenderTarget(this.renderToScreen ? null : n), t.clear(), this.clearColor && t.setClearColor(i, r)
                            }
                        }]), e
                    }(((i = n(4)) && i.__esModule ? i : {
                        default: i
                    }).default);
                e.default = o
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                var i = function() {
                        function t(t, e) {
                            for (var n = 0; n < e.length; n++) {
                                var i = e[n];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                            }
                        }
                        return function(e, n, i) {
                            return n && t(e.prototype, n), i && t(e, i), e
                        }
                    }(),
                    r = function(t) {
                        if (t && t.__esModule) return t;
                        var e = {};
                        if (null != t)
                            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                        return e.default = t, e
                    }(n(0)),
                    o = c(n(34)),
                    s = c(n(15)),
                    a = c(n(35)),
                    l = c(n(36));

                function c(t) {
                    return t && t.__esModule ? t : {
                        default: t
                    }
                }
                var h = function() {
                    function t(e, n) {
                        ! function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t);
                        var i = n;
                        if (this.renderer = e, void 0 === i) {
                            var a = {
                                    minFilter: r.LinearFilter,
                                    magFilter: r.LinearFilter,
                                    format: r.RGBAFormat,
                                    stencilBuffer: !1
                                },
                                l = e.getSize(new r.Vector2);
                            this._pixelRatio = e.getPixelRatio(), this._width = l.width, this._height = l.height, (i = new r.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, a)).texture.name = "EffectComposer.rt1"
                        } else this._pixelRatio = 1, this._width = i.width, this._height = i.height;
                        this.renderTarget1 = i, this.renderTarget2 = i.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new o.default(s.default), this.clock = new r.Clock
                    }
                    return i(t, [{
                        key: "swapBuffers",
                        value: function() {
                            var t = this.readBuffer;
                            this.readBuffer = this.writeBuffer, this.writeBuffer = t
                        }
                    }, {
                        key: "addPass",
                        value: function(t) {
                            this.passes.push(t);
                            var e = this.renderer.getDrawingBufferSize(new r.Vector2);
                            t.setSize(e.width, e.height)
                        }
                    }, {
                        key: "insertPass",
                        value: function(t, e) {
                            this.passes.splice(e, 0, t)
                        }
                    }, {
                        key: "isLastEnabledPass",
                        value: function(t) {
                            for (var e = t + 1; e < this.passes.length; e += 1)
                                if (this.passes[e].enabled) return !1;
                            return !0
                        }
                    }, {
                        key: "render",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.clock.getDelta(),
                                e = this.renderer.getRenderTarget(),
                                n = !1,
                                i = void 0,
                                r = void 0,
                                o = this.passes.length;
                            for (r = 0; r < o; r += 1) {
                                if (!1 !== (i = this.passes[r]).enabled && (i.renderToScreen = this.renderToScreen && this.isLastEnabledPass(r), i.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), i.needsSwap)) {
                                    if (n) {
                                        var s = this.renderer.context;
                                        s.stencilFunc(s.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), s.stencilFunc(s.EQUAL, 1, 4294967295)
                                    }
                                    this.swapBuffers()
                                }
                                i instanceof a.default ? n = !0 : i instanceof l.default && (n = !1)
                            }
                            this.renderer.setRenderTarget(e)
                        }
                    }, {
                        key: "reset",
                        value: function(t) {
                            var e = t;
                            if (void 0 === e) {
                                var n = this.renderer.getSize(new r.Vector2);
                                this._pixelRatio = this.renderer.getPixelRatio(), this._width = n.width, this._height = n.height, (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                            }
                            this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
                        }
                    }, {
                        key: "setSize",
                        value: function(t, e) {
                            this._width = t, this._height = e;
                            var n = this._width * this._pixelRatio,
                                i = this._height * this._pixelRatio;
                            this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
                            for (var r = 0; r < this.passes.length; r += 1) this.passes[r].setSize(n, i)
                        }
                    }, {
                        key: "setPixelRatio",
                        value: function(t) {
                            this._pixelRatio = t, this.setSize(this._width, this._height)
                        }
                    }]), t
                }();
                e.default = h
            }, function(t, e, n) {
                "use strict";
                n.r(e), n.d(e, "WaterShader", (function() {
                    return r
                }));
                const i = n(0);
                let r = {
                    uniforms: {
                        iGlobalTime: {
                            type: "f",
                            value: .1
                        },
                        iResolution: {
                            type: "v2",
                            value: new i.Vector2
                        },
                        cameraPos: {
                            value: new i.Vector3
                        },
                        lightDir: {
                            value: new i.Vector3
                        }
                    },
                    vertexShader: "\n\n    varying vec3 vWorldPosition;\n    varying vec2 vTexCoord;\n\n    void main()\t{\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n        vWorldPosition = worldPosition.xyz;\n\n        vTexCoord = uv;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n      }\n    ",
                    fragmentShader: "\n    uniform float iGlobalTime;\n    uniform vec2 iResolution;\n    uniform vec3 cameraPos;\n    uniform vec3 lightDir;\n\n    varying vec3 vWorldPosition;\n    varying vec2 vTexCoord;\n  \n    const int NUM_STEPS = 8;\n    const float PI\t \t= 3.1415;\n    const float EPSILON\t= 1e-3;\n    float EPSILON_NRM\t= 0.1 / iResolution.x;\n  \n    // sea variables\n    const int ITER_GEOMETRY = 3;\n    const int ITER_FRAGMENT = 5;\n    const float SEA_HEIGHT = 0.6;\n    const float SEA_CHOPPY = 1.0;\n    const float SEA_SPEED = 1.0;\n    const float SEA_FREQ = 0.16;\n    const vec3 SEA_BASE = vec3(0.1,0.19,0.22);\n    const vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\n    float SEA_TIME = iGlobalTime * SEA_SPEED;\n    mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n  \n    mat3 fromEuler(vec3 ang) {\n      vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n      vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n      vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n      mat3 m;\n      m[0] = vec3(\n          a1.y*a3.y+a1.x*a2.x*a3.x,\n          a1.y*a2.x*a3.x+a3.y*a1.x,\n          -a2.y*a3.x\n      );\n      m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n      m[2] = vec3(\n          a3.y*a1.x*a2.x+a1.y*a3.x,\n        a1.x*a3.x-a1.y*a3.y*a2.x,\n        a2.y*a3.y\n      );\n      return m;\n    }\n  \n    float hash( vec2 p ) {\n      float h = dot(p,vec2(127.1,311.7));\t\n      return fract(sin(h)*43758.5453123);\n    }\n  \n    float noise( in vec2 p ) {\n      vec2 i = floor(p);\n      vec2 f = fract(p);\t\n      vec2 u = f * f * (3.0 - 2.0 * f);\n      return -1.0 + 2.0 * mix(\n          mix(\n            hash(i + vec2(0.0,0.0)\n        ), \n          hash(i + vec2(1.0,0.0)), u.x),\n          mix(hash(i + vec2(0.0,1.0) ), \n          hash(i + vec2(1.0,1.0) ), u.x), \n        u.y\n      );\n    }\n  \n    float diffuse(vec3 n,vec3 l,float p) {\n      return pow(dot(n,l) * 0.4 + 0.6,p);\n    }\n  \n    float specular(vec3 n,vec3 l,vec3 e,float s) {    \n      float nrm = (s + 8.0) / (3.1415 * 8.0);\n      return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n    }\n  \n    vec3 getSkyColor(vec3 e) {\n      e.y = max(e.y, 0.0);\n      vec3 ret;\n      ret.x = pow(1.0 - e.y, 2.0);\n      ret.y = 1.0 - e.y;\n      ret.z = 0.6+(1.0 - e.y) * 0.4;\n      return ret;\n    }\n  \n  \n    float sea_octave(vec2 uv, float choppy) {\n      uv += noise(uv);         \n      vec2 wv = 1.0 - abs(sin(uv));\n      vec2 swv = abs(cos(uv));    \n      wv = mix(wv, swv, wv);\n      return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n    }\n  \n    float map(vec3 p) {\n      float freq = SEA_FREQ;\n      float amp = SEA_HEIGHT ;\n      float choppy = SEA_CHOPPY;\n      vec2 uv = p.xz; \n      uv.x *= 0.75;\n  \n      float d, h = 0.0;    \n      for(int i = 0; i < ITER_GEOMETRY; i++) {        \n        d = sea_octave((uv + SEA_TIME) * freq, choppy);\n        d += sea_octave((uv - SEA_TIME) * freq, choppy);\n        h += d * amp;        \n        uv *= octave_m;\n        freq *= 1.9; \n        amp *= 0.22;\n        choppy = mix(choppy, 1.0, 0.2);\n      }\n      return p.y - h;\n    }\n  \n    float map_detailed(vec3 p) {\n        float freq = SEA_FREQ;\n        float amp = SEA_HEIGHT;\n        float choppy = SEA_CHOPPY;\n        vec2 uv = p.xz;\n        uv.x *= 0.75;\n  \n        float d, h = 0.0;    \n        for(int i = 0; i < ITER_FRAGMENT; i++) {        \n          d = sea_octave((uv+SEA_TIME) * freq, choppy);\n          d += sea_octave((uv-SEA_TIME) * freq, choppy);\n          h += d * amp;        \n          uv *= octave_m;\n          freq *= 1.9; \n          amp *= 0.22;\n          choppy = mix(choppy,1.0,0.2);\n        }\n        return p.y - h;\n    }\n  \n    vec3 getSeaColor(\n        vec3 p,\n      vec3 n, \n      vec3 l, \n      vec3 eye, \n      vec3 dist\n    ) {  \n      float fresnel = 1.0 - max(dot(n,-eye),0.0);\n      fresnel = pow(fresnel,3.0) * 0.65;\n  \n      vec3 reflected = getSkyColor(reflect(eye,n));    \n      vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n  \n      vec3 color = mix(refracted,reflected,fresnel);\n  \n      float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n      color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n  \n      float night = dot(l, vec3(0.0, 1.0, 0.0));\n      night = clamp(night + 0.1, 0.0, 0.5) * 2.0;\n      color *= vec3(night);\n\n      color += vec3(specular(n,l,eye,60.0));\n  \n      return color;\n    }\n  \n    // tracing\n    vec3 getNormal(vec3 p, float eps) {\n      vec3 n;\n      n.y = map_detailed(p);    \n      n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n      n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n      n.y = eps;\n      return normalize(n);\n    }\n  \n    float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n\n      vec3 oriComp = ori;\n      oriComp.y -= vWorldPosition.y - SEA_HEIGHT;\n\n      float tm = 0.0;\n      float tx = 1000.0;\n      float hx = map(oriComp + dir * tx);\n\n      if(hx > 0.0) {\n        return tx;   \n      }\n  \n      float hm = map(oriComp + dir * tm);    \n      float tmid = 0.0;\n      for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = oriComp + dir * tmid;   \n        float hmid = map(p);\n        if(hmid < 0.0) {\n          tx = tmid;\n          hx = hmid;\n        } else {\n          tm = tmid;\n          hm = hmid;\n         }\n      }\n\n      return tmid;\n    }\n  \n    void main() {\n      float time = iGlobalTime * 0.3;\n  \n      // ray\n      vec3 ang = vec3(\n        sin(time*3.0)*0.1,sin(time)*0.2+0.3,time\n      );    \n\n      vec3 dir = normalize( vWorldPosition - cameraPos );\n  \n      // tracing\n      vec3 p;\n      heightMapTracing(cameraPos,dir,p);\n      vec3 dist = vWorldPosition - cameraPos;\n      vec3 n = getNormal(\n        p,\n        dot(dist,dist) * EPSILON_NRM\n      );\n  \n      // color\n      vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,lightDir,dir,dist),\n        pow(smoothstep(0.0,-0.05,dir.y),0.3)\n      );\n  \n      // post\n      gl_FragColor = vec4(pow(color,vec3(0.8)), 1.0) * 1.2;\n\n      float fogfac = clamp(length(dist), 300.0, 600.0);\n      fogfac -= 300.0;\n      fogfac /= 300.0;\n      gl_FragColor.a = 1.0 - fogfac;\n\n      #if defined( TONE_MAPPING )\n        gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n      #endif\n    }\n    "
                }
            }, function(t, e, n) {
                "use strict";
                n.r(e), n.d(e, "Detector", (function() {
                    return i
                }));
                var i = {
                    canvas: !!window.CanvasRenderingContext2D,
                    webgl: function() {
                        try {
                            var t = document.createElement("canvas");
                            return !(!window.WebGLRenderingContext || !t.getContext("webgl") && !t.getContext("experimental-webgl"))
                        } catch (t) {
                            return !1
                        }
                    }(),
                    workers: !!window.Worker,
                    fileapi: window.File && window.FileReader && window.FileList && window.Blob,
                    getWebGLErrorMessage: function() {
                        var t = document.createElement("div");
                        return t.id = "webgl-error-message", t.style.fontFamily = "monospace", t.style.fontSize = "13px", t.style.fontWeight = "normal", t.style.textAlign = "center", t.style.background = "#fff", t.style.color = "#000", t.style.padding = "1.5em", t.style.width = "400px", t.style.margin = "5em auto 0", this.webgl || (t.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join("\n") : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join("\n")), t
                    },
                    addGetWebGLMessage: function(t) {
                        var e, n, r;
                        e = void 0 !== (t = t || {}).parent ? t.parent : document.body, n = void 0 !== t.id ? t.id : "oldie", (r = i.getWebGLErrorMessage()).id = n, e.appendChild(r)
                    }
                }
            }, function(t, e, n) {
                "use strict";
                n.r(e), n.d(e, "Stats", (function() {
                    return i
                }));
                var i = function() {
                    var t = document.createElement("div");

                    function e(e) {
                        return t.appendChild(e.dom), e
                    }

                    function n(e) {
                        for (var n = 0; n < t.children.length; n++) t.children[n].style.display = "inline-block"
                    }
                    t.classList.add("statsBox");
                    var r = (performance || Date).now(),
                        o = r,
                        s = 0,
                        a = e(new i.Panel("FPS", "#0ff", "#002"));
                    return self.performance && self.performance.memory, n(0), {
                        REVISION: 16,
                        dom: t,
                        addPanel: e,
                        showPanel: n,
                        begin: function() {
                            r = (performance || Date).now()
                        },
                        end: function() {
                            s++;
                            var t = (performance || Date).now();
                            return t > o + 1e3 && (a.update(1e3 * s / (t - o), 100), o = t, s = 0), t
                        },
                        update: function() {
                            r = this.end()
                        },
                        domElement: t,
                        setMode: n
                    }
                };
                i.Panel = function(t, e, n) {
                    var i = 1 / 0,
                        r = 0,
                        o = Math.round,
                        s = o(window.devicePixelRatio || 1),
                        a = 80 * s,
                        l = 48 * s,
                        c = 3 * s,
                        h = 2 * s,
                        u = 3 * s,
                        d = 15 * s,
                        p = 74 * s,
                        f = 30 * s,
                        m = document.createElement("canvas");
                    m.width = a, m.height = l, m.style.cssText = "width:80px;height:48px";
                    var g = m.getContext("2d");
                    return g.font = "bold " + 9 * s + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = n, g.fillRect(0, 0, a, l), g.fillStyle = e, g.fillText(t, c, h), g.fillRect(u, d, p, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(u, d, p, f), {
                        dom: m,
                        update: function(l, v) {
                            i = Math.min(i, l), r = Math.max(r, l), g.fillStyle = n, g.globalAlpha = 1, g.fillRect(0, 0, a, d), g.fillStyle = e, g.fillText(o(l) + " " + t + " (" + o(i) + "-" + o(r) + ")", c, h), g.drawImage(m, u + s, d, p - s, f, u, d, p - s, f), g.fillRect(u + p - s, d, s, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(u + p - s, d, s, o((1 - l / v) * f))
                        }
                    }
                }
            }, function(t, e, n) {
                t.exports = function() {
                    "use strict";

                    function t(t, e) {
                        var n = t.__state.conversionName.toString(),
                            i = Math.round(t.r),
                            r = Math.round(t.g),
                            o = Math.round(t.b),
                            s = t.a,
                            a = Math.round(t.h),
                            l = t.s.toFixed(1),
                            c = t.v.toFixed(1);
                        if (e || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
                            for (var h = t.hex.toString(16); h.length < 6;) h = "0" + h;
                            return "#" + h
                        }
                        return "CSS_RGB" === n ? "rgb(" + i + "," + r + "," + o + ")" : "CSS_RGBA" === n ? "rgba(" + i + "," + r + "," + o + "," + s + ")" : "HEX" === n ? "0x" + t.hex.toString(16) : "RGB_ARRAY" === n ? "[" + i + "," + r + "," + o + "]" : "RGBA_ARRAY" === n ? "[" + i + "," + r + "," + o + "," + s + "]" : "RGB_OBJ" === n ? "{r:" + i + ",g:" + r + ",b:" + o + "}" : "RGBA_OBJ" === n ? "{r:" + i + ",g:" + r + ",b:" + o + ",a:" + s + "}" : "HSV_OBJ" === n ? "{h:" + a + ",s:" + l + ",v:" + c + "}" : "HSVA_OBJ" === n ? "{h:" + a + ",s:" + l + ",v:" + c + ",a:" + s + "}" : "unknown format"
                    }
                    var e = Array.prototype.forEach,
                        n = Array.prototype.slice,
                        i = {
                            BREAK: {},
                            extend: function(t) {
                                return this.each(n.call(arguments, 1), (function(e) {
                                    (this.isObject(e) ? Object.keys(e) : []).forEach(function(n) {
                                        this.isUndefined(e[n]) || (t[n] = e[n])
                                    }.bind(this))
                                }), this), t
                            },
                            defaults: function(t) {
                                return this.each(n.call(arguments, 1), (function(e) {
                                    (this.isObject(e) ? Object.keys(e) : []).forEach(function(n) {
                                        this.isUndefined(t[n]) && (t[n] = e[n])
                                    }.bind(this))
                                }), this), t
                            },
                            compose: function() {
                                var t = n.call(arguments);
                                return function() {
                                    for (var e = n.call(arguments), i = t.length - 1; i >= 0; i--) e = [t[i].apply(this, e)];
                                    return e[0]
                                }
                            },
                            each: function(t, n, i) {
                                if (t)
                                    if (e && t.forEach && t.forEach === e) t.forEach(n, i);
                                    else if (t.length === t.length + 0) {
                                    var r, o = void 0;
                                    for (o = 0, r = t.length; o < r; o++)
                                        if (o in t && n.call(i, t[o], o) === this.BREAK) return
                                } else
                                    for (var s in t)
                                        if (n.call(i, t[s], s) === this.BREAK) return
                            },
                            defer: function(t) {
                                setTimeout(t, 0)
                            },
                            debounce: function(t, e, n) {
                                var i = void 0;
                                return function() {
                                    var r = this,
                                        o = arguments;

                                    function s() {
                                        i = null, n || t.apply(r, o)
                                    }
                                    var a = n || !i;
                                    clearTimeout(i), i = setTimeout(s, e), a && t.apply(r, o)
                                }
                            },
                            toArray: function(t) {
                                return t.toArray ? t.toArray() : n.call(t)
                            },
                            isUndefined: function(t) {
                                return void 0 === t
                            },
                            isNull: function(t) {
                                return null === t
                            },
                            isNaN: function(t) {
                                function e(e) {
                                    return t.apply(this, arguments)
                                }
                                return e.toString = function() {
                                    return t.toString()
                                }, e
                            }((function(t) {
                                return isNaN(t)
                            })),
                            isArray: Array.isArray || function(t) {
                                return t.constructor === Array
                            },
                            isObject: function(t) {
                                return t === Object(t)
                            },
                            isNumber: function(t) {
                                return t === t + 0
                            },
                            isString: function(t) {
                                return t === t + ""
                            },
                            isBoolean: function(t) {
                                return !1 === t || !0 === t
                            },
                            isFunction: function(t) {
                                return "[object Function]" === Object.prototype.toString.call(t)
                            }
                        },
                        r = [{
                            litmus: i.isString,
                            conversions: {
                                THREE_CHAR_HEX: {
                                    read: function(t) {
                                        var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                                        return null !== e && {
                                            space: "HEX",
                                            hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0)
                                        }
                                    },
                                    write: t
                                },
                                SIX_CHAR_HEX: {
                                    read: function(t) {
                                        var e = t.match(/^#([A-F0-9]{6})$/i);
                                        return null !== e && {
                                            space: "HEX",
                                            hex: parseInt("0x" + e[1].toString(), 0)
                                        }
                                    },
                                    write: t
                                },
                                CSS_RGB: {
                                    read: function(t) {
                                        var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                                        return null !== e && {
                                            space: "RGB",
                                            r: parseFloat(e[1]),
                                            g: parseFloat(e[2]),
                                            b: parseFloat(e[3])
                                        }
                                    },
                                    write: t
                                },
                                CSS_RGBA: {
                                    read: function(t) {
                                        var e = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                                        return null !== e && {
                                            space: "RGB",
                                            r: parseFloat(e[1]),
                                            g: parseFloat(e[2]),
                                            b: parseFloat(e[3]),
                                            a: parseFloat(e[4])
                                        }
                                    },
                                    write: t
                                }
                            }
                        }, {
                            litmus: i.isNumber,
                            conversions: {
                                HEX: {
                                    read: function(t) {
                                        return {
                                            space: "HEX",
                                            hex: t,
                                            conversionName: "HEX"
                                        }
                                    },
                                    write: function(t) {
                                        return t.hex
                                    }
                                }
                            }
                        }, {
                            litmus: i.isArray,
                            conversions: {
                                RGB_ARRAY: {
                                    read: function(t) {
                                        return 3 === t.length && {
                                            space: "RGB",
                                            r: t[0],
                                            g: t[1],
                                            b: t[2]
                                        }
                                    },
                                    write: function(t) {
                                        return [t.r, t.g, t.b]
                                    }
                                },
                                RGBA_ARRAY: {
                                    read: function(t) {
                                        return 4 === t.length && {
                                            space: "RGB",
                                            r: t[0],
                                            g: t[1],
                                            b: t[2],
                                            a: t[3]
                                        }
                                    },
                                    write: function(t) {
                                        return [t.r, t.g, t.b, t.a]
                                    }
                                }
                            }
                        }, {
                            litmus: i.isObject,
                            conversions: {
                                RGBA_OBJ: {
                                    read: function(t) {
                                        return !!(i.isNumber(t.r) && i.isNumber(t.g) && i.isNumber(t.b) && i.isNumber(t.a)) && {
                                            space: "RGB",
                                            r: t.r,
                                            g: t.g,
                                            b: t.b,
                                            a: t.a
                                        }
                                    },
                                    write: function(t) {
                                        return {
                                            r: t.r,
                                            g: t.g,
                                            b: t.b,
                                            a: t.a
                                        }
                                    }
                                },
                                RGB_OBJ: {
                                    read: function(t) {
                                        return !!(i.isNumber(t.r) && i.isNumber(t.g) && i.isNumber(t.b)) && {
                                            space: "RGB",
                                            r: t.r,
                                            g: t.g,
                                            b: t.b
                                        }
                                    },
                                    write: function(t) {
                                        return {
                                            r: t.r,
                                            g: t.g,
                                            b: t.b
                                        }
                                    }
                                },
                                HSVA_OBJ: {
                                    read: function(t) {
                                        return !!(i.isNumber(t.h) && i.isNumber(t.s) && i.isNumber(t.v) && i.isNumber(t.a)) && {
                                            space: "HSV",
                                            h: t.h,
                                            s: t.s,
                                            v: t.v,
                                            a: t.a
                                        }
                                    },
                                    write: function(t) {
                                        return {
                                            h: t.h,
                                            s: t.s,
                                            v: t.v,
                                            a: t.a
                                        }
                                    }
                                },
                                HSV_OBJ: {
                                    read: function(t) {
                                        return !!(i.isNumber(t.h) && i.isNumber(t.s) && i.isNumber(t.v)) && {
                                            space: "HSV",
                                            h: t.h,
                                            s: t.s,
                                            v: t.v
                                        }
                                    },
                                    write: function(t) {
                                        return {
                                            h: t.h,
                                            s: t.s,
                                            v: t.v
                                        }
                                    }
                                }
                            }
                        }],
                        o = void 0,
                        s = void 0,
                        a = function() {
                            s = !1;
                            var t = arguments.length > 1 ? i.toArray(arguments) : arguments[0];
                            return i.each(r, (function(e) {
                                if (e.litmus(t)) return i.each(e.conversions, (function(e, n) {
                                    if (o = e.read(t), !1 === s && !1 !== o) return s = o, o.conversionName = n, o.conversion = e, i.BREAK
                                })), i.BREAK
                            })), s
                        },
                        l = void 0,
                        c = {
                            hsv_to_rgb: function(t, e, n) {
                                var i = Math.floor(t / 60) % 6,
                                    r = t / 60 - Math.floor(t / 60),
                                    o = n * (1 - e),
                                    s = n * (1 - r * e),
                                    a = n * (1 - (1 - r) * e),
                                    l = [
                                        [n, a, o],
                                        [s, n, o],
                                        [o, n, a],
                                        [o, s, n],
                                        [a, o, n],
                                        [n, o, s]
                                    ][i];
                                return {
                                    r: 255 * l[0],
                                    g: 255 * l[1],
                                    b: 255 * l[2]
                                }
                            },
                            rgb_to_hsv: function(t, e, n) {
                                var i = Math.min(t, e, n),
                                    r = Math.max(t, e, n),
                                    o = r - i,
                                    s = void 0;
                                return 0 === r ? {
                                    h: NaN,
                                    s: 0,
                                    v: 0
                                } : (s = t === r ? (e - n) / o : e === r ? 2 + (n - t) / o : 4 + (t - e) / o, (s /= 6) < 0 && (s += 1), {
                                    h: 360 * s,
                                    s: o / r,
                                    v: r / 255
                                })
                            },
                            rgb_to_hex: function(t, e, n) {
                                var i = this.hex_with_component(0, 2, t);
                                return i = this.hex_with_component(i, 1, e), this.hex_with_component(i, 0, n)
                            },
                            component_from_hex: function(t, e) {
                                return t >> 8 * e & 255
                            },
                            hex_with_component: function(t, e, n) {
                                return n << (l = 8 * e) | t & ~(255 << l)
                            }
                        },
                        h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                            return typeof t
                        } : function(t) {
                            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                        },
                        u = function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        },
                        d = function() {
                            function t(t, e) {
                                for (var n = 0; n < e.length; n++) {
                                    var i = e[n];
                                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                                }
                            }
                            return function(e, n, i) {
                                return n && t(e.prototype, n), i && t(e, i), e
                            }
                        }(),
                        p = function t(e, n, i) {
                            null === e && (e = Function.prototype);
                            var r = Object.getOwnPropertyDescriptor(e, n);
                            if (void 0 === r) {
                                var o = Object.getPrototypeOf(e);
                                return null === o ? void 0 : t(o, n, i)
                            }
                            if ("value" in r) return r.value;
                            var s = r.get;
                            return void 0 !== s ? s.call(i) : void 0
                        },
                        f = function(t, e) {
                            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                            t.prototype = Object.create(e && e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                        },
                        m = function(t, e) {
                            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return !e || "object" != typeof e && "function" != typeof e ? t : e
                        },
                        g = function() {
                            function e() {
                                if (u(this, e), this.__state = a.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments");
                                this.__state.a = this.__state.a || 1
                            }
                            return d(e, [{
                                key: "toString",
                                value: function() {
                                    return t(this)
                                }
                            }, {
                                key: "toHexString",
                                value: function() {
                                    return t(this, !0)
                                }
                            }, {
                                key: "toOriginal",
                                value: function() {
                                    return this.__state.conversion.write(this)
                                }
                            }]), e
                        }();

                    function v(t, e, n) {
                        Object.defineProperty(t, e, {
                            get: function() {
                                return "RGB" === this.__state.space || g.recalculateRGB(this, e, n), this.__state[e]
                            },
                            set: function(t) {
                                "RGB" !== this.__state.space && (g.recalculateRGB(this, e, n), this.__state.space = "RGB"), this.__state[e] = t
                            }
                        })
                    }

                    function y(t, e) {
                        Object.defineProperty(t, e, {
                            get: function() {
                                return "HSV" === this.__state.space || g.recalculateHSV(this), this.__state[e]
                            },
                            set: function(t) {
                                "HSV" !== this.__state.space && (g.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = t
                            }
                        })
                    }
                    g.recalculateRGB = function(t, e, n) {
                        if ("HEX" === t.__state.space) t.__state[e] = c.component_from_hex(t.__state.hex, n);
                        else {
                            if ("HSV" !== t.__state.space) throw new Error("Corrupted color state");
                            i.extend(t.__state, c.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v))
                        }
                    }, g.recalculateHSV = function(t) {
                        var e = c.rgb_to_hsv(t.r, t.g, t.b);
                        i.extend(t.__state, {
                            s: e.s,
                            v: e.v
                        }), i.isNaN(e.h) ? i.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h
                    }, g.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], v(g.prototype, "r", 2), v(g.prototype, "g", 1), v(g.prototype, "b", 0), y(g.prototype, "h"), y(g.prototype, "s"), y(g.prototype, "v"), Object.defineProperty(g.prototype, "a", {
                        get: function() {
                            return this.__state.a
                        },
                        set: function(t) {
                            this.__state.a = t
                        }
                    }), Object.defineProperty(g.prototype, "hex", {
                        get: function() {
                            return "HEX" !== !this.__state.space && (this.__state.hex = c.rgb_to_hex(this.r, this.g, this.b)), this.__state.hex
                        },
                        set: function(t) {
                            this.__state.space = "HEX", this.__state.hex = t
                        }
                    });
                    var x = function() {
                            function t(e, n) {
                                u(this, t), this.initialValue = e[n], this.domElement = document.createElement("div"), this.object = e, this.property = n, this.__onChange = void 0, this.__onFinishChange = void 0
                            }
                            return d(t, [{
                                key: "onChange",
                                value: function(t) {
                                    return this.__onChange = t, this
                                }
                            }, {
                                key: "onFinishChange",
                                value: function(t) {
                                    return this.__onFinishChange = t, this
                                }
                            }, {
                                key: "setValue",
                                value: function(t) {
                                    return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this
                                }
                            }, {
                                key: "getValue",
                                value: function() {
                                    return this.object[this.property]
                                }
                            }, {
                                key: "updateDisplay",
                                value: function() {
                                    return this
                                }
                            }, {
                                key: "isModified",
                                value: function() {
                                    return this.initialValue !== this.getValue()
                                }
                            }]), t
                        }(),
                        b = {};
                    i.each({
                        HTMLEvents: ["change"],
                        MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
                        KeyboardEvents: ["keydown"]
                    }, (function(t, e) {
                        i.each(t, (function(t) {
                            b[t] = e
                        }))
                    }));
                    var w = /(\d+(\.\d+)?)px/;

                    function _(t) {
                        if ("0" === t || i.isUndefined(t)) return 0;
                        var e = t.match(w);
                        return i.isNull(e) ? 0 : parseFloat(e[1])
                    }
                    var S = {
                            makeSelectable: function(t, e) {
                                void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function() {
                                    return !1
                                } : function() {}, t.style.MozUserSelect = e ? "auto" : "none", t.style.KhtmlUserSelect = e ? "auto" : "none", t.unselectable = e ? "on" : "off")
                            },
                            makeFullscreen: function(t, e, n) {
                                var r = n,
                                    o = e;
                                i.isUndefined(o) && (o = !0), i.isUndefined(r) && (r = !0), t.style.position = "absolute", o && (t.style.left = 0, t.style.right = 0), r && (t.style.top = 0, t.style.bottom = 0)
                            },
                            fakeEvent: function(t, e, n, r) {
                                var o = n || {},
                                    s = b[e];
                                if (!s) throw new Error("Event type " + e + " not supported.");
                                var a = document.createEvent(s);
                                switch (s) {
                                    case "MouseEvents":
                                        var l = o.x || o.clientX || 0,
                                            c = o.y || o.clientY || 0;
                                        a.initMouseEvent(e, o.bubbles || !1, o.cancelable || !0, window, o.clickCount || 1, 0, 0, l, c, !1, !1, !1, !1, 0, null);
                                        break;
                                    case "KeyboardEvents":
                                        var h = a.initKeyboardEvent || a.initKeyEvent;
                                        i.defaults(o, {
                                            cancelable: !0,
                                            ctrlKey: !1,
                                            altKey: !1,
                                            shiftKey: !1,
                                            metaKey: !1,
                                            keyCode: void 0,
                                            charCode: void 0
                                        }), h(e, o.bubbles || !1, o.cancelable, window, o.ctrlKey, o.altKey, o.shiftKey, o.metaKey, o.keyCode, o.charCode);
                                        break;
                                    default:
                                        a.initEvent(e, o.bubbles || !1, o.cancelable || !0)
                                }
                                i.defaults(a, r), t.dispatchEvent(a)
                            },
                            bind: function(t, e, n, i) {
                                var r = i || !1;
                                return t.addEventListener ? t.addEventListener(e, n, r) : t.attachEvent && t.attachEvent("on" + e, n), S
                            },
                            unbind: function(t, e, n, i) {
                                var r = i || !1;
                                return t.removeEventListener ? t.removeEventListener(e, n, r) : t.detachEvent && t.detachEvent("on" + e, n), S
                            },
                            addClass: function(t, e) {
                                if (void 0 === t.className) t.className = e;
                                else if (t.className !== e) {
                                    var n = t.className.split(/ +/); - 1 === n.indexOf(e) && (n.push(e), t.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
                                }
                                return S
                            },
                            removeClass: function(t, e) {
                                if (e)
                                    if (t.className === e) t.removeAttribute("class");
                                    else {
                                        var n = t.className.split(/ +/),
                                            i = n.indexOf(e); - 1 !== i && (n.splice(i, 1), t.className = n.join(" "))
                                    }
                                else t.className = void 0;
                                return S
                            },
                            hasClass: function(t, e) {
                                return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1
                            },
                            getWidth: function(t) {
                                var e = getComputedStyle(t);
                                return _(e["border-left-width"]) + _(e["border-right-width"]) + _(e["padding-left"]) + _(e["padding-right"]) + _(e.width)
                            },
                            getHeight: function(t) {
                                var e = getComputedStyle(t);
                                return _(e["border-top-width"]) + _(e["border-bottom-width"]) + _(e["padding-top"]) + _(e["padding-bottom"]) + _(e.height)
                            },
                            getOffset: function(t) {
                                var e = t,
                                    n = {
                                        left: 0,
                                        top: 0
                                    };
                                if (e.offsetParent)
                                    do {
                                        n.left += e.offsetLeft, n.top += e.offsetTop, e = e.offsetParent
                                    } while (e);
                                return n
                            },
                            isActive: function(t) {
                                return t === document.activeElement && (t.type || t.href)
                            }
                        },
                        M = function(t) {
                            function e(t, n) {
                                u(this, e);
                                var i = m(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                                    r = i;
                                return i.__prev = i.getValue(), i.__checkbox = document.createElement("input"), i.__checkbox.setAttribute("type", "checkbox"), S.bind(i.__checkbox, "change", (function() {
                                    r.setValue(!r.__prev)
                                }), !1), i.domElement.appendChild(i.__checkbox), i.updateDisplay(), i
                            }
                            return f(e, t), d(e, [{
                                key: "setValue",
                                value: function(t) {
                                    var n = p(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                                    return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), n
                                }
                            }, {
                                key: "updateDisplay",
                                value: function() {
                                    return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), p(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                                }
                            }]), e
                        }(x),
                        A = function(t) {
                            function e(t, n, r) {
                                u(this, e);
                                var o = m(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                                    s = r,
                                    a = o;
                                if (o.__select = document.createElement("select"), i.isArray(s)) {
                                    var l = {};
                                    i.each(s, (function(t) {
                                        l[t] = t
                                    })), s = l
                                }
                                return i.each(s, (function(t, e) {
                                    var n = document.createElement("option");
                                    n.innerHTML = e, n.setAttribute("value", t), a.__select.appendChild(n)
                                })), o.updateDisplay(), S.bind(o.__select, "change", (function() {
                                    var t = this.options[this.selectedIndex].value;
                                    a.setValue(t)
                                })), o.domElement.appendChild(o.__select), o
                            }
                            return f(e, t), d(e, [{
                                key: "setValue",
                                value: function(t) {
                                    var n = p(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                                    return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), n
                                }
                            }, {
                                key: "updateDisplay",
                                value: function() {
                                    return S.isActive(this.__select) ? this : (this.__select.value = this.getValue(), p(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this))
                                }
                            }]), e
                        }(x),
                        T = function(t) {
                            function e(t, n) {
                                u(this, e);
                                var i = m(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                                    r = i;

                                function o() {
                                    r.setValue(r.__input.value)
                                }
                                return i.__input = document.createElement("input"), i.__input.setAttribute("type", "text"), S.bind(i.__input, "keyup", o), S.bind(i.__input, "change", o), S.bind(i.__input, "blur", (function() {
                                    r.__onFinishChange && r.__onFinishChange.call(r, r.getValue())
                                })), S.bind(i.__input, "keydown", (function(t) {
                                    13 === t.keyCode && this.blur()
                                })), i.updateDisplay(), i.domElement.appendChild(i.__input), i
                            }
                            return f(e, t), d(e, [{
                                key: "updateDisplay",
                                value: function() {
                                    return S.isActive(this.__input) || (this.__input.value = this.getValue()), p(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                                }
                            }]), e
                        }(x);

                    function E(t) {
                        var e = t.toString();
                        return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0
                    }
                    var C = function(t) {
                            function e(t, n, r) {
                                u(this, e);
                                var o = m(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                                    s = r || {};
                                return o.__min = s.min, o.__max = s.max, o.__step = s.step, i.isUndefined(o.__step) ? 0 === o.initialValue ? o.__impliedStep = 1 : o.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(o.initialValue)) / Math.LN10)) / 10 : o.__impliedStep = o.__step, o.__precision = E(o.__impliedStep), o
                            }
                            return f(e, t), d(e, [{
                                key: "setValue",
                                value: function(t) {
                                    var n = t;
                                    return void 0 !== this.__min && n < this.__min ? n = this.__min : void 0 !== this.__max && n > this.__max && (n = this.__max), void 0 !== this.__step && n % this.__step != 0 && (n = Math.round(n / this.__step) * this.__step), p(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, n)
                                }
                            }, {
                                key: "min",
                                value: function(t) {
                                    return this.__min = t, this
                                }
                            }, {
                                key: "max",
                                value: function(t) {
                                    return this.__max = t, this
                                }
                            }, {
                                key: "step",
                                value: function(t) {
                                    return this.__step = t, this.__impliedStep = t, this.__precision = E(t), this
                                }
                            }]), e
                        }(x),
                        P = function(t) {
                            function e(t, n, r) {
                                u(this, e);
                                var o = m(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, r));
                                o.__truncationSuspended = !1;
                                var s = o,
                                    a = void 0;

                                function l() {
                                    s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
                                }

                                function c(t) {
                                    var e = a - t.clientY;
                                    s.setValue(s.getValue() + e * s.__impliedStep), a = t.clientY
                                }

                                function h() {
                                    S.unbind(window, "mousemove", c), S.unbind(window, "mouseup", h), l()
                                }
                                return o.__input = document.createElement("input"), o.__input.setAttribute("type", "text"), S.bind(o.__input, "change", (function() {
                                    var t = parseFloat(s.__input.value);
                                    i.isNaN(t) || s.setValue(t)
                                })), S.bind(o.__input, "blur", (function() {
                                    l()
                                })), S.bind(o.__input, "mousedown", (function(t) {
                                    S.bind(window, "mousemove", c), S.bind(window, "mouseup", h), a = t.clientY
                                })), S.bind(o.__input, "keydown", (function(t) {
                                    13 === t.keyCode && (s.__truncationSuspended = !0, this.blur(), s.__truncationSuspended = !1, l())
                                })), o.updateDisplay(), o.domElement.appendChild(o.__input), o
                            }
                            return f(e, t), d(e, [{
                                key: "updateDisplay",
                                value: function() {
                                    var t, n, i;
                                    return this.__input.value = this.__truncationSuspended ? this.getValue() : (t = this.getValue(), n = this.__precision, i = Math.pow(10, n), Math.round(t * i) / i), p(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                                }
                            }]), e
                        }(C);

                    function L(t, e, n, i, r) {
                        return i + (t - e) / (n - e) * (r - i)
                    }
                    var R = function(t) {
                            function e(t, n, i, r, o) {
                                u(this, e);
                                var s = m(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, {
                                        min: i,
                                        max: r,
                                        step: o
                                    })),
                                    a = s;

                                function l(t) {
                                    t.preventDefault();
                                    var e = a.__background.getBoundingClientRect();
                                    return a.setValue(L(t.clientX, e.left, e.right, a.__min, a.__max)), !1
                                }

                                function c() {
                                    S.unbind(window, "mousemove", l), S.unbind(window, "mouseup", c), a.__onFinishChange && a.__onFinishChange.call(a, a.getValue())
                                }

                                function h(t) {
                                    var e = t.touches[0].clientX,
                                        n = a.__background.getBoundingClientRect();
                                    a.setValue(L(e, n.left, n.right, a.__min, a.__max))
                                }

                                function d() {
                                    S.unbind(window, "touchmove", h), S.unbind(window, "touchend", d), a.__onFinishChange && a.__onFinishChange.call(a, a.getValue())
                                }
                                return s.__background = document.createElement("div"), s.__foreground = document.createElement("div"), S.bind(s.__background, "mousedown", (function(t) {
                                    document.activeElement.blur(), S.bind(window, "mousemove", l), S.bind(window, "mouseup", c), l(t)
                                })), S.bind(s.__background, "touchstart", (function(t) {
                                    1 === t.touches.length && (S.bind(window, "touchmove", h), S.bind(window, "touchend", d), h(t))
                                })), S.addClass(s.__background, "slider"), S.addClass(s.__foreground, "slider-fg"), s.updateDisplay(), s.__background.appendChild(s.__foreground), s.domElement.appendChild(s.__background), s
                            }
                            return f(e, t), d(e, [{
                                key: "updateDisplay",
                                value: function() {
                                    var t = (this.getValue() - this.__min) / (this.__max - this.__min);
                                    return this.__foreground.style.width = 100 * t + "%", p(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                                }
                            }]), e
                        }(C),
                        I = function(t) {
                            function e(t, n, i) {
                                u(this, e);
                                var r = m(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                                    o = r;
                                return r.__button = document.createElement("div"), r.__button.innerHTML = void 0 === i ? "Fire" : i, S.bind(r.__button, "click", (function(t) {
                                    return t.preventDefault(), o.fire(), !1
                                })), S.addClass(r.__button, "button"), r.domElement.appendChild(r.__button), r
                            }
                            return f(e, t), d(e, [{
                                key: "fire",
                                value: function() {
                                    this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
                                }
                            }]), e
                        }(x),
                        F = function(t) {
                            function e(t, n) {
                                u(this, e);
                                var r = m(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
                                r.__color = new g(r.getValue()), r.__temp = new g(0);
                                var o = r;
                                r.domElement = document.createElement("div"), S.makeSelectable(r.domElement, !1), r.__selector = document.createElement("div"), r.__selector.className = "selector", r.__saturation_field = document.createElement("div"), r.__saturation_field.className = "saturation-field", r.__field_knob = document.createElement("div"), r.__field_knob.className = "field-knob", r.__field_knob_border = "2px solid ", r.__hue_knob = document.createElement("div"), r.__hue_knob.className = "hue-knob", r.__hue_field = document.createElement("div"), r.__hue_field.className = "hue-field", r.__input = document.createElement("input"), r.__input.type = "text", r.__input_textShadow = "0 1px 1px ", S.bind(r.__input, "keydown", (function(t) {
                                    13 === t.keyCode && f.call(this)
                                })), S.bind(r.__input, "blur", f), S.bind(r.__selector, "mousedown", (function() {
                                    S.addClass(this, "drag").bind(window, "mouseup", (function() {
                                        S.removeClass(o.__selector, "drag")
                                    }))
                                })), S.bind(r.__selector, "touchstart", (function() {
                                    S.addClass(this, "drag").bind(window, "touchend", (function() {
                                        S.removeClass(o.__selector, "drag")
                                    }))
                                }));
                                var s, l = document.createElement("div");

                                function c(t) {
                                    y(t), S.bind(window, "mousemove", y), S.bind(window, "touchmove", y), S.bind(window, "mouseup", d), S.bind(window, "touchend", d)
                                }

                                function h(t) {
                                    x(t), S.bind(window, "mousemove", x), S.bind(window, "touchmove", x), S.bind(window, "mouseup", p), S.bind(window, "touchend", p)
                                }

                                function d() {
                                    S.unbind(window, "mousemove", y), S.unbind(window, "touchmove", y), S.unbind(window, "mouseup", d), S.unbind(window, "touchend", d), v()
                                }

                                function p() {
                                    S.unbind(window, "mousemove", x), S.unbind(window, "touchmove", x), S.unbind(window, "mouseup", p), S.unbind(window, "touchend", p), v()
                                }

                                function f() {
                                    var t = a(this.value);
                                    !1 !== t ? (o.__color.__state = t, o.setValue(o.__color.toOriginal())) : this.value = o.__color.toString()
                                }

                                function v() {
                                    o.__onFinishChange && o.__onFinishChange.call(o, o.__color.toOriginal())
                                }

                                function y(t) {
                                    -1 === t.type.indexOf("touch") && t.preventDefault();
                                    var e = o.__saturation_field.getBoundingClientRect(),
                                        n = t.touches && t.touches[0] || t,
                                        i = n.clientX,
                                        r = n.clientY,
                                        s = (i - e.left) / (e.right - e.left),
                                        a = 1 - (r - e.top) / (e.bottom - e.top);
                                    return a > 1 ? a = 1 : a < 0 && (a = 0), s > 1 ? s = 1 : s < 0 && (s = 0), o.__color.v = a, o.__color.s = s, o.setValue(o.__color.toOriginal()), !1
                                }

                                function x(t) {
                                    -1 === t.type.indexOf("touch") && t.preventDefault();
                                    var e = o.__hue_field.getBoundingClientRect(),
                                        n = 1 - ((t.touches && t.touches[0] || t).clientY - e.top) / (e.bottom - e.top);
                                    return n > 1 ? n = 1 : n < 0 && (n = 0), o.__color.h = 360 * n, o.setValue(o.__color.toOriginal()), !1
                                }
                                return i.extend(r.__selector.style, {
                                    width: "122px",
                                    height: "102px",
                                    padding: "3px",
                                    backgroundColor: "#222",
                                    boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
                                }), i.extend(r.__field_knob.style, {
                                    position: "absolute",
                                    width: "12px",
                                    height: "12px",
                                    border: r.__field_knob_border + (r.__color.v < .5 ? "#fff" : "#000"),
                                    boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                                    borderRadius: "12px",
                                    zIndex: 1
                                }), i.extend(r.__hue_knob.style, {
                                    position: "absolute",
                                    width: "15px",
                                    height: "2px",
                                    borderRight: "4px solid #fff",
                                    zIndex: 1
                                }), i.extend(r.__saturation_field.style, {
                                    width: "100px",
                                    height: "100px",
                                    border: "1px solid #555",
                                    marginRight: "3px",
                                    display: "inline-block",
                                    cursor: "pointer"
                                }), i.extend(l.style, {
                                    width: "100%",
                                    height: "100%",
                                    background: "none"
                                }), N(l, "top", "rgba(0,0,0,0)", "#000"), i.extend(r.__hue_field.style, {
                                    width: "15px",
                                    height: "100px",
                                    border: "1px solid #555",
                                    cursor: "ns-resize",
                                    position: "absolute",
                                    top: "3px",
                                    right: "3px"
                                }), (s = r.__hue_field).style.background = "", s.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", s.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", s.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", s.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", s.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", i.extend(r.__input.style, {
                                    outline: "none",
                                    textAlign: "center",
                                    color: "#fff",
                                    border: 0,
                                    fontWeight: "bold",
                                    textShadow: r.__input_textShadow + "rgba(0,0,0,0.7)"
                                }), S.bind(r.__saturation_field, "mousedown", c), S.bind(r.__saturation_field, "touchstart", c), S.bind(r.__field_knob, "mousedown", c), S.bind(r.__field_knob, "touchstart", c), S.bind(r.__hue_field, "mousedown", h), S.bind(r.__hue_field, "touchstart", h), r.__saturation_field.appendChild(l), r.__selector.appendChild(r.__field_knob), r.__selector.appendChild(r.__saturation_field), r.__selector.appendChild(r.__hue_field), r.__hue_field.appendChild(r.__hue_knob), r.domElement.appendChild(r.__input), r.domElement.appendChild(r.__selector), r.updateDisplay(), r
                            }
                            return f(e, t), d(e, [{
                                key: "updateDisplay",
                                value: function() {
                                    var t = a(this.getValue());
                                    if (!1 !== t) {
                                        var e = !1;
                                        i.each(g.COMPONENTS, (function(n) {
                                            if (!i.isUndefined(t[n]) && !i.isUndefined(this.__color.__state[n]) && t[n] !== this.__color.__state[n]) return e = !0, {}
                                        }), this), e && i.extend(this.__color.__state, t)
                                    }
                                    i.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
                                    var n = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0,
                                        r = 255 - n;
                                    i.extend(this.__field_knob.style, {
                                        marginLeft: 100 * this.__color.s - 7 + "px",
                                        marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                                        backgroundColor: this.__temp.toHexString(),
                                        border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")"
                                    }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, N(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), i.extend(this.__input.style, {
                                        backgroundColor: this.__color.toHexString(),
                                        color: "rgb(" + n + "," + n + "," + n + ")",
                                        textShadow: this.__input_textShadow + "rgba(" + r + "," + r + "," + r + ",.7)"
                                    })
                                }
                            }]), e
                        }(x),
                        O = ["-moz-", "-o-", "-webkit-", "-ms-", ""];

                    function N(t, e, n, r) {
                        t.style.background = "", i.each(O, (function(i) {
                            t.style.cssText += "background: " + i + "linear-gradient(" + e + ", " + n + " 0%, " + r + " 100%); "
                        }))
                    }
                    var B = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>',
                        D = function(t, e) {
                            var n = t[e];
                            return i.isArray(arguments[2]) || i.isObject(arguments[2]) ? new A(t, e, arguments[2]) : i.isNumber(n) ? i.isNumber(arguments[2]) && i.isNumber(arguments[3]) ? i.isNumber(arguments[4]) ? new R(t, e, arguments[2], arguments[3], arguments[4]) : new R(t, e, arguments[2], arguments[3]) : i.isNumber(arguments[4]) ? new P(t, e, {
                                min: arguments[2],
                                max: arguments[3],
                                step: arguments[4]
                            }) : new P(t, e, {
                                min: arguments[2],
                                max: arguments[3]
                            }) : i.isString(n) ? new T(t, e) : i.isFunction(n) ? new I(t, e, "") : i.isBoolean(n) ? new M(t, e) : null
                        },
                        V = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t) {
                            setTimeout(t, 1e3 / 60)
                        },
                        j = function() {
                            function t() {
                                u(this, t), this.backgroundElement = document.createElement("div"), i.extend(this.backgroundElement.style, {
                                    backgroundColor: "rgba(0,0,0,0.8)",
                                    top: 0,
                                    left: 0,
                                    display: "none",
                                    zIndex: "1000",
                                    opacity: 0,
                                    WebkitTransition: "opacity 0.2s linear",
                                    transition: "opacity 0.2s linear"
                                }), S.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), i.extend(this.domElement.style, {
                                    position: "fixed",
                                    display: "none",
                                    zIndex: "1001",
                                    opacity: 0,
                                    WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                                    transition: "transform 0.2s ease-out, opacity 0.2s linear"
                                }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
                                var e = this;
                                S.bind(this.backgroundElement, "click", (function() {
                                    e.hide()
                                }))
                            }
                            return d(t, [{
                                key: "show",
                                value: function() {
                                    var t = this;
                                    this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), i.defer((function() {
                                        t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)"
                                    }))
                                }
                            }, {
                                key: "hide",
                                value: function() {
                                    var t = this,
                                        e = function e() {
                                            t.domElement.style.display = "none", t.backgroundElement.style.display = "none", S.unbind(t.domElement, "webkitTransitionEnd", e), S.unbind(t.domElement, "transitionend", e), S.unbind(t.domElement, "oTransitionEnd", e)
                                        };
                                    S.bind(this.domElement, "webkitTransitionEnd", e), S.bind(this.domElement, "transitionend", e), S.bind(this.domElement, "oTransitionEnd", e), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
                                }
                            }, {
                                key: "layout",
                                value: function() {
                                    this.domElement.style.left = window.innerWidth / 2 - S.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - S.getHeight(this.domElement) / 2 + "px"
                                }
                            }]), t
                        }(),
                        k = "Default",
                        U = function() {
                            try {
                                return "localStorage" in window && null !== window.localStorage
                            } catch (t) {
                                return !1
                            }
                        }(),
                        z = void 0,
                        G = !0,
                        H = void 0,
                        W = !1,
                        Y = [],
                        X = function t(e) {
                            var n = this,
                                r = e || {};
                            this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), S.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], r = i.defaults(r, {
                                closeOnTop: !1,
                                autoPlace: !0,
                                width: t.DEFAULT_WIDTH
                            }), r = i.defaults(r, {
                                resizable: r.autoPlace,
                                hideable: r.autoPlace
                            }), i.isUndefined(r.load) ? r.load = {
                                preset: k
                            } : r.preset && (r.load.preset = r.preset), i.isUndefined(r.parent) && r.hideable && Y.push(this), r.resizable = i.isUndefined(r.parent) && r.resizable, r.autoPlace && i.isUndefined(r.scrollable) && (r.scrollable = !0);
                            var o, s = U && "true" === localStorage.getItem($(0, "isLocal")),
                                a = void 0;
                            if (Object.defineProperties(this, {
                                    parent: {
                                        get: function() {
                                            return r.parent
                                        }
                                    },
                                    scrollable: {
                                        get: function() {
                                            return r.scrollable
                                        }
                                    },
                                    autoPlace: {
                                        get: function() {
                                            return r.autoPlace
                                        }
                                    },
                                    closeOnTop: {
                                        get: function() {
                                            return r.closeOnTop
                                        }
                                    },
                                    preset: {
                                        get: function() {
                                            return n.parent ? n.getRoot().preset : r.load.preset
                                        },
                                        set: function(t) {
                                            n.parent ? n.getRoot().preset = t : r.load.preset = t,
                                                function(t) {
                                                    for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e)
                                                }(this), n.revert()
                                        }
                                    },
                                    width: {
                                        get: function() {
                                            return r.width
                                        },
                                        set: function(t) {
                                            r.width = t, it(n, t)
                                        }
                                    },
                                    name: {
                                        get: function() {
                                            return r.name
                                        },
                                        set: function(t) {
                                            r.name = t, titleRowName && (titleRowName.innerHTML = r.name)
                                        }
                                    },
                                    closed: {
                                        get: function() {
                                            return r.closed
                                        },
                                        set: function(e) {
                                            r.closed = e, r.closed ? S.addClass(n.__ul, t.CLASS_CLOSED) : S.removeClass(n.__ul, t.CLASS_CLOSED), this.onResize(), n.__closeButton && (n.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED)
                                        }
                                    },
                                    load: {
                                        get: function() {
                                            return r.load
                                        }
                                    },
                                    useLocalStorage: {
                                        get: function() {
                                            return s
                                        },
                                        set: function(t) {
                                            U && (s = t, t ? S.bind(window, "unload", a) : S.unbind(window, "unload", a), localStorage.setItem($(0, "isLocal"), t))
                                        }
                                    }
                                }), i.isUndefined(r.parent)) {
                                if (r.closed = !1, S.addClass(this.domElement, t.CLASS_MAIN), S.makeSelectable(this.domElement, !1), U && s) {
                                    n.useLocalStorage = !0;
                                    var l = localStorage.getItem($(0, "gui"));
                                    l && (r.load = JSON.parse(l))
                                }
                                this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t.TEXT_CLOSED, S.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON), r.closeOnTop ? (S.addClass(this.__closeButton, t.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (S.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), S.bind(this.__closeButton, "click", (function() {
                                    n.closed = !n.closed
                                }))
                            } else {
                                void 0 === r.closed && (r.closed = !0);
                                var c = document.createTextNode(r.name);
                                S.addClass(c, "controller-name");
                                var h = q(n, c);
                                S.addClass(this.__ul, t.CLASS_CLOSED), S.addClass(h, "title"), S.bind(h, "click", (function(t) {
                                    return t.preventDefault(), n.closed = !n.closed, !1
                                })), r.closed || (this.closed = !1)
                            }
                            r.autoPlace && (i.isUndefined(r.parent) && (G && (H = document.createElement("div"), S.addClass(H, "dg"), S.addClass(H, t.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(H), G = !1), H.appendChild(this.domElement), S.addClass(this.domElement, t.CLASS_AUTO_PLACE)), this.parent || it(n, r.width)), a = function() {
                                U && "true" === localStorage.getItem($(0, "isLocal")) && localStorage.setItem($(0, "gui"), JSON.stringify(n.getSaveObject()))
                            }, this.saveToLocalStorageIfPossible = a, r.parent || ((o = n.getRoot()).width += 1, i.defer((function() {
                                o.width -= 1
                            })))
                        };

                    function q(t, e, n) {
                        var i = document.createElement("li");
                        return e && i.appendChild(e), n ? t.__ul.insertBefore(i, n) : t.__ul.appendChild(i), t.onResize(), i
                    }

                    function Q(t) {
                        S.unbind(window, "resize", t.__resizeHandler), t.saveToLocalStorageIfPossible && S.unbind(window, "unload", t.saveToLocalStorageIfPossible)
                    }

                    function Z(t, e) {
                        var n = t.__preset_select[t.__preset_select.selectedIndex];
                        n.innerHTML = e ? n.value + "*" : n.value
                    }

                    function J(t, e) {
                        var n = t.getRoot(),
                            i = n.__rememberedObjects.indexOf(e.object);
                        if (-1 !== i) {
                            var r = n.__rememberedObjectIndecesToControllers[i];
                            if (void 0 === r && (r = {}, n.__rememberedObjectIndecesToControllers[i] = r), r[e.property] = e, n.load && n.load.remembered) {
                                var o = n.load.remembered,
                                    s = void 0;
                                if (o[t.preset]) s = o[t.preset];
                                else {
                                    if (!o[k]) return;
                                    s = o[k]
                                }
                                if (s[i] && void 0 !== s[i][e.property]) {
                                    var a = s[i][e.property];
                                    e.initialValue = a, e.setValue(a)
                                }
                            }
                        }
                    }

                    function K(t, e, n, r) {
                        if (void 0 === e[n]) throw new Error('Object "' + e + '" has no property "' + n + '"');
                        var o = void 0;
                        if (r.color) o = new F(e, n);
                        else {
                            var s = [e, n].concat(r.factoryArgs);
                            o = D.apply(t, s)
                        }
                        r.before instanceof x && (r.before = r.before.__li), J(t, o), S.addClass(o.domElement, "c");
                        var a = document.createElement("span");
                        S.addClass(a, "property-name"), a.innerHTML = o.property;
                        var l = document.createElement("div");
                        l.appendChild(a), l.appendChild(o.domElement);
                        var c = q(t, l, r.before);
                        return S.addClass(c, X.CLASS_CONTROLLER_ROW), o instanceof F ? S.addClass(c, "color") : S.addClass(c, h(o.getValue())),
                            function(t, e, n) {
                                if (n.__li = e, n.__gui = t, i.extend(n, {
                                        options: function(e) {
                                            if (arguments.length > 1) {
                                                var r = n.__li.nextElementSibling;
                                                return n.remove(), K(t, n.object, n.property, {
                                                    before: r,
                                                    factoryArgs: [i.toArray(arguments)]
                                                })
                                            }
                                            if (i.isArray(e) || i.isObject(e)) {
                                                var o = n.__li.nextElementSibling;
                                                return n.remove(), K(t, n.object, n.property, {
                                                    before: o,
                                                    factoryArgs: [e]
                                                })
                                            }
                                        },
                                        name: function(t) {
                                            return n.__li.firstElementChild.firstElementChild.innerHTML = t, n
                                        },
                                        listen: function() {
                                            return n.__gui.listen(n), n
                                        },
                                        remove: function() {
                                            return n.__gui.remove(n), n
                                        }
                                    }), n instanceof R) {
                                    var r = new P(n.object, n.property, {
                                        min: n.__min,
                                        max: n.__max,
                                        step: n.__step
                                    });
                                    i.each(["updateDisplay", "onChange", "onFinishChange", "step"], (function(t) {
                                        var e = n[t],
                                            i = r[t];
                                        n[t] = r[t] = function() {
                                            var t = Array.prototype.slice.call(arguments);
                                            return i.apply(r, t), e.apply(n, t)
                                        }
                                    })), S.addClass(e, "has-slider"), n.domElement.insertBefore(r.domElement, n.domElement.firstElementChild)
                                } else if (n instanceof P) {
                                    var o = function(e) {
                                        if (i.isNumber(n.__min) && i.isNumber(n.__max)) {
                                            var r = n.__li.firstElementChild.firstElementChild.innerHTML,
                                                o = n.__gui.__listening.indexOf(n) > -1;
                                            n.remove();
                                            var s = K(t, n.object, n.property, {
                                                before: n.__li.nextElementSibling,
                                                factoryArgs: [n.__min, n.__max, n.__step]
                                            });
                                            return s.name(r), o && s.listen(), s
                                        }
                                        return e
                                    };
                                    n.min = i.compose(o, n.min), n.max = i.compose(o, n.max)
                                } else n instanceof M ? (S.bind(e, "click", (function() {
                                    S.fakeEvent(n.__checkbox, "click")
                                })), S.bind(n.__checkbox, "click", (function(t) {
                                    t.stopPropagation()
                                }))) : n instanceof I ? (S.bind(e, "click", (function() {
                                    S.fakeEvent(n.__button, "click")
                                })), S.bind(e, "mouseover", (function() {
                                    S.addClass(n.__button, "hover")
                                })), S.bind(e, "mouseout", (function() {
                                    S.removeClass(n.__button, "hover")
                                }))) : n instanceof F && (S.addClass(e, "color"), n.updateDisplay = i.compose((function(t) {
                                    return e.style.borderLeftColor = n.__color.toString(), t
                                }), n.updateDisplay), n.updateDisplay());
                                n.setValue = i.compose((function(e) {
                                    return t.getRoot().__preset_select && n.isModified() && Z(t.getRoot(), !0), e
                                }), n.setValue)
                            }(t, c, o), t.__controllers.push(o), o
                    }

                    function $(t, e) {
                        return document.location.href + "." + e
                    }

                    function tt(t, e, n) {
                        var i = document.createElement("option");
                        i.innerHTML = e, i.value = e, t.__preset_select.appendChild(i), n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
                    }

                    function et(t, e) {
                        e.style.display = t.useLocalStorage ? "block" : "none"
                    }

                    function nt(t) {
                        var e = t.__save_row = document.createElement("li");
                        S.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), S.addClass(e, "save-row");
                        var n = document.createElement("span");
                        n.innerHTML = "&nbsp;", S.addClass(n, "button gears");
                        var r = document.createElement("span");
                        r.innerHTML = "Save", S.addClass(r, "button"), S.addClass(r, "save");
                        var o = document.createElement("span");
                        o.innerHTML = "New", S.addClass(o, "button"), S.addClass(o, "save-as");
                        var s = document.createElement("span");
                        s.innerHTML = "Revert", S.addClass(s, "button"), S.addClass(s, "revert");
                        var a = t.__preset_select = document.createElement("select");
                        if (t.load && t.load.remembered ? i.each(t.load.remembered, (function(e, n) {
                                tt(t, n, n === t.preset)
                            })) : tt(t, k, !1), S.bind(a, "change", (function() {
                                for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].innerHTML = t.__preset_select[e].value;
                                t.preset = this.value
                            })), e.appendChild(a), e.appendChild(n), e.appendChild(r), e.appendChild(o), e.appendChild(s), U) {
                            var l = document.getElementById("dg-local-explain"),
                                c = document.getElementById("dg-local-storage");
                            document.getElementById("dg-save-locally").style.display = "block", "true" === localStorage.getItem($(0, "isLocal")) && c.setAttribute("checked", "checked"), et(t, l), S.bind(c, "change", (function() {
                                t.useLocalStorage = !t.useLocalStorage, et(t, l)
                            }))
                        }
                        var h = document.getElementById("dg-new-constructor");
                        S.bind(h, "keydown", (function(t) {
                            !t.metaKey || 67 !== t.which && 67 !== t.keyCode || z.hide()
                        })), S.bind(n, "click", (function() {
                            h.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), z.show(), h.focus(), h.select()
                        })), S.bind(r, "click", (function() {
                            t.save()
                        })), S.bind(o, "click", (function() {
                            var e = prompt("Enter a new preset name.");
                            e && t.saveAs(e)
                        })), S.bind(s, "click", (function() {
                            t.revert()
                        }))
                    }

                    function it(t, e) {
                        t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px")
                    }

                    function rt(t, e) {
                        var n = {};
                        return i.each(t.__rememberedObjects, (function(r, o) {
                            var s = {},
                                a = t.__rememberedObjectIndecesToControllers[o];
                            i.each(a, (function(t, n) {
                                s[n] = e ? t.initialValue : t.getValue()
                            })), n[o] = s
                        })), n
                    }
                    return X.toggleHide = function() {
                        W = !W, i.each(Y, (function(t) {
                            t.domElement.style.display = W ? "none" : ""
                        }))
                    }, X.CLASS_AUTO_PLACE = "a", X.CLASS_AUTO_PLACE_CONTAINER = "ac", X.CLASS_MAIN = "main", X.CLASS_CONTROLLER_ROW = "cr", X.CLASS_TOO_TALL = "taller-than-window", X.CLASS_CLOSED = "closed", X.CLASS_CLOSE_BUTTON = "close-button", X.CLASS_CLOSE_TOP = "close-top", X.CLASS_CLOSE_BOTTOM = "close-bottom", X.CLASS_DRAG = "drag", X.DEFAULT_WIDTH = 240, X.TEXT_CLOSED = "Close Controls", X.TEXT_OPEN = "Open Controls", X._keydownHandler = function(t) {
                        "text" === document.activeElement.type || 72 !== t.which && 72 !== t.keyCode || X.toggleHide()
                    }, S.bind(window, "keydown", X._keydownHandler, !1), i.extend(X.prototype, {
                        add: function(t, e) {
                            return K(this, t, e, {
                                factoryArgs: Array.prototype.slice.call(arguments, 2)
                            })
                        },
                        addColor: function(t, e) {
                            return K(this, t, e, {
                                color: !0
                            })
                        },
                        remove: function(t) {
                            this.__ul.removeChild(t.__li), this.__controllers.splice(this.__controllers.indexOf(t), 1);
                            var e = this;
                            i.defer((function() {
                                e.onResize()
                            }))
                        },
                        destroy: function() {
                            if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
                            this.autoPlace && H.removeChild(this.domElement);
                            var t = this;
                            i.each(this.__folders, (function(e) {
                                t.removeFolder(e)
                            })), S.unbind(window, "keydown", X._keydownHandler, !1), Q(this)
                        },
                        addFolder: function(t) {
                            if (void 0 !== this.__folders[t]) throw new Error('You already have a folder in this GUI by the name "' + t + '"');
                            var e = {
                                name: t,
                                parent: this
                            };
                            e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed, e.load = this.load.folders[t]);
                            var n = new X(e);
                            this.__folders[t] = n;
                            var i = q(this, n.domElement);
                            return S.addClass(i, "folder"), n
                        },
                        removeFolder: function(t) {
                            this.__ul.removeChild(t.domElement.parentElement), delete this.__folders[t.name], this.load && this.load.folders && this.load.folders[t.name] && delete this.load.folders[t.name], Q(t);
                            var e = this;
                            i.each(t.__folders, (function(e) {
                                t.removeFolder(e)
                            })), i.defer((function() {
                                e.onResize()
                            }))
                        },
                        open: function() {
                            this.closed = !1
                        },
                        close: function() {
                            this.closed = !0
                        },
                        onResize: function() {
                            var t = this.getRoot();
                            if (t.scrollable) {
                                var e = S.getOffset(t.__ul).top,
                                    n = 0;
                                i.each(t.__ul.childNodes, (function(e) {
                                    t.autoPlace && e === t.__save_row || (n += S.getHeight(e))
                                })), window.innerHeight - e - 20 < n ? (S.addClass(t.domElement, X.CLASS_TOO_TALL), t.__ul.style.height = window.innerHeight - e - 20 + "px") : (S.removeClass(t.domElement, X.CLASS_TOO_TALL), t.__ul.style.height = "auto")
                            }
                            t.__resize_handle && i.defer((function() {
                                t.__resize_handle.style.height = t.__ul.offsetHeight + "px"
                            })), t.__closeButton && (t.__closeButton.style.width = t.width + "px")
                        },
                        onResizeDebounced: i.debounce((function() {
                            this.onResize()
                        }), 50),
                        remember: function() {
                            if (i.isUndefined(z) && ((z = new j).domElement.innerHTML = B), this.parent) throw new Error("You can only call remember on a top level GUI.");
                            var t = this;
                            i.each(Array.prototype.slice.call(arguments), (function(e) {
                                0 === t.__rememberedObjects.length && nt(t), -1 === t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e)
                            })), this.autoPlace && it(this, this.width)
                        },
                        getRoot: function() {
                            for (var t = this; t.parent;) t = t.parent;
                            return t
                        },
                        getSaveObject: function() {
                            var t = this.load;
                            return t.closed = this.closed, this.__rememberedObjects.length > 0 && (t.preset = this.preset, t.remembered || (t.remembered = {}), t.remembered[this.preset] = rt(this)), t.folders = {}, i.each(this.__folders, (function(e, n) {
                                t.folders[n] = e.getSaveObject()
                            })), t
                        },
                        save: function() {
                            this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = rt(this), Z(this, !1), this.saveToLocalStorageIfPossible()
                        },
                        saveAs: function(t) {
                            this.load.remembered || (this.load.remembered = {}, this.load.remembered[k] = rt(this, !0)), this.load.remembered[t] = rt(this), this.preset = t, tt(this, t, !0), this.saveToLocalStorageIfPossible()
                        },
                        revert: function(t) {
                            i.each(this.__controllers, (function(e) {
                                this.getRoot().load.remembered ? J(t || this.getRoot(), e) : e.setValue(e.initialValue), e.__onFinishChange && e.__onFinishChange.call(e, e.getValue())
                            }), this), i.each(this.__folders, (function(t) {
                                t.revert(t)
                            })), t || Z(this.getRoot(), !1)
                        },
                        listen: function(t) {
                            var e = 0 === this.__listening.length;
                            this.__listening.push(t), e && function t(e) {
                                0 !== e.length && V.call(window, (function() {
                                    t(e)
                                })), i.each(e, (function(t) {
                                    t.updateDisplay()
                                }))
                            }(this.__listening)
                        },
                        updateDisplay: function() {
                            i.each(this.__controllers, (function(t) {
                                t.updateDisplay()
                            })), i.each(this.__folders, (function(t) {
                                t.updateDisplay()
                            }))
                        }
                    }), {
                        color: {
                            Color: g,
                            math: c,
                            interpret: a
                        },
                        controllers: {
                            Controller: x,
                            BooleanController: M,
                            OptionController: A,
                            StringController: T,
                            NumberController: C,
                            NumberControllerBox: P,
                            NumberControllerSlider: R,
                            FunctionController: I,
                            ColorController: F
                        },
                        dom: {
                            dom: S
                        },
                        gui: {
                            GUI: X
                        },
                        GUI: X
                    }
                }()
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.InputManager = class {
                    constructor(t, e) {
                        this.touchXStart = 0, this.touchYStart = 0, this.onMouseOut = () => {
                            this.domElement.removeEventListener("mousemove", this.boundOnMouseMove, !1), this.domElement.removeEventListener("mouseup", this.boundOnMouseUp, !1)
                        }, this.world = t, this.domElement = e || document.body, this.pointerLock = this.world.params.Pointer_Lock, this.isLocked = !1, this.boundOnMouseDown = t => this.onMouseDown(t), this.boundOnMouseMove = t => this.onMouseMove(t), this.boundOnMouseUp = t => this.onMouseUp(t), this.boundOnMouseWheelMove = t => this.onMouseWheelMove(t), this.boundOnPointerlockChange = t => this.onPointerlockChange(t), this.boundOnPointerlockError = t => this.onPointerlockError(t), this.boundOnKeyDown = t => this.onKeyDown(t), this.boundOnKeyUp = t => this.onKeyUp(t), this.domElement.addEventListener("mousedown", this.boundOnMouseDown, !1), document.addEventListener("wheel", this.boundOnMouseWheelMove, !1), document.addEventListener("pointerlockchange", this.boundOnPointerlockChange, !1), document.addEventListener("pointerlockerror", this.boundOnPointerlockError, !1), document.addEventListener("keydown", this.boundOnKeyDown, !1), document.addEventListener("keyup", this.boundOnKeyUp, !1)
                    }
                    setDomElement(t) {
                        this.domElement.removeEventListener("mousedown", this.boundOnMouseDown, !1), this.domElement.removeEventListener("mousemove", this.boundOnMouseMove, !1), this.domElement.removeEventListener("mouseup", this.boundOnMouseUp, !1), this.domElement = t, this.domElement.addEventListener("mousedown", this.boundOnMouseDown, !1)
                    }
                    isMobileButton(t) {
                        var e;
                        return !(null === (e = t.target.className) || void 0 === e || !e.includes("material-icons"))
                    }
                    update(t) {
                        void 0 === this.inputReceiver && void 0 !== this.world && void 0 !== this.world.cameraOperator && this.setInputReceiver(this.world.cameraOperator), void 0 !== this.inputReceiver && this.inputReceiver.inputReceiverUpdate(t)
                    }
                    enableTouchControls(t) {
                        t.addEventListener("touchstart", (t => {
                            for (let e = 0; e < t.touches.length; e++) this.isMobileButton(t.touches[e]) || (this.touchXStart = t.touches[e].pageX, this.touchYStart = t.touches[e].pageY)
                        }), !1), t.addEventListener("touchmove", (t => {
                            for (let e = 0; e < t.touches.length; e++) {
                                if (this.isMobileButton(t.touches[e])) continue;
                                let n = this.touchXStart - t.touches[e].pageX,
                                    i = this.touchYStart - t.touches[e].pageY;
                                this.touchXStart = t.touches[e].pageX, this.touchYStart = t.touches[e].pageY, this.inputReceiver.handleMouseMove(t, -n, -i)
                            }
                        }), !1)
                    }
                    handleMouseMove(t, e) {
                        this.inputReceiver.handleMouseMove(void 0, -t, -e)
                    }
                    setInputReceiver(t) {
                        this.inputReceiver = t, this.inputReceiver.inputReceiverInit()
                    }
                    setPointerLock(t) {
                        this.pointerLock = t
                    }
                    onPointerlockChange(t) {
                        document.pointerLockElement === this.domElement ? (this.domElement.addEventListener("mousemove", this.boundOnMouseMove, !1), this.domElement.addEventListener("mouseup", this.boundOnMouseUp, !1), this.isLocked = !0) : (this.domElement.removeEventListener("mousemove", this.boundOnMouseMove, !1), this.domElement.removeEventListener("mouseup", this.boundOnMouseUp, !1), this.isLocked = !1)
                    }
                    onPointerlockError(t) {
                        console.error("PointerLockControls: Unable to use Pointer Lock API")
                    }
                    onMouseDown(t) {
                        this.pointerLock && 0 == t.button && this.domElement.requestPointerLock(), 1 == t.button && (this.domElement.addEventListener("mousemove", this.boundOnMouseMove, !1), this.domElement.addEventListener("mouseup", this.boundOnMouseUp, !1), this.domElement.addEventListener("mouseout", this.onMouseOut, !1)), void 0 !== this.inputReceiver && this.inputReceiver.handleMouseButton(t, "mouse" + t.button, !0)
                    }
                    onMouseMove(t) {
                        void 0 !== this.inputReceiver && this.inputReceiver.handleMouseMove(t, t.movementX, t.movementY)
                    }
                    onMouseUp(t) {
                        1 == t.button && (this.domElement.removeEventListener("mousemove", this.boundOnMouseMove, !1), this.domElement.removeEventListener("mouseup", this.boundOnMouseUp, !1)), void 0 !== this.inputReceiver && this.inputReceiver.handleMouseButton(t, "mouse" + t.button, !1)
                    }
                    onKeyDown(t) {
                        void 0 !== this.inputReceiver && this.inputReceiver.handleKeyboardEvent(t, t.code, !0)
                    }
                    onKeyUp(t) {
                        void 0 !== this.inputReceiver && this.inputReceiver.handleKeyboardEvent(t, t.code, !1)
                    }
                    onMouseWheelMove(t) {
                        void 0 !== this.inputReceiver && this.inputReceiver.handleMouseWheel(t, t.deltaY)
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                });
                const i = n(91);
                e.Path = class {
                    constructor() {
                        this.nodes = {}
                    }
                    addNode(t) {
                        let e = new i.PathNode;
                        e.object = t, e.path = this, this.nodes[t.name] = e
                    }
                    connectNodes() {
                        for (const t in this.nodes)
                            if (this.nodes.hasOwnProperty(t)) {
                                const e = this.nodes[t];
                                e.nextNode = this.nodes[e.object.userData.nextNode], e.previousNode = this.nodes[e.object.userData.previousNode]
                            }
                    }
                    firstNode() {
                        return this.nodes[Object.keys(this.nodes)[6]]
                    }
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.PathNode = class {}
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.LoadingTrackerEntry = class {
                    constructor(t) {
                        this.progress = 0, this.finished = !1, this.path = t
                    }
                }
            }, function(t, e, n) {
                "use strict";
                n.r(e);
                var i = n(0),
                    r = n(1);
                const o = function() {
                    var t, e, n, r, o, s, a, l, c, h, u, d, p, f, m, g, v, y, x, b = [],
                        w = [],
                        _ = 0,
                        S = function() {
                            var t = new i.Vector3,
                                e = new i.Vector3,
                                n = new i.Vector3;
                            return function(i, r, o) {
                                return t.subVectors(o, i), e.subVectors(r, i), n.crossVectors(t, e), n.normalize()
                            }
                        }();

                    function M(t, e) {
                        if (void 0 !== t.normal) return t.normal;
                        var n = e[t[0]],
                            i = e[t[1]],
                            r = e[t[2]];
                        return u.subVectors(i, n), d.subVectors(r, n), m.crossVectors(d, u), m.normalize(), t.normal = m.clone()
                    }

                    function A(t, e, n) {
                        var i = n[t[0]],
                            r = [],
                            o = M(t, n);
                        e.sort((function(t, e) {
                            return r[t.x / 3] = void 0 !== r[t.x / 3] ? r[t.x / 3] : o.dot(p.subVectors(t, i)), r[e.x / 3] = void 0 !== r[e.x / 3] ? r[e.x / 3] : o.dot(f.subVectors(e, i)), r[t.x / 3] - r[e.x / 3]
                        }));
                        var s = e.length;
                        for (1 === s && (r[e[0].x / 3] = o.dot(p.subVectors(e[0], i))); s-- > 0 && r[e[s].x / 3] > 0;);
                        s + 1 < e.length && r[e[s + 1].x / 3] > 0 && (t.visiblePoints = e.splice(s + 1))
                    }

                    function T(t, e) {
                        for (var n, i = b.length, r = [t], o = e.indexOf(t.visiblePoints.pop()); i-- > 0;)(n = b[i]) !== t && M(n, e).dot(g.subVectors(e[o], e[n[0]])) > 0 && r.push(n);
                        var s, a, l, c, h = i = r.length,
                            u = 1 === i,
                            d = [],
                            p = 0,
                            f = [];
                        if (r[0][0], r[0][1], r[0][1], r[0][2], r[0][2], r[0][0], 1 === r.length) d = [(n = r[0])[0], n[1], n[1], n[2], n[2], n[0]], w.indexOf(n) > -1 && w.splice(w.indexOf(n), 1), n.visiblePoints && (f = f.concat(n.visiblePoints)), b.splice(b.indexOf(n), 1);
                        else
                            for (; i-- > 0;) {
                                var m;
                                for (n = r[i], w.indexOf(n) > -1 && w.splice(w.indexOf(n), 1), n.visiblePoints && (f = f.concat(n.visiblePoints)), b.splice(b.indexOf(n), 1), cEdgeIndex = 0; cEdgeIndex < 3;) {
                                    for (m = !1, h = r.length, l = n[cEdgeIndex], c = n[(cEdgeIndex + 1) % 3]; h-- > 0 && !m;)
                                        if (p = 0, (s = r[h]) !== n)
                                            for (; p < 3 && !m;) a = p + 1, m = s[p] === l && s[a % 3] === c || s[p] === c && s[a % 3] === l, p++;
                                    m && !u || (d.push(l), d.push(c)), cEdgeIndex++
                                }
                            }
                        i = 0;
                        for (var v, y = d.length / 2; i < y;) A(v = [d[2 * i + 1], o, d[2 * i]], f, e), b.push(v), void 0 !== v.visiblePoints && w.push(v), i++
                    }
                    var E = function() {
                        var t = new i.Vector3,
                            e = new i.Vector3,
                            n = new i.Vector3;
                        return function(i, r, o) {
                            t.subVectors(r, i), e.subVectors(o, i), n.subVectors(o, r);
                            var s = e.dot(t);
                            if (s < 0) return e.dot(e);
                            var a = t.dot(t);
                            return s >= a ? n.dot(n) : e.dot(e) - s * s / a
                        }
                    }();
                    return function(M) {
                        for (u = new i.Vector3, d = new i.Vector3, new i.Vector3, p = new i.Vector3, f = new i.Vector3, m = new i.Vector3, g = new i.Vector3, v = new i.Vector3, y = new i.Vector3, x = new i.Vector3, points = M.vertices, b = [], w = [], O = t = points.length, e = points.slice(0, 6), _ = 0; O-- > 0;) points[O].x < e[0].x && (e[0] = points[O]), points[O].x > e[1].x && (e[1] = points[O]), points[O].y < e[2].y && (e[2] = points[O]), points[O].y < e[3].y && (e[3] = points[O]), points[O].z < e[4].z && (e[4] = points[O]), points[O].z < e[5].z && (e[5] = points[O]);
                        for (r = O = 6; O-- > 0;)
                            for (r = O - 1; r-- > 0;) _ < (n = e[O].distanceToSquared(e[r])) && (_ = n, o = e[O], s = e[r]);
                        for (O = 6, _ = 0; O-- > 0;) n = E(o, s, e[O]), _ < n && (_ = n, a = e[O]);
                        for (c = S(o, s, a), h = c.dot(o), _ = 0, O = t; O-- > 0;) n = Math.abs(points[O].dot(c) - h), _ < n && (_ = n, l = points[O]);
                        var C = points.indexOf(o),
                            P = points.indexOf(s),
                            L = points.indexOf(a),
                            R = points.indexOf(l),
                            I = [
                                [L, P, C],
                                [P, R, C],
                                [L, R, P],
                                [C, R, L]
                            ];
                        v.subVectors(s, o).normalize(), y.subVectors(a, o).normalize(), x.subVectors(l, o).normalize(), x.dot((new i.Vector3).crossVectors(y, v)) < 0 && (I[0].reverse(), I[1].reverse(), I[2].reverse(), I[3].reverse());
                        var F = points.slice();
                        F.splice(F.indexOf(o), 1), F.splice(F.indexOf(s), 1), F.splice(F.indexOf(a), 1), F.splice(F.indexOf(l), 1);
                        for (var O = I.length; O-- > 0;) A(I[O], F, points), void 0 !== I[O].visiblePoints && w.push(I[O]), b.push(I[O]);
                        ! function(t) {
                            for (; w.length > 0;) T(w.shift(), t)
                        }(points);
                        for (var N = b.length; N-- > 0;) M.faces[N] = new i.Face3(b[N][2], b[N][1], b[N][0], b[N].normal);
                        return M.normalsNeedUpdate = !0, M
                    }
                }();
                n.d(e, "threeToCannon", (function() {
                    return l
                }));
                var s = Math.PI / 2,
                    a = {
                        BOX: "Box",
                        CYLINDER: "Cylinder",
                        SPHERE: "Sphere",
                        HULL: "ConvexPolyhedron",
                        MESH: "Trimesh"
                    };
                const l = function(t, e) {
                    var n;
                    if ((e = e || {}).type === a.BOX) return h(t);
                    if (e.type === a.CYLINDER) return function(t, e) {
                        var n, o, a, l = new i.Box3,
                            c = ["x", "y", "z"],
                            h = e.cylinderAxis || "y",
                            u = c.splice(c.indexOf(h), 1) && c;
                        return l.setFromObject(t), isFinite(l.min.lengthSq()) ? (o = l.max[h] - l.min[h], a = .5 * Math.max(l.max[u[0]] - l.min[u[0]], l.max[u[1]] - l.min[u[1]]), (n = new r.Cylinder(a, a, o, 12))._type = r.Shape.types.CYLINDER, n.radiusTop = a, n.radiusBottom = a, n.height = o, n.numSegments = 12, n.orientation = new r.Quaternion, n.orientation.setFromEuler("y" === h ? s : 0, "z" === h ? s : 0, 0, "XYZ").normalize(), n) : null
                    }(t, e);
                    if (e.type === a.SPHERE) return function(t, e) {
                        if (e.sphereRadius) return new r.Sphere(e.sphereRadius);
                        var n = u(t);
                        return n ? (n.computeBoundingSphere(), new r.Sphere(n.boundingSphere.radius)) : null
                    }(t, e);
                    if (e.type === a.HULL) return function(t) {
                        var e, n, i, s, a = u(t);
                        if (!a || !a.vertices.length) return null;
                        for (e = 0; e < a.vertices.length; e++) a.vertices[e].x += 1e-4 * (Math.random() - .5), a.vertices[e].y += 1e-4 * (Math.random() - .5), a.vertices[e].z += 1e-4 * (Math.random() - .5);
                        for (s = o(a), n = new Array(s.vertices.length), e = 0; e < s.vertices.length; e++) n[e] = new r.Vec3(s.vertices[e].x, s.vertices[e].y, s.vertices[e].z);
                        for (i = new Array(s.faces.length), e = 0; e < s.faces.length; e++) i[e] = [s.faces[e].a, s.faces[e].b, s.faces[e].c];
                        return new r.ConvexPolyhedron(n, i)
                    }(t);
                    if (e.type === a.MESH) return (n = u(t)) ? function(t) {
                        var e, n = d(t);
                        return n.length ? (e = Object.keys(n).map(Number), new r.Trimesh(n, e)) : null
                    }(n) : null;
                    if (e.type) throw new Error('[CANNON.threeToCannon] Invalid type "%s".', e.type);
                    if (!(n = u(t))) return null;
                    switch (n.metadata ? n.metadata.type : n.type) {
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                            return c(n);
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            return function(t) {
                                var e, n = t.metadata ? t.metadata.parameters : t.parameters;
                                return (e = new r.Cylinder(n.radiusTop, n.radiusBottom, n.height, n.radialSegments))._type = r.Shape.types.CYLINDER, e.radiusTop = n.radiusTop, e.radiusBottom = n.radiusBottom, e.height = n.height, e.numSegments = n.radialSegments, e.orientation = new r.Quaternion, e.orientation.setFromEuler(i.Math.degToRad(90), 0, 0, "XYZ").normalize(), e
                            }(n);
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            return function(t) {
                                t.computeBoundingBox();
                                var e = t.boundingBox;
                                return new r.Box(new r.Vec3((e.max.x - e.min.x) / 2 || .1, (e.max.y - e.min.y) / 2 || .1, (e.max.z - e.min.z) / 2 || .1))
                            }(n);
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            return function(t) {
                                var e = t.metadata ? t.metadata.parameters : t.parameters;
                                return new r.Sphere(e.radius)
                            }(n);
                        case "TubeGeometry":
                        case "Geometry":
                        case "BufferGeometry":
                            return h(t);
                        default:
                            return console.warn('Unrecognized geometry: "%s". Using bounding box as shape.', n.type), c(n)
                    }
                };

                function c(t) {
                    if (!d(t).length) return null;
                    t.computeBoundingBox();
                    var e = t.boundingBox;
                    return new r.Box(new r.Vec3((e.max.x - e.min.x) / 2, (e.max.y - e.min.y) / 2, (e.max.z - e.min.z) / 2))
                }

                function h(t) {
                    var e, n, o = new i.Box3,
                        s = t.clone();
                    return s.quaternion.set(0, 0, 0, 1), s.updateMatrixWorld(), o.setFromObject(s), isFinite(o.min.lengthSq()) ? (e = new r.Box(new r.Vec3((o.max.x - o.min.x) / 2, (o.max.y - o.min.y) / 2, (o.max.z - o.min.z) / 2)), (n = o.translate(s.position.negate()).getCenter(new i.Vector3)).lengthSq() && (e.offset = n), e) : null
                }

                function u(t) {
                    var e, n, r = function(t) {
                            var e = [];
                            return t.traverse((function(t) {
                                "Mesh" === t.type && e.push(t)
                            })), e
                        }(t),
                        o = new i.Geometry,
                        s = new i.Geometry;
                    if (0 === r.length) return null;
                    if (1 === r.length) {
                        var a = new i.Vector3,
                            l = new i.Quaternion,
                            c = new i.Vector3;
                        return r[0].geometry.isBufferGeometry ? r[0].geometry.attributes.position && r[0].geometry.attributes.position.itemSize > 2 && o.fromBufferGeometry(r[0].geometry) : o = r[0].geometry.clone(), o.metadata = r[0].geometry.metadata, r[0].updateMatrixWorld(), r[0].matrixWorld.decompose(a, l, c), o.scale(c.x, c.y, c.z)
                    }
                    for (; n = r.pop();)
                        if (n.updateMatrixWorld(), n.geometry.isBufferGeometry) {
                            if (n.geometry.attributes.position && n.geometry.attributes.position.itemSize > 2) {
                                var h = new i.Geometry;
                                h.fromBufferGeometry(n.geometry), s.merge(h, n.matrixWorld), h.dispose()
                            }
                        } else s.merge(n.geometry, n.matrixWorld);
                    return (e = new i.Matrix4).scale(t.scale), s.applyMatrix(e), s
                }

                function d(t) {
                    return t.attributes || (t = (new i.BufferGeometry).fromGeometry(t)), (t.attributes.position || {}).array || []
                }
                l.Type = a
            }])
        },
        81: function(t) {
            t.exports = JSON.parse('[{"id":0,"stringId":"box","name":"Box"},{"id":1,"stringId":"ninja","name":"Ninja"},{"id":2,"stringId":"knight_gold","name":"Gold Knight"},{"id":3,"stringId":"pixel","name":"Pixel"},{"id":4,"stringId":"gorilla_yellow","name":"Yellow Gorilla"},{"id":5,"stringId":"gorilla_blue","name":"Blue Gorilla"},{"id":6,"stringId":"gorilla_red","name":"Red Gorilla"},{"id":7,"stringId":"gorilla_black","name":"Black Gorilla"},{"id":8,"stringId":"lynx","name":"Lynx"}]')
        }
    },
    [
        [405, 1, 2]
    ]
]);
